#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InGameModule

#include "Basic.hpp"

#include "ReplicationGraph_structs.hpp"
#include "ReplicationGraph_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CommonModule_structs.hpp"
#include "GameModule_structs.hpp"
#include "GameModule_classes.hpp"
#include "MasterDataModule_structs.hpp"
#include "UIFramework_structs.hpp"
#include "UIFramework_classes.hpp"
#include "InGameModule_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SlateCore_structs.hpp"
#include "BykingUnrealModule_structs.hpp"
#include "BykingUnrealModule_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "CriWareRuntime_classes.hpp"
#include "ActionCamera_classes.hpp"
#include "Slate_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "AIModule_classes.hpp"
#include "PhysicsCore_classes.hpp"


namespace SDK
{

// Class InGameModule.DogTagManagerComponent
// 0x0068 (0x0118 - 0x00B0)
class UDogTagManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x68];                                      // 0x00B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConsumeDogTag_ToClient(class APlayerStateBattle* PlayerState);
	void ConsumeDogTag_ToServer(class APlayerStateBattle* PlayerState);
	void LockDogTag_ToClient(uint8 TeamId, int16 PlayrId);
	void LockDogTag_ToServer(uint8 TeamId, int16 PlayrId);
	void OnPickupDogTag_ToClient(uint8 TeamId, int16 PlayerId);
	void OnPickupDogTag_ToServer(uint8 TeamId, int16 PlayerId);
	void UnlockDogTag_ToClient(uint8 TeamId, int16 PlayrId);
	void UnlockDogTag_ToServer(uint8 TeamId, int16 PlayrId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DogTagManagerComponent">();
	}
	static class UDogTagManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDogTagManagerComponent>();
	}
};
static_assert(alignof(UDogTagManagerComponent) == 0x000008, "Wrong alignment on UDogTagManagerComponent");
static_assert(sizeof(UDogTagManagerComponent) == 0x000118, "Wrong size on UDogTagManagerComponent");

// Class InGameModule.AN_BattleBase
// 0x0000 (0x0040 - 0x0040)
class UAN_BattleBase : public UAN_CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_BattleBase">();
	}
	static class UAN_BattleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_BattleBase>();
	}
};
static_assert(alignof(UAN_BattleBase) == 0x000008, "Wrong alignment on UAN_BattleBase");
static_assert(sizeof(UAN_BattleBase) == 0x000040, "Wrong size on UAN_BattleBase");

// Class InGameModule.AN_AttackSetSpeedV
// 0x0010 (0x0050 - 0x0040)
class UAN_AttackSetSpeedV final : public UAN_BattleBase
{
public:
	float                                         _initialSpeed;                                     // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lastSpeed;                                        // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _span;                                             // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _useCurrentSpeed;                                  // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackSetSpeedV">();
	}
	static class UAN_AttackSetSpeedV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackSetSpeedV>();
	}
};
static_assert(alignof(UAN_AttackSetSpeedV) == 0x000008, "Wrong alignment on UAN_AttackSetSpeedV");
static_assert(sizeof(UAN_AttackSetSpeedV) == 0x000050, "Wrong size on UAN_AttackSetSpeedV");
static_assert(offsetof(UAN_AttackSetSpeedV, _initialSpeed) == 0x000040, "Member 'UAN_AttackSetSpeedV::_initialSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackSetSpeedV, _lastSpeed) == 0x000044, "Member 'UAN_AttackSetSpeedV::_lastSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackSetSpeedV, _span) == 0x000048, "Member 'UAN_AttackSetSpeedV::_span' has a wrong offset!");
static_assert(offsetof(UAN_AttackSetSpeedV, _useCurrentSpeed) == 0x00004C, "Member 'UAN_AttackSetSpeedV::_useCurrentSpeed' has a wrong offset!");

// Class InGameModule.PlayerControllerBattle
// 0x0388 (0x0998 - 0x0610)
class APlayerControllerBattle : public APlayerControllerGame
{
public:
	uint8                                         Pad_610[0x38];                                     // 0x0610(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _OriginalPawn;                                     // 0x0648(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_650[0xF8];                                     // 0x0650(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraShaker*                          CameraShacker;                                     // 0x0748(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_750[0xE0];                                     // 0x0750(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UHudCommandControlComponent*            _commandHudComponent;                              // 0x0830(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0838(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISubsystemComponent*                  _uiSubsystemComponent;                             // 0x0840(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWinDemoControllerComponent*            _winDemoController;                                // 0x0848(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreamingDynamic*                 _showProfileSubLevelStreamingDynamic;              // 0x0850(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_858[0x18];                                     // 0x0858(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _viewTargetPlayerState;                            // 0x0870(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_878[0x28];                                     // 0x0878(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGameModeType, TSoftClassPtr<class UClass>> _commentaryVoiceComponentMap;                      // 0x08A0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   _commentaryVoiceComponent;                         // 0x08F0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x40];                                     // 0x0918(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                DEBUG_EnvVfxCommandWidget;                         // 0x0958(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DEBUG_OnEnvDebugWheelOpen;                         // 0x0960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DEBUG_OnEnvDebugWheelClose;                        // 0x0970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCameraControllerBattle*                _cameraControllerBattle;                           // 0x0980(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_988[0x10];                                     // 0x0988(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_PlayCameraShakeParam(const struct FCameraShakerParam& Param, float Scale);
	void BP_SendViolationReport_CallServer(EMdPenaltyType PenaltyReportType);
	void BP_ServerTravel(const class FString& URL);
	void ChangeButtonGuideVisibilityEvent__DelegateSignature();
	void ClientPrepareRestart();
	void ClientSelectRestartPosition();
	void ClientSetBattleResultData(const TArray<struct FBattleResultData>& Data, const TArray<struct FDropItemParamInfo>& DropItems, bool bRetire);
	void ClientSetSpectatingCamera();
	void DEBUG_DoEnvVfxCommandRPC_OnServer(EDamageAttribute Element);
	void DEBUG_DoEnvVfxDebugCommand(EDamageAttribute Element);
	void Debug_OnEnvDebugCommandDispatched__DelegateSignature();
	void DropItem_OnServer(const int32 DipIndex);
	void OnRemovePlayerStateSpectating(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnRep_ChangePawn();
	void OnShowProfileSubLevelHidden();
	void OnShowProfileSubLevelShow();
	void OpenSpectating();
	void RequestPlayerDataActivityStatus(const struct FUniqueNetIdKey& UniqueId);
	void ReTargetViewSpectatingServer();
	void SendCheer_OnServer(class APlayerStateBattle* SendCheerPlayerState, class APlayerStateBattle* RecvCheerPlayerState, int32 AddCheerCount);
	void SendPlayerDataActivityStatus(const struct FPlayerDataActivityStatus& ScoreData);
	void SendViolationReport_OnServer(const class FString& SendSelectedPlayerId, const class FString& RecvSelectedPlayerId, EMdPenaltyType PenaltyReportType);
	void SendViolationReport_OnServerDebug(const class FString& RecvSelectedPlayerId, EMdPenaltyType PenaltyReportType);
	void ServerSpectatingChangePlayerView(bool bNext);
	void ServerTravelBattle(const class FString& InGameMode, const class FString& InStage);
	void StartBattle(const class FString& InGameMode, const class FString& InStage);
	void StartSpectatingFromDead();
	void SwitchAbilityInfoVisibility(bool bVisible);
	void SwitchAllyPlayerStatusInfo(bool bVisible);
	void SwitchBattleCounterVisibility(bool bVisible);
	void SwitchCrossHairsVisibility(bool bVisible);
	void SwitchInGameButtonGuideVisibility(bool bVisible);
	void SwitchLocalPlayerStatusInfo(bool bVisible);
	void SwitchLvUpShortCutVisibility(bool bVisible);
	void SwitchMiscInfoVisibility(bool bVisible);
	void SwitchPlusUltraVisibility(bool bVisible);
	void SwitchShortcutInfoVisibility(bool bVisible);

	class UHudCommandControlComponent* BP_GetCommandHUDControlComponent() const;
	class ACharacterBattle* BP_GetControlledCharacter() const;
	class UCommentaryVoiceComponent* GetCommentaryVoiceComponent() const;
	void ServerTravel(const class FString& URL) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerBattle">();
	}
	static class APlayerControllerBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerBattle>();
	}
};
static_assert(alignof(APlayerControllerBattle) == 0x000008, "Wrong alignment on APlayerControllerBattle");
static_assert(sizeof(APlayerControllerBattle) == 0x000998, "Wrong size on APlayerControllerBattle");
static_assert(offsetof(APlayerControllerBattle, _OriginalPawn) == 0x000648, "Member 'APlayerControllerBattle::_OriginalPawn' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, CameraShacker) == 0x000748, "Member 'APlayerControllerBattle::CameraShacker' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _commandHudComponent) == 0x000830, "Member 'APlayerControllerBattle::_commandHudComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _localPlayerHudManager) == 0x000838, "Member 'APlayerControllerBattle::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _uiSubsystemComponent) == 0x000840, "Member 'APlayerControllerBattle::_uiSubsystemComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _winDemoController) == 0x000848, "Member 'APlayerControllerBattle::_winDemoController' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _showProfileSubLevelStreamingDynamic) == 0x000850, "Member 'APlayerControllerBattle::_showProfileSubLevelStreamingDynamic' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _viewTargetPlayerState) == 0x000870, "Member 'APlayerControllerBattle::_viewTargetPlayerState' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _commentaryVoiceComponentMap) == 0x0008A0, "Member 'APlayerControllerBattle::_commentaryVoiceComponentMap' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _commentaryVoiceComponent) == 0x0008F0, "Member 'APlayerControllerBattle::_commentaryVoiceComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, DEBUG_EnvVfxCommandWidget) == 0x000958, "Member 'APlayerControllerBattle::DEBUG_EnvVfxCommandWidget' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, DEBUG_OnEnvDebugWheelOpen) == 0x000960, "Member 'APlayerControllerBattle::DEBUG_OnEnvDebugWheelOpen' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, DEBUG_OnEnvDebugWheelClose) == 0x000970, "Member 'APlayerControllerBattle::DEBUG_OnEnvDebugWheelClose' has a wrong offset!");
static_assert(offsetof(APlayerControllerBattle, _cameraControllerBattle) == 0x000980, "Member 'APlayerControllerBattle::_cameraControllerBattle' has a wrong offset!");

// Class InGameModule.PlayerControllerReplaySpectator
// 0x0000 (0x0998 - 0x0998)
class APlayerControllerReplaySpectator final : public APlayerControllerBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerReplaySpectator">();
	}
	static class APlayerControllerReplaySpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerReplaySpectator>();
	}
};
static_assert(alignof(APlayerControllerReplaySpectator) == 0x000008, "Wrong alignment on APlayerControllerReplaySpectator");
static_assert(sizeof(APlayerControllerReplaySpectator) == 0x000998, "Wrong size on APlayerControllerReplaySpectator");

// Class InGameModule.SupplyActorBase
// 0x0098 (0x02B8 - 0x0220)
class ASupplyActorBase : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPinnedActorComponent*                  _pinnedActorComponent;                             // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x18];                                     // 0x0238(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _supplyId;                                         // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        _netSupplyId;                                      // 0x0258(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A[0x6];                                      // 0x025A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       _blockCollisionSphereComponent;                    // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              _moveVectorXY;                                     // 0x0268(0x000C)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bInitializeMove;                                  // 0x0274(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  _veloXZ_accel;                                     // 0x0278(0x000C)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isCorrectPositoin;                                // 0x0284(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_285[0x27];                                     // 0x0285(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnablePoisonMistReductionEvent;                   // 0x02AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AD[0xB];                                      // 0x02AD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FirstSearchUnderObject();
	void OnCollapseInAirEvent(class AActor* Actor);
	void OnRep_NetSupplyId();
	void OnSearchUnderActor();
	void OnSearchUnderActorCorrect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyActorBase">();
	}
	static class ASupplyActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyActorBase>();
	}
};
static_assert(alignof(ASupplyActorBase) == 0x000008, "Wrong alignment on ASupplyActorBase");
static_assert(sizeof(ASupplyActorBase) == 0x0002B8, "Wrong size on ASupplyActorBase");
static_assert(offsetof(ASupplyActorBase, _pinnedActorComponent) == 0x000230, "Member 'ASupplyActorBase::_pinnedActorComponent' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, _supplyId) == 0x000250, "Member 'ASupplyActorBase::_supplyId' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, _netSupplyId) == 0x000258, "Member 'ASupplyActorBase::_netSupplyId' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, _blockCollisionSphereComponent) == 0x000260, "Member 'ASupplyActorBase::_blockCollisionSphereComponent' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, _moveVectorXY) == 0x000268, "Member 'ASupplyActorBase::_moveVectorXY' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, _bInitializeMove) == 0x000274, "Member 'ASupplyActorBase::_bInitializeMove' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, _veloXZ_accel) == 0x000278, "Member 'ASupplyActorBase::_veloXZ_accel' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, _isCorrectPositoin) == 0x000284, "Member 'ASupplyActorBase::_isCorrectPositoin' has a wrong offset!");
static_assert(offsetof(ASupplyActorBase, bEnablePoisonMistReductionEvent) == 0x0002AC, "Member 'ASupplyActorBase::bEnablePoisonMistReductionEvent' has a wrong offset!");

// Class InGameModule.AN_AttackDedicatedEvent
// 0x0008 (0x0048 - 0x0040)
class UAN_AttackDedicatedEvent final : public UAN_BattleBase
{
public:
	EAttackDedicatedEventId                       _eventId;                                          // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackDedicatedEvent">();
	}
	static class UAN_AttackDedicatedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackDedicatedEvent>();
	}
};
static_assert(alignof(UAN_AttackDedicatedEvent) == 0x000008, "Wrong alignment on UAN_AttackDedicatedEvent");
static_assert(sizeof(UAN_AttackDedicatedEvent) == 0x000048, "Wrong size on UAN_AttackDedicatedEvent");
static_assert(offsetof(UAN_AttackDedicatedEvent, _eventId) == 0x000040, "Member 'UAN_AttackDedicatedEvent::_eventId' has a wrong offset!");

// Class InGameModule.BattleBriefingPinWidget
// 0x00B8 (0x0408 - 0x0350)
class UBattleBriefingPinWidget final : public UWidgetBase
{
public:
	ECharacterId                                  _charaId;                                          // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHudResource*                           _characterDataAsset;                               // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _charaFaceMat;                                     // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _charaFaceMatDynamic;                              // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _characterFaceEdgeColor;                           // 0x0370(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _canvasPanel;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _pinBody;                                          // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _playerInfoCanvasPanel;                            // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _charaIcon;                                        // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleBriefingPlayerNameWidget*        _playerName;                                       // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             _leaderOrder;                                      // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        _leadersTeamSwitcher;                              // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           _seTimerHandle;                                    // 0x03C0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       _animDecision;                                     // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _animChangeLeader;                                 // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _animChangeLeaderOrder;                            // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _animCancelLeaderOrder;                            // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _animCancelLeader;                                 // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingPinWidget">();
	}
	static class UBattleBriefingPinWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingPinWidget>();
	}
};
static_assert(alignof(UBattleBriefingPinWidget) == 0x000008, "Wrong alignment on UBattleBriefingPinWidget");
static_assert(sizeof(UBattleBriefingPinWidget) == 0x000408, "Wrong size on UBattleBriefingPinWidget");
static_assert(offsetof(UBattleBriefingPinWidget, _charaId) == 0x000350, "Member 'UBattleBriefingPinWidget::_charaId' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _characterDataAsset) == 0x000358, "Member 'UBattleBriefingPinWidget::_characterDataAsset' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _charaFaceMat) == 0x000360, "Member 'UBattleBriefingPinWidget::_charaFaceMat' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _charaFaceMatDynamic) == 0x000368, "Member 'UBattleBriefingPinWidget::_charaFaceMatDynamic' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _characterFaceEdgeColor) == 0x000370, "Member 'UBattleBriefingPinWidget::_characterFaceEdgeColor' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _canvasPanel) == 0x000380, "Member 'UBattleBriefingPinWidget::_canvasPanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _pinBody) == 0x000388, "Member 'UBattleBriefingPinWidget::_pinBody' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _playerInfoCanvasPanel) == 0x000390, "Member 'UBattleBriefingPinWidget::_playerInfoCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _charaIcon) == 0x000398, "Member 'UBattleBriefingPinWidget::_charaIcon' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _playerName) == 0x0003A0, "Member 'UBattleBriefingPinWidget::_playerName' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _leaderOrder) == 0x0003B0, "Member 'UBattleBriefingPinWidget::_leaderOrder' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _leadersTeamSwitcher) == 0x0003B8, "Member 'UBattleBriefingPinWidget::_leadersTeamSwitcher' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _seTimerHandle) == 0x0003C0, "Member 'UBattleBriefingPinWidget::_seTimerHandle' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _animDecision) == 0x0003D0, "Member 'UBattleBriefingPinWidget::_animDecision' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _animChangeLeader) == 0x0003D8, "Member 'UBattleBriefingPinWidget::_animChangeLeader' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _animChangeLeaderOrder) == 0x0003E0, "Member 'UBattleBriefingPinWidget::_animChangeLeaderOrder' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _animCancelLeaderOrder) == 0x0003E8, "Member 'UBattleBriefingPinWidget::_animCancelLeaderOrder' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPinWidget, _animCancelLeader) == 0x0003F0, "Member 'UBattleBriefingPinWidget::_animCancelLeader' has a wrong offset!");

// Class InGameModule.ItemBase
// 0x00D0 (0x0388 - 0x02B8)
class AItemBase : public ASupplyActorBase
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemVisiblityType                            _visiblityType;                                    // 0x02C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyManagerComponent*                _itemManagerComponent;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _activeParticle;                                   // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _respawnParticle;                                  // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _acquiredParticle;                                 // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bUseAbilityColor;                                 // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _colorTableRowName;                                // 0x02EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleCustomParticleSystemComponent*   _activeParticleSystem;                             // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _respawnParticleSystem;                            // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _despawnParticleSystem;                            // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPaperSprite*                           _itemSignalTexture;                                // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerControllerBattle*                _playerController;                                 // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialControlComponent*              _materialControl;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       _dynamicMaterialInstanceArray;                     // 0x0328(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _rootComponent;                                    // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x18];                                     // 0x0348(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystemComponent*>       _particleSystemComponent;                          // 0x0360(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         _teamId;                                           // 0x0370(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _squadId;                                          // 0x0371(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _playerId;                                         // 0x0372(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_373[0x5];                                      // 0x0373(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractTargetComponent*               _interactTargetComponent;                          // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        _serial_levelField;                                // 0x0380(0x0002)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x6];                                      // 0x0382(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractToClient_RPC(class APlayerState* PalyerState);
	void SetupComponents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBase">();
	}
	static class AItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBase>();
	}
};
static_assert(alignof(AItemBase) == 0x000008, "Wrong alignment on AItemBase");
static_assert(sizeof(AItemBase) == 0x000388, "Wrong size on AItemBase");
static_assert(offsetof(AItemBase, _visiblityType) == 0x0002C0, "Member 'AItemBase::_visiblityType' has a wrong offset!");
static_assert(offsetof(AItemBase, _itemManagerComponent) == 0x0002C8, "Member 'AItemBase::_itemManagerComponent' has a wrong offset!");
static_assert(offsetof(AItemBase, _activeParticle) == 0x0002D0, "Member 'AItemBase::_activeParticle' has a wrong offset!");
static_assert(offsetof(AItemBase, _respawnParticle) == 0x0002D8, "Member 'AItemBase::_respawnParticle' has a wrong offset!");
static_assert(offsetof(AItemBase, _acquiredParticle) == 0x0002E0, "Member 'AItemBase::_acquiredParticle' has a wrong offset!");
static_assert(offsetof(AItemBase, _bUseAbilityColor) == 0x0002E8, "Member 'AItemBase::_bUseAbilityColor' has a wrong offset!");
static_assert(offsetof(AItemBase, _colorTableRowName) == 0x0002EC, "Member 'AItemBase::_colorTableRowName' has a wrong offset!");
static_assert(offsetof(AItemBase, _activeParticleSystem) == 0x0002F8, "Member 'AItemBase::_activeParticleSystem' has a wrong offset!");
static_assert(offsetof(AItemBase, _respawnParticleSystem) == 0x000300, "Member 'AItemBase::_respawnParticleSystem' has a wrong offset!");
static_assert(offsetof(AItemBase, _despawnParticleSystem) == 0x000308, "Member 'AItemBase::_despawnParticleSystem' has a wrong offset!");
static_assert(offsetof(AItemBase, _itemSignalTexture) == 0x000310, "Member 'AItemBase::_itemSignalTexture' has a wrong offset!");
static_assert(offsetof(AItemBase, _playerController) == 0x000318, "Member 'AItemBase::_playerController' has a wrong offset!");
static_assert(offsetof(AItemBase, _materialControl) == 0x000320, "Member 'AItemBase::_materialControl' has a wrong offset!");
static_assert(offsetof(AItemBase, _dynamicMaterialInstanceArray) == 0x000328, "Member 'AItemBase::_dynamicMaterialInstanceArray' has a wrong offset!");
static_assert(offsetof(AItemBase, _rootComponent) == 0x000340, "Member 'AItemBase::_rootComponent' has a wrong offset!");
static_assert(offsetof(AItemBase, _particleSystemComponent) == 0x000360, "Member 'AItemBase::_particleSystemComponent' has a wrong offset!");
static_assert(offsetof(AItemBase, _teamId) == 0x000370, "Member 'AItemBase::_teamId' has a wrong offset!");
static_assert(offsetof(AItemBase, _squadId) == 0x000371, "Member 'AItemBase::_squadId' has a wrong offset!");
static_assert(offsetof(AItemBase, _playerId) == 0x000372, "Member 'AItemBase::_playerId' has a wrong offset!");
static_assert(offsetof(AItemBase, _interactTargetComponent) == 0x000378, "Member 'AItemBase::_interactTargetComponent' has a wrong offset!");
static_assert(offsetof(AItemBase, _serial_levelField) == 0x000380, "Member 'AItemBase::_serial_levelField' has a wrong offset!");

// Class InGameModule.AbilityActor
// 0x0058 (0x03E0 - 0x0388)
class AAbilityActor final : public AItemBase
{
public:
	TMap<EMdAbilityType, class UParticleSystem*>  _abilityParticles;                                 // 0x0388(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	EAttackId                                     _attackID;                                         // 0x03D8(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECharacterId                                  _characterId;                                      // 0x03D9(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DA[0x6];                                      // 0x03DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityActor">();
	}
	static class AAbilityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityActor>();
	}
};
static_assert(alignof(AAbilityActor) == 0x000008, "Wrong alignment on AAbilityActor");
static_assert(sizeof(AAbilityActor) == 0x0003E0, "Wrong size on AAbilityActor");
static_assert(offsetof(AAbilityActor, _abilityParticles) == 0x000388, "Member 'AAbilityActor::_abilityParticles' has a wrong offset!");
static_assert(offsetof(AAbilityActor, _attackID) == 0x0003D8, "Member 'AAbilityActor::_attackID' has a wrong offset!");
static_assert(offsetof(AAbilityActor, _characterId) == 0x0003D9, "Member 'AAbilityActor::_characterId' has a wrong offset!");

// Class InGameModule.AutoChatComponent
// 0x0048 (0x00F8 - 0x00B0)
class UAutoChatComponent final : public UActorComponent
{
public:
	int32                                         _poisonMistNotAnnouncePhase;                       // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _poisonMistWaitingTime;                            // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _supplyBoxJudgeRadius;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _supplyBoxSpawnWaitingTime;                        // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stopperTime;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x34];                                      // 0x00C4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoChatComponent">();
	}
	static class UAutoChatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoChatComponent>();
	}
};
static_assert(alignof(UAutoChatComponent) == 0x000008, "Wrong alignment on UAutoChatComponent");
static_assert(sizeof(UAutoChatComponent) == 0x0000F8, "Wrong size on UAutoChatComponent");
static_assert(offsetof(UAutoChatComponent, _poisonMistNotAnnouncePhase) == 0x0000B0, "Member 'UAutoChatComponent::_poisonMistNotAnnouncePhase' has a wrong offset!");
static_assert(offsetof(UAutoChatComponent, _poisonMistWaitingTime) == 0x0000B4, "Member 'UAutoChatComponent::_poisonMistWaitingTime' has a wrong offset!");
static_assert(offsetof(UAutoChatComponent, _supplyBoxJudgeRadius) == 0x0000B8, "Member 'UAutoChatComponent::_supplyBoxJudgeRadius' has a wrong offset!");
static_assert(offsetof(UAutoChatComponent, _supplyBoxSpawnWaitingTime) == 0x0000BC, "Member 'UAutoChatComponent::_supplyBoxSpawnWaitingTime' has a wrong offset!");
static_assert(offsetof(UAutoChatComponent, _stopperTime) == 0x0000C0, "Member 'UAutoChatComponent::_stopperTime' has a wrong offset!");

// Class InGameModule.AbilityDataAsset
// 0x0050 (0x0118 - 0x00C8)
class UAbilityDataAsset final : public USupplyBaseDataAsset
{
public:
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterId                                  _characterId;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x00E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _actionAttackClass;                                // 0x00E8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultDuration;                                  // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityDataAsset">();
	}
	static class UAbilityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityDataAsset>();
	}
};
static_assert(alignof(UAbilityDataAsset) == 0x000008, "Wrong alignment on UAbilityDataAsset");
static_assert(sizeof(UAbilityDataAsset) == 0x000118, "Wrong size on UAbilityDataAsset");
static_assert(offsetof(UAbilityDataAsset, _characterId) == 0x0000E0, "Member 'UAbilityDataAsset::_characterId' has a wrong offset!");
static_assert(offsetof(UAbilityDataAsset, _attackID) == 0x0000E1, "Member 'UAbilityDataAsset::_attackID' has a wrong offset!");
static_assert(offsetof(UAbilityDataAsset, _actionAttackClass) == 0x0000E8, "Member 'UAbilityDataAsset::_actionAttackClass' has a wrong offset!");
static_assert(offsetof(UAbilityDataAsset, _defaultDuration) == 0x000110, "Member 'UAbilityDataAsset::_defaultDuration' has a wrong offset!");

// Class InGameModule.InventoryDragDropOperation
// 0x0008 (0x0090 - 0x0088)
class UInventoryDragDropOperation final : public UDragDropOperation
{
public:
	class UUserWidget*                            _widgetRef;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryDragDropOperation">();
	}
	static class UInventoryDragDropOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryDragDropOperation>();
	}
};
static_assert(alignof(UInventoryDragDropOperation) == 0x000008, "Wrong alignment on UInventoryDragDropOperation");
static_assert(sizeof(UInventoryDragDropOperation) == 0x000090, "Wrong size on UInventoryDragDropOperation");
static_assert(offsetof(UInventoryDragDropOperation, _widgetRef) == 0x000088, "Member 'UInventoryDragDropOperation::_widgetRef' has a wrong offset!");

// Class InGameModule.AbilityDataWork
// 0x0050 (0x0080 - 0x0030)
class UAbilityDataWork final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityDataWork">();
	}
	static class UAbilityDataWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityDataWork>();
	}
};
static_assert(alignof(UAbilityDataWork) == 0x000008, "Wrong alignment on UAbilityDataWork");
static_assert(sizeof(UAbilityDataWork) == 0x000080, "Wrong size on UAbilityDataWork");

// Class InGameModule.AN_AttackSetSpeedH
// 0x0010 (0x0050 - 0x0040)
class UAN_AttackSetSpeedH final : public UAN_BattleBase
{
public:
	float                                         _initialSpeed;                                     // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lastSpeed;                                        // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _span;                                             // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _useCurrentSpeed;                                  // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackSetSpeedH">();
	}
	static class UAN_AttackSetSpeedH* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackSetSpeedH>();
	}
};
static_assert(alignof(UAN_AttackSetSpeedH) == 0x000008, "Wrong alignment on UAN_AttackSetSpeedH");
static_assert(sizeof(UAN_AttackSetSpeedH) == 0x000050, "Wrong size on UAN_AttackSetSpeedH");
static_assert(offsetof(UAN_AttackSetSpeedH, _initialSpeed) == 0x000040, "Member 'UAN_AttackSetSpeedH::_initialSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackSetSpeedH, _lastSpeed) == 0x000044, "Member 'UAN_AttackSetSpeedH::_lastSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackSetSpeedH, _span) == 0x000048, "Member 'UAN_AttackSetSpeedH::_span' has a wrong offset!");
static_assert(offsetof(UAN_AttackSetSpeedH, _useCurrentSpeed) == 0x00004C, "Member 'UAN_AttackSetSpeedH::_useCurrentSpeed' has a wrong offset!");

// Class InGameModule.BattleBriefingSignalPinWidget
// 0x00B8 (0x0408 - 0x0350)
class UBattleBriefingSignalPinWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterId                                  _charaId;                                          // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHudResource*                           _characterDataAsset;                               // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _secondClickTimeLimit;                             // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     _charaFaceMat;                                     // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _charaFaceMatDynamic;                              // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _myEdgeColor;                                      // 0x0390(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _otherEdgeColor;                                   // 0x03A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _dangerEdgeColor;                                  // 0x03B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _triangleParts;                                    // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _playerMark;                                       // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _charaIcon;                                        // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                _collider;                                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _crown;                                            // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _signalKindIcon;                                   // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _playerName;                                       // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CommitPin(const struct FVector2D& PinUpPosition, const bool& bAlert);
	void CommitPinDelegate__DelegateSignature(const bool bAlert);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingSignalPinWidget">();
	}
	static class UBattleBriefingSignalPinWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingSignalPinWidget>();
	}
};
static_assert(alignof(UBattleBriefingSignalPinWidget) == 0x000008, "Wrong alignment on UBattleBriefingSignalPinWidget");
static_assert(sizeof(UBattleBriefingSignalPinWidget) == 0x000408, "Wrong size on UBattleBriefingSignalPinWidget");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _charaId) == 0x000360, "Member 'UBattleBriefingSignalPinWidget::_charaId' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _characterDataAsset) == 0x000368, "Member 'UBattleBriefingSignalPinWidget::_characterDataAsset' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _secondClickTimeLimit) == 0x000378, "Member 'UBattleBriefingSignalPinWidget::_secondClickTimeLimit' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _charaFaceMat) == 0x000380, "Member 'UBattleBriefingSignalPinWidget::_charaFaceMat' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _charaFaceMatDynamic) == 0x000388, "Member 'UBattleBriefingSignalPinWidget::_charaFaceMatDynamic' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _myEdgeColor) == 0x000390, "Member 'UBattleBriefingSignalPinWidget::_myEdgeColor' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _otherEdgeColor) == 0x0003A0, "Member 'UBattleBriefingSignalPinWidget::_otherEdgeColor' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _dangerEdgeColor) == 0x0003B0, "Member 'UBattleBriefingSignalPinWidget::_dangerEdgeColor' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _triangleParts) == 0x0003D0, "Member 'UBattleBriefingSignalPinWidget::_triangleParts' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _playerMark) == 0x0003D8, "Member 'UBattleBriefingSignalPinWidget::_playerMark' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _charaIcon) == 0x0003E0, "Member 'UBattleBriefingSignalPinWidget::_charaIcon' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _collider) == 0x0003E8, "Member 'UBattleBriefingSignalPinWidget::_collider' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _crown) == 0x0003F0, "Member 'UBattleBriefingSignalPinWidget::_crown' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _signalKindIcon) == 0x0003F8, "Member 'UBattleBriefingSignalPinWidget::_signalKindIcon' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSignalPinWidget, _playerName) == 0x000400, "Member 'UBattleBriefingSignalPinWidget::_playerName' has a wrong offset!");

// Class InGameModule.AbilityIconWidget
// 0x0028 (0x0378 - 0x0350)
class UAbilityIconWidget final : public UWidgetBase
{
public:
	class UImage*                                 _iconImage;                                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _attackIdImage;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _levelTextImage;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _levelNumberImage;                                 // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _IconImageMaterialInstance;                        // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_SetAvility(ECharacterId CharacterId, EAttackId AttackId, int32 VariationNo);
	void BP_SetLevel(int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityIconWidget">();
	}
	static class UAbilityIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityIconWidget>();
	}
};
static_assert(alignof(UAbilityIconWidget) == 0x000008, "Wrong alignment on UAbilityIconWidget");
static_assert(sizeof(UAbilityIconWidget) == 0x000378, "Wrong size on UAbilityIconWidget");
static_assert(offsetof(UAbilityIconWidget, _iconImage) == 0x000350, "Member 'UAbilityIconWidget::_iconImage' has a wrong offset!");
static_assert(offsetof(UAbilityIconWidget, _attackIdImage) == 0x000358, "Member 'UAbilityIconWidget::_attackIdImage' has a wrong offset!");
static_assert(offsetof(UAbilityIconWidget, _levelTextImage) == 0x000360, "Member 'UAbilityIconWidget::_levelTextImage' has a wrong offset!");
static_assert(offsetof(UAbilityIconWidget, _levelNumberImage) == 0x000368, "Member 'UAbilityIconWidget::_levelNumberImage' has a wrong offset!");
static_assert(offsetof(UAbilityIconWidget, _IconImageMaterialInstance) == 0x000370, "Member 'UAbilityIconWidget::_IconImageMaterialInstance' has a wrong offset!");

// Class InGameModule.AbilityInfoWidget
// 0x0138 (0x0488 - 0x0350)
class UAbilityInfoWidget final : public UWidgetBase
{
public:
	class UAbilityHolder*                         _holder;                                           // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        _timerTypeSwitcher;                                // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerStateBattle*                     _playerState;                                      // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMdAbilityType                                _abilityType;                                      // 0x0368(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _levelPlatePosition;                               // 0x036C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _timerPower;                                       // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _timerSupport;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _timerSpeed;                                       // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _timerDefense;                                     // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _timerTechnique;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _mainTimerMID;                                     // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _powerTimerMaterial;                               // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _supportTimerMaterial;                             // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _speedTimerMaterial;                               // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _defenseTimerMaterial;                             // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _techiniqueTimerMaterial;                          // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _abilityIcon;                                      // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _blankArrow;                                       // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _uniqueType;                                       // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityLevelCounter*                   _levelCounter;                                     // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _timerDefaultColor;                                // 0x03F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyArtInfoDataAsset*                _supplyArtInfo;                                    // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _supplyCardImage;                                  // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             _alpha;                                            // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             _beta;                                             // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             _gamma;                                            // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniAutoSetLeft;                                   // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniAutoSetRight;                                  // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniCardFadeOut;                                   // 0x0468(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bCardAnimLeftSide;                                // 0x0470(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperSprite*                           _tempIconSprite;                                   // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x4];                                      // 0x0480(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeToHideCardAfterAnimFinished;                  // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FinishedAbilityTime(class UAbilityHolder* FinishedAbilityHolder);
	void HideAbilitySetCardAfterAnimation();
	void PlayAbilitySetAnimation(class USupply* NewSupply);
	void StartAbilityTimer(class UAbilityHolder* beganAbilityHolder);
	void UpdateAbilityShortcut();
	void UpdateEventAbility(class USupply* NewSupply);
	void Wait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityInfoWidget">();
	}
	static class UAbilityInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityInfoWidget>();
	}
};
static_assert(alignof(UAbilityInfoWidget) == 0x000008, "Wrong alignment on UAbilityInfoWidget");
static_assert(sizeof(UAbilityInfoWidget) == 0x000488, "Wrong size on UAbilityInfoWidget");
static_assert(offsetof(UAbilityInfoWidget, _holder) == 0x000350, "Member 'UAbilityInfoWidget::_holder' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timerTypeSwitcher) == 0x000358, "Member 'UAbilityInfoWidget::_timerTypeSwitcher' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _playerState) == 0x000360, "Member 'UAbilityInfoWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _abilityType) == 0x000368, "Member 'UAbilityInfoWidget::_abilityType' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _levelPlatePosition) == 0x00036C, "Member 'UAbilityInfoWidget::_levelPlatePosition' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timerPower) == 0x000378, "Member 'UAbilityInfoWidget::_timerPower' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timerSupport) == 0x000380, "Member 'UAbilityInfoWidget::_timerSupport' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timerSpeed) == 0x000388, "Member 'UAbilityInfoWidget::_timerSpeed' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timerDefense) == 0x000390, "Member 'UAbilityInfoWidget::_timerDefense' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timerTechnique) == 0x000398, "Member 'UAbilityInfoWidget::_timerTechnique' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _mainTimerMID) == 0x0003A0, "Member 'UAbilityInfoWidget::_mainTimerMID' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _powerTimerMaterial) == 0x0003A8, "Member 'UAbilityInfoWidget::_powerTimerMaterial' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _supportTimerMaterial) == 0x0003B0, "Member 'UAbilityInfoWidget::_supportTimerMaterial' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _speedTimerMaterial) == 0x0003B8, "Member 'UAbilityInfoWidget::_speedTimerMaterial' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _defenseTimerMaterial) == 0x0003C0, "Member 'UAbilityInfoWidget::_defenseTimerMaterial' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _techiniqueTimerMaterial) == 0x0003C8, "Member 'UAbilityInfoWidget::_techiniqueTimerMaterial' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _abilityIcon) == 0x0003D0, "Member 'UAbilityInfoWidget::_abilityIcon' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _blankArrow) == 0x0003D8, "Member 'UAbilityInfoWidget::_blankArrow' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _uniqueType) == 0x0003E0, "Member 'UAbilityInfoWidget::_uniqueType' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _levelCounter) == 0x0003E8, "Member 'UAbilityInfoWidget::_levelCounter' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timerDefaultColor) == 0x0003F0, "Member 'UAbilityInfoWidget::_timerDefaultColor' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _hudResource) == 0x000418, "Member 'UAbilityInfoWidget::_hudResource' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _supplyArtInfo) == 0x000430, "Member 'UAbilityInfoWidget::_supplyArtInfo' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _supplyCardImage) == 0x000438, "Member 'UAbilityInfoWidget::_supplyCardImage' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _alpha) == 0x000440, "Member 'UAbilityInfoWidget::_alpha' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _beta) == 0x000448, "Member 'UAbilityInfoWidget::_beta' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _gamma) == 0x000450, "Member 'UAbilityInfoWidget::_gamma' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _aniAutoSetLeft) == 0x000458, "Member 'UAbilityInfoWidget::_aniAutoSetLeft' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _aniAutoSetRight) == 0x000460, "Member 'UAbilityInfoWidget::_aniAutoSetRight' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _aniCardFadeOut) == 0x000468, "Member 'UAbilityInfoWidget::_aniCardFadeOut' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _bCardAnimLeftSide) == 0x000470, "Member 'UAbilityInfoWidget::_bCardAnimLeftSide' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _tempIconSprite) == 0x000478, "Member 'UAbilityInfoWidget::_tempIconSprite' has a wrong offset!");
static_assert(offsetof(UAbilityInfoWidget, _timeToHideCardAfterAnimFinished) == 0x000484, "Member 'UAbilityInfoWidget::_timeToHideCardAfterAnimFinished' has a wrong offset!");

// Class InGameModule.ProjectileInterface
// 0x0000 (0x0028 - 0x0028)
class IProjectileInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileInterface">();
	}
	static class IProjectileInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProjectileInterface>();
	}
};
static_assert(alignof(IProjectileInterface) == 0x000008, "Wrong alignment on IProjectileInterface");
static_assert(sizeof(IProjectileInterface) == 0x000028, "Wrong size on IProjectileInterface");

// Class InGameModule.AbilityLevelCounter
// 0x0070 (0x03C0 - 0x0350)
class UAbilityLevelCounter final : public UWidgetBase
{
public:
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _levelNum;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _level;                                            // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FSlateColor>               _levelCounterColor;                                // 0x0370(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	void PlayLevelUpAnim();
	void PlayLevelUpAnim_Internal();
	void SetLevel(int32 Level);

	void ChangeTextColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityLevelCounter">();
	}
	static class UAbilityLevelCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityLevelCounter>();
	}
};
static_assert(alignof(UAbilityLevelCounter) == 0x000008, "Wrong alignment on UAbilityLevelCounter");
static_assert(sizeof(UAbilityLevelCounter) == 0x0003C0, "Wrong size on UAbilityLevelCounter");
static_assert(offsetof(UAbilityLevelCounter, Mid) == 0x000350, "Member 'UAbilityLevelCounter::Mid' has a wrong offset!");
static_assert(offsetof(UAbilityLevelCounter, _levelNum) == 0x000360, "Member 'UAbilityLevelCounter::_levelNum' has a wrong offset!");
static_assert(offsetof(UAbilityLevelCounter, _level) == 0x000368, "Member 'UAbilityLevelCounter::_level' has a wrong offset!");
static_assert(offsetof(UAbilityLevelCounter, _levelCounterColor) == 0x000370, "Member 'UAbilityLevelCounter::_levelCounterColor' has a wrong offset!");

// Class InGameModule.InventoryRequestIconWidget
// 0x0008 (0x03F0 - 0x03E8)
class UInventoryRequestIconWidget final : public UAppWidget
{
public:
	class UWidgetAnimation*                       _aniIdle;                                          // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryRequestIconWidget">();
	}
	static class UInventoryRequestIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryRequestIconWidget>();
	}
};
static_assert(alignof(UInventoryRequestIconWidget) == 0x000008, "Wrong alignment on UInventoryRequestIconWidget");
static_assert(sizeof(UInventoryRequestIconWidget) == 0x0003F0, "Wrong size on UInventoryRequestIconWidget");
static_assert(offsetof(UInventoryRequestIconWidget, _aniIdle) == 0x0003E8, "Member 'UInventoryRequestIconWidget::_aniIdle' has a wrong offset!");

// Class InGameModule.ActionBattleBase
// 0x0138 (0x01B0 - 0x0078)
class UActionBattleBase : public UActionBase
{
public:
	uint8                                         Pad_78[0x9];                                       // 0x0078(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bEnableAiming;                                    // 0x0081(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bStopedAimingMode;                                // 0x0082(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBattleCameraType                             _cameraType;                                       // 0x0083(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bEnableCameraLag;                                 // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_85[0xB];                                       // 0x0085(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _actionTargetActor;                                // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x14];                                      // 0x0098(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _disableShiftActionDefaultTime;                    // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _receiveNegotiateTargetBeforeActive;               // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _grabCharacter;                                    // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bAlongGroundSurface;                              // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x2];                                       // 0x00C1(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bEnableUseSupply;                                 // 0x00C3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0xC4];                                      // 0x00C4(0x00C4)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bTemp_bool1;                                      // 0x0188(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bTemp_bool2;                                      // 0x0189(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18A[0x2];                                      // 0x018A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _temp_int1;                                        // 0x018C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _temp_int2;                                        // 0x0190(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _temp_int3;                                        // 0x0194(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _temp_int4;                                        // 0x0198(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _temp_float1;                                      // 0x019C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _temp_float2;                                      // 0x01A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _temp_float3;                                      // 0x01A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _temp_float4;                                      // 0x01A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ActionPingDelay(bool bWaitForSpecificPing, int32 TargetPing, const struct FLatentActionInfo& LatentInfo);
	void BP_AddUniqueUseCount(int32 UniqueNum);
	void BP_AnimEndDelay(EAnimationSlot Slot, bool OnBlendOut, const struct FLatentActionInfo& LatentInfo);
	void BP_ChangeNagaraAttackToWhole();
	void BP_ChangeWholeAttackToNagara();
	void BP_ClearCenterRotation(float ReverseRate);
	void BP_CommandDelay(ECommandId CommandID, const struct FLatentActionInfo& LatentInfo);
	void BP_NegotiationDelay(float MaxDuration, const struct FLatentActionInfo& LatentInfo);
	void BP_OnAbortGrabbedEvent();
	void BP_OnAbortGrabEvent();
	void BP_OnBeginAimingMode();
	void BP_OnEndAimingMode();
	void BP_OnLandingEvent();
	void BP_OnLeaveGroundEvent();
	void BP_ProgressDelay(float Duration, const struct FLatentActionInfo& LatentInfo);
	void BP_RequestNegotiateAndWaitActionTarget(class ACharacterBattle* NegotiationTargetCharacter);
	void BP_RequestNegotiateTarget(class AActor* NegotiationTarget);
	void BP_RequestShiftAction(class FName ShiftActionName);
	void BP_RestoreAimingMode();
	void BP_SendActionPing(int32 Ping);
	void BP_SendBeginActionInfoToMember();
	void BP_SendEndActionInfoToMember();
	void BP_SetAnimationAdditionalTime(float Time);
	void BP_SetDamageActionToGrabbedCharacter(class FName DamageName);
	void BP_SetEnableAiming(const bool Enable);
	void BP_SetEnableUseSupply(bool Flag);
	void BP_SetForceGrabCharacter(class ACharacterBattle* GrabbedCharacter, class FName GrabJointName, class FName GrabbedJointName, EAnimationId GrabbedAnimationId, const class FName GrabbedActionName, bool bEnableGrabbedCamera);
	void BP_SetGrabbedCharacterAnimation(EAnimationId AnimId, float BlendTime, float StartPosition);
	void BP_SetMoveDirection(const struct FVector& Direction);
	void BP_SetNormalActionToGrabbedCharacter(class FName ActionName);
	void BP_SetReturnToNormal();
	void BP_SSetCameraType(EBattleCameraType Type);
	void BP_StartRotationPitchToDirection(float Span, EActionAxis TargetAxis);
	void BP_UpdateMoveDirection(const struct FVector& DestDirection, float Rate, float DeltaSeconds);
	bool BP_UpdateRotationPitchToDirection(float DeltaSeconds, const struct FVector& Direction, float Rate, float MaxDegrees);

	int32 BP_GetActionArgment() const;
	int32 BP_GetActionPing() const;
	class AActor* BP_GetActionTargetActor() const;
	class ACharacterBattle* BP_GetActionTargetAsCharacterBattle() const;
	class UAnimation* BP_GetAnimation() const;
	float BP_GetAnimationAdditionalTime() const;
	class UCharacterBattleEffectComponent* BP_GetBattleEffect() const;
	const struct FVector BP_GetCameraDirection() const;
	struct FVector BP_GetForwardDirectionForBaseActionMovement(const struct FVector& SourceDirection) const;
	class UMagazineManagementComponent* BP_GetMagazine() const;
	const struct FVector BP_GetMoveDirection() const;
	class ACharacterBattle* BP_GetNearestCharacter(float Radius, bool bAlly, bool bDying) const;
	class ACharacterBattle* BP_GetOwnerCharacterBattle() const;
	class UCharacterCommandComponent* BP_GetOwnerCommand() const;
	class UCharacterDamageComponent* BP_GetOwnerDamage() const;
	class UMovementComponentBattle* BP_GetOwnerMovementBattle() const;
	class UCharacterState* BP_GetOwnerState() const;
	class UCharacterParam* BP_GetParam() const;
	class APlayerStateBattle* BP_GetPlayerStateBattle() const;
	bool BP_IsEnableShiftAction(const class FName& NextAction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionBattleBase">();
	}
	static class UActionBattleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionBattleBase>();
	}
};
static_assert(alignof(UActionBattleBase) == 0x000008, "Wrong alignment on UActionBattleBase");
static_assert(sizeof(UActionBattleBase) == 0x0001B0, "Wrong size on UActionBattleBase");
static_assert(offsetof(UActionBattleBase, _bEnableAiming) == 0x000081, "Member 'UActionBattleBase::_bEnableAiming' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _bStopedAimingMode) == 0x000082, "Member 'UActionBattleBase::_bStopedAimingMode' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _cameraType) == 0x000083, "Member 'UActionBattleBase::_cameraType' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _bEnableCameraLag) == 0x000084, "Member 'UActionBattleBase::_bEnableCameraLag' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _actionTargetActor) == 0x000090, "Member 'UActionBattleBase::_actionTargetActor' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _disableShiftActionDefaultTime) == 0x0000AC, "Member 'UActionBattleBase::_disableShiftActionDefaultTime' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _receiveNegotiateTargetBeforeActive) == 0x0000B0, "Member 'UActionBattleBase::_receiveNegotiateTargetBeforeActive' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _grabCharacter) == 0x0000B8, "Member 'UActionBattleBase::_grabCharacter' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _bAlongGroundSurface) == 0x0000C0, "Member 'UActionBattleBase::_bAlongGroundSurface' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _bEnableUseSupply) == 0x0000C3, "Member 'UActionBattleBase::_bEnableUseSupply' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _bTemp_bool1) == 0x000188, "Member 'UActionBattleBase::_bTemp_bool1' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _bTemp_bool2) == 0x000189, "Member 'UActionBattleBase::_bTemp_bool2' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_int1) == 0x00018C, "Member 'UActionBattleBase::_temp_int1' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_int2) == 0x000190, "Member 'UActionBattleBase::_temp_int2' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_int3) == 0x000194, "Member 'UActionBattleBase::_temp_int3' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_int4) == 0x000198, "Member 'UActionBattleBase::_temp_int4' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_float1) == 0x00019C, "Member 'UActionBattleBase::_temp_float1' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_float2) == 0x0001A0, "Member 'UActionBattleBase::_temp_float2' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_float3) == 0x0001A4, "Member 'UActionBattleBase::_temp_float3' has a wrong offset!");
static_assert(offsetof(UActionBattleBase, _temp_float4) == 0x0001A8, "Member 'UActionBattleBase::_temp_float4' has a wrong offset!");

// Class InGameModule.BattleBriefingSwitchWidget
// 0x0020 (0x0370 - 0x0350)
class UBattleBriefingSwitchWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppWidget*                             _onButton;                                         // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppWidget*                             _offButton;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomInputKey*                        _customInputKey;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PressSwitchOnKey(const class FName CustomName, const bool bTrg, const bool bRapidFire);
	void PushOffButton(class UAppWidget* Widget, EWidgetInputType InputType);
	void PushOnButton(class UAppWidget* Widget, EWidgetInputType InputType);
	void ReleaseSwitchOnKey(const class FName CustomName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingSwitchWidget">();
	}
	static class UBattleBriefingSwitchWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingSwitchWidget>();
	}
};
static_assert(alignof(UBattleBriefingSwitchWidget) == 0x000008, "Wrong alignment on UBattleBriefingSwitchWidget");
static_assert(sizeof(UBattleBriefingSwitchWidget) == 0x000370, "Wrong size on UBattleBriefingSwitchWidget");
static_assert(offsetof(UBattleBriefingSwitchWidget, _onButton) == 0x000358, "Member 'UBattleBriefingSwitchWidget::_onButton' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSwitchWidget, _offButton) == 0x000360, "Member 'UBattleBriefingSwitchWidget::_offButton' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSwitchWidget, _customInputKey) == 0x000368, "Member 'UBattleBriefingSwitchWidget::_customInputKey' has a wrong offset!");

// Class InGameModule.ActionAttackBase
// 0x01A0 (0x0350 - 0x01B0)
class UActionAttackBase : public UActionBattleBase
{
public:
	uint8                                         Pad_1B0[0x61];                                     // 0x01B0(0x0061)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterId                                  _masterCharacterId;                                // 0x0211(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_212[0x6];                                      // 0x0212(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttackLaunchType, struct FActionAttackProperty> _attackProperty;                                   // 0x0218(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EAttackLaunchTarget                           _attackTargetType;                                 // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttackTargetSetting                   _attackTargetSetting;                              // 0x026C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          _doReplicationHitAttack;                           // 0x027C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChargeAttackEffect>            _chargeAttackEffects;                              // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FChargeAttackEffect>            _chargeCompletedEffects;                           // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, EAttackVisualLevel>               _visualLevelData;                                  // 0x02A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EMaterialOverWriteType, class UMaterialInstance*> _overWriteMaterialList;                            // 0x02F0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _bRefreshedGrab;                                   // 0x0340(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bGenerateRamdomSeed;                              // 0x0341(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bNotClearCharacterCondition;                      // 0x0342(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bEndAttackOnAirial;                               // 0x0343(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bStopedDash;                                      // 0x0344(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bNagaraSuperArmor;                                // 0x0345(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bCallableKPICount;                                // 0x0346(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_347[0x9];                                      // 0x0347(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ActionAttackChargeMain();
	void BP_ActionAttackChargeMainAir();
	void BP_ActionAttackChargeMainGround();
	void BP_ActionAttackChargeRemote();
	void BP_ActionAttackChargeRemoteAir();
	void BP_ActionAttackChargeRemoteGround();
	void BP_ActionAttackMainAir();
	void BP_ActionAttackMainGround();
	void BP_ActionAttackRemoteAir();
	void BP_ActionAttackRemoteGround();
	void BP_DisableActionCancel(EActionCancelFlag Flag);
	void BP_EnableActionCancel(EActionCancelFlag Flag);
	void BP_EndAttack();
	void BP_OnAngleRangeOut();
	void BP_OnAngleRangeOutAir();
	void BP_OnAngleRangeOutCharge();
	void BP_OnAngleRangeOutChargeAir();
	void BP_OnAngleRangeOutChargeGround();
	void BP_OnAngleRangeOutGround();
	void BP_OnAnimSpeedChanged(EAttackAnimationEventId EventId, float DefaultRate, bool bNagara);
	void BP_OnBeginActionAttackAir(const class FName& PrevAction);
	void BP_OnBeginActionAttackCharge(const class FName& PrevAction);
	void BP_OnBeginActionAttackChargeAir(const class FName& PrevAction);
	void BP_OnBeginActionAttackChargeGround(const class FName& PrevAction);
	void BP_OnBeginActionAttackGround(const class FName& PrevAction);
	void BP_OnBeginMultiLockOn();
	void BP_OnBootDamage(bool bSuperArmor, bool bZeroDamage);
	void BP_OnChangeAttackPhase(int32 NextPhase);
	void BP_OnChangeAttackPhaseAir(int32 NextPhase);
	void BP_OnChangeAttackPhaseAirForRemote(int32 NextPhase);
	void BP_OnChangeAttackPhaseCharge(int32 NextPhase);
	void BP_OnChangeAttackPhaseChargeAir(int32 NextPhase);
	void BP_OnChangeAttackPhaseChargeAirForRemote(int32 NextPhase);
	void BP_OnChangeAttackPhaseChargeForRemote(int32 NextPhase);
	void BP_OnChangeAttackPhaseChargeGround(int32 NextPhase);
	void BP_OnChangeAttackPhaseChargeGroundForRemote(int32 NextPhase);
	void BP_OnChangeAttackPhaseForRemote(int32 NextPhase);
	void BP_OnChangeAttackPhaseGround(int32 NextPhase);
	void BP_OnChangeAttackPhaseGroundForRemote(int32 NextPhase);
	void BP_OnChangeLevelAttackAction();
	void BP_OnDestroyedProjectileEvent(EBulletDestroyType Type, const class FName ProjectileName);
	void BP_OnDestroyedProjectileEventAir(EBulletDestroyType Type, const class FName ProjectileName);
	void BP_OnDestroyedProjectileEventCharge(EBulletDestroyType Type, const class FName ProjectileName);
	void BP_OnDestroyedProjectileEventChargeAir(EBulletDestroyType Type, const class FName ProjectileName);
	void BP_OnDestroyedProjectileEventChargeGround(EBulletDestroyType Type, const class FName ProjectileName);
	void BP_OnDestroyedProjectileEventGround(EBulletDestroyType Type, const class FName ProjectileName);
	void BP_OnEmptyMagazine();
	void BP_OnEndActionAttackAir(const class FName& NextAction);
	void BP_OnEndActionAttackCharge(const class FName& NextAction);
	void BP_OnEndActionAttackChargeAir(const class FName& NextAction);
	void BP_OnEndActionAttackChargeGround(const class FName& NextAction);
	void BP_OnEndActionAttackGround(const class FName& NextAction);
	void BP_OnEndMultiLockOn();
	void BP_OnHitAttackEvent(const struct FVector& HitLocation, class FName ProjectileName, class ACharacterBattle* HitCharacter);
	void BP_OnHitAttackEventAir(const struct FVector& HitLocation, class FName ProjectileName, class ACharacterBattle* HitCharacter);
	void BP_OnHitAttackEventCharge(const struct FVector& HitLocation, class FName ProjectileName, class ACharacterBattle* HitCharacter);
	void BP_OnHitAttackEventChargeAir(const struct FVector& HitLocation, class FName ProjectileName, class ACharacterBattle* HitCharacter);
	void BP_OnHitAttackEventChargeGround(const struct FVector& HitLocation, class FName ProjectileName, class ACharacterBattle* HitCharacter);
	void BP_OnHitAttackEventGround(const struct FVector& HitLocation, class FName ProjectileName, class ACharacterBattle* HitCharacter);
	void BP_OnHitProjectileEvent(EAttackId ProjectileAttackId, EAttackHitResult Type, const struct FVector& Location, class AActor* HitActor);
	void BP_OnHitProjectileEventAir(EAttackId ProjectileAttackId, EAttackHitResult Type, const struct FVector& Location, class AActor* HitActor);
	void BP_OnHitProjectileEventCharge(EAttackId ProjectileAttackId, EAttackHitResult Type, const struct FVector& Location, class AActor* HitActor);
	void BP_OnHitProjectileEventChargeAir(EAttackId ProjectileAttackId, EAttackHitResult Type, const struct FVector& Location, class AActor* HitActor);
	void BP_OnHitProjectileEventChargeGround(EAttackId ProjectileAttackId, EAttackHitResult Type, const struct FVector& Location, class AActor* HitActor);
	void BP_OnHitProjectileEventGround(EAttackId ProjectileAttackId, EAttackHitResult Type, const struct FVector& Location, class AActor* HitActor);
	void BP_OnHitReceiveBullet(const class ABullet* HitBullet, const struct FHitResult& Hit);
	void BP_OnLandingAir();
	void BP_OnLandingChargeAir();
	void BP_OnLandingChargeGround();
	void BP_OnLandingGround();
	void BP_OnLoadParams(const class FName& ActionName, int32 UniqueLevel);
	void BP_OnLoadParamsForChargeAttack(const class FName& ActionName, int32 UniqueLevel);
	void BP_OnLoadParamsForDefaultAttack(const class FName& ActionName, int32 UniqueLevel);
	void BP_OnNotificationAttackChargeDedicatedEvent(EAttackDedicatedEventId ID);
	void BP_OnNotificationAttackDedicatedEvent(EAttackDedicatedEventId ID);
	void BP_OnRepHitProjectileEvent(const struct FVector& HitLocation);
	void BP_OnRepHitProjectileEventAir(const struct FVector& HitLocation);
	void BP_OnRepHitProjectileEventCharge(const struct FVector& HitLocation);
	void BP_OnRepHitProjectileEventChargeAir(const struct FVector& HitLocation);
	void BP_OnRepHitProjectileEventChargeGround(const struct FVector& HitLocation);
	void BP_OnRepHitProjectileEventGround(const struct FVector& HitLocation);
	void BP_OnSetAttackIdAndLevel_Avatar(EAttackId AttackId, int32 Level);
	void BP_RegisterAttackAction();
	void BP_RegisterAttackAction_Avatar();
	void BP_SendToProjectileEvent(class FName EventName);
	void BP_SetAttackPhaseEndDelay(float SleepTime, const struct FLatentActionInfo& LatentInfo);
	void BP_SetChargeEnabled(bool Flag);
	void BP_SetEnableNagaraTurn(bool Enable);
	void BP_SetGrabDamage(class FName DamageParamName);
	void BP_SetMovementSpeedDeltaRate(float Rate);
	void BP_UnRegisterAttackAction();
	void BP_UnRegisterAttackAction_Avatar();
	void PostSpawnProjectileBullet(class ABullet* SpawnedBullet);
	void PostSpawnProjectileGenerator(class AProjectileGeneratorBattle* SpawnedGenerator);

	class UCharacterAttackComponent* BP_GetAttackComponent() const;
	EAttackId BP_GetAttackId() const;
	int32 BP_GetCurrentUniqueLevel() const;
	ECharacterId BP_GetMasterCharacter() const;
	bool BP_IsLaunchAttack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAttackBase">();
	}
	static class UActionAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionAttackBase>();
	}
};
static_assert(alignof(UActionAttackBase) == 0x000008, "Wrong alignment on UActionAttackBase");
static_assert(sizeof(UActionAttackBase) == 0x000350, "Wrong size on UActionAttackBase");
static_assert(offsetof(UActionAttackBase, _masterCharacterId) == 0x000211, "Member 'UActionAttackBase::_masterCharacterId' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _attackProperty) == 0x000218, "Member 'UActionAttackBase::_attackProperty' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _attackTargetType) == 0x000268, "Member 'UActionAttackBase::_attackTargetType' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _attackTargetSetting) == 0x00026C, "Member 'UActionAttackBase::_attackTargetSetting' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _doReplicationHitAttack) == 0x00027C, "Member 'UActionAttackBase::_doReplicationHitAttack' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _chargeAttackEffects) == 0x000280, "Member 'UActionAttackBase::_chargeAttackEffects' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _chargeCompletedEffects) == 0x000290, "Member 'UActionAttackBase::_chargeCompletedEffects' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _visualLevelData) == 0x0002A0, "Member 'UActionAttackBase::_visualLevelData' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _overWriteMaterialList) == 0x0002F0, "Member 'UActionAttackBase::_overWriteMaterialList' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _bRefreshedGrab) == 0x000340, "Member 'UActionAttackBase::_bRefreshedGrab' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _bGenerateRamdomSeed) == 0x000341, "Member 'UActionAttackBase::_bGenerateRamdomSeed' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _bNotClearCharacterCondition) == 0x000342, "Member 'UActionAttackBase::_bNotClearCharacterCondition' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _bEndAttackOnAirial) == 0x000343, "Member 'UActionAttackBase::_bEndAttackOnAirial' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _bStopedDash) == 0x000344, "Member 'UActionAttackBase::_bStopedDash' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _bNagaraSuperArmor) == 0x000345, "Member 'UActionAttackBase::_bNagaraSuperArmor' has a wrong offset!");
static_assert(offsetof(UActionAttackBase, _bCallableKPICount) == 0x000346, "Member 'UActionAttackBase::_bCallableKPICount' has a wrong offset!");

// Class InGameModule.ActionAttackSpecialBase
// 0x0008 (0x0358 - 0x0350)
class UActionAttackSpecialBase : public UActionAttackBase
{
public:
	uint8                                         Pad_350[0x1];                                      // 0x0350(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ESpecialActionLaunchType                      _specialActionLaunchType;                          // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bPopupUsed;                                       // 0x0352(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bMultipleAction;                                  // 0x0353(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_PlayCoopVoice();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAttackSpecialBase">();
	}
	static class UActionAttackSpecialBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionAttackSpecialBase>();
	}
};
static_assert(alignof(UActionAttackSpecialBase) == 0x000008, "Wrong alignment on UActionAttackSpecialBase");
static_assert(sizeof(UActionAttackSpecialBase) == 0x000358, "Wrong size on UActionAttackSpecialBase");
static_assert(offsetof(UActionAttackSpecialBase, _specialActionLaunchType) == 0x000351, "Member 'UActionAttackSpecialBase::_specialActionLaunchType' has a wrong offset!");
static_assert(offsetof(UActionAttackSpecialBase, _bPopupUsed) == 0x000352, "Member 'UActionAttackSpecialBase::_bPopupUsed' has a wrong offset!");
static_assert(offsetof(UActionAttackSpecialBase, _bMultipleAction) == 0x000353, "Member 'UActionAttackSpecialBase::_bMultipleAction' has a wrong offset!");

// Class InGameModule.AN_AttackLinkAnimLayer
// 0x0028 (0x0068 - 0x0040)
class UAN_AttackLinkAnimLayer final : public UAN_BattleBase
{
public:
	TSubclassOf<class UAnimInstance>              _linkedAnimClass;                                  // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bBlend;                                           // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blendTime;                                        // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _attachToBullet;                                   // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ignoreAttached;                                   // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _division;                                         // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _rootSocket;                                       // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _originalLength;                                   // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackLinkAnimLayer">();
	}
	static class UAN_AttackLinkAnimLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackLinkAnimLayer>();
	}
};
static_assert(alignof(UAN_AttackLinkAnimLayer) == 0x000008, "Wrong alignment on UAN_AttackLinkAnimLayer");
static_assert(sizeof(UAN_AttackLinkAnimLayer) == 0x000068, "Wrong size on UAN_AttackLinkAnimLayer");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _linkedAnimClass) == 0x000040, "Member 'UAN_AttackLinkAnimLayer::_linkedAnimClass' has a wrong offset!");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _bBlend) == 0x000048, "Member 'UAN_AttackLinkAnimLayer::_bBlend' has a wrong offset!");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _blendTime) == 0x00004C, "Member 'UAN_AttackLinkAnimLayer::_blendTime' has a wrong offset!");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _attachToBullet) == 0x000050, "Member 'UAN_AttackLinkAnimLayer::_attachToBullet' has a wrong offset!");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _ignoreAttached) == 0x000051, "Member 'UAN_AttackLinkAnimLayer::_ignoreAttached' has a wrong offset!");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _division) == 0x000054, "Member 'UAN_AttackLinkAnimLayer::_division' has a wrong offset!");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _rootSocket) == 0x000058, "Member 'UAN_AttackLinkAnimLayer::_rootSocket' has a wrong offset!");
static_assert(offsetof(UAN_AttackLinkAnimLayer, _originalLength) == 0x000060, "Member 'UAN_AttackLinkAnimLayer::_originalLength' has a wrong offset!");

// Class InGameModule.BattleBriefingPlayerNameWidget
// 0x0090 (0x03E0 - 0x0350)
class UBattleBriefingPlayerNameWidget final : public UWidgetBase
{
public:
	class UWidgetText*                            _playerName;                                       // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                _leaderBG;                                         // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                _spacerTop;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                _spacerBottom;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         _playerFont;                                       // 0x0370(0x0058)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _fontSize;                                         // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spaceTop;                                         // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spaceBottom;                                      // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       _animDecideLeader;                                 // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingPlayerNameWidget">();
	}
	static class UBattleBriefingPlayerNameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingPlayerNameWidget>();
	}
};
static_assert(alignof(UBattleBriefingPlayerNameWidget) == 0x000008, "Wrong alignment on UBattleBriefingPlayerNameWidget");
static_assert(sizeof(UBattleBriefingPlayerNameWidget) == 0x0003E0, "Wrong size on UBattleBriefingPlayerNameWidget");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _playerName) == 0x000350, "Member 'UBattleBriefingPlayerNameWidget::_playerName' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _leaderBG) == 0x000358, "Member 'UBattleBriefingPlayerNameWidget::_leaderBG' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _spacerTop) == 0x000360, "Member 'UBattleBriefingPlayerNameWidget::_spacerTop' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _spacerBottom) == 0x000368, "Member 'UBattleBriefingPlayerNameWidget::_spacerBottom' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _playerFont) == 0x000370, "Member 'UBattleBriefingPlayerNameWidget::_playerFont' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _fontSize) == 0x0003C8, "Member 'UBattleBriefingPlayerNameWidget::_fontSize' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _spaceTop) == 0x0003CC, "Member 'UBattleBriefingPlayerNameWidget::_spaceTop' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _spaceBottom) == 0x0003D0, "Member 'UBattleBriefingPlayerNameWidget::_spaceBottom' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameWidget, _animDecideLeader) == 0x0003D8, "Member 'UBattleBriefingPlayerNameWidget::_animDecideLeader' has a wrong offset!");

// Class InGameModule.ActionAttack_Special_Coop
// 0x0008 (0x0360 - 0x0358)
class UActionAttack_Special_Coop : public UActionAttackSpecialBase
{
public:
	bool                                          _bPlayCoopVoiceAuto;                               // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAttack_Special_Coop">();
	}
	static class UActionAttack_Special_Coop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionAttack_Special_Coop>();
	}
};
static_assert(alignof(UActionAttack_Special_Coop) == 0x000008, "Wrong alignment on UActionAttack_Special_Coop");
static_assert(sizeof(UActionAttack_Special_Coop) == 0x000360, "Wrong size on UActionAttack_Special_Coop");
static_assert(offsetof(UActionAttack_Special_Coop, _bPlayCoopVoiceAuto) == 0x000358, "Member 'UActionAttack_Special_Coop::_bPlayCoopVoiceAuto' has a wrong offset!");

// Class InGameModule.CharacterBattleComponentBase
// 0x0000 (0x00B8 - 0x00B8)
class UCharacterBattleComponentBase : public UCharacterComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBattleComponentBase">();
	}
	static class UCharacterBattleComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBattleComponentBase>();
	}
};
static_assert(alignof(UCharacterBattleComponentBase) == 0x000008, "Wrong alignment on UCharacterBattleComponentBase");
static_assert(sizeof(UCharacterBattleComponentBase) == 0x0000B8, "Wrong size on UCharacterBattleComponentBase");

// Class InGameModule.CharacterChargeEffectComponent
// 0x0020 (0x00D8 - 0x00B8)
class UCharacterChargeEffectComponent final : public UCharacterBattleComponentBase
{
public:
	TArray<struct FChargeEffectInfo>              _effectList;                                       // 0x00B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FChargeEffectInfo>              _completedList;                                    // 0x00C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterChargeEffectComponent">();
	}
	static class UCharacterChargeEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterChargeEffectComponent>();
	}
};
static_assert(alignof(UCharacterChargeEffectComponent) == 0x000008, "Wrong alignment on UCharacterChargeEffectComponent");
static_assert(sizeof(UCharacterChargeEffectComponent) == 0x0000D8, "Wrong size on UCharacterChargeEffectComponent");
static_assert(offsetof(UCharacterChargeEffectComponent, _effectList) == 0x0000B8, "Member 'UCharacterChargeEffectComponent::_effectList' has a wrong offset!");
static_assert(offsetof(UCharacterChargeEffectComponent, _completedList) == 0x0000C8, "Member 'UCharacterChargeEffectComponent::_completedList' has a wrong offset!");

// Class InGameModule.ActionNormalBase
// 0x0000 (0x01B0 - 0x01B0)
class UActionNormalBase : public UActionBattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionNormalBase">();
	}
	static class UActionNormalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionNormalBase>();
	}
};
static_assert(alignof(UActionNormalBase) == 0x000008, "Wrong alignment on UActionNormalBase");
static_assert(sizeof(UActionNormalBase) == 0x0001B0, "Wrong size on UActionNormalBase");

// Class InGameModule.ActionFailedWallThrough
// 0x0000 (0x01B0 - 0x01B0)
class UActionFailedWallThrough : public UActionNormalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionFailedWallThrough">();
	}
	static class UActionFailedWallThrough* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionFailedWallThrough>();
	}
};
static_assert(alignof(UActionFailedWallThrough) == 0x000008, "Wrong alignment on UActionFailedWallThrough");
static_assert(sizeof(UActionFailedWallThrough) == 0x0001B0, "Wrong size on UActionFailedWallThrough");

// Class InGameModule.JumpPadComponent
// 0x0008 (0x00B8 - 0x00B0)
class UJumpPadComponent final : public UActorComponent
{
public:
	float                                         _jumpPower;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginOverlap_JumpPadComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void BP_BindOverlapEvents(class UShapeComponent* Hitshape);
	void EndOverlap_JumpPadComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpPadComponent">();
	}
	static class UJumpPadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJumpPadComponent>();
	}
};
static_assert(alignof(UJumpPadComponent) == 0x000008, "Wrong alignment on UJumpPadComponent");
static_assert(sizeof(UJumpPadComponent) == 0x0000B8, "Wrong size on UJumpPadComponent");
static_assert(offsetof(UJumpPadComponent, _jumpPower) == 0x0000B0, "Member 'UJumpPadComponent::_jumpPower' has a wrong offset!");

// Class InGameModule.ActionAttackFinisher
// 0x0018 (0x0368 - 0x0350)
class UActionAttackFinisher : public UActionAttackBase
{
public:
	class AActor*                                 _firstTargetActor;                                 // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _finisherCompleteSeconds;                          // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _launchDistance;                                   // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healGuardPointRate;                               // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionCancelLength;                               // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_AllLevelUp_Local();
	void BP_RecoverGuardPointInAuthority();

	class AActor* BP_GetFirstTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAttackFinisher">();
	}
	static class UActionAttackFinisher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionAttackFinisher>();
	}
};
static_assert(alignof(UActionAttackFinisher) == 0x000008, "Wrong alignment on UActionAttackFinisher");
static_assert(sizeof(UActionAttackFinisher) == 0x000368, "Wrong size on UActionAttackFinisher");
static_assert(offsetof(UActionAttackFinisher, _firstTargetActor) == 0x000350, "Member 'UActionAttackFinisher::_firstTargetActor' has a wrong offset!");
static_assert(offsetof(UActionAttackFinisher, _finisherCompleteSeconds) == 0x000358, "Member 'UActionAttackFinisher::_finisherCompleteSeconds' has a wrong offset!");
static_assert(offsetof(UActionAttackFinisher, _launchDistance) == 0x00035C, "Member 'UActionAttackFinisher::_launchDistance' has a wrong offset!");
static_assert(offsetof(UActionAttackFinisher, _healGuardPointRate) == 0x000360, "Member 'UActionAttackFinisher::_healGuardPointRate' has a wrong offset!");
static_assert(offsetof(UActionAttackFinisher, _actionCancelLength) == 0x000364, "Member 'UActionAttackFinisher::_actionCancelLength' has a wrong offset!");

// Class InGameModule.BattleEventEffectComponent
// 0x07C0 (0x0870 - 0x00B0)
class UBattleEventEffectComponent final : public UActorComponent
{
public:
	struct FBattleEventEffectInfo                 _begin;                                            // 0x00B0(0x0100)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBattleEventEffectInfo                 _hit;                                              // 0x01B0(0x0100)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBattleEventEffectInfo                 _hitVanish;                                        // 0x02B0(0x0100)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBattleEventEffectInfo                 _wallHit;                                          // 0x03B0(0x0100)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBattleEventEffectInfo                 _wallHitVanish;                                    // 0x04B0(0x0100)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBattleEventEffectInfo                 _break;                                            // 0x05B0(0x0100)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBattleEventEffectInfo                 _vanish;                                           // 0x06B0(0x0100)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _beginTbl;                                         // 0x07B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _hitTbl;                                           // 0x07C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _hitVanishTbl;                                     // 0x07D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _wallHitTbl;                                       // 0x07E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _wallHitVanishTbl;                                 // 0x07F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _breakTbl;                                         // 0x0800(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _vanishTbl;                                        // 0x0810(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _commonTbl;                                        // 0x0820(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _eraseVanishTbl;                                   // 0x0830(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          _bIsPlayEffect;                                    // 0x0840(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_841[0x7];                                      // 0x0841(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _ownerCharacter;                                   // 0x0848(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0x20];                                     // 0x0850(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayEffect(EBattleEventEffectType Type, const struct FTransform& Trs, const class FName& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleEventEffectComponent">();
	}
	static class UBattleEventEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleEventEffectComponent>();
	}
};
static_assert(alignof(UBattleEventEffectComponent) == 0x000010, "Wrong alignment on UBattleEventEffectComponent");
static_assert(sizeof(UBattleEventEffectComponent) == 0x000870, "Wrong size on UBattleEventEffectComponent");
static_assert(offsetof(UBattleEventEffectComponent, _begin) == 0x0000B0, "Member 'UBattleEventEffectComponent::_begin' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _hit) == 0x0001B0, "Member 'UBattleEventEffectComponent::_hit' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _hitVanish) == 0x0002B0, "Member 'UBattleEventEffectComponent::_hitVanish' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _wallHit) == 0x0003B0, "Member 'UBattleEventEffectComponent::_wallHit' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _wallHitVanish) == 0x0004B0, "Member 'UBattleEventEffectComponent::_wallHitVanish' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _break) == 0x0005B0, "Member 'UBattleEventEffectComponent::_break' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _vanish) == 0x0006B0, "Member 'UBattleEventEffectComponent::_vanish' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _beginTbl) == 0x0007B0, "Member 'UBattleEventEffectComponent::_beginTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _hitTbl) == 0x0007C0, "Member 'UBattleEventEffectComponent::_hitTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _hitVanishTbl) == 0x0007D0, "Member 'UBattleEventEffectComponent::_hitVanishTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _wallHitTbl) == 0x0007E0, "Member 'UBattleEventEffectComponent::_wallHitTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _wallHitVanishTbl) == 0x0007F0, "Member 'UBattleEventEffectComponent::_wallHitVanishTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _breakTbl) == 0x000800, "Member 'UBattleEventEffectComponent::_breakTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _vanishTbl) == 0x000810, "Member 'UBattleEventEffectComponent::_vanishTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _commonTbl) == 0x000820, "Member 'UBattleEventEffectComponent::_commonTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _eraseVanishTbl) == 0x000830, "Member 'UBattleEventEffectComponent::_eraseVanishTbl' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _bIsPlayEffect) == 0x000840, "Member 'UBattleEventEffectComponent::_bIsPlayEffect' has a wrong offset!");
static_assert(offsetof(UBattleEventEffectComponent, _ownerCharacter) == 0x000848, "Member 'UBattleEventEffectComponent::_ownerCharacter' has a wrong offset!");

// Class InGameModule.ActionAttackUseItem
// 0x0010 (0x0360 - 0x0350)
class UActionAttackUseItem : public UActionAttackBase
{
public:
	float                                         _useTakeTime;                                      // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0xC];                                      // 0x0354(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_PlayUseSupplyVoice();
	void BP_SetSupplyId(class FName SupplyId);

	class FName BP_GetSuuplyId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAttackUseItem">();
	}
	static class UActionAttackUseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionAttackUseItem>();
	}
};
static_assert(alignof(UActionAttackUseItem) == 0x000008, "Wrong alignment on UActionAttackUseItem");
static_assert(sizeof(UActionAttackUseItem) == 0x000360, "Wrong size on UActionAttackUseItem");
static_assert(offsetof(UActionAttackUseItem, _useTakeTime) == 0x000350, "Member 'UActionAttackUseItem::_useTakeTime' has a wrong offset!");

// Class InGameModule.ActionDamageBase
// 0x0008 (0x01B8 - 0x01B0)
class UActionDamageBase : public UActionBattleBase
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_EndDamage();
	void BP_InitialTurnToDirection(const struct FVector& DamageDirection, EDamageDirection FrontDirection);
	void BP_OnPlayDamageVoiceEvent();
	void BP_ResetCharacterGauge();
	void BP_SetEnableRecover(bool bEnable);
	void BP_SetPlayDamageVoice(bool bPlayDamageVoice);
	void BP_SetSpeedAndRotationForDamageFall();
	void BP_SetSpeedAndRotationForDamageGuard();
	void BP_SetSpeedAndRotationForDamageStrong();
	void BP_SetSpeedAndRotationForDamageStrongBound(const struct FVector& Direction);
	void BP_SetSpeedAndRotationForDamageWeak();
	void BP_SetSpeedAndRotationForDamageZeroGravity();
	void BP_ShiftDamageAction(class FName DamageName);

	const struct FDamageInfo BP_GetDamageInfo() const;
	const struct FDamageParam BP_GetDamageParam() const;
	bool BP_IsDead() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDamageBase">();
	}
	static class UActionDamageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDamageBase>();
	}
};
static_assert(alignof(UActionDamageBase) == 0x000008, "Wrong alignment on UActionDamageBase");
static_assert(sizeof(UActionDamageBase) == 0x0001B8, "Wrong size on UActionDamageBase");

// Class InGameModule.ActionDamageInvolved
// 0x0010 (0x01C8 - 0x01B8)
class UActionDamageInvolved : public UActionDamageBase
{
public:
	float                                         _radius;                                           // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _shape;                                            // 0x01C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDamageInvolved">();
	}
	static class UActionDamageInvolved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDamageInvolved>();
	}
};
static_assert(alignof(UActionDamageInvolved) == 0x000008, "Wrong alignment on UActionDamageInvolved");
static_assert(sizeof(UActionDamageInvolved) == 0x0001C8, "Wrong size on UActionDamageInvolved");
static_assert(offsetof(UActionDamageInvolved, _radius) == 0x0001B8, "Member 'UActionDamageInvolved::_radius' has a wrong offset!");
static_assert(offsetof(UActionDamageInvolved, _shape) == 0x0001C0, "Member 'UActionDamageInvolved::_shape' has a wrong offset!");

// Class InGameModule.DamageParamWork
// 0x0010 (0x0040 - 0x0030)
class UDamageParamWork final : public UGameInstanceSubsystem
{
public:
	TArray<struct FCharacterDamageParamData>      _characterDamageParamDataList;                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnMasterDataInitializeComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageParamWork">();
	}
	static class UDamageParamWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageParamWork>();
	}
};
static_assert(alignof(UDamageParamWork) == 0x000008, "Wrong alignment on UDamageParamWork");
static_assert(sizeof(UDamageParamWork) == 0x000040, "Wrong size on UDamageParamWork");
static_assert(offsetof(UDamageParamWork, _characterDamageParamDataList) == 0x000030, "Member 'UDamageParamWork::_characterDamageParamDataList' has a wrong offset!");

// Class InGameModule.ActionCameraBase
// 0x0020 (0x02D0 - 0x02B0)
class AActionCameraBase final : public AActionCameraActor
{
public:
	class ACharacterBattle*                       _myCharacter;                                      // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UANS_ActionCameraBeginBattle*           _paramBattle;                                      // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionCameraBase">();
	}
	static class AActionCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionCameraBase>();
	}
};
static_assert(alignof(AActionCameraBase) == 0x000010, "Wrong alignment on AActionCameraBase");
static_assert(sizeof(AActionCameraBase) == 0x0002D0, "Wrong size on AActionCameraBase");
static_assert(offsetof(AActionCameraBase, _myCharacter) == 0x0002A8, "Member 'AActionCameraBase::_myCharacter' has a wrong offset!");
static_assert(offsetof(AActionCameraBase, _paramBattle) == 0x0002B0, "Member 'AActionCameraBase::_paramBattle' has a wrong offset!");

// Class InGameModule.BgHismComponent
// 0x0040 (0x06C0 - 0x0680)
class UBgHismComponent : public UHierarchicalInstancedStaticMeshComponent
{
public:
	int32                                         _damage;                                           // 0x0678(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_67C[0x1C];                                     // 0x067C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RemoveIndexHistory;                                // 0x0698(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x10];                                     // 0x06A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _instanceNum;                                      // 0x06B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RemoveIndexHistory();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgHismComponent">();
	}
	static class UBgHismComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgHismComponent>();
	}
};
static_assert(alignof(UBgHismComponent) == 0x000010, "Wrong alignment on UBgHismComponent");
static_assert(sizeof(UBgHismComponent) == 0x0006C0, "Wrong size on UBgHismComponent");
static_assert(offsetof(UBgHismComponent, _damage) == 0x000678, "Member 'UBgHismComponent::_damage' has a wrong offset!");
static_assert(offsetof(UBgHismComponent, RemoveIndexHistory) == 0x000698, "Member 'UBgHismComponent::RemoveIndexHistory' has a wrong offset!");
static_assert(offsetof(UBgHismComponent, _instanceNum) == 0x0006B8, "Member 'UBgHismComponent::_instanceNum' has a wrong offset!");

// Class InGameModule.ActionCameraGrabbed
// 0x0010 (0x02C0 - 0x02B0)
class AActionCameraGrabbed final : public AActionCameraTimeActor
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionCameraGrabbed">();
	}
	static class AActionCameraGrabbed* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionCameraGrabbed>();
	}
};
static_assert(alignof(AActionCameraGrabbed) == 0x000010, "Wrong alignment on AActionCameraGrabbed");
static_assert(sizeof(AActionCameraGrabbed) == 0x0002C0, "Wrong size on AActionCameraGrabbed");

// Class InGameModule.KillLogWidget
// 0x0048 (0x0398 - 0x0350)
class UKillLogWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfKillLogPreview;                           // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           _killLogVerticalBox;                               // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       _killLogWrapperSlot;                               // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _killLogStartPosition;                             // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _killLogMaxLength;                                 // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKillLogChildWidget>        _killLogWidgetCreate;                              // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UKillLogChildWidget*>            _currentVisibleKillLogs;                           // 0x0388(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillLogWidget">();
	}
	static class UKillLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillLogWidget>();
	}
};
static_assert(alignof(UKillLogWidget) == 0x000008, "Wrong alignment on UKillLogWidget");
static_assert(sizeof(UKillLogWidget) == 0x000398, "Wrong size on UKillLogWidget");
static_assert(offsetof(UKillLogWidget, _numberOfKillLogPreview) == 0x000358, "Member 'UKillLogWidget::_numberOfKillLogPreview' has a wrong offset!");
static_assert(offsetof(UKillLogWidget, _killLogVerticalBox) == 0x000360, "Member 'UKillLogWidget::_killLogVerticalBox' has a wrong offset!");
static_assert(offsetof(UKillLogWidget, _killLogWrapperSlot) == 0x000368, "Member 'UKillLogWidget::_killLogWrapperSlot' has a wrong offset!");
static_assert(offsetof(UKillLogWidget, _killLogStartPosition) == 0x000370, "Member 'UKillLogWidget::_killLogStartPosition' has a wrong offset!");
static_assert(offsetof(UKillLogWidget, _killLogMaxLength) == 0x000378, "Member 'UKillLogWidget::_killLogMaxLength' has a wrong offset!");
static_assert(offsetof(UKillLogWidget, _killLogWidgetCreate) == 0x000380, "Member 'UKillLogWidget::_killLogWidgetCreate' has a wrong offset!");
static_assert(offsetof(UKillLogWidget, _currentVisibleKillLogs) == 0x000388, "Member 'UKillLogWidget::_currentVisibleKillLogs' has a wrong offset!");

// Class InGameModule.ActionGrabbed
// 0x0008 (0x01B8 - 0x01B0)
class UActionGrabbed : public UActionBattleBase
{
public:
	bool                                          _bDisableAnimEffect;                               // 0x01B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionGrabbed">();
	}
	static class UActionGrabbed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionGrabbed>();
	}
};
static_assert(alignof(UActionGrabbed) == 0x000008, "Wrong alignment on UActionGrabbed");
static_assert(sizeof(UActionGrabbed) == 0x0001B8, "Wrong size on UActionGrabbed");
static_assert(offsetof(UActionGrabbed, _bDisableAnimEffect) == 0x0001B0, "Member 'UActionGrabbed::_bDisableAnimEffect' has a wrong offset!");

// Class InGameModule.BattleSequenceComponent
// 0x0028 (0x0050 - 0x0028)
class UBattleSequenceComponent : public UObject
{
public:
	class UScoreComponentBase*                    _scoreComponent;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGameModeBattle*                        _gameMode;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSequenceComponent">();
	}
	static class UBattleSequenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSequenceComponent>();
	}
};
static_assert(alignof(UBattleSequenceComponent) == 0x000008, "Wrong alignment on UBattleSequenceComponent");
static_assert(sizeof(UBattleSequenceComponent) == 0x000050, "Wrong size on UBattleSequenceComponent");
static_assert(offsetof(UBattleSequenceComponent, _scoreComponent) == 0x000028, "Member 'UBattleSequenceComponent::_scoreComponent' has a wrong offset!");
static_assert(offsetof(UBattleSequenceComponent, _gameMode) == 0x000030, "Member 'UBattleSequenceComponent::_gameMode' has a wrong offset!");

// Class InGameModule.BattleSequenceComponentCustomMatch
// 0x0010 (0x0060 - 0x0050)
class UBattleSequenceComponentCustomMatch final : public UBattleSequenceComponent
{
public:
	struct FTimerHandle                           _forceQuitTimerHandle;                             // 0x0050(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSequenceComponentCustomMatch">();
	}
	static class UBattleSequenceComponentCustomMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSequenceComponentCustomMatch>();
	}
};
static_assert(alignof(UBattleSequenceComponentCustomMatch) == 0x000008, "Wrong alignment on UBattleSequenceComponentCustomMatch");
static_assert(sizeof(UBattleSequenceComponentCustomMatch) == 0x000060, "Wrong size on UBattleSequenceComponentCustomMatch");
static_assert(offsetof(UBattleSequenceComponentCustomMatch, _forceQuitTimerHandle) == 0x000050, "Member 'UBattleSequenceComponentCustomMatch::_forceQuitTimerHandle' has a wrong offset!");

// Class InGameModule.ActionCarried
// 0x0000 (0x01B8 - 0x01B8)
class UActionCarried : public UActionGrabbed
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionCarried">();
	}
	static class UActionCarried* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionCarried>();
	}
};
static_assert(alignof(UActionCarried) == 0x000008, "Wrong alignment on UActionCarried");
static_assert(sizeof(UActionCarried) == 0x0001B8, "Wrong size on UActionCarried");

// Class InGameModule.ActionEmote
// 0x0000 (0x01B0 - 0x01B0)
class UActionEmote : public UActionBattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionEmote">();
	}
	static class UActionEmote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionEmote>();
	}
};
static_assert(alignof(UActionEmote) == 0x000008, "Wrong alignment on UActionEmote");
static_assert(sizeof(UActionEmote) == 0x0001B0, "Wrong size on UActionEmote");

// Class InGameModule.DialogueWidget
// 0x0078 (0x03C8 - 0x0350)
class UDialogueWidget final : public UWidgetBase
{
public:
	class UCanvasPanel*                           _rootCanvasPanel;                                  // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       _panelSlotForDialogueBox;                          // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rowSize;                                          // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               _teamDialogueOverlay;                              // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDialogueTextBlock>         _teamDialogueBox;                                  // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _boxLifeTimeFromLastMessage;                       // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _maxMessageRowsNum;                                // 0x037C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDialogueTextBlock*>             _showingMessageList;                               // 0x0380(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _playerState;                                      // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         _messageVoiceComponent;                            // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           _dialogueVerticalBox;                              // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideDialogueBox();
	void OnBattleSequenceChanged(EBattleSequence NewSequence);
	void OnCharacterVoiceMessageReceived(int16 SenderPlayerId, const class FString& InKeyForTable);
	void PlayAllyBattleResultMessage(const class ACharacterBattle* Victim, const class ACharacterBattle* Aggriever);
	void PlayAllyDyingMessage(const class ACharacterBattle* Victim, const class ACharacterBattle* Aggriever);
	void PlayPlayerStateDeadVoice(class UAtomComponent* AtomComponent);
	void RemoveFromMessageArray(class UDialogueTextBlock* TargetMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueWidget">();
	}
	static class UDialogueWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueWidget>();
	}
};
static_assert(alignof(UDialogueWidget) == 0x000008, "Wrong alignment on UDialogueWidget");
static_assert(sizeof(UDialogueWidget) == 0x0003C8, "Wrong size on UDialogueWidget");
static_assert(offsetof(UDialogueWidget, _rootCanvasPanel) == 0x000350, "Member 'UDialogueWidget::_rootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _panelSlotForDialogueBox) == 0x000358, "Member 'UDialogueWidget::_panelSlotForDialogueBox' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _rowSize) == 0x000360, "Member 'UDialogueWidget::_rowSize' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _teamDialogueOverlay) == 0x000368, "Member 'UDialogueWidget::_teamDialogueOverlay' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _teamDialogueBox) == 0x000370, "Member 'UDialogueWidget::_teamDialogueBox' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _boxLifeTimeFromLastMessage) == 0x000378, "Member 'UDialogueWidget::_boxLifeTimeFromLastMessage' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _maxMessageRowsNum) == 0x00037C, "Member 'UDialogueWidget::_maxMessageRowsNum' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _showingMessageList) == 0x000380, "Member 'UDialogueWidget::_showingMessageList' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _playerState) == 0x000398, "Member 'UDialogueWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _playerController) == 0x0003A0, "Member 'UDialogueWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _messageVoiceComponent) == 0x0003A8, "Member 'UDialogueWidget::_messageVoiceComponent' has a wrong offset!");
static_assert(offsetof(UDialogueWidget, _dialogueVerticalBox) == 0x0003B0, "Member 'UDialogueWidget::_dialogueVerticalBox' has a wrong offset!");

// Class InGameModule.BattleCounterBase
// 0x0028 (0x0378 - 0x0350)
class UBattleCounterBase : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameTeamInfoComponent*                 _teamInfoComponent;                                // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillLogManagerComponent*               _killLogManager;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerStateBattle*                     _playerState;                                      // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCaptionText();
	void UpdateCounter();
	void UpdateCounterNoArgsWrapper();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCounterBase">();
	}
	static class UBattleCounterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleCounterBase>();
	}
};
static_assert(alignof(UBattleCounterBase) == 0x000008, "Wrong alignment on UBattleCounterBase");
static_assert(sizeof(UBattleCounterBase) == 0x000378, "Wrong size on UBattleCounterBase");
static_assert(offsetof(UBattleCounterBase, _teamInfoComponent) == 0x000358, "Member 'UBattleCounterBase::_teamInfoComponent' has a wrong offset!");
static_assert(offsetof(UBattleCounterBase, _killLogManager) == 0x000360, "Member 'UBattleCounterBase::_killLogManager' has a wrong offset!");
static_assert(offsetof(UBattleCounterBase, _playerState) == 0x000368, "Member 'UBattleCounterBase::_playerState' has a wrong offset!");

// Class InGameModule.ActionDamageFall
// 0x0000 (0x01B8 - 0x01B8)
class UActionDamageFall : public UActionDamageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDamageFall">();
	}
	static class UActionDamageFall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDamageFall>();
	}
};
static_assert(alignof(UActionDamageFall) == 0x000008, "Wrong alignment on UActionDamageFall");
static_assert(sizeof(UActionDamageFall) == 0x0001B8, "Wrong size on UActionDamageFall");

// Class InGameModule.ActionDamageGrabbed
// 0x0000 (0x01B8 - 0x01B8)
class UActionDamageGrabbed : public UActionDamageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDamageGrabbed">();
	}
	static class UActionDamageGrabbed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDamageGrabbed>();
	}
};
static_assert(alignof(UActionDamageGrabbed) == 0x000008, "Wrong alignment on UActionDamageGrabbed");
static_assert(sizeof(UActionDamageGrabbed) == 0x0001B8, "Wrong size on UActionDamageGrabbed");

// Class InGameModule.ActionDamagePulledUp
// 0x0010 (0x01C8 - 0x01B8)
class UActionDamagePulledUp : public UActionDamageBase
{
public:
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDamagePulledUp">();
	}
	static class UActionDamagePulledUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDamagePulledUp>();
	}
};
static_assert(alignof(UActionDamagePulledUp) == 0x000008, "Wrong alignment on UActionDamagePulledUp");
static_assert(sizeof(UActionDamagePulledUp) == 0x0001C8, "Wrong size on UActionDamagePulledUp");

// Class InGameModule.CharacterLinkedAnimationControlComponent
// 0x0138 (0x01F0 - 0x00B8)
class alignas(0x10) UCharacterLinkedAnimationControlComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              _linkedAnimClass;                                  // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x110];                                     // 0x00C8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class ACustomBullet*                          _attachedBullet;                                   // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _attachedCharacter;                                // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_AttachToBullet(class ACustomBullet* Bullet);
	void BP_AttachToCharacter(class ACharacterBattle* Character, class FName SocketName);
	void BP_LinkAnimation(TSubclassOf<class UAnimInstanceAttack> InClass);
	void BP_LinkAnimationWithBlend(TSubclassOf<class UAnimInstanceAttack> InClass, float BlendTime);
	void BP_OnHitToCharacter(class ACharacterBattle* Character, class FName SocketName);
	void BP_SetTargetLocation(const struct FVector& Location);
	void BP_UnlinkAnimation();
	void BP_UnlinkAnimationWithBlend(float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterLinkedAnimationControlComponent">();
	}
	static class UCharacterLinkedAnimationControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterLinkedAnimationControlComponent>();
	}
};
static_assert(alignof(UCharacterLinkedAnimationControlComponent) == 0x000010, "Wrong alignment on UCharacterLinkedAnimationControlComponent");
static_assert(sizeof(UCharacterLinkedAnimationControlComponent) == 0x0001F0, "Wrong size on UCharacterLinkedAnimationControlComponent");
static_assert(offsetof(UCharacterLinkedAnimationControlComponent, _linkedAnimClass) == 0x0000C0, "Member 'UCharacterLinkedAnimationControlComponent::_linkedAnimClass' has a wrong offset!");
static_assert(offsetof(UCharacterLinkedAnimationControlComponent, _attachedBullet) == 0x0001D8, "Member 'UCharacterLinkedAnimationControlComponent::_attachedBullet' has a wrong offset!");
static_assert(offsetof(UCharacterLinkedAnimationControlComponent, _attachedCharacter) == 0x0001E0, "Member 'UCharacterLinkedAnimationControlComponent::_attachedCharacter' has a wrong offset!");

// Class InGameModule.ActionDamageStrong
// 0x0000 (0x01B8 - 0x01B8)
class UActionDamageStrong : public UActionDamageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDamageStrong">();
	}
	static class UActionDamageStrong* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDamageStrong>();
	}
};
static_assert(alignof(UActionDamageStrong) == 0x000008, "Wrong alignment on UActionDamageStrong");
static_assert(sizeof(UActionDamageStrong) == 0x0001B8, "Wrong size on UActionDamageStrong");

// Class InGameModule.ActionDie
// 0x0000 (0x01B0 - 0x01B0)
class UActionDie : public UActionBattleBase
{
public:
	void BP_RespawnCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDie">();
	}
	static class UActionDie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDie>();
	}
};
static_assert(alignof(UActionDie) == 0x000008, "Wrong alignment on UActionDie");
static_assert(sizeof(UActionDie) == 0x0001B0, "Wrong size on UActionDie");

// Class InGameModule.ActionOpenBox
// 0x0008 (0x01B8 - 0x01B0)
class UActionOpenBox : public UActionNormalBase
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_NegotiationCompleted();
	void BP_OpenComplete();
	void BP_SetEnablePoisonMistReductionEvent(bool bEnable);

	float BP_GetRequiredOpenTime() const;
	bool BP_IsLarge(const class AActor* ActionTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionOpenBox">();
	}
	static class UActionOpenBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionOpenBox>();
	}
};
static_assert(alignof(UActionOpenBox) == 0x000008, "Wrong alignment on UActionOpenBox");
static_assert(sizeof(UActionOpenBox) == 0x0001B8, "Wrong size on UActionOpenBox");

// Class InGameModule.ActionParkourJump
// 0x0008 (0x01B8 - 0x01B0)
class UActionParkourJump : public UActionNormalBase
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float BP_GetDestHeight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionParkourJump">();
	}
	static class UActionParkourJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionParkourJump>();
	}
};
static_assert(alignof(UActionParkourJump) == 0x000008, "Wrong alignment on UActionParkourJump");
static_assert(sizeof(UActionParkourJump) == 0x0001B8, "Wrong size on UActionParkourJump");

// Class InGameModule.UMGEffectAttachedToActor
// 0x0060 (0x03B0 - 0x0350)
class UUMGEffectAttachedToActor : public UWidgetBase
{
public:
	float                                         _lifeTime;                                         // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerBattle*                _playerController;                                 // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       _slot;                                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       _animation;                                        // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x30];                                     // 0x0380(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Deactivate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGEffectAttachedToActor">();
	}
	static class UUMGEffectAttachedToActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGEffectAttachedToActor>();
	}
};
static_assert(alignof(UUMGEffectAttachedToActor) == 0x000008, "Wrong alignment on UUMGEffectAttachedToActor");
static_assert(sizeof(UUMGEffectAttachedToActor) == 0x0003B0, "Wrong size on UUMGEffectAttachedToActor");
static_assert(offsetof(UUMGEffectAttachedToActor, _lifeTime) == 0x000350, "Member 'UUMGEffectAttachedToActor::_lifeTime' has a wrong offset!");
static_assert(offsetof(UUMGEffectAttachedToActor, _playerController) == 0x000358, "Member 'UUMGEffectAttachedToActor::_playerController' has a wrong offset!");
static_assert(offsetof(UUMGEffectAttachedToActor, _slot) == 0x000360, "Member 'UUMGEffectAttachedToActor::_slot' has a wrong offset!");
static_assert(offsetof(UUMGEffectAttachedToActor, _animation) == 0x000378, "Member 'UUMGEffectAttachedToActor::_animation' has a wrong offset!");

// Class InGameModule.DownWidget
// 0x0008 (0x03B8 - 0x03B0)
class UDownWidget final : public UUMGEffectAttachedToActor
{
public:
	class UWidgetSwitcher*                        _downSwitcher;                                     // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownWidget">();
	}
	static class UDownWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownWidget>();
	}
};
static_assert(alignof(UDownWidget) == 0x000008, "Wrong alignment on UDownWidget");
static_assert(sizeof(UDownWidget) == 0x0003B8, "Wrong size on UDownWidget");
static_assert(offsetof(UDownWidget, _downSwitcher) == 0x0003B0, "Member 'UDownWidget::_downSwitcher' has a wrong offset!");

// Class InGameModule.ActionPlusUltra
// 0x0000 (0x01B0 - 0x01B0)
class UActionPlusUltra : public UActionNormalBase
{
public:
	void BP_CreateAttackCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPlusUltra">();
	}
	static class UActionPlusUltra* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionPlusUltra>();
	}
};
static_assert(alignof(UActionPlusUltra) == 0x000008, "Wrong alignment on UActionPlusUltra");
static_assert(sizeof(UActionPlusUltra) == 0x0001B0, "Wrong size on UActionPlusUltra");

// Class InGameModule.CircularProgressBarWidget
// 0x0020 (0x0370 - 0x0350)
class UCircularProgressBarWidget final : public UWidgetBase
{
public:
	float                                         _timeRate;                                         // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _progressImage;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _icon;                                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _usingSupplyTimerMID;                              // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CircularProgressBarWidget">();
	}
	static class UCircularProgressBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCircularProgressBarWidget>();
	}
};
static_assert(alignof(UCircularProgressBarWidget) == 0x000008, "Wrong alignment on UCircularProgressBarWidget");
static_assert(sizeof(UCircularProgressBarWidget) == 0x000370, "Wrong size on UCircularProgressBarWidget");
static_assert(offsetof(UCircularProgressBarWidget, _timeRate) == 0x000350, "Member 'UCircularProgressBarWidget::_timeRate' has a wrong offset!");
static_assert(offsetof(UCircularProgressBarWidget, _progressImage) == 0x000358, "Member 'UCircularProgressBarWidget::_progressImage' has a wrong offset!");
static_assert(offsetof(UCircularProgressBarWidget, _icon) == 0x000360, "Member 'UCircularProgressBarWidget::_icon' has a wrong offset!");
static_assert(offsetof(UCircularProgressBarWidget, _usingSupplyTimerMID) == 0x000368, "Member 'UCircularProgressBarWidget::_usingSupplyTimerMID' has a wrong offset!");

// Class InGameModule.ActionRecoverAlly
// 0x0000 (0x01B0 - 0x01B0)
class UActionRecoverAlly : public UActionNormalBase
{
public:
	void BP_PlayVoice();
	void BP_RecoverSuccessful();

	float BP_GetRequiredRecoverTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionRecoverAlly">();
	}
	static class UActionRecoverAlly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionRecoverAlly>();
	}
};
static_assert(alignof(UActionRecoverAlly) == 0x000008, "Wrong alignment on UActionRecoverAlly");
static_assert(sizeof(UActionRecoverAlly) == 0x0001B0, "Wrong size on UActionRecoverAlly");

// Class InGameModule.ActionRecoverCitizen
// 0x0000 (0x01B0 - 0x01B0)
class UActionRecoverCitizen : public UActionNormalBase
{
public:
	void BP_CitizenRecoveryBegin();
	void BP_CitizenRecoveryComplete();
	void BP_CitizenRecoveryEnd();

	float BP_GetRequiredRecoverTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionRecoverCitizen">();
	}
	static class UActionRecoverCitizen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionRecoverCitizen>();
	}
};
static_assert(alignof(UActionRecoverCitizen) == 0x000008, "Wrong alignment on UActionRecoverCitizen");
static_assert(sizeof(UActionRecoverCitizen) == 0x0001B0, "Wrong size on UActionRecoverCitizen");

// Class InGameModule.ActionRespawnAlly
// 0x0008 (0x01B8 - 0x01B0)
class UActionRespawnAlly : public UActionNormalBase
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_DecideRespawnLocation();

	float BP_GetRequiredRespawnTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionRespawnAlly">();
	}
	static class UActionRespawnAlly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionRespawnAlly>();
	}
};
static_assert(alignof(UActionRespawnAlly) == 0x000008, "Wrong alignment on UActionRespawnAlly");
static_assert(sizeof(UActionRespawnAlly) == 0x0001B8, "Wrong size on UActionRespawnAlly");

// Class InGameModule.ExPostProcessVolume
// 0x0040 (0x0810 - 0x07D0)
class AExPostProcessVolume final : public APostProcessVolume
{
public:
	class UMaterialParameterCollection*           _materialParameterCollection;                      // 0x07D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _ctrlParamName;                                    // 0x07D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _ctrlParam;                                        // 0x07E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSphere;                                          // 0x07F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExUnbound;                                       // 0x07F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F2[0x1E];                                     // 0x07F2(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExPostProcessVolume">();
	}
	static class AExPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExPostProcessVolume>();
	}
};
static_assert(alignof(AExPostProcessVolume) == 0x000010, "Wrong alignment on AExPostProcessVolume");
static_assert(sizeof(AExPostProcessVolume) == 0x000810, "Wrong size on AExPostProcessVolume");
static_assert(offsetof(AExPostProcessVolume, _materialParameterCollection) == 0x0007D0, "Member 'AExPostProcessVolume::_materialParameterCollection' has a wrong offset!");
static_assert(offsetof(AExPostProcessVolume, _ctrlParamName) == 0x0007D8, "Member 'AExPostProcessVolume::_ctrlParamName' has a wrong offset!");
static_assert(offsetof(AExPostProcessVolume, _ctrlParam) == 0x0007E0, "Member 'AExPostProcessVolume::_ctrlParam' has a wrong offset!");
static_assert(offsetof(AExPostProcessVolume, IsSphere) == 0x0007F0, "Member 'AExPostProcessVolume::IsSphere' has a wrong offset!");
static_assert(offsetof(AExPostProcessVolume, IsExUnbound) == 0x0007F1, "Member 'AExPostProcessVolume::IsExUnbound' has a wrong offset!");

// Class InGameModule.ActionScoutEnemy
// 0x0008 (0x01B8 - 0x01B0)
class UActionScoutEnemy : public UActionNormalBase
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnScoutRequestCompleteEvent(bool bSuccess);
	void BP_PlayVoice();
	void BP_RecoverSuccessful();
	void BP_ScoutRequest();

	float BP_GetRequiredRecoverTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionScoutEnemy">();
	}
	static class UActionScoutEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionScoutEnemy>();
	}
};
static_assert(alignof(UActionScoutEnemy) == 0x000008, "Wrong alignment on UActionScoutEnemy");
static_assert(sizeof(UActionScoutEnemy) == 0x0001B8, "Wrong size on UActionScoutEnemy");

// Class InGameModule.CharacterInfoInterface
// 0x0000 (0x0028 - 0x0028)
class ICharacterInfoInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInfoInterface">();
	}
	static class ICharacterInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterInfoInterface>();
	}
};
static_assert(alignof(ICharacterInfoInterface) == 0x000008, "Wrong alignment on ICharacterInfoInterface");
static_assert(sizeof(ICharacterInfoInterface) == 0x000028, "Wrong size on ICharacterInfoInterface");

// Class InGameModule.ActionSleepForWholeAttack
// 0x0000 (0x01B0 - 0x01B0)
class UActionSleepForWholeAttack final : public UActionBattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionSleepForWholeAttack">();
	}
	static class UActionSleepForWholeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionSleepForWholeAttack>();
	}
};
static_assert(alignof(UActionSleepForWholeAttack) == 0x000008, "Wrong alignment on UActionSleepForWholeAttack");
static_assert(sizeof(UActionSleepForWholeAttack) == 0x0001B0, "Wrong size on UActionSleepForWholeAttack");

// Class InGameModule.ActionSleepForWholeDamage
// 0x0000 (0x01B0 - 0x01B0)
class UActionSleepForWholeDamage final : public UActionBattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionSleepForWholeDamage">();
	}
	static class UActionSleepForWholeDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionSleepForWholeDamage>();
	}
};
static_assert(alignof(UActionSleepForWholeDamage) == 0x000008, "Wrong alignment on UActionSleepForWholeDamage");
static_assert(sizeof(UActionSleepForWholeDamage) == 0x0001B0, "Wrong size on UActionSleepForWholeDamage");

// Class InGameModule.ActionThrowned
// 0x0010 (0x01C0 - 0x01B0)
class UActionThrowned : public UActionBattleBase
{
public:
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FVector BP_GetThrownedDirection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionThrowned">();
	}
	static class UActionThrowned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionThrowned>();
	}
};
static_assert(alignof(UActionThrowned) == 0x000008, "Wrong alignment on UActionThrowned");
static_assert(sizeof(UActionThrowned) == 0x0001C0, "Wrong size on UActionThrowned");

// Class InGameModule.CharacterBattleVoiceComponent
// 0x0050 (0x12C0 - 0x1270)
class UCharacterBattleVoiceComponent final : public UCharacterVoiceComponent
{
public:
	uint8                                         Pad_1270[0x50];                                    // 0x1270(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_PlayCharacterVoice(const class FString& VoiceName, bool UseWholeCueName, bool bAllMember);
	void BP_PlayDamageVoice(const class FString& VoiceName, const struct FDamageInfo& DamageInfo);
	void BP_SetIgnoreNotifyEvent(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBattleVoiceComponent">();
	}
	static class UCharacterBattleVoiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBattleVoiceComponent>();
	}
};
static_assert(alignof(UCharacterBattleVoiceComponent) == 0x000010, "Wrong alignment on UCharacterBattleVoiceComponent");
static_assert(sizeof(UCharacterBattleVoiceComponent) == 0x0012C0, "Wrong size on UCharacterBattleVoiceComponent");

// Class InGameModule.ActionWallCrawl
// 0x0008 (0x01B8 - 0x01B0)
class UActionWallCrawl : public UActionNormalBase
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_SetWallCrawlState(EWallCrawlState State);

	struct FVector BP_GetDestForwardDirection() const;
	struct FVector BP_GetDestVerticalDirection() const;
	EWallCrawlState BP_GetWallCrawlState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionWallCrawl">();
	}
	static class UActionWallCrawl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionWallCrawl>();
	}
};
static_assert(alignof(UActionWallCrawl) == 0x000008, "Wrong alignment on UActionWallCrawl");
static_assert(sizeof(UActionWallCrawl) == 0x0001B8, "Wrong size on UActionWallCrawl");

// Class InGameModule.Bullet
// 0x1BC0 (0x1DE0 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) ABullet : public AActor
{
public:
	struct FBulletSE                              _beginSE;                                          // 0x0220(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBulletSE                              _vanishSE;                                         // 0x0240(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EWarpCopyType                                 _warpType;                                         // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleEventEffectComponent*            _battleEventEffectComp;                            // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroProjectileMovementComponent*       _projectileMovementComp;                           // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileReplicateBattleComponent*    _replicator;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletRestoreComponent*                _restoreComp;                                      // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInGameDecalComponent*>          _inGameDecalComponents;                            // 0x0288(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UBulletTimeEventComponent*              _bulletTimeEventComponent;                         // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x1A10];                                   // 0x02A0(0x1A10)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _subClass;                                         // 0x1CB0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB8[0x8];                                     // 0x1CB8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitColInfo>                    _hitColInfoTbl;                                    // 0x1CC0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHitColInfo>                    _hitBGColInfoTbl;                                  // 0x1CD0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CE0[0x10];                                    // 0x1CE0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UShapeComponent*>                _hitAIColTbl;                                      // 0x1CF0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UCustomParticleSystemComponent*> _customParticleTbl;                                // 0x1D00(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBattleCustomParticleSystemComponent*> _battleParticleTbl;                                // 0x1D10(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBulletParticleSystemComponent*> _bulletParticleTbl;                                // 0x1D20(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBulletParticleSetComponent*>    _bulletParticleSetTbl;                             // 0x1D30(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ACharacterBattle*                       _viewCharacter;                                    // 0x1D40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacterBattle*                       _ownerChr;                                         // 0x1D48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacterBattle*                       _baseOwnerChr;                                     // 0x1D50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AProjectileGeneratorBattle*             _ownerGen;                                         // 0x1D58(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _parent;                                           // 0x1D60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABullet*                                _parentBullet;                                     // 0x1D68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABgProp*                                _parentBgProp;                                     // 0x1D70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D78[0x8];                                     // 0x1D78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         _beginSEComp;                                      // 0x1D80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _vanishSEComp;                                     // 0x1D88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           _restoreRemoveTimer;                               // 0x1D90(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bNoClimb;                                         // 0x1D98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bNoDashClimb;                                     // 0x1D99(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bNoIgnoreBasis;                                   // 0x1D9A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOtherClientHitCol;                               // 0x1D9B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bReceiveAlwaysHit;                                // 0x1D9C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9D[0x3];                                     // 0x1D9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _wallSlideRate;                                    // 0x1DA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _wallBlockTranslucent;                             // 0x1DA4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA5[0x3];                                     // 0x1DA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forceTargetAlpha;                                 // 0x1DA8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _forceTargetAlphaTime;                             // 0x1DAC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _firstMovementSkipFrame;                           // 0x1DB0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB1[0x27];                                    // 0x1DB1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Exit();
	void BP_OnHitReceiveBackground();
	float BP_ResetLimit(float Time);
	void BP_RestoreBegin();
	void BP_RestoreBeginAfter();
	struct FVector BP_SetVelocity(const struct FVector& NewVelocity);
	void BP_StopBeginSE();
	void BP_TimeUp(EBulletDestroyType DestroyType);
	void OnBackgroundHitCountZero(const struct FHitResult& Hit);
	void OnCharacterHitCountZero(const struct FHitResult& Hit);
	void OnCollisionComponentDestroyed(class UPrimitiveComponent* PrimitiveComponent);
	bool OnFirstHitBackground(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	bool OnFirstHitCharacter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	bool OnHitBackground(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	bool OnHitCharacter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	EHitThrowType OnHitReceiveBackground(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnHitSPEventDelegate__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnPostHit(const struct FHeroHitCollisionInfo& CastHitInfo, class AActor* HitActor);
	bool OnPreHitBackground(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	bool OnPreHitCharacter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

	bool BP_CharacterEqual(const class ABullet* Src) const;
	ECharacterId BP_GetCharacterId() const;
	const TArray<struct FHitCollision> BP_GetHitCols() const;
	int32 BP_GetLevel() const;
	const struct FBulletLevelData BP_GetLevelDB() const;
	float BP_GetLimit() const;
	const struct FLimit BP_GetLimitMax() const;
	class UHeroProjectileMovementComponent* BP_GetProjectileMovementComponent() const;
	struct FRandomStream BP_GetRandStream() const;
	const struct FVector BP_InitDirection() const;
	const struct FVector BP_InitLocation() const;
	const struct FQuat BP_InitRotation() const;
	const struct FVector BP_InitScale() const;
	const struct FVector BP_InitTarget() const;
	bool BP_IsLimit() const;
	const struct FVector BP_PrevLocate() const;
	EAttackId GetAttackId() const;
	class ACharacterBattle* GetBaseOwnerCharacterBattle() const;
	ECharacterId GetCharacterID() const;
	ECommandId GetCommandID() const;
	bool GetIsProjectileCreatorMode() const;
	bool GetIsRestoreLoad() const;
	float GetOverrideLimitTime() const;
	class ACharacterBattle* GetOwnerCharacterBattle() const;
	class AProjectileGeneratorBattle* GetOwnerGenerator() const;
	uint8 GetPlayerId() const;
	uint8 GetTeamID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bullet">();
	}
	static class ABullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABullet>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABullet) == 0x000010, "Wrong alignment on ABullet");
static_assert(sizeof(ABullet) == 0x001DE0, "Wrong size on ABullet");
static_assert(offsetof(ABullet, _beginSE) == 0x000220, "Member 'ABullet::_beginSE' has a wrong offset!");
static_assert(offsetof(ABullet, _vanishSE) == 0x000240, "Member 'ABullet::_vanishSE' has a wrong offset!");
static_assert(offsetof(ABullet, _warpType) == 0x000260, "Member 'ABullet::_warpType' has a wrong offset!");
static_assert(offsetof(ABullet, _battleEventEffectComp) == 0x000268, "Member 'ABullet::_battleEventEffectComp' has a wrong offset!");
static_assert(offsetof(ABullet, _projectileMovementComp) == 0x000270, "Member 'ABullet::_projectileMovementComp' has a wrong offset!");
static_assert(offsetof(ABullet, _replicator) == 0x000278, "Member 'ABullet::_replicator' has a wrong offset!");
static_assert(offsetof(ABullet, _restoreComp) == 0x000280, "Member 'ABullet::_restoreComp' has a wrong offset!");
static_assert(offsetof(ABullet, _inGameDecalComponents) == 0x000288, "Member 'ABullet::_inGameDecalComponents' has a wrong offset!");
static_assert(offsetof(ABullet, _bulletTimeEventComponent) == 0x000298, "Member 'ABullet::_bulletTimeEventComponent' has a wrong offset!");
static_assert(offsetof(ABullet, _subClass) == 0x001CB0, "Member 'ABullet::_subClass' has a wrong offset!");
static_assert(offsetof(ABullet, _hitColInfoTbl) == 0x001CC0, "Member 'ABullet::_hitColInfoTbl' has a wrong offset!");
static_assert(offsetof(ABullet, _hitBGColInfoTbl) == 0x001CD0, "Member 'ABullet::_hitBGColInfoTbl' has a wrong offset!");
static_assert(offsetof(ABullet, _hitAIColTbl) == 0x001CF0, "Member 'ABullet::_hitAIColTbl' has a wrong offset!");
static_assert(offsetof(ABullet, _customParticleTbl) == 0x001D00, "Member 'ABullet::_customParticleTbl' has a wrong offset!");
static_assert(offsetof(ABullet, _battleParticleTbl) == 0x001D10, "Member 'ABullet::_battleParticleTbl' has a wrong offset!");
static_assert(offsetof(ABullet, _bulletParticleTbl) == 0x001D20, "Member 'ABullet::_bulletParticleTbl' has a wrong offset!");
static_assert(offsetof(ABullet, _bulletParticleSetTbl) == 0x001D30, "Member 'ABullet::_bulletParticleSetTbl' has a wrong offset!");
static_assert(offsetof(ABullet, _viewCharacter) == 0x001D40, "Member 'ABullet::_viewCharacter' has a wrong offset!");
static_assert(offsetof(ABullet, _ownerChr) == 0x001D48, "Member 'ABullet::_ownerChr' has a wrong offset!");
static_assert(offsetof(ABullet, _baseOwnerChr) == 0x001D50, "Member 'ABullet::_baseOwnerChr' has a wrong offset!");
static_assert(offsetof(ABullet, _ownerGen) == 0x001D58, "Member 'ABullet::_ownerGen' has a wrong offset!");
static_assert(offsetof(ABullet, _parent) == 0x001D60, "Member 'ABullet::_parent' has a wrong offset!");
static_assert(offsetof(ABullet, _parentBullet) == 0x001D68, "Member 'ABullet::_parentBullet' has a wrong offset!");
static_assert(offsetof(ABullet, _parentBgProp) == 0x001D70, "Member 'ABullet::_parentBgProp' has a wrong offset!");
static_assert(offsetof(ABullet, _beginSEComp) == 0x001D80, "Member 'ABullet::_beginSEComp' has a wrong offset!");
static_assert(offsetof(ABullet, _vanishSEComp) == 0x001D88, "Member 'ABullet::_vanishSEComp' has a wrong offset!");
static_assert(offsetof(ABullet, _restoreRemoveTimer) == 0x001D90, "Member 'ABullet::_restoreRemoveTimer' has a wrong offset!");
static_assert(offsetof(ABullet, _bNoClimb) == 0x001D98, "Member 'ABullet::_bNoClimb' has a wrong offset!");
static_assert(offsetof(ABullet, _bNoDashClimb) == 0x001D99, "Member 'ABullet::_bNoDashClimb' has a wrong offset!");
static_assert(offsetof(ABullet, _bNoIgnoreBasis) == 0x001D9A, "Member 'ABullet::_bNoIgnoreBasis' has a wrong offset!");
static_assert(offsetof(ABullet, _bOtherClientHitCol) == 0x001D9B, "Member 'ABullet::_bOtherClientHitCol' has a wrong offset!");
static_assert(offsetof(ABullet, _bReceiveAlwaysHit) == 0x001D9C, "Member 'ABullet::_bReceiveAlwaysHit' has a wrong offset!");
static_assert(offsetof(ABullet, _wallSlideRate) == 0x001DA0, "Member 'ABullet::_wallSlideRate' has a wrong offset!");
static_assert(offsetof(ABullet, _wallBlockTranslucent) == 0x001DA4, "Member 'ABullet::_wallBlockTranslucent' has a wrong offset!");
static_assert(offsetof(ABullet, _forceTargetAlpha) == 0x001DA8, "Member 'ABullet::_forceTargetAlpha' has a wrong offset!");
static_assert(offsetof(ABullet, _forceTargetAlphaTime) == 0x001DAC, "Member 'ABullet::_forceTargetAlphaTime' has a wrong offset!");
static_assert(offsetof(ABullet, _firstMovementSkipFrame) == 0x001DB0, "Member 'ABullet::_firstMovementSkipFrame' has a wrong offset!");

// Class InGameModule.Compress
// 0x0050 (0x1E30 - 0x1DE0)
class ACompress final : public ABullet
{
public:
	class UHeroBoxComponent*                      _hitBoxComponent;                                  // 0x1DD8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _compressParticleComponent;                        // 0x1DE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _compressParticle;                                 // 0x1DE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CompressParticleOffset;                            // 0x1DF0(0x0030)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E20[0x10];                                    // 0x1E20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Compress">();
	}
	static class ACompress* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACompress>();
	}
};
static_assert(alignof(ACompress) == 0x000010, "Wrong alignment on ACompress");
static_assert(sizeof(ACompress) == 0x001E30, "Wrong size on ACompress");
static_assert(offsetof(ACompress, _hitBoxComponent) == 0x001DD8, "Member 'ACompress::_hitBoxComponent' has a wrong offset!");
static_assert(offsetof(ACompress, _compressParticleComponent) == 0x001DE0, "Member 'ACompress::_compressParticleComponent' has a wrong offset!");
static_assert(offsetof(ACompress, _compressParticle) == 0x001DE8, "Member 'ACompress::_compressParticle' has a wrong offset!");
static_assert(offsetof(ACompress, CompressParticleOffset) == 0x001DF0, "Member 'ACompress::CompressParticleOffset' has a wrong offset!");

// Class InGameModule.PlayerInfoBaseWidget
// 0x0018 (0x0368 - 0x0350)
class UPlayerInfoBaseWidget : public UWidgetBase
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USimulatedPlayerHudManager*             _simulatedPlayerHudManager;                        // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHudResource*                           _hudResource;                                      // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInfoBaseWidget">();
	}
	static class UPlayerInfoBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInfoBaseWidget>();
	}
};
static_assert(alignof(UPlayerInfoBaseWidget) == 0x000008, "Wrong alignment on UPlayerInfoBaseWidget");
static_assert(sizeof(UPlayerInfoBaseWidget) == 0x000368, "Wrong size on UPlayerInfoBaseWidget");
static_assert(offsetof(UPlayerInfoBaseWidget, _playerState) == 0x000350, "Member 'UPlayerInfoBaseWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UPlayerInfoBaseWidget, _simulatedPlayerHudManager) == 0x000358, "Member 'UPlayerInfoBaseWidget::_simulatedPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UPlayerInfoBaseWidget, _hudResource) == 0x000360, "Member 'UPlayerInfoBaseWidget::_hudResource' has a wrong offset!");

// Class InGameModule.AFOSpecialInfo
// 0x0058 (0x03C0 - 0x0368)
class UAFOSpecialInfo final : public UPlayerInfoBaseWidget
{
public:
	class APlayerControllerBattle*                _playerControllerBattle;                           // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _characterFaceMID;                                 // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x18];                                     // 0x0380(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             _afoFaceTexture;                                   // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _noStockImage;                                     // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _characterFace;                                    // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _face;                                             // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniStocked;                                       // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AFOSpecialInfo">();
	}
	static class UAFOSpecialInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAFOSpecialInfo>();
	}
};
static_assert(alignof(UAFOSpecialInfo) == 0x000008, "Wrong alignment on UAFOSpecialInfo");
static_assert(sizeof(UAFOSpecialInfo) == 0x0003C0, "Wrong size on UAFOSpecialInfo");
static_assert(offsetof(UAFOSpecialInfo, _playerControllerBattle) == 0x000368, "Member 'UAFOSpecialInfo::_playerControllerBattle' has a wrong offset!");
static_assert(offsetof(UAFOSpecialInfo, _characterFaceMID) == 0x000370, "Member 'UAFOSpecialInfo::_characterFaceMID' has a wrong offset!");
static_assert(offsetof(UAFOSpecialInfo, _playerDatabaseWork) == 0x000378, "Member 'UAFOSpecialInfo::_playerDatabaseWork' has a wrong offset!");
static_assert(offsetof(UAFOSpecialInfo, _afoFaceTexture) == 0x000398, "Member 'UAFOSpecialInfo::_afoFaceTexture' has a wrong offset!");
static_assert(offsetof(UAFOSpecialInfo, _noStockImage) == 0x0003A0, "Member 'UAFOSpecialInfo::_noStockImage' has a wrong offset!");
static_assert(offsetof(UAFOSpecialInfo, _characterFace) == 0x0003A8, "Member 'UAFOSpecialInfo::_characterFace' has a wrong offset!");
static_assert(offsetof(UAFOSpecialInfo, _face) == 0x0003B0, "Member 'UAFOSpecialInfo::_face' has a wrong offset!");
static_assert(offsetof(UAFOSpecialInfo, _aniStocked) == 0x0003B8, "Member 'UAFOSpecialInfo::_aniStocked' has a wrong offset!");

// Class InGameModule.AIControllerBattle
// 0x00D0 (0x03F8 - 0x0328)
class AAIControllerBattle : public ABumAIController
{
public:
	class UPoisonMistManagerComponent*            _poisonMistMng;                                    // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAIMode                                       _mode;                                             // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIParam*                               _param;                                            // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAIDifficultyLevel                            _difficultyLevel;                                  // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341[0x17];                                     // 0x0341(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISensor*                              _sensor;                                           // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAISkill*>                       _skills;                                           // 0x0360(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIMove*                                _move;                                             // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAISkill*                               _selectSkill;                                      // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITimer*                               _freezeTimer;                                      // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITimer*                               _moveLimitTimer;                                   // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITimer*                               _targetTimer;                                      // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _targetMemory;                                     // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATargetPoint*                           _targetPoint;                                      // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _targetChaseActor;                                 // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x38];                                     // 0x03B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ABgProp*                                _pCombatWallBGProp;                                // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool BP_CombatChaseCheck(class AActor* TargetActor);
	float BP_CombatChaseFinish();
	bool BP_CombatCheck();
	void BP_CombatPolling();
	bool BP_CombatStart();
	bool BP_DodgeCheck();
	bool BP_DodgeStart();
	bool BP_EscapeCheck();
	float BP_EscapeFinish();
	void BP_EscapePolling();
	bool BP_EscapeStart();
	class AActor* BP_GetTargetMemory();
	class AActor* BP_GetTargetPoint();
	void BP_MoveAction(const struct FAIMoveCommand& Command);
	void BP_MoveExit();
	void BP_MoveInput(const struct FAIMoveCommand& Command);
	void BP_MoveTick(class AActor* TargetActor);
	bool BP_PatrolCheck();
	float BP_PatrolFinish();
	void BP_PatrolPolling();
	bool BP_PatrolStart();
	bool BP_PossibleNavigation(class AActor* TargetActor);
	bool BP_RootStart();
	void BP_SkillAction(const TArray<struct FAISkillCommand>& Commands, bool Instant, float Interval);
	void BP_SkillExit();
	bool BP_SkillExitCheck();
	void BP_SkillInput(const struct FAISkillCommand& Command);
	bool BP_SkillPerform(class AActor* TargetActor);
	void BP_StartAI();
	void OnPostCharacterStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIControllerBattle">();
	}
	static class AAIControllerBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIControllerBattle>();
	}
};
static_assert(alignof(AAIControllerBattle) == 0x000008, "Wrong alignment on AAIControllerBattle");
static_assert(sizeof(AAIControllerBattle) == 0x0003F8, "Wrong size on AAIControllerBattle");
static_assert(offsetof(AAIControllerBattle, _poisonMistMng) == 0x000328, "Member 'AAIControllerBattle::_poisonMistMng' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _mode) == 0x000330, "Member 'AAIControllerBattle::_mode' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _param) == 0x000338, "Member 'AAIControllerBattle::_param' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _difficultyLevel) == 0x000340, "Member 'AAIControllerBattle::_difficultyLevel' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _sensor) == 0x000358, "Member 'AAIControllerBattle::_sensor' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _skills) == 0x000360, "Member 'AAIControllerBattle::_skills' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _move) == 0x000378, "Member 'AAIControllerBattle::_move' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _selectSkill) == 0x000380, "Member 'AAIControllerBattle::_selectSkill' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _freezeTimer) == 0x000388, "Member 'AAIControllerBattle::_freezeTimer' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _moveLimitTimer) == 0x000390, "Member 'AAIControllerBattle::_moveLimitTimer' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _targetTimer) == 0x000398, "Member 'AAIControllerBattle::_targetTimer' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _targetMemory) == 0x0003A0, "Member 'AAIControllerBattle::_targetMemory' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _targetPoint) == 0x0003A8, "Member 'AAIControllerBattle::_targetPoint' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _targetChaseActor) == 0x0003B0, "Member 'AAIControllerBattle::_targetChaseActor' has a wrong offset!");
static_assert(offsetof(AAIControllerBattle, _pCombatWallBGProp) == 0x0003F0, "Member 'AAIControllerBattle::_pCombatWallBGProp' has a wrong offset!");

// Class InGameModule.CharacterConditionBase
// 0x00D8 (0x0100 - 0x0028)
class UCharacterConditionBase : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterConditionParam               _condtionParam;                                    // 0x0058(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _ownerPlayerState;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FConditionDataList                     _effectData;                                       // 0x0070(0x0020)(NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _instigatedPlayer;                                 // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bAutoEffectSetting;                               // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0xF];                                       // 0x0099(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomParticleSystemComponent*> _particles;                                        // 0x00A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessComponent*                  _postProcessComponent;                             // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAtomComponent*>                 _pAtoms;                                           // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_DeactivateParticles();
	void BP_OnAgainCondition();
	void BP_OnBeginCondition();
	void BP_OnChangeConditionLevel(int32 OldLevel, int32 NewLevel);
	void BP_OnChangeConditionSubLevel(int32 OldLevel, int32 NewLevel);
	void BP_OnEndCondition();
	void BP_OnHiddenCondition();
	void BP_OnRefreshCondition();
	void BP_OnUpdateIntervalValue(float Value);
	void BP_OnVisibleCondition();
	class UCustomParticleSystemComponent* BP_PlayEffect(class UParticleSystem* ParticleSystem, const class FName SocketName, const struct FVector& Offset, const struct FRotator& Rotation, bool bAttached);
	void BP_RecoverHealth(float Value, bool bEnableRecoverCondition, class APlayerStateBattle* Healer);
	void BP_RevertAnimationSpeedDeltaRate();
	void BP_RevertMoveSpeedDeltaRate();
	void BP_SetAnimationSpeedDeltaRate(float Rate);
	void BP_SetMoveSpeedDeltaRate(float Rate);
	void BP_SpawnBeginParticles(bool bChangeCondition, bool bAgainCondition);
	void BP_SpawnEndParticles();

	class APlayerStateBattle* BP_GetInstigatedPlayer() const;
	float BP_GetIntervalSpan() const;
	float BP_GetIntervalValue() const;
	int32 BP_GetLevel() const;
	class ACharacterBattle* BP_GetOwnerCharacterBattle() const;
	class APlayerStateBattle* BP_GetOwnerPlayerState() const;
	float BP_GetProgress() const;
	float BP_GetRemainTime() const;
	bool BP_IsEnableChangeCondition(int32 Level, float Span, float Value, float Interval) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterConditionBase">();
	}
	static class UCharacterConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterConditionBase>();
	}
};
static_assert(alignof(UCharacterConditionBase) == 0x000008, "Wrong alignment on UCharacterConditionBase");
static_assert(sizeof(UCharacterConditionBase) == 0x000100, "Wrong size on UCharacterConditionBase");
static_assert(offsetof(UCharacterConditionBase, _condtionParam) == 0x000058, "Member 'UCharacterConditionBase::_condtionParam' has a wrong offset!");
static_assert(offsetof(UCharacterConditionBase, _ownerPlayerState) == 0x000068, "Member 'UCharacterConditionBase::_ownerPlayerState' has a wrong offset!");
static_assert(offsetof(UCharacterConditionBase, _effectData) == 0x000070, "Member 'UCharacterConditionBase::_effectData' has a wrong offset!");
static_assert(offsetof(UCharacterConditionBase, _instigatedPlayer) == 0x000090, "Member 'UCharacterConditionBase::_instigatedPlayer' has a wrong offset!");
static_assert(offsetof(UCharacterConditionBase, _bAutoEffectSetting) == 0x000098, "Member 'UCharacterConditionBase::_bAutoEffectSetting' has a wrong offset!");
static_assert(offsetof(UCharacterConditionBase, _particles) == 0x0000A8, "Member 'UCharacterConditionBase::_particles' has a wrong offset!");
static_assert(offsetof(UCharacterConditionBase, _postProcessComponent) == 0x0000E0, "Member 'UCharacterConditionBase::_postProcessComponent' has a wrong offset!");
static_assert(offsetof(UCharacterConditionBase, _pAtoms) == 0x0000E8, "Member 'UCharacterConditionBase::_pAtoms' has a wrong offset!");

// Class InGameModule.AIDifficultyManager
// 0x0008 (0x0038 - 0x0030)
class UAIDifficultyManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDifficultyManager">();
	}
	static class UAIDifficultyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDifficultyManager>();
	}
};
static_assert(alignof(UAIDifficultyManager) == 0x000008, "Wrong alignment on UAIDifficultyManager");
static_assert(sizeof(UAIDifficultyManager) == 0x000038, "Wrong size on UAIDifficultyManager");

// Class InGameModule.CharacterState
// 0x00A8 (0x00E0 - 0x0038)
class UCharacterState final : public UCharacterStateBase
{
public:
	class ACharacterBattle*                       _ownerCharacterBattle;                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpecialActionFlags                    _specialActionFlags;                               // 0x0040(0x0003)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43[0x25];                                      // 0x0043(0x0025)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _touchWallActor;                                   // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _grabbedCharacter;                                 // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _grabCharacter;                                    // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _reservedForceGrabCharacter;                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ChangeGrabInfo(class FName GrabJointName, class FName GrabbedJointName, EAnimationId GrabbedAnimationId, float AnimationBlendTime, float AnimationStartPosition);
	void BP_ClearGrab();
	void BP_ClearGrabbed();
	void BP_SetAimExcluded(bool Flag);
	void BP_SetAirJump(bool Flag);
	void BP_SetBlowOff(bool Flag);
	void BP_SetCantDashAirTime(float Time);
	void BP_SetCantDodgeTime(float Time);
	void BP_SetCrouch(bool Flag);
	void BP_SetDash(bool Flag);
	void BP_SetDashAir(bool Flag);
	void BP_SetDashAirInfinity(bool Flag);
	void BP_SetDashAirTime(float Time);
	void BP_SetDashJump(bool Flag);
	void BP_SetDodge(bool Flag);
	void BP_SetDontFall(bool Flag);
	void BP_SetDown(bool Flag);
	void BP_SetDyingRecover(bool Flag);
	void BP_SetEnableJumpPad(bool Flag);
	void BP_SetEnableUseSupply(bool Flag);
	void BP_SetForwardJump(bool Flag);
	void BP_SetFreeze(bool Flag);
	void BP_SetGiant(bool Flag);
	void BP_SetGrabInfo(class FName GrabJointName, class FName GrabbedJointName, EAnimationId GrabbedAnimationId);
	void BP_SetOpenBox(bool Flag);
	void BP_SetPickUpItem(bool Flag);
	void BP_SetPlusUltraAction(bool Flag);
	void BP_SetRecoverAlly(bool Flag);
	void BP_SetRecoverDamaging(bool Flag);
	void BP_SetScoutEnemy(bool Flag);
	void BP_SetShock(bool Flag);
	void BP_SetStandUp(bool Flag);
	void BP_SetUseItem(bool Flag);
	void BP_SetWallCrawl(bool Flag);
	void BP_SetWallDash(bool Flag);
	void BP_SetWallWalk(bool Flag);
	void OnRep_PlayerState(class APlayerStateBattle* PlayerState);

	float BP_GetDashAirTime() const;
	class ACharacterBattle* BP_GetGrabbedCharacter() const;
	class ACharacterBattle* BP_GetGrabCharacter() const;
	const struct FVector BP_GetTouchWallNormal() const;
	bool BP_HasVerticalFixedWallCrawl() const;
	bool BP_HasWallDash() const;
	bool BP_IsAimingMode() const;
	bool BP_IsAirJump() const;
	bool BP_IsAttacking() const;
	bool BP_IsBlowOff() const;
	bool BP_IsCrouching() const;
	bool BP_IsDamaging() const;
	bool BP_IsDash() const;
	bool BP_IsDashAir() const;
	bool BP_IsDashAirLimit() const;
	bool BP_IsDashJump() const;
	bool BP_IsDodge() const;
	bool BP_IsDontFall() const;
	bool BP_IsDown() const;
	bool BP_IsDyingRecover() const;
	bool BP_IsForwardJump() const;
	bool BP_IsFreeze() const;
	bool BP_IsGiant() const;
	bool BP_IsGrab() const;
	bool BP_IsGrabbed() const;
	bool BP_IsNagaraAttacking() const;
	bool BP_IsNagaraDamaging() const;
	bool BP_IsOnWall() const;
	bool BP_IsOpenBox() const;
	bool BP_IsPickUpItem() const;
	bool BP_IsPlusUltraAction() const;
	bool BP_IsRecoverDamaging() const;
	bool BP_IsRecoveringAlly() const;
	bool BP_IsScoutingEnemy() const;
	bool BP_IsShock() const;
	bool BP_IsStandUp() const;
	bool BP_IsTouchGround() const;
	bool BP_IsTouchWall() const;
	bool BP_IsUseItem() const;
	bool BP_IsWallCrawl() const;
	bool BP_IsWallDash() const;
	bool BP_IsWallWalk() const;
	bool BP_IsWholeAttacking() const;
	bool BP_IsWholeDamaging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterState">();
	}
	static class UCharacterState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterState>();
	}
};
static_assert(alignof(UCharacterState) == 0x000008, "Wrong alignment on UCharacterState");
static_assert(sizeof(UCharacterState) == 0x0000E0, "Wrong size on UCharacterState");
static_assert(offsetof(UCharacterState, _ownerCharacterBattle) == 0x000038, "Member 'UCharacterState::_ownerCharacterBattle' has a wrong offset!");
static_assert(offsetof(UCharacterState, _specialActionFlags) == 0x000040, "Member 'UCharacterState::_specialActionFlags' has a wrong offset!");
static_assert(offsetof(UCharacterState, _touchWallActor) == 0x000068, "Member 'UCharacterState::_touchWallActor' has a wrong offset!");
static_assert(offsetof(UCharacterState, _grabbedCharacter) == 0x000098, "Member 'UCharacterState::_grabbedCharacter' has a wrong offset!");
static_assert(offsetof(UCharacterState, _grabCharacter) == 0x0000A0, "Member 'UCharacterState::_grabCharacter' has a wrong offset!");
static_assert(offsetof(UCharacterState, _reservedForceGrabCharacter) == 0x0000A8, "Member 'UCharacterState::_reservedForceGrabCharacter' has a wrong offset!");

// Class InGameModule.AIMove
// 0x0128 (0x0150 - 0x0028)
class alignas(0x10) UAIMove final : public UObject
{
public:
	class UGameTeamInfoComponent*                 _teamInfoComponent;                                // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAIMode                                       _mode;                                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x2];                                       // 0x0031(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EAICombatRangeType                            _combatRangeType;                                  // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _owner;                                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _teamTarget;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _selectTarget;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _targetCharacter;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITimer*                               _dashTimer;                                        // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITimer*                               _dashInterval;                                     // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x90];                                      // 0x0068(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITimer*                               _dodgeTimer;                                       // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoisonMistManagerComponent*            _poisonMistMng;                                    // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _rayCastTargetActor;                               // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeAttackedDetection(const class AActor* Actor, const struct FVector& Location);
	void OnDamageHit(const struct FDamageInfo& NewInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMove">();
	}
	static class UAIMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMove>();
	}
};
static_assert(alignof(UAIMove) == 0x000010, "Wrong alignment on UAIMove");
static_assert(sizeof(UAIMove) == 0x000150, "Wrong size on UAIMove");
static_assert(offsetof(UAIMove, _teamInfoComponent) == 0x000028, "Member 'UAIMove::_teamInfoComponent' has a wrong offset!");
static_assert(offsetof(UAIMove, _mode) == 0x000030, "Member 'UAIMove::_mode' has a wrong offset!");
static_assert(offsetof(UAIMove, _combatRangeType) == 0x000033, "Member 'UAIMove::_combatRangeType' has a wrong offset!");
static_assert(offsetof(UAIMove, _owner) == 0x000038, "Member 'UAIMove::_owner' has a wrong offset!");
static_assert(offsetof(UAIMove, _teamTarget) == 0x000040, "Member 'UAIMove::_teamTarget' has a wrong offset!");
static_assert(offsetof(UAIMove, _selectTarget) == 0x000048, "Member 'UAIMove::_selectTarget' has a wrong offset!");
static_assert(offsetof(UAIMove, _targetCharacter) == 0x000050, "Member 'UAIMove::_targetCharacter' has a wrong offset!");
static_assert(offsetof(UAIMove, _dashTimer) == 0x000058, "Member 'UAIMove::_dashTimer' has a wrong offset!");
static_assert(offsetof(UAIMove, _dashInterval) == 0x000060, "Member 'UAIMove::_dashInterval' has a wrong offset!");
static_assert(offsetof(UAIMove, _dodgeTimer) == 0x0000F8, "Member 'UAIMove::_dodgeTimer' has a wrong offset!");
static_assert(offsetof(UAIMove, _poisonMistMng) == 0x000118, "Member 'UAIMove::_poisonMistMng' has a wrong offset!");
static_assert(offsetof(UAIMove, _rayCastTargetActor) == 0x000130, "Member 'UAIMove::_rayCastTargetActor' has a wrong offset!");

// Class InGameModule.AIParam
// 0x0058 (0x0080 - 0x0028)
class UAIParam final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIParam">();
	}
	static class UAIParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIParam>();
	}
};
static_assert(alignof(UAIParam) == 0x000008, "Wrong alignment on UAIParam");
static_assert(sizeof(UAIParam) == 0x000080, "Wrong size on UAIParam");

// Class InGameModule.HeroDecalActor
// 0x0058 (0x0280 - 0x0228)
class AHeroDecalActor : public ADecalActor
{
public:
	EViewType                                     _viewType;                                         // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0230(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class ACharacterBattle*                       _owner;                                            // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _midy;                                             // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroDecalActor">();
	}
	static class AHeroDecalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHeroDecalActor>();
	}
};
static_assert(alignof(AHeroDecalActor) == 0x000008, "Wrong alignment on AHeroDecalActor");
static_assert(sizeof(AHeroDecalActor) == 0x000280, "Wrong size on AHeroDecalActor");
static_assert(offsetof(AHeroDecalActor, _viewType) == 0x000228, "Member 'AHeroDecalActor::_viewType' has a wrong offset!");
static_assert(offsetof(AHeroDecalActor, _graduallyAlpha) == 0x000230, "Member 'AHeroDecalActor::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(AHeroDecalActor, _owner) == 0x000270, "Member 'AHeroDecalActor::_owner' has a wrong offset!");
static_assert(offsetof(AHeroDecalActor, _midy) == 0x000278, "Member 'AHeroDecalActor::_midy' has a wrong offset!");

// Class InGameModule.CharacterDeltaRateControlComponent
// 0x0008 (0x00C0 - 0x00B8)
class UCharacterDeltaRateControlComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDeltaRateControlComponent">();
	}
	static class UCharacterDeltaRateControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDeltaRateControlComponent>();
	}
};
static_assert(alignof(UCharacterDeltaRateControlComponent) == 0x000008, "Wrong alignment on UCharacterDeltaRateControlComponent");
static_assert(sizeof(UCharacterDeltaRateControlComponent) == 0x0000C0, "Wrong size on UCharacterDeltaRateControlComponent");

// Class InGameModule.AirForceDecal
// 0x0038 (0x02B8 - 0x0280)
class AAirForceDecal final : public AHeroDecalActor
{
public:
	class UCurveFloat*                            _decalParameterCurve;                              // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _decalParameter;                                   // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomZRot;                                       // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomXYScaleMin;                                 // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomXYScaleMax;                                 // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0xC];                                      // 0x029C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _chrBtl;                                           // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirForceDecal">();
	}
	static class AAirForceDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAirForceDecal>();
	}
};
static_assert(alignof(AAirForceDecal) == 0x000008, "Wrong alignment on AAirForceDecal");
static_assert(sizeof(AAirForceDecal) == 0x0002B8, "Wrong size on AAirForceDecal");
static_assert(offsetof(AAirForceDecal, _decalParameterCurve) == 0x000280, "Member 'AAirForceDecal::_decalParameterCurve' has a wrong offset!");
static_assert(offsetof(AAirForceDecal, _decalParameter) == 0x000288, "Member 'AAirForceDecal::_decalParameter' has a wrong offset!");
static_assert(offsetof(AAirForceDecal, _randomZRot) == 0x000290, "Member 'AAirForceDecal::_randomZRot' has a wrong offset!");
static_assert(offsetof(AAirForceDecal, _randomXYScaleMin) == 0x000294, "Member 'AAirForceDecal::_randomXYScaleMin' has a wrong offset!");
static_assert(offsetof(AAirForceDecal, _randomXYScaleMax) == 0x000298, "Member 'AAirForceDecal::_randomXYScaleMax' has a wrong offset!");
static_assert(offsetof(AAirForceDecal, _chrBtl) == 0x0002A8, "Member 'AAirForceDecal::_chrBtl' has a wrong offset!");

// Class InGameModule.GameStateBattle
// 0x02C0 (0x0610 - 0x0350)
class AGameStateBattle : public AHerovsGameState
{
public:
	class UFiniteStateMachine*                    _fsm;                                              // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bSpawnableSupplyBox;                              // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bSpawnableSupplies;                               // 0x0359(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bSpawnablePoisonMist;                             // 0x035A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableCommentaryVoice;                           // 0x035B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotManager*                            _botManager;                                       // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPoisonMistManagerComponent*            _poisonMistManager;                                // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _onNumTeamsDecreased;                              // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onNumTeamsIncreased;                              // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         _numOfPlayerForClimax;                             // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x14];                                     // 0x0394(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _RemainingTeamNumAtPlayClimaxBgm;                  // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         _resultWinTeamId;                                  // 0x03AC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bTimeUp;                                          // 0x03AD(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AE[0x9A];                                     // 0x03AE(0x009A)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterActingComponent*              _actingComponent;                                  // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UActorComponent>            _actingClass;                                      // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameTeamInfoComponent*                 _gameTeamInfoComponent;                            // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCreateTeamComponent*                   _createTeamComponent;                              // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x30];                                     // 0x0470(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EBattleSequence                               _battleSequence;                                   // 0x04A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _sequenceTimer;                                    // 0x04A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x4];                                      // 0x04A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _battleLimitTime;                                  // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKillLogManagerComponent*               _killLogManagerComponent;                          // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimeDilationComponent*                 _timeDilationComponent;                            // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x30];                                     // 0x04C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              _WinDemoDecaleTexture;                             // 0x04F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x50];                                     // 0x0518(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeToSpawnBox;                                   // 0x0568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_56C[0x6C];                                     // 0x056C(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	class UDogTagManagerComponent*                _dogTagManager;                                    // 0x05D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERespawnType                                  _respawnType;                                      // 0x05E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E1[0x7];                                      // 0x05E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleAchievementComponent*            _battleAchievementComponent;                       // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x10];                                     // 0x05F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomMatchComponent*                  _customMatchComponent;                             // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllEnemyStatusWeakened();
	void AttackTutorialNPC(const class FString& Value);
	bool CheckTutorialMockBattleTimer();
	bool CheckTutorialPlayerAttack(EAttackId AttackId);
	void ClearKeepControllTimer();
	class ASimpleCharacter* CreateTutorialCh012(const struct FTransform& Transform);
	void CreateTutorialNPC(const class FString& Value);
	class FString DeleteMessageTag(const class FString& Message);
	void DeleteTutorialNPC(const class FString& Value);
	void DownTutorialNPC(const class FString& Value);
	TArray<struct FTutorialCheckListButtonGuideData> GetButtonGuideFromCommand(const class FString& TaskValue);
	int64 GetTutorialCheckKey(const class FString& Value);
	class FText GetTutorialOperationMessage(const class FString& MessageKey);
	EPlatform GetTutorialPlatform();
	int32 GetTutorialTaskTableIndex(const class FString& TaskValue);
	bool GetWin();
	bool HasNpcCharacterStarted();
	void InitializeUseItemParameter();
	bool IsAttackTutorialNPC(const class FString& Value);
	bool IsDeadTutorialNPC(const class FString& Value);
	bool IsGameModeTraining();
	bool IsGameModeTutorial();
	bool IsKillEnemy();
	bool IsMoveTutorialNPC(const class FString& Value);
	bool IsPoisonMistCondition();
	bool IsRecoveringCitizen();
	bool IsStartShrinkPoisonMist();
	bool IsTutorial();
	void MoveTutorialNPC(const class FString& Value);
	void OnCharacterDead_NetMulti(class APlayerStateBattle* VictimPlayerState, class ACharacterBattle* Aggriever);
	void OnCharacterDying_NetMulti(class APlayerStateBattle* VictimPlayerState, class ACharacterBattle* Aggriever);
	void OnDecreasePlayer();
	void OnDecreaseTeam();
	void OnExitInGameTutorial();
	void OnHitAttackLastBattle(const struct FDamageInfo& NewInfo);
	void OnPlayRemainingTeamVice();
	void OnRep_BattleSequence();
	void OnRep_SequenceTimer();
	void OpenBriefing();
	void RequestTeleportationTutorial(int32 X, int32 Y, int32 Z);
	void RequestTeleportationTutorialWithRotator(int32 X, int32 Y, int32 Z, int32 Pitch, int32 Yaw, int32 Roll);
	void ResetTutorial();
	void ResetTutorialPlayerAttack();
	void SetBattleSequence(EBattleSequence Seq);
	void SetCanPlayAnnounceWidget(bool bCanPlay);
	void SetTutorialDamage();
	int32 SetTutorialEnemyCount();
	void SetTutorialItem(const class FString& KindItem);
	void SetTutorialLift();
	void SetTutorialMockBattleTimer(float MockBattleTimeCount);
	void SetTutorialPlayerCommandValidity(bool bValidty);
	void SetTutorialPoisonMist();
	void SetTutorialRescuerRequired();
	TArray<class FString> SplitStringByCarriageReturn(const class FString& Message);
	void SwitchAbilityInfoVisibility(bool Sw);
	void SwitchAllyPlayerStatusInfo(bool Sw);
	void SwitchBattleCounterVisibility(bool Sw);
	void SwitchCrossHairsVisibility(bool Sw);
	void SwitchInGameButtonGuideVisibility(bool Sw);
	void SwitchLocalPlayerStatusInfoVisibility(bool Sw);
	void SwitchLvUpShortCutVisibility(bool Sw);
	void SwitchMiscInfoVisibility(bool Sw);
	void SwitchPlusUltraVisibility(bool Sw);
	void SwitchShortcutInfoVisibility(bool Sw);
	void SwitchTutorialAI(bool Sw);
	void TeamNumberChangeEvent__DelegateSignature();
	void TutorialCharSpecial();

	bool CanPlayAnnounceWidget() const;
	int32 GetAlivePlayerNum(bool bIncludeBot) const;
	EBattleSequence GetBattleSequence() const;
	class UCustomMatchComponent* GetCustomMatchComponent() const;
	void GetTutorialCamera() const;
	int64 GetTutorialKeyCheck(int64 CheckKey, int64 beforeKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle">();
	}
	static class AGameStateBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateBattle>();
	}
};
static_assert(alignof(AGameStateBattle) == 0x000008, "Wrong alignment on AGameStateBattle");
static_assert(sizeof(AGameStateBattle) == 0x000610, "Wrong size on AGameStateBattle");
static_assert(offsetof(AGameStateBattle, _fsm) == 0x000350, "Member 'AGameStateBattle::_fsm' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _bSpawnableSupplyBox) == 0x000358, "Member 'AGameStateBattle::_bSpawnableSupplyBox' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _bSpawnableSupplies) == 0x000359, "Member 'AGameStateBattle::_bSpawnableSupplies' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _bSpawnablePoisonMist) == 0x00035A, "Member 'AGameStateBattle::_bSpawnablePoisonMist' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _bEnableCommentaryVoice) == 0x00035B, "Member 'AGameStateBattle::_bEnableCommentaryVoice' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _botManager) == 0x000360, "Member 'AGameStateBattle::_botManager' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _poisonMistManager) == 0x000368, "Member 'AGameStateBattle::_poisonMistManager' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _onNumTeamsDecreased) == 0x000370, "Member 'AGameStateBattle::_onNumTeamsDecreased' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _onNumTeamsIncreased) == 0x000380, "Member 'AGameStateBattle::_onNumTeamsIncreased' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _numOfPlayerForClimax) == 0x000390, "Member 'AGameStateBattle::_numOfPlayerForClimax' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _RemainingTeamNumAtPlayClimaxBgm) == 0x0003A8, "Member 'AGameStateBattle::_RemainingTeamNumAtPlayClimaxBgm' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _resultWinTeamId) == 0x0003AC, "Member 'AGameStateBattle::_resultWinTeamId' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _bTimeUp) == 0x0003AD, "Member 'AGameStateBattle::_bTimeUp' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _actingComponent) == 0x000448, "Member 'AGameStateBattle::_actingComponent' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _actingClass) == 0x000450, "Member 'AGameStateBattle::_actingClass' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _gameTeamInfoComponent) == 0x000460, "Member 'AGameStateBattle::_gameTeamInfoComponent' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _createTeamComponent) == 0x000468, "Member 'AGameStateBattle::_createTeamComponent' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _battleSequence) == 0x0004A0, "Member 'AGameStateBattle::_battleSequence' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _sequenceTimer) == 0x0004A4, "Member 'AGameStateBattle::_sequenceTimer' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _battleLimitTime) == 0x0004AC, "Member 'AGameStateBattle::_battleLimitTime' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _killLogManagerComponent) == 0x0004B0, "Member 'AGameStateBattle::_killLogManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _timeDilationComponent) == 0x0004B8, "Member 'AGameStateBattle::_timeDilationComponent' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _WinDemoDecaleTexture) == 0x0004F0, "Member 'AGameStateBattle::_WinDemoDecaleTexture' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _timeToSpawnBox) == 0x000568, "Member 'AGameStateBattle::_timeToSpawnBox' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _dogTagManager) == 0x0005D8, "Member 'AGameStateBattle::_dogTagManager' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _respawnType) == 0x0005E0, "Member 'AGameStateBattle::_respawnType' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _battleAchievementComponent) == 0x0005E8, "Member 'AGameStateBattle::_battleAchievementComponent' has a wrong offset!");
static_assert(offsetof(AGameStateBattle, _customMatchComponent) == 0x000600, "Member 'AGameStateBattle::_customMatchComponent' has a wrong offset!");

// Class InGameModule.GameStateSquadBattle
// 0x0008 (0x0618 - 0x0610)
class AGameStateSquadBattle final : public AGameStateBattle
{
public:
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateSquadBattle">();
	}
	static class AGameStateSquadBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateSquadBattle>();
	}
};
static_assert(alignof(AGameStateSquadBattle) == 0x000008, "Wrong alignment on AGameStateSquadBattle");
static_assert(sizeof(AGameStateSquadBattle) == 0x000618, "Wrong size on AGameStateSquadBattle");

// Class InGameModule.AISensor
// 0x0088 (0x00B0 - 0x0028)
class alignas(0x10) UAISensor final : public UObject
{
public:
	EAIMode                                       _mode;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _owner;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionComponent*                 _perception;                                       // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _sightPerceivedActors;                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _hearingPerceivedActors;                           // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _damagePerceivedActors;                            // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x40];                                      // 0x0070(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPerceptionUpdated(const TArray<class AActor*>& UpdatedActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISensor">();
	}
	static class UAISensor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISensor>();
	}
};
static_assert(alignof(UAISensor) == 0x000010, "Wrong alignment on UAISensor");
static_assert(sizeof(UAISensor) == 0x0000B0, "Wrong size on UAISensor");
static_assert(offsetof(UAISensor, _mode) == 0x000028, "Member 'UAISensor::_mode' has a wrong offset!");
static_assert(offsetof(UAISensor, _owner) == 0x000030, "Member 'UAISensor::_owner' has a wrong offset!");
static_assert(offsetof(UAISensor, _perception) == 0x000038, "Member 'UAISensor::_perception' has a wrong offset!");
static_assert(offsetof(UAISensor, _sightPerceivedActors) == 0x000040, "Member 'UAISensor::_sightPerceivedActors' has a wrong offset!");
static_assert(offsetof(UAISensor, _hearingPerceivedActors) == 0x000050, "Member 'UAISensor::_hearingPerceivedActors' has a wrong offset!");
static_assert(offsetof(UAISensor, _damagePerceivedActors) == 0x000060, "Member 'UAISensor::_damagePerceivedActors' has a wrong offset!");

// Class InGameModule.AISkill
// 0x0050 (0x0078 - 0x0028)
class UAISkill final : public UObject
{
public:
	class ACharacterBattle*                       _owner;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITimer*                               _skillDuration;                                    // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill">();
	}
	static class UAISkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill>();
	}
};
static_assert(alignof(UAISkill) == 0x000008, "Wrong alignment on UAISkill");
static_assert(sizeof(UAISkill) == 0x000078, "Wrong size on UAISkill");
static_assert(offsetof(UAISkill, _owner) == 0x000028, "Member 'UAISkill::_owner' has a wrong offset!");
static_assert(offsetof(UAISkill, _skillDuration) == 0x000058, "Member 'UAISkill::_skillDuration' has a wrong offset!");

// Class InGameModule.AIStatics
// 0x0000 (0x0028 - 0x0028)
class UAIStatics final : public UBlueprintFunctionLibrary
{
public:
	static float GetSkillCommandFixedDuration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIStatics">();
	}
	static class UAIStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIStatics>();
	}
};
static_assert(alignof(UAIStatics) == 0x000008, "Wrong alignment on UAIStatics");
static_assert(sizeof(UAIStatics) == 0x000028, "Wrong size on UAIStatics");

// Class InGameModule.CharacterInteractComponent
// 0x0050 (0x0108 - 0x00B8)
class UCharacterInteractComponent final : public UCharacterBattleComponentBase
{
public:
	TArray<struct FInteractInfo>                  _targetList;                                       // 0x00B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _actionTarget;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACharacterBattle*>               _recoverActionTargetList;                          // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UInteractTargetComponent*               _currentFocus;                                     // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractTargetComponent*               _prevFocus;                                        // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupply*                                _focusSupply;                                      // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_ToClient(class UInteractTargetComponent* Target, uint8 InteractArgument);
	void Interact_ToServer(class UInteractTargetComponent* Target, class APlayerStateBattle* PlayerState, uint8 InteractArgument);
	void Negotiation_ToServer(class UInteractTargetComponent* Target, uint8 InteractArgument);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInteractComponent">();
	}
	static class UCharacterInteractComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInteractComponent>();
	}
};
static_assert(alignof(UCharacterInteractComponent) == 0x000008, "Wrong alignment on UCharacterInteractComponent");
static_assert(sizeof(UCharacterInteractComponent) == 0x000108, "Wrong size on UCharacterInteractComponent");
static_assert(offsetof(UCharacterInteractComponent, _targetList) == 0x0000B8, "Member 'UCharacterInteractComponent::_targetList' has a wrong offset!");
static_assert(offsetof(UCharacterInteractComponent, _actionTarget) == 0x0000D0, "Member 'UCharacterInteractComponent::_actionTarget' has a wrong offset!");
static_assert(offsetof(UCharacterInteractComponent, _recoverActionTargetList) == 0x0000D8, "Member 'UCharacterInteractComponent::_recoverActionTargetList' has a wrong offset!");
static_assert(offsetof(UCharacterInteractComponent, _currentFocus) == 0x0000E8, "Member 'UCharacterInteractComponent::_currentFocus' has a wrong offset!");
static_assert(offsetof(UCharacterInteractComponent, _prevFocus) == 0x0000F0, "Member 'UCharacterInteractComponent::_prevFocus' has a wrong offset!");
static_assert(offsetof(UCharacterInteractComponent, _focusSupply) == 0x0000F8, "Member 'UCharacterInteractComponent::_focusSupply' has a wrong offset!");

// Class InGameModule.AITimer
// 0x0018 (0x0040 - 0x0028)
class UAITimer final : public UObject
{
public:
	class ACharacterBattle*                       _owner;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITimer">();
	}
	static class UAITimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITimer>();
	}
};
static_assert(alignof(UAITimer) == 0x000008, "Wrong alignment on UAITimer");
static_assert(sizeof(UAITimer) == 0x000040, "Wrong size on UAITimer");
static_assert(offsetof(UAITimer, _owner) == 0x000028, "Member 'UAITimer::_owner' has a wrong offset!");

// Class InGameModule.CommandWheelPresenter
// 0x0028 (0x02F8 - 0x02D0)
class ACommandWheelPresenter final : public AMultiWidgetCreator
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      _playerController;                                 // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _hudCommandControlComponent;                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LoadWheelItems();
	void LobbyCloseWheel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandWheelPresenter">();
	}
	static class ACommandWheelPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommandWheelPresenter>();
	}
};
static_assert(alignof(ACommandWheelPresenter) == 0x000008, "Wrong alignment on ACommandWheelPresenter");
static_assert(sizeof(ACommandWheelPresenter) == 0x0002F8, "Wrong size on ACommandWheelPresenter");
static_assert(offsetof(ACommandWheelPresenter, _playerController) == 0x0002D8, "Member 'ACommandWheelPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(ACommandWheelPresenter, _playerState) == 0x0002E0, "Member 'ACommandWheelPresenter::_playerState' has a wrong offset!");
static_assert(offsetof(ACommandWheelPresenter, _hudCommandControlComponent) == 0x0002E8, "Member 'ACommandWheelPresenter::_hudCommandControlComponent' has a wrong offset!");
static_assert(offsetof(ACommandWheelPresenter, _playerDatabaseWork) == 0x0002F0, "Member 'ACommandWheelPresenter::_playerDatabaseWork' has a wrong offset!");

// Class InGameModule.AlertWidget
// 0x0020 (0x0370 - 0x0350)
class UAlertWidget final : public UWidgetBase
{
public:
	class APlayerControllerBattle*                _playerController;                                 // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _rootCanvas;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageIndicator*                       _damageIndicator;                                  // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameOption*                            _gameOption;                                       // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertWidget">();
	}
	static class UAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlertWidget>();
	}
};
static_assert(alignof(UAlertWidget) == 0x000008, "Wrong alignment on UAlertWidget");
static_assert(sizeof(UAlertWidget) == 0x000370, "Wrong size on UAlertWidget");
static_assert(offsetof(UAlertWidget, _playerController) == 0x000350, "Member 'UAlertWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UAlertWidget, _rootCanvas) == 0x000358, "Member 'UAlertWidget::_rootCanvas' has a wrong offset!");
static_assert(offsetof(UAlertWidget, _damageIndicator) == 0x000360, "Member 'UAlertWidget::_damageIndicator' has a wrong offset!");
static_assert(offsetof(UAlertWidget, _gameOption) == 0x000368, "Member 'UAlertWidget::_gameOption' has a wrong offset!");

// Class InGameModule.AN_ApplyDamageToCitizen
// 0x0000 (0x0040 - 0x0040)
class UAN_ApplyDamageToCitizen final : public UAN_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_ApplyDamageToCitizen">();
	}
	static class UAN_ApplyDamageToCitizen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_ApplyDamageToCitizen>();
	}
};
static_assert(alignof(UAN_ApplyDamageToCitizen) == 0x000008, "Wrong alignment on UAN_ApplyDamageToCitizen");
static_assert(sizeof(UAN_ApplyDamageToCitizen) == 0x000040, "Wrong size on UAN_ApplyDamageToCitizen");

// Class InGameModule.Ch043Unique1Shot
// 0x0060 (0x1E40 - 0x1DE0)
class ACh043Unique1Shot final : public ABullet
{
public:
	class AActor*                                 _targetActor;                                      // 0x1DD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DE0[0x60];                                    // 0x1DE0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch043Unique1Shot">();
	}
	static class ACh043Unique1Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh043Unique1Shot>();
	}
};
static_assert(alignof(ACh043Unique1Shot) == 0x000010, "Wrong alignment on ACh043Unique1Shot");
static_assert(sizeof(ACh043Unique1Shot) == 0x001E40, "Wrong size on ACh043Unique1Shot");
static_assert(offsetof(ACh043Unique1Shot, _targetActor) == 0x001DD8, "Member 'ACh043Unique1Shot::_targetActor' has a wrong offset!");

// Class InGameModule.AN_AttackAnimSpeed
// 0x0008 (0x0048 - 0x0040)
class UAN_AttackAnimSpeed final : public UAN_BattleBase
{
public:
	float                                         _defaultRate;                                      // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bNagara;                                          // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackAnimationEventId                       _eventId;                                          // 0x0045(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackAnimSpeed">();
	}
	static class UAN_AttackAnimSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackAnimSpeed>();
	}
};
static_assert(alignof(UAN_AttackAnimSpeed) == 0x000008, "Wrong alignment on UAN_AttackAnimSpeed");
static_assert(sizeof(UAN_AttackAnimSpeed) == 0x000048, "Wrong size on UAN_AttackAnimSpeed");
static_assert(offsetof(UAN_AttackAnimSpeed, _defaultRate) == 0x000040, "Member 'UAN_AttackAnimSpeed::_defaultRate' has a wrong offset!");
static_assert(offsetof(UAN_AttackAnimSpeed, _bNagara) == 0x000044, "Member 'UAN_AttackAnimSpeed::_bNagara' has a wrong offset!");
static_assert(offsetof(UAN_AttackAnimSpeed, _eventId) == 0x000045, "Member 'UAN_AttackAnimSpeed::_eventId' has a wrong offset!");

// Class InGameModule.CustomRecastNavMesh
// 0x0020 (0x04F8 - 0x04D8)
class ACustomRecastNavMesh final : public ARecastNavMesh
{
public:
	float                                         _edgeDivisor;                                      // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _edgeRayLength;                                    // 0x04DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _floorRayLength;                                   // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _floorRaySlantDegree;                              // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _createNavLink;                                    // 0x04E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _removeNavLink;                                    // 0x04E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EA[0x2];                                      // 0x04EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _navLinkProxyDataCount;                            // 0x04EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _drawDebugBuildItems;                              // 0x04F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F1[0x3];                                      // 0x04F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _drawDebugLifeTime;                                // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomRecastNavMesh">();
	}
	static class ACustomRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomRecastNavMesh>();
	}
};
static_assert(alignof(ACustomRecastNavMesh) == 0x000008, "Wrong alignment on ACustomRecastNavMesh");
static_assert(sizeof(ACustomRecastNavMesh) == 0x0004F8, "Wrong size on ACustomRecastNavMesh");
static_assert(offsetof(ACustomRecastNavMesh, _edgeDivisor) == 0x0004D8, "Member 'ACustomRecastNavMesh::_edgeDivisor' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _edgeRayLength) == 0x0004DC, "Member 'ACustomRecastNavMesh::_edgeRayLength' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _floorRayLength) == 0x0004E0, "Member 'ACustomRecastNavMesh::_floorRayLength' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _floorRaySlantDegree) == 0x0004E4, "Member 'ACustomRecastNavMesh::_floorRaySlantDegree' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _createNavLink) == 0x0004E8, "Member 'ACustomRecastNavMesh::_createNavLink' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _removeNavLink) == 0x0004E9, "Member 'ACustomRecastNavMesh::_removeNavLink' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _navLinkProxyDataCount) == 0x0004EC, "Member 'ACustomRecastNavMesh::_navLinkProxyDataCount' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _drawDebugBuildItems) == 0x0004F0, "Member 'ACustomRecastNavMesh::_drawDebugBuildItems' has a wrong offset!");
static_assert(offsetof(ACustomRecastNavMesh, _drawDebugLifeTime) == 0x0004F4, "Member 'ACustomRecastNavMesh::_drawDebugLifeTime' has a wrong offset!");

// Class InGameModule.AN_AttackChaseEnd
// 0x0000 (0x0040 - 0x0040)
class UAN_AttackChaseEnd final : public UAN_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackChaseEnd">();
	}
	static class UAN_AttackChaseEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackChaseEnd>();
	}
};
static_assert(alignof(UAN_AttackChaseEnd) == 0x000008, "Wrong alignment on UAN_AttackChaseEnd");
static_assert(sizeof(UAN_AttackChaseEnd) == 0x000040, "Wrong size on UAN_AttackChaseEnd");

// Class InGameModule.AN_AttackChaseStart
// 0x0048 (0x0088 - 0x0040)
class UAN_AttackChaseStart final : public UAN_BattleBase
{
public:
	bool                                          _enableSetSpeed;                                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _initialSpeed;                                     // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lastSpeed;                                        // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _speedSpan;                                        // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _endDistance;                                      // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _addTargetOffset;                                  // 0x0054(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnTime;                                         // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnRate;                                         // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _turnEasing;                                       // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _alwaysSetSpeed;                                   // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _clearSpeedAsEnd;                                  // 0x006A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ignorePassing;                                    // 0x006B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inertiaRate;                                      // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inertiaSpan;                                      // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _targetDirectionTo2D;                              // 0x0074(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _enablePitchRotation;                              // 0x0075(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pitchRotationSpan;                                // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionAxis                                   _pitchTargetAxis;                                  // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pitchRotationRate;                                // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _pitchRotationMaxDegreesPerFrame;                  // 0x0084(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackChaseStart">();
	}
	static class UAN_AttackChaseStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackChaseStart>();
	}
};
static_assert(alignof(UAN_AttackChaseStart) == 0x000008, "Wrong alignment on UAN_AttackChaseStart");
static_assert(sizeof(UAN_AttackChaseStart) == 0x000088, "Wrong size on UAN_AttackChaseStart");
static_assert(offsetof(UAN_AttackChaseStart, _enableSetSpeed) == 0x000040, "Member 'UAN_AttackChaseStart::_enableSetSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _initialSpeed) == 0x000044, "Member 'UAN_AttackChaseStart::_initialSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _lastSpeed) == 0x000048, "Member 'UAN_AttackChaseStart::_lastSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _speedSpan) == 0x00004C, "Member 'UAN_AttackChaseStart::_speedSpan' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _endDistance) == 0x000050, "Member 'UAN_AttackChaseStart::_endDistance' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _addTargetOffset) == 0x000054, "Member 'UAN_AttackChaseStart::_addTargetOffset' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _turnTime) == 0x000060, "Member 'UAN_AttackChaseStart::_turnTime' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _turnRate) == 0x000064, "Member 'UAN_AttackChaseStart::_turnRate' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _turnEasing) == 0x000068, "Member 'UAN_AttackChaseStart::_turnEasing' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _alwaysSetSpeed) == 0x000069, "Member 'UAN_AttackChaseStart::_alwaysSetSpeed' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _clearSpeedAsEnd) == 0x00006A, "Member 'UAN_AttackChaseStart::_clearSpeedAsEnd' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _ignorePassing) == 0x00006B, "Member 'UAN_AttackChaseStart::_ignorePassing' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _inertiaRate) == 0x00006C, "Member 'UAN_AttackChaseStart::_inertiaRate' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _inertiaSpan) == 0x000070, "Member 'UAN_AttackChaseStart::_inertiaSpan' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _targetDirectionTo2D) == 0x000074, "Member 'UAN_AttackChaseStart::_targetDirectionTo2D' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _enablePitchRotation) == 0x000075, "Member 'UAN_AttackChaseStart::_enablePitchRotation' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _pitchRotationSpan) == 0x000078, "Member 'UAN_AttackChaseStart::_pitchRotationSpan' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _pitchTargetAxis) == 0x00007C, "Member 'UAN_AttackChaseStart::_pitchTargetAxis' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _pitchRotationRate) == 0x000080, "Member 'UAN_AttackChaseStart::_pitchRotationRate' has a wrong offset!");
static_assert(offsetof(UAN_AttackChaseStart, _pitchRotationMaxDegreesPerFrame) == 0x000084, "Member 'UAN_AttackChaseStart::_pitchRotationMaxDegreesPerFrame' has a wrong offset!");

// Class InGameModule.AN_AttackComboChain
// 0x0000 (0x0040 - 0x0040)
class UAN_AttackComboChain final : public UAN_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackComboChain">();
	}
	static class UAN_AttackComboChain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackComboChain>();
	}
};
static_assert(alignof(UAN_AttackComboChain) == 0x000008, "Wrong alignment on UAN_AttackComboChain");
static_assert(sizeof(UAN_AttackComboChain) == 0x000040, "Wrong size on UAN_AttackComboChain");

// Class InGameModule.Ch043Unique3Trap
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh043Unique3Trap final : public ABullet
{
public:
	class UHeroSphereComponent*                   _responceShape;                                    // 0x1DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE0[0x10];                                    // 0x1DE0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnResponceHit(class AActor* HitActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch043Unique3Trap">();
	}
	static class ACh043Unique3Trap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh043Unique3Trap>();
	}
};
static_assert(alignof(ACh043Unique3Trap) == 0x000010, "Wrong alignment on ACh043Unique3Trap");
static_assert(sizeof(ACh043Unique3Trap) == 0x001DF0, "Wrong size on ACh043Unique3Trap");
static_assert(offsetof(ACh043Unique3Trap, _responceShape) == 0x001DD8, "Member 'ACh043Unique3Trap::_responceShape' has a wrong offset!");

// Class InGameModule.ConditionEffectDataAsset
// 0x0050 (0x0080 - 0x0030)
class UConditionEffectDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<ECharacterConditionId, struct FConditionDataList> _conditionEffectDataList;                          // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void SortByAlphabetName();
	void SortByEnum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionEffectDataAsset">();
	}
	static class UConditionEffectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionEffectDataAsset>();
	}
};
static_assert(alignof(UConditionEffectDataAsset) == 0x000008, "Wrong alignment on UConditionEffectDataAsset");
static_assert(sizeof(UConditionEffectDataAsset) == 0x000080, "Wrong size on UConditionEffectDataAsset");
static_assert(offsetof(UConditionEffectDataAsset, _conditionEffectDataList) == 0x000030, "Member 'UConditionEffectDataAsset::_conditionEffectDataList' has a wrong offset!");

// Class InGameModule.AN_AttackEnd
// 0x0000 (0x0040 - 0x0040)
class UAN_AttackEnd final : public UAN_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackEnd">();
	}
	static class UAN_AttackEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackEnd>();
	}
};
static_assert(alignof(UAN_AttackEnd) == 0x000008, "Wrong alignment on UAN_AttackEnd");
static_assert(sizeof(UAN_AttackEnd) == 0x000040, "Wrong size on UAN_AttackEnd");

// Class InGameModule.AN_AttackUnlinkAnimLayer
// 0x0008 (0x0048 - 0x0040)
class UAN_AttackUnlinkAnimLayer final : public UAN_BattleBase
{
public:
	bool                                          _bBlend;                                           // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blendTime;                                        // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackUnlinkAnimLayer">();
	}
	static class UAN_AttackUnlinkAnimLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackUnlinkAnimLayer>();
	}
};
static_assert(alignof(UAN_AttackUnlinkAnimLayer) == 0x000008, "Wrong alignment on UAN_AttackUnlinkAnimLayer");
static_assert(sizeof(UAN_AttackUnlinkAnimLayer) == 0x000048, "Wrong size on UAN_AttackUnlinkAnimLayer");
static_assert(offsetof(UAN_AttackUnlinkAnimLayer, _bBlend) == 0x000040, "Member 'UAN_AttackUnlinkAnimLayer::_bBlend' has a wrong offset!");
static_assert(offsetof(UAN_AttackUnlinkAnimLayer, _blendTime) == 0x000044, "Member 'UAN_AttackUnlinkAnimLayer::_blendTime' has a wrong offset!");

// Class InGameModule.CustomBullet
// 0x01F0 (0x1FD0 - 0x1DE0)
class ACustomBullet : public ABullet
{
public:
	TArray<struct FCustomBulletChildInfo>         _childInfo;                                        // 0x1DD8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _HitBGAfterDestorySpan;                            // 0x1DE8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DEC[0x4];                                     // 0x1DEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FReserveDeActiveParticleInfo> _reserveDeActiveParticleList;                      // 0x1DF0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          _bAttachParentForGround;                           // 0x1E40(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E41[0x7];                                     // 0x1E41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomBulletInterval>          _childSpawnIntervals;                              // 0x1E48(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E58[0xA8];                                    // 0x1E58(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHitBackGroundEventDispatcher;                    // 0x1F00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitCharacterEventDispatcher;                     // 0x1F10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F20[0x70];                                    // 0x1F20(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _targetActor;                                      // 0x1F90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F98[0x38];                                    // 0x1F98(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitDelegate__DelegateSignature(const struct FHitResult& HitResult);
	void SetRotationFollowsVelocity(bool bRotate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomBullet">();
	}
	static class ACustomBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomBullet>();
	}
};
static_assert(alignof(ACustomBullet) == 0x000010, "Wrong alignment on ACustomBullet");
static_assert(sizeof(ACustomBullet) == 0x001FD0, "Wrong size on ACustomBullet");
static_assert(offsetof(ACustomBullet, _childInfo) == 0x001DD8, "Member 'ACustomBullet::_childInfo' has a wrong offset!");
static_assert(offsetof(ACustomBullet, _HitBGAfterDestorySpan) == 0x001DE8, "Member 'ACustomBullet::_HitBGAfterDestorySpan' has a wrong offset!");
static_assert(offsetof(ACustomBullet, _reserveDeActiveParticleList) == 0x001DF0, "Member 'ACustomBullet::_reserveDeActiveParticleList' has a wrong offset!");
static_assert(offsetof(ACustomBullet, _bAttachParentForGround) == 0x001E40, "Member 'ACustomBullet::_bAttachParentForGround' has a wrong offset!");
static_assert(offsetof(ACustomBullet, _childSpawnIntervals) == 0x001E48, "Member 'ACustomBullet::_childSpawnIntervals' has a wrong offset!");
static_assert(offsetof(ACustomBullet, OnHitBackGroundEventDispatcher) == 0x001F00, "Member 'ACustomBullet::OnHitBackGroundEventDispatcher' has a wrong offset!");
static_assert(offsetof(ACustomBullet, OnHitCharacterEventDispatcher) == 0x001F10, "Member 'ACustomBullet::OnHitCharacterEventDispatcher' has a wrong offset!");
static_assert(offsetof(ACustomBullet, _targetActor) == 0x001F90, "Member 'ACustomBullet::_targetActor' has a wrong offset!");

// Class InGameModule.Ch046Unique2BulletBase
// 0x0020 (0x1FF0 - 0x1FD0)
class ACh046Unique2BulletBase final : public ACustomBullet
{
public:
	class UDurableBulletComponent*                _durableBulletComponent;                           // 0x1FD0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _eventBulletDestroy;                               // 0x1FD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitEffectComponent*                    _hitEffectComponent;                               // 0x1FE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FE8[0x8];                                     // 0x1FE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetShieldHp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch046Unique2BulletBase">();
	}
	static class ACh046Unique2BulletBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh046Unique2BulletBase>();
	}
};
static_assert(alignof(ACh046Unique2BulletBase) == 0x000010, "Wrong alignment on ACh046Unique2BulletBase");
static_assert(sizeof(ACh046Unique2BulletBase) == 0x001FF0, "Wrong size on ACh046Unique2BulletBase");
static_assert(offsetof(ACh046Unique2BulletBase, _durableBulletComponent) == 0x001FD0, "Member 'ACh046Unique2BulletBase::_durableBulletComponent' has a wrong offset!");
static_assert(offsetof(ACh046Unique2BulletBase, _eventBulletDestroy) == 0x001FD8, "Member 'ACh046Unique2BulletBase::_eventBulletDestroy' has a wrong offset!");
static_assert(offsetof(ACh046Unique2BulletBase, _hitEffectComponent) == 0x001FE0, "Member 'ACh046Unique2BulletBase::_hitEffectComponent' has a wrong offset!");

// Class InGameModule.AN_AttackTurnToLever
// 0x0018 (0x0058 - 0x0040)
class UAN_AttackTurnToLever final : public UAN_BattleBase
{
public:
	bool                                          _ignoreMovementDirection;                          // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ignoreTurnDirection;                              // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _turnTime;                                         // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnRate;                                         // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _turnEasing;                                       // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _limitDegrees;                                     // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _chargeAttackOnly;                                 // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackTurnToLever">();
	}
	static class UAN_AttackTurnToLever* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackTurnToLever>();
	}
};
static_assert(alignof(UAN_AttackTurnToLever) == 0x000008, "Wrong alignment on UAN_AttackTurnToLever");
static_assert(sizeof(UAN_AttackTurnToLever) == 0x000058, "Wrong size on UAN_AttackTurnToLever");
static_assert(offsetof(UAN_AttackTurnToLever, _ignoreMovementDirection) == 0x000040, "Member 'UAN_AttackTurnToLever::_ignoreMovementDirection' has a wrong offset!");
static_assert(offsetof(UAN_AttackTurnToLever, _ignoreTurnDirection) == 0x000041, "Member 'UAN_AttackTurnToLever::_ignoreTurnDirection' has a wrong offset!");
static_assert(offsetof(UAN_AttackTurnToLever, _turnTime) == 0x000044, "Member 'UAN_AttackTurnToLever::_turnTime' has a wrong offset!");
static_assert(offsetof(UAN_AttackTurnToLever, _turnRate) == 0x000048, "Member 'UAN_AttackTurnToLever::_turnRate' has a wrong offset!");
static_assert(offsetof(UAN_AttackTurnToLever, _turnEasing) == 0x00004C, "Member 'UAN_AttackTurnToLever::_turnEasing' has a wrong offset!");
static_assert(offsetof(UAN_AttackTurnToLever, _limitDegrees) == 0x000050, "Member 'UAN_AttackTurnToLever::_limitDegrees' has a wrong offset!");
static_assert(offsetof(UAN_AttackTurnToLever, _chargeAttackOnly) == 0x000054, "Member 'UAN_AttackTurnToLever::_chargeAttackOnly' has a wrong offset!");

// Class InGameModule.AN_AttackTurnToLeverEnd
// 0x0000 (0x0040 - 0x0040)
class UAN_AttackTurnToLeverEnd final : public UAN_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_AttackTurnToLeverEnd">();
	}
	static class UAN_AttackTurnToLeverEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_AttackTurnToLeverEnd>();
	}
};
static_assert(alignof(UAN_AttackTurnToLeverEnd) == 0x000008, "Wrong alignment on UAN_AttackTurnToLeverEnd");
static_assert(sizeof(UAN_AttackTurnToLeverEnd) == 0x000040, "Wrong size on UAN_AttackTurnToLeverEnd");

// Class InGameModule.CharacterBattle
// 0x0648 (0x0B10 - 0x04C8)
class alignas(0x10) ACharacterBattle : public ACharacterGame
{
public:
	uint8                                         Pad_4C8[0x178];                                    // 0x04C8(0x0178)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _playerStateBattle;                                // 0x0640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _teamId;                                           // 0x0648(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterRespawnControlCompnent*       _respawnControlComponent;                          // 0x0650(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           _overlappedMeshComponentListForInsideWall;         // 0x0658(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x50];                                     // 0x0668(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterBuffControlCompnent*          _buffControlComponent;                             // 0x06B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C0[0x60];                                     // 0x06C0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterParam*                        _characterParam;                                   // 0x0720(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_728[0x98];                                     // 0x0728(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIControllerBattle*                    _localAiController;                                // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterCommandComponent*             _commandComponent;                                 // 0x07D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D8[0x8];                                      // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterActionControlComponent*       _actionControlComponent;                           // 0x07E0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _defaultUniqueLevel;                               // 0x07E8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UCharacterAttackComponent*              _attackComponent;                                  // 0x07F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _aiTargetActor;                                    // 0x0800(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_808[0xA0];                                     // 0x0808(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class USkillManagementComponent*              _skillManagementComponent;                         // 0x08A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AProjectileGeneratorBattle*>     _owningProjectileGenerators;                       // 0x08B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ABullet*>                        _owningBullets;                                    // 0x08C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMagazineManagementComponent*           _magazineManagementComponent;                      // 0x08D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterDamageComponent*              _damageComponent;                                  // 0x08D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileReplicateBattleComponent*    _projectileReplicator;                             // 0x08E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterAttackReplicateComponent*     _characterAttackReplicator;                        // 0x08E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F0[0x8];                                      // 0x08F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    _springArmComponent;                               // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponentForOffCenterProjection* _cameraComponent;                                  // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_908[0x28];                                     // 0x0908(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterGiantControlComponent*        _giantControlComponent;                            // 0x0930(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterConditionControlComponent*    _conditionControlComponent;                        // 0x0938(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterBattleEffectComponent*        _battleEffectComponent;                            // 0x0940(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUseItemEffectComponent*                _useItemEffectComponent;                           // 0x0948(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitEffectComponent*                    _hitEffectComponent;                               // 0x0950(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URestraintEffectComponent*              _restraintEffectComponent;                         // 0x0958(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterChargeEffectComponent*        _characterChargeEffectComponent;                   // 0x0960(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomSoundObject*                       _soundObject;                                      // 0x0968(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       _aiStatusWidget;                                   // 0x0970(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterInteractComponent*            _interactComponent;                                // 0x0978(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractTargetComponent*               _interactTargetComponent;                          // 0x0980(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_988[0x20];                                     // 0x0988(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterDeltaRateControlComponent*    _deltaRateControlComponent;                        // 0x09A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _requestedNegotiationTarget;                       // 0x09B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _currentNegotiationTarget;                         // 0x09B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _reserveGrabCharacter_Server;                      // 0x09C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C8[0x10];                                     // 0x09C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAddPartsComponent*            _addPartsComponent;                                // 0x09D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterAttackCollisionController*    _attackCollisionCtrl;                              // 0x09E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E8[0x8];                                      // 0x09E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     _wireFramePP;                                      // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _beginTransparentEasingSeconds;                    // 0x09F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _endTransparentEasingSeconds;                      // 0x09FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _wireFramePPStencil;                               // 0x0A00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A08[0xC8];                                     // 0x0A08(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _capsuleComponentforCheckInsideWall;               // 0x0AD0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD8[0x8];                                      // 0x0AD8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterLinkedAnimationControlComponent* _linkAnimContorol;                                 // 0x0AE0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AE8[0x8];                                      // 0x0AE8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _rightFootIKSocketName;                            // 0x0AF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _leftFootIKSocketName;                             // 0x0AF8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B00[0x10];                                     // 0x0B00(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginWireFramePostProcess();
	void BP_BeginChangeBoundsScale(float BoundsScale);
	void BP_EndChangeBoundsScale();
	uint8 BP_GetSpawnCharacterId();
	uint8 BP_GetTeamId();
	bool BP_IsDuplicating();
	bool BP_IsTransforming();
	void BP_JumpPadDirection(const struct FVector& Normal);
	void BP_OnJumpPad(float Power, class AActor* JumpPadActor);
	void BP_RecoverDyingAlly(class AActor* Ally, bool bSpecialAction);
	void BP_SetCameraOffset(float Scale, float Seconds, EEasingFunc Type);
	void BP_SetEnableWallThrough(bool Flag);
	void BP_SetJumpPadPower(float Power);
	void BP_SetMeshVisiblity(bool bEnable);
	void ClearNegotiateInfo_ToClient(uint8 MyActionIndex);
	void ClearNegotiateInfo_ToServer(uint8 MyActionIndex);
	void EnableBlendingAimDirAndMoveDir(bool Flag);
	void EndWireFramePostProcess();
	void NegotiateAndWaitActionTarget_ToServer(class ACharacterBattle* NegotiationTargetCharacter, uint8 MyActionIndex);
	void NegotiateTarget_ToServer(class AActor* NegotiationTarget, uint8 MyActionIndex);
	void NegotiateTargetResult_ToClient(class AActor* NegotiationTarget, uint8 MyActionIndex);
	void OnBeginOverlapComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void RecoverDyingAlly_ToServer(class ACharacterBattle* Ally, bool bSpecialAction);
	void ReleaseNegotiateTarget_NetMulticast(class AActor* NegotiationTarget);
	void ReleaseNegotiateTarget_ToServer(class AActor* NegotiationTarget);
	void SetWaitActionAfterNegotiation_ToClient(uint32 ServerPriorityActionSerialNo);

	class UCharacterAddPartsComponent* BP_GetAddPartsComponent() const;
	class UCharacterAttackComponent* BP_GetAttackComponent() const;
	class UCharacterBattleVoiceComponent* BP_GetBattleVoiceComponent() const;
	struct FVector BP_GetCameraDirection() const;
	ECharacterAssign BP_GetCharacterAssign() const;
	ECharacterBodySize BP_GetCharacterBodySize() const;
	class UCharacterMaterialControlComponent* BP_GetCharacterMaterialControl() const;
	class UCharacterCommandComponent* BP_GetCommandComponent() const;
	class UCharacterConditionControlComponent* BP_GetConditionControlComponent() const;
	class UCharacterDamageComponent* BP_GetDamageComponent() const;
	class UCharacterGiantControlComponent* BP_GetGiantControlComponent() const;
	bool BP_GetIsEnableAttackDuringDash() const;
	struct FVector BP_GetJumpPadDirection() const;
	float BP_GetJumpPadPower() const;
	class UCharacterLinkedAnimationControlComponent* BP_GetLinkAnimContorol() const;
	class UMagazineManagementComponent* BP_GetMagazineManagementComponent() const;
	class UMovementComponentBattle* BP_GetMovementBattle() const;
	class UCharacterRespawnControlCompnent* BP_GetRespawnControlComponent() const;
	class URestraintEffectComponent* BP_GetRestraintEffectComponent() const;
	class USkillManagementComponent* BP_GetSkillManagementCompnent() const;
	class UCharacterState* BP_GetState() const;
	class UBPInGameActorUtilityComponent* BP_GetUBPInGameActorUtilityComponent() const;
	float GetLeftFootIKOffset() const;
	class UProjectileReplicateBattleComponent* GetProjectileReplicator() const;
	float GetRightFootIKOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBattle">();
	}
	static class ACharacterBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterBattle>();
	}
};
static_assert(alignof(ACharacterBattle) == 0x000010, "Wrong alignment on ACharacterBattle");
static_assert(sizeof(ACharacterBattle) == 0x000B10, "Wrong size on ACharacterBattle");
static_assert(offsetof(ACharacterBattle, _playerStateBattle) == 0x000640, "Member 'ACharacterBattle::_playerStateBattle' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _teamId) == 0x000648, "Member 'ACharacterBattle::_teamId' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _respawnControlComponent) == 0x000650, "Member 'ACharacterBattle::_respawnControlComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _overlappedMeshComponentListForInsideWall) == 0x000658, "Member 'ACharacterBattle::_overlappedMeshComponentListForInsideWall' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _buffControlComponent) == 0x0006B8, "Member 'ACharacterBattle::_buffControlComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _characterParam) == 0x000720, "Member 'ACharacterBattle::_characterParam' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _localAiController) == 0x0007C0, "Member 'ACharacterBattle::_localAiController' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _commandComponent) == 0x0007D0, "Member 'ACharacterBattle::_commandComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _actionControlComponent) == 0x0007E0, "Member 'ACharacterBattle::_actionControlComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _defaultUniqueLevel) == 0x0007E8, "Member 'ACharacterBattle::_defaultUniqueLevel' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _attackComponent) == 0x0007F8, "Member 'ACharacterBattle::_attackComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _aiTargetActor) == 0x000800, "Member 'ACharacterBattle::_aiTargetActor' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _skillManagementComponent) == 0x0008A8, "Member 'ACharacterBattle::_skillManagementComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _owningProjectileGenerators) == 0x0008B0, "Member 'ACharacterBattle::_owningProjectileGenerators' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _owningBullets) == 0x0008C0, "Member 'ACharacterBattle::_owningBullets' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _magazineManagementComponent) == 0x0008D0, "Member 'ACharacterBattle::_magazineManagementComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _damageComponent) == 0x0008D8, "Member 'ACharacterBattle::_damageComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _projectileReplicator) == 0x0008E0, "Member 'ACharacterBattle::_projectileReplicator' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _characterAttackReplicator) == 0x0008E8, "Member 'ACharacterBattle::_characterAttackReplicator' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _springArmComponent) == 0x0008F8, "Member 'ACharacterBattle::_springArmComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _cameraComponent) == 0x000900, "Member 'ACharacterBattle::_cameraComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _giantControlComponent) == 0x000930, "Member 'ACharacterBattle::_giantControlComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _conditionControlComponent) == 0x000938, "Member 'ACharacterBattle::_conditionControlComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _battleEffectComponent) == 0x000940, "Member 'ACharacterBattle::_battleEffectComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _useItemEffectComponent) == 0x000948, "Member 'ACharacterBattle::_useItemEffectComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _hitEffectComponent) == 0x000950, "Member 'ACharacterBattle::_hitEffectComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _restraintEffectComponent) == 0x000958, "Member 'ACharacterBattle::_restraintEffectComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _characterChargeEffectComponent) == 0x000960, "Member 'ACharacterBattle::_characterChargeEffectComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _soundObject) == 0x000968, "Member 'ACharacterBattle::_soundObject' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _aiStatusWidget) == 0x000970, "Member 'ACharacterBattle::_aiStatusWidget' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _interactComponent) == 0x000978, "Member 'ACharacterBattle::_interactComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _interactTargetComponent) == 0x000980, "Member 'ACharacterBattle::_interactTargetComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _deltaRateControlComponent) == 0x0009A8, "Member 'ACharacterBattle::_deltaRateControlComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _requestedNegotiationTarget) == 0x0009B0, "Member 'ACharacterBattle::_requestedNegotiationTarget' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _currentNegotiationTarget) == 0x0009B8, "Member 'ACharacterBattle::_currentNegotiationTarget' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _reserveGrabCharacter_Server) == 0x0009C0, "Member 'ACharacterBattle::_reserveGrabCharacter_Server' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _addPartsComponent) == 0x0009D8, "Member 'ACharacterBattle::_addPartsComponent' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _attackCollisionCtrl) == 0x0009E0, "Member 'ACharacterBattle::_attackCollisionCtrl' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _wireFramePP) == 0x0009F0, "Member 'ACharacterBattle::_wireFramePP' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _beginTransparentEasingSeconds) == 0x0009F8, "Member 'ACharacterBattle::_beginTransparentEasingSeconds' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _endTransparentEasingSeconds) == 0x0009FC, "Member 'ACharacterBattle::_endTransparentEasingSeconds' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _wireFramePPStencil) == 0x000A00, "Member 'ACharacterBattle::_wireFramePPStencil' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _capsuleComponentforCheckInsideWall) == 0x000AD0, "Member 'ACharacterBattle::_capsuleComponentforCheckInsideWall' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _linkAnimContorol) == 0x000AE0, "Member 'ACharacterBattle::_linkAnimContorol' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _rightFootIKSocketName) == 0x000AF0, "Member 'ACharacterBattle::_rightFootIKSocketName' has a wrong offset!");
static_assert(offsetof(ACharacterBattle, _leftFootIKSocketName) == 0x000AF8, "Member 'ACharacterBattle::_leftFootIKSocketName' has a wrong offset!");

// Class InGameModule.Ch100
// 0x0010 (0x0B20 - 0x0B10)
class ACh100 final : public ACharacterBattle
{
public:
	uint8                                         Pad_B10[0x1];                                      // 0x0B10(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bGiant_Simulated;                                 // 0x0B11(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B12[0xE];                                      // 0x0B12(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Replicated_bGiant_Simulated();
	void SetGiantSimulated_ToSever(bool bGiant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch100">();
	}
	static class ACh100* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh100>();
	}
};
static_assert(alignof(ACh100) == 0x000010, "Wrong alignment on ACh100");
static_assert(sizeof(ACh100) == 0x000B20, "Wrong size on ACh100");
static_assert(offsetof(ACh100, _bGiant_Simulated) == 0x000B11, "Member 'ACh100::_bGiant_Simulated' has a wrong offset!");

// Class InGameModule.AN_Base
// 0x0008 (0x0040 - 0x0038)
class UAN_Base final : public UAnimNotify
{
public:
	uint8                                         _bUseActiveMesh : 1;                               // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_Base">();
	}
	static class UAN_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_Base>();
	}
};
static_assert(alignof(UAN_Base) == 0x000008, "Wrong alignment on UAN_Base");
static_assert(sizeof(UAN_Base) == 0x000040, "Wrong size on UAN_Base");

// Class InGameModule.CustomBulletComponentBase
// 0x0000 (0x00B0 - 0x00B0)
class UCustomBulletComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomBulletComponentBase">();
	}
	static class UCustomBulletComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomBulletComponentBase>();
	}
};
static_assert(alignof(UCustomBulletComponentBase) == 0x000008, "Wrong alignment on UCustomBulletComponentBase");
static_assert(sizeof(UCustomBulletComponentBase) == 0x0000B0, "Wrong size on UCustomBulletComponentBase");

// Class InGameModule.CustomBulletPhysicsLikeComponent
// 0x0150 (0x0200 - 0x00B0)
class UCustomBulletPhysicsLikeComponent final : public UCustomBulletComponentBase
{
public:
	FMulticastInlineDelegateProperty_             _onReflectionCountRunsOut;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onReflection;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onNewGravityApplied;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ACustomBullet*                          _owner;                                            // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _gravity;                                          // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bReflectionOnHitBG;                               // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _reflectionCount;                                  // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reflectionIgnoreDist;                             // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reflectionIgnoreInterval;                         // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reflectionFriction;                               // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _zeroSpeedtHreshold;                               // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reflectionDist;                                   // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxSpeed;                                         // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bAngleLimit;                                      // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxAngleLimitDegree;                              // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _reflectionEffect;                                 // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _reflectionEffectScale;                            // 0x0120(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _useBulletScale;                                   // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0130(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          _bSpawnBulletWhenReflecting;                       // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _spawnBulletName;                                  // 0x0174(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x3C];                                     // 0x017C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _oldReflectActor;                                  // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x40];                                     // 0x01C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CustomBulletPhysicsLikeEvent__DelegateSignature();
	void OnHitBackground(const struct FHitResult& HitResult);
	void OnHitCharacter(const struct FHitResult& HitResult);
	void ReflectionCountRunsOutDelegate__DelegateSignature();
	void ReflectionDelegate__DelegateSignature(const struct FVector& Normal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomBulletPhysicsLikeComponent">();
	}
	static class UCustomBulletPhysicsLikeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomBulletPhysicsLikeComponent>();
	}
};
static_assert(alignof(UCustomBulletPhysicsLikeComponent) == 0x000008, "Wrong alignment on UCustomBulletPhysicsLikeComponent");
static_assert(sizeof(UCustomBulletPhysicsLikeComponent) == 0x000200, "Wrong size on UCustomBulletPhysicsLikeComponent");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _onReflectionCountRunsOut) == 0x0000B0, "Member 'UCustomBulletPhysicsLikeComponent::_onReflectionCountRunsOut' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _onReflection) == 0x0000C0, "Member 'UCustomBulletPhysicsLikeComponent::_onReflection' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _onNewGravityApplied) == 0x0000D0, "Member 'UCustomBulletPhysicsLikeComponent::_onNewGravityApplied' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _owner) == 0x0000E0, "Member 'UCustomBulletPhysicsLikeComponent::_owner' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _gravity) == 0x0000E8, "Member 'UCustomBulletPhysicsLikeComponent::_gravity' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _bReflectionOnHitBG) == 0x0000EC, "Member 'UCustomBulletPhysicsLikeComponent::_bReflectionOnHitBG' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _reflectionCount) == 0x0000F0, "Member 'UCustomBulletPhysicsLikeComponent::_reflectionCount' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _reflectionIgnoreDist) == 0x0000F4, "Member 'UCustomBulletPhysicsLikeComponent::_reflectionIgnoreDist' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _reflectionIgnoreInterval) == 0x0000F8, "Member 'UCustomBulletPhysicsLikeComponent::_reflectionIgnoreInterval' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _reflectionFriction) == 0x0000FC, "Member 'UCustomBulletPhysicsLikeComponent::_reflectionFriction' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _zeroSpeedtHreshold) == 0x000100, "Member 'UCustomBulletPhysicsLikeComponent::_zeroSpeedtHreshold' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _reflectionDist) == 0x000104, "Member 'UCustomBulletPhysicsLikeComponent::_reflectionDist' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _maxSpeed) == 0x000108, "Member 'UCustomBulletPhysicsLikeComponent::_maxSpeed' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _bAngleLimit) == 0x00010C, "Member 'UCustomBulletPhysicsLikeComponent::_bAngleLimit' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _maxAngleLimitDegree) == 0x000110, "Member 'UCustomBulletPhysicsLikeComponent::_maxAngleLimitDegree' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _reflectionEffect) == 0x000118, "Member 'UCustomBulletPhysicsLikeComponent::_reflectionEffect' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _reflectionEffectScale) == 0x000120, "Member 'UCustomBulletPhysicsLikeComponent::_reflectionEffectScale' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _useBulletScale) == 0x00012C, "Member 'UCustomBulletPhysicsLikeComponent::_useBulletScale' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _graduallyAlpha) == 0x000130, "Member 'UCustomBulletPhysicsLikeComponent::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _bSpawnBulletWhenReflecting) == 0x000170, "Member 'UCustomBulletPhysicsLikeComponent::_bSpawnBulletWhenReflecting' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _spawnBulletName) == 0x000174, "Member 'UCustomBulletPhysicsLikeComponent::_spawnBulletName' has a wrong offset!");
static_assert(offsetof(UCustomBulletPhysicsLikeComponent, _oldReflectActor) == 0x0001B8, "Member 'UCustomBulletPhysicsLikeComponent::_oldReflectActor' has a wrong offset!");

// Class InGameModule.AN_CameraShake
// 0x0088 (0x00C8 - 0x0040)
class UAN_CameraShake final : public UAN_BattleBase
{
public:
	bool                                          _bShakeMyself;                                     // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bShakeNearPlayer;                                 // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _shakeNearDistance;                                // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bCheckDedicatedState;                             // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _bDedicatedStateID;                                // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAttackVisualLevel>                    _visualLevel;                                      // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         _shakeScale;                                       // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraShakerParam                     _shakeParam;                                       // 0x0064(0x0060)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_CameraShake">();
	}
	static class UAN_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_CameraShake>();
	}
};
static_assert(alignof(UAN_CameraShake) == 0x000008, "Wrong alignment on UAN_CameraShake");
static_assert(sizeof(UAN_CameraShake) == 0x0000C8, "Wrong size on UAN_CameraShake");
static_assert(offsetof(UAN_CameraShake, _bShakeMyself) == 0x000040, "Member 'UAN_CameraShake::_bShakeMyself' has a wrong offset!");
static_assert(offsetof(UAN_CameraShake, _bShakeNearPlayer) == 0x000041, "Member 'UAN_CameraShake::_bShakeNearPlayer' has a wrong offset!");
static_assert(offsetof(UAN_CameraShake, _shakeNearDistance) == 0x000044, "Member 'UAN_CameraShake::_shakeNearDistance' has a wrong offset!");
static_assert(offsetof(UAN_CameraShake, _bCheckDedicatedState) == 0x000048, "Member 'UAN_CameraShake::_bCheckDedicatedState' has a wrong offset!");
static_assert(offsetof(UAN_CameraShake, _bDedicatedStateID) == 0x00004C, "Member 'UAN_CameraShake::_bDedicatedStateID' has a wrong offset!");
static_assert(offsetof(UAN_CameraShake, _visualLevel) == 0x000050, "Member 'UAN_CameraShake::_visualLevel' has a wrong offset!");
static_assert(offsetof(UAN_CameraShake, _shakeScale) == 0x000060, "Member 'UAN_CameraShake::_shakeScale' has a wrong offset!");
static_assert(offsetof(UAN_CameraShake, _shakeParam) == 0x000064, "Member 'UAN_CameraShake::_shakeParam' has a wrong offset!");

// Class InGameModule.AN_ChangeGrabInfo
// 0x0020 (0x0060 - 0x0040)
class UAN_ChangeGrabInfo final : public UAN_BattleBase
{
public:
	class FName                                   _grabJointName;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _grabbedJointName;                                 // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationId                                  _grabbedAnimationId;                               // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blendTime;                                        // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _startPosition;                                    // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_ChangeGrabInfo">();
	}
	static class UAN_ChangeGrabInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_ChangeGrabInfo>();
	}
};
static_assert(alignof(UAN_ChangeGrabInfo) == 0x000008, "Wrong alignment on UAN_ChangeGrabInfo");
static_assert(sizeof(UAN_ChangeGrabInfo) == 0x000060, "Wrong size on UAN_ChangeGrabInfo");
static_assert(offsetof(UAN_ChangeGrabInfo, _grabJointName) == 0x000040, "Member 'UAN_ChangeGrabInfo::_grabJointName' has a wrong offset!");
static_assert(offsetof(UAN_ChangeGrabInfo, _grabbedJointName) == 0x000048, "Member 'UAN_ChangeGrabInfo::_grabbedJointName' has a wrong offset!");
static_assert(offsetof(UAN_ChangeGrabInfo, _grabbedAnimationId) == 0x000050, "Member 'UAN_ChangeGrabInfo::_grabbedAnimationId' has a wrong offset!");
static_assert(offsetof(UAN_ChangeGrabInfo, _blendTime) == 0x000054, "Member 'UAN_ChangeGrabInfo::_blendTime' has a wrong offset!");
static_assert(offsetof(UAN_ChangeGrabInfo, _startPosition) == 0x000058, "Member 'UAN_ChangeGrabInfo::_startPosition' has a wrong offset!");

// Class InGameModule.AN_ClearCenterOffset
// 0x0008 (0x0048 - 0x0040)
class UAN_ClearCenterOffset final : public UAN_BattleBase
{
public:
	float                                         _reverseRate;                                      // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_ClearCenterOffset">();
	}
	static class UAN_ClearCenterOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_ClearCenterOffset>();
	}
};
static_assert(alignof(UAN_ClearCenterOffset) == 0x000008, "Wrong alignment on UAN_ClearCenterOffset");
static_assert(sizeof(UAN_ClearCenterOffset) == 0x000048, "Wrong size on UAN_ClearCenterOffset");
static_assert(offsetof(UAN_ClearCenterOffset, _reverseRate) == 0x000040, "Member 'UAN_ClearCenterOffset::_reverseRate' has a wrong offset!");

// Class InGameModule.ProjectileGeneratorBattle
// 0x0130 (0x0450 - 0x0320)
#pragma pack(push, 0x1)
class alignas(0x10) AProjectileGeneratorBattle : public AProjectileGeneratorGame
{
public:
	struct FDestroyBulletGenRep                   _destroyBulletRep;                                 // 0x0318(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _beginSE;                                          // 0x0328(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         _beginSEComp;                                      // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _ownerBtl;                                         // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _meshComp;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABullet*>                        _bulletTbl;                                        // 0x0368(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FHitSavedInfo>             _hitSavedTbl;                                      // 0x0378(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x80];                                     // 0x03C8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_DestroyReserved();
	class UMovementComponentBattle* BP_GetOwnerMovementComponent();
	void BP_OnProjectileNotificationEvent(const class FName& EventName, int32 AttackSerial);
	void DestroyBullet_RPC(const struct FDestroyBulletGenRep& Rep);
	TArray<class ABullet*> GetBullets();
	void OnRep_DestroyBullet();
	class ABullet* SpawnBullet(const struct FTransform& Transform, const struct FVector& Dir, int32 JsonIDX);

	class ACharacterBattle* BP_GetOwnerBtl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileGeneratorBattle">();
	}
	static class AProjectileGeneratorBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileGeneratorBattle>();
	}
};
#pragma pack(pop)
static_assert(alignof(AProjectileGeneratorBattle) == 0x000010, "Wrong alignment on AProjectileGeneratorBattle");
static_assert(sizeof(AProjectileGeneratorBattle) == 0x000450, "Wrong size on AProjectileGeneratorBattle");
static_assert(offsetof(AProjectileGeneratorBattle, _destroyBulletRep) == 0x000318, "Member 'AProjectileGeneratorBattle::_destroyBulletRep' has a wrong offset!");
static_assert(offsetof(AProjectileGeneratorBattle, _beginSE) == 0x000328, "Member 'AProjectileGeneratorBattle::_beginSE' has a wrong offset!");
static_assert(offsetof(AProjectileGeneratorBattle, _beginSEComp) == 0x000350, "Member 'AProjectileGeneratorBattle::_beginSEComp' has a wrong offset!");
static_assert(offsetof(AProjectileGeneratorBattle, _ownerBtl) == 0x000358, "Member 'AProjectileGeneratorBattle::_ownerBtl' has a wrong offset!");
static_assert(offsetof(AProjectileGeneratorBattle, _meshComp) == 0x000360, "Member 'AProjectileGeneratorBattle::_meshComp' has a wrong offset!");
static_assert(offsetof(AProjectileGeneratorBattle, _bulletTbl) == 0x000368, "Member 'AProjectileGeneratorBattle::_bulletTbl' has a wrong offset!");
static_assert(offsetof(AProjectileGeneratorBattle, _hitSavedTbl) == 0x000378, "Member 'AProjectileGeneratorBattle::_hitSavedTbl' has a wrong offset!");

// Class InGameModule.CompressReleaseGen
// 0x0050 (0x04A0 - 0x0450)
class ACompressReleaseGen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x58];                                     // 0x0448(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompressReleaseGen">();
	}
	static class ACompressReleaseGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACompressReleaseGen>();
	}
};
static_assert(alignof(ACompressReleaseGen) == 0x000010, "Wrong alignment on ACompressReleaseGen");
static_assert(sizeof(ACompressReleaseGen) == 0x0004A0, "Wrong size on ACompressReleaseGen");

// Class InGameModule.AN_Decal
// 0x00B8 (0x00F8 - 0x0040)
class UAN_Decal final : public UAN_CharacterBase
{
public:
	bool                                          _enable;                                           // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewType                                     _viewType;                                         // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAttackVisualLevel>                    _visualLevel;                                      // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _material;                                         // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _decalParameterCurve;                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _decalParameter;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _heightScale;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomZRot;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomXYScaleMin;                                 // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomXYScaleMax;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffTransform                          _offset;                                           // 0x0080(0x0024)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x00A8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   _socketName;                                       // 0x00E8(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _inGameDecalMaster;                                // 0x00F0(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_Decal">();
	}
	static class UAN_Decal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_Decal>();
	}
};
static_assert(alignof(UAN_Decal) == 0x000008, "Wrong alignment on UAN_Decal");
static_assert(sizeof(UAN_Decal) == 0x0000F8, "Wrong size on UAN_Decal");
static_assert(offsetof(UAN_Decal, _enable) == 0x000040, "Member 'UAN_Decal::_enable' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _viewType) == 0x000041, "Member 'UAN_Decal::_viewType' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _visualLevel) == 0x000048, "Member 'UAN_Decal::_visualLevel' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _material) == 0x000058, "Member 'UAN_Decal::_material' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _decalParameterCurve) == 0x000060, "Member 'UAN_Decal::_decalParameterCurve' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _decalParameter) == 0x000068, "Member 'UAN_Decal::_decalParameter' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _heightScale) == 0x000070, "Member 'UAN_Decal::_heightScale' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _randomZRot) == 0x000074, "Member 'UAN_Decal::_randomZRot' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _randomXYScaleMin) == 0x000078, "Member 'UAN_Decal::_randomXYScaleMin' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _randomXYScaleMax) == 0x00007C, "Member 'UAN_Decal::_randomXYScaleMax' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _offset) == 0x000080, "Member 'UAN_Decal::_offset' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _graduallyAlpha) == 0x0000A8, "Member 'UAN_Decal::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _socketName) == 0x0000E8, "Member 'UAN_Decal::_socketName' has a wrong offset!");
static_assert(offsetof(UAN_Decal, _inGameDecalMaster) == 0x0000F0, "Member 'UAN_Decal::_inGameDecalMaster' has a wrong offset!");

// Class InGameModule.FogGrab
// 0x0020 (0x1FF0 - 0x1FD0)
class AFogGrab final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x20];                                    // 0x1FD0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FogGrab">();
	}
	static class AFogGrab* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFogGrab>();
	}
};
static_assert(alignof(AFogGrab) == 0x000010, "Wrong alignment on AFogGrab");
static_assert(sizeof(AFogGrab) == 0x001FF0, "Wrong size on AFogGrab");

// Class InGameModule.AN_MagazineManagement
// 0x0008 (0x0048 - 0x0040)
class UAN_MagazineManagement final : public UAN_CharacterBase
{
public:
	EAttackId                                     _attackID;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnMagazineShootType                          _shootType;                                        // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _consumptionRate;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_MagazineManagement">();
	}
	static class UAN_MagazineManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_MagazineManagement>();
	}
};
static_assert(alignof(UAN_MagazineManagement) == 0x000008, "Wrong alignment on UAN_MagazineManagement");
static_assert(sizeof(UAN_MagazineManagement) == 0x000048, "Wrong size on UAN_MagazineManagement");
static_assert(offsetof(UAN_MagazineManagement, _attackID) == 0x000040, "Member 'UAN_MagazineManagement::_attackID' has a wrong offset!");
static_assert(offsetof(UAN_MagazineManagement, _shootType) == 0x000041, "Member 'UAN_MagazineManagement::_shootType' has a wrong offset!");
static_assert(offsetof(UAN_MagazineManagement, _consumptionRate) == 0x000044, "Member 'UAN_MagazineManagement::_consumptionRate' has a wrong offset!");

// Class InGameModule.AN_PlayEffect
// 0x0150 (0x0190 - 0x0040)
class UAN_PlayEffect : public UAN_CharacterBase
{
public:
	EPlayEffectTemplate                           _writeTemplate;                                    // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _softReference;                                    // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _PSTemplate;                                       // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         _softRefPSTemplate;                                // 0x0050(0x0028)(Edit, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayEffectNotifyInfo                  _info;                                             // 0x0078(0x00F0)(Edit, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAvaterOverride                        _avaterOverride;                                   // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_PlayEffect">();
	}
	static class UAN_PlayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_PlayEffect>();
	}
};
static_assert(alignof(UAN_PlayEffect) == 0x000008, "Wrong alignment on UAN_PlayEffect");
static_assert(sizeof(UAN_PlayEffect) == 0x000190, "Wrong size on UAN_PlayEffect");
static_assert(offsetof(UAN_PlayEffect, _writeTemplate) == 0x000040, "Member 'UAN_PlayEffect::_writeTemplate' has a wrong offset!");
static_assert(offsetof(UAN_PlayEffect, _softReference) == 0x000041, "Member 'UAN_PlayEffect::_softReference' has a wrong offset!");
static_assert(offsetof(UAN_PlayEffect, _PSTemplate) == 0x000048, "Member 'UAN_PlayEffect::_PSTemplate' has a wrong offset!");
static_assert(offsetof(UAN_PlayEffect, _softRefPSTemplate) == 0x000050, "Member 'UAN_PlayEffect::_softRefPSTemplate' has a wrong offset!");
static_assert(offsetof(UAN_PlayEffect, _info) == 0x000078, "Member 'UAN_PlayEffect::_info' has a wrong offset!");
static_assert(offsetof(UAN_PlayEffect, _avaterOverride) == 0x000168, "Member 'UAN_PlayEffect::_avaterOverride' has a wrong offset!");

// Class InGameModule.AN_PlayEffectMtLady
// 0x0010 (0x01A0 - 0x0190)
class UAN_PlayEffectMtLady final : public UAN_PlayEffect
{
public:
	class UParticleSystem*                        _PSTemplateMtLady;                                 // 0x0190(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bGiant;                                           // 0x0198(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_PlayEffectMtLady">();
	}
	static class UAN_PlayEffectMtLady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_PlayEffectMtLady>();
	}
};
static_assert(alignof(UAN_PlayEffectMtLady) == 0x000008, "Wrong alignment on UAN_PlayEffectMtLady");
static_assert(sizeof(UAN_PlayEffectMtLady) == 0x0001A0, "Wrong size on UAN_PlayEffectMtLady");
static_assert(offsetof(UAN_PlayEffectMtLady, _PSTemplateMtLady) == 0x000190, "Member 'UAN_PlayEffectMtLady::_PSTemplateMtLady' has a wrong offset!");
static_assert(offsetof(UAN_PlayEffectMtLady, _bGiant) == 0x000198, "Member 'UAN_PlayEffectMtLady::_bGiant' has a wrong offset!");

// Class InGameModule.CracksGen
// 0x0060 (0x04B0 - 0x0450)
class ACracksGen final : public AProjectileGeneratorBattle
{
public:
	float                                         _searchHeightOffset;                               // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxHitDepth;                                      // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x60];                                     // 0x0450(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CracksGen">();
	}
	static class ACracksGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACracksGen>();
	}
};
static_assert(alignof(ACracksGen) == 0x000010, "Wrong alignment on ACracksGen");
static_assert(sizeof(ACracksGen) == 0x0004B0, "Wrong size on ACracksGen");
static_assert(offsetof(ACracksGen, _searchHeightOffset) == 0x000448, "Member 'ACracksGen::_searchHeightOffset' has a wrong offset!");
static_assert(offsetof(ACracksGen, _maxHitDepth) == 0x00044C, "Member 'ACracksGen::_maxHitDepth' has a wrong offset!");

// Class InGameModule.AN_PlayEffectSupply
// 0x0010 (0x0050 - 0x0040)
class UAN_PlayEffectSupply final : public UAN_CharacterBase
{
public:
	class UDataTable*                             _dataTable;                                        // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _typeName;                                         // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_PlayEffectSupply">();
	}
	static class UAN_PlayEffectSupply* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_PlayEffectSupply>();
	}
};
static_assert(alignof(UAN_PlayEffectSupply) == 0x000008, "Wrong alignment on UAN_PlayEffectSupply");
static_assert(sizeof(UAN_PlayEffectSupply) == 0x000050, "Wrong size on UAN_PlayEffectSupply");
static_assert(offsetof(UAN_PlayEffectSupply, _dataTable) == 0x000040, "Member 'UAN_PlayEffectSupply::_dataTable' has a wrong offset!");
static_assert(offsetof(UAN_PlayEffectSupply, _typeName) == 0x000048, "Member 'UAN_PlayEffectSupply::_typeName' has a wrong offset!");

// Class InGameModule.DeltaRateComponent
// 0x0070 (0x0120 - 0x00B0)
class UDeltaRateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x70];                                      // 0x00B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeltaRateComponent">();
	}
	static class UDeltaRateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeltaRateComponent>();
	}
};
static_assert(alignof(UDeltaRateComponent) == 0x000008, "Wrong alignment on UDeltaRateComponent");
static_assert(sizeof(UDeltaRateComponent) == 0x000120, "Wrong size on UDeltaRateComponent");

// Class InGameModule.AN_PlayParticleSet
// 0x0110 (0x0150 - 0x0040)
class UAN_PlayParticleSet : public UAN_CharacterBase
{
public:
	class UDataTable*                             _tbl;                                              // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayEffectNotifyInfo                  _info;                                             // 0x0048(0x00F0)(Edit, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESurfaceType                                  _viewerSurfaveType;                                // 0x0138(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0xF];                                      // 0x0139(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _workTbl;                                          // 0x0148(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_PlayParticleSet">();
	}
	static class UAN_PlayParticleSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_PlayParticleSet>();
	}
};
static_assert(alignof(UAN_PlayParticleSet) == 0x000008, "Wrong alignment on UAN_PlayParticleSet");
static_assert(sizeof(UAN_PlayParticleSet) == 0x000150, "Wrong size on UAN_PlayParticleSet");
static_assert(offsetof(UAN_PlayParticleSet, _tbl) == 0x000040, "Member 'UAN_PlayParticleSet::_tbl' has a wrong offset!");
static_assert(offsetof(UAN_PlayParticleSet, _info) == 0x000048, "Member 'UAN_PlayParticleSet::_info' has a wrong offset!");
static_assert(offsetof(UAN_PlayParticleSet, _viewerSurfaveType) == 0x000138, "Member 'UAN_PlayParticleSet::_viewerSurfaveType' has a wrong offset!");
static_assert(offsetof(UAN_PlayParticleSet, _workTbl) == 0x000148, "Member 'UAN_PlayParticleSet::_workTbl' has a wrong offset!");

// Class InGameModule.AN_PlayParticleSetMtLady
// 0x0010 (0x0160 - 0x0150)
class UAN_PlayParticleSetMtLady final : public UAN_PlayParticleSet
{
public:
	class UDataTable*                             _tblMtLady;                                        // 0x0150(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bGiant;                                           // 0x0158(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_PlayParticleSetMtLady">();
	}
	static class UAN_PlayParticleSetMtLady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_PlayParticleSetMtLady>();
	}
};
static_assert(alignof(UAN_PlayParticleSetMtLady) == 0x000008, "Wrong alignment on UAN_PlayParticleSetMtLady");
static_assert(sizeof(UAN_PlayParticleSetMtLady) == 0x000160, "Wrong size on UAN_PlayParticleSetMtLady");
static_assert(offsetof(UAN_PlayParticleSetMtLady, _tblMtLady) == 0x000150, "Member 'UAN_PlayParticleSetMtLady::_tblMtLady' has a wrong offset!");
static_assert(offsetof(UAN_PlayParticleSetMtLady, _bGiant) == 0x000158, "Member 'UAN_PlayParticleSetMtLady::_bGiant' has a wrong offset!");

// Class InGameModule.AN_PlaySound
// 0x0098 (0x00D8 - 0x0040)
class UAN_PlaySound final : public UAN_CharacterBase
{
public:
	class FString                                 _soundName;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          _cue;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _attached;                                         // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlaySoundNotifyInfo                   _info;                                             // 0x0060(0x0078)(Edit, BlueprintReadOnly, NativeAccessSpecifierPrivate)

public:
	void SetCue(class USoundAtomCue* Cue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_PlaySound">();
	}
	static class UAN_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_PlaySound>();
	}
};
static_assert(alignof(UAN_PlaySound) == 0x000008, "Wrong alignment on UAN_PlaySound");
static_assert(sizeof(UAN_PlaySound) == 0x0000D8, "Wrong size on UAN_PlaySound");
static_assert(offsetof(UAN_PlaySound, _soundName) == 0x000040, "Member 'UAN_PlaySound::_soundName' has a wrong offset!");
static_assert(offsetof(UAN_PlaySound, _cue) == 0x000050, "Member 'UAN_PlaySound::_cue' has a wrong offset!");
static_assert(offsetof(UAN_PlaySound, _attached) == 0x000058, "Member 'UAN_PlaySound::_attached' has a wrong offset!");
static_assert(offsetof(UAN_PlaySound, _info) == 0x000060, "Member 'UAN_PlaySound::_info' has a wrong offset!");

// Class InGameModule.CustomBulletDecalComponent
// 0x0058 (0x0108 - 0x00B0)
class UCustomBulletDecalComponent final : public UCustomBulletComponentBase
{
public:
	class UDataTable*                             _groundImpactTbl;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             _groundDecalMaterialTbl;                           // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCustomBulletGroundEffect              _groundEffect;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCustomBulletGroundDecal               _decal;                                            // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         _groundParticleLimitAngle;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleCustomParticleSystemComponent*   _groundPSC;                                        // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomBulletDecalComponent">();
	}
	static class UCustomBulletDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomBulletDecalComponent>();
	}
};
static_assert(alignof(UCustomBulletDecalComponent) == 0x000008, "Wrong alignment on UCustomBulletDecalComponent");
static_assert(sizeof(UCustomBulletDecalComponent) == 0x000108, "Wrong size on UCustomBulletDecalComponent");
static_assert(offsetof(UCustomBulletDecalComponent, _groundImpactTbl) == 0x0000B0, "Member 'UCustomBulletDecalComponent::_groundImpactTbl' has a wrong offset!");
static_assert(offsetof(UCustomBulletDecalComponent, _groundDecalMaterialTbl) == 0x0000B8, "Member 'UCustomBulletDecalComponent::_groundDecalMaterialTbl' has a wrong offset!");
static_assert(offsetof(UCustomBulletDecalComponent, _groundEffect) == 0x0000C0, "Member 'UCustomBulletDecalComponent::_groundEffect' has a wrong offset!");
static_assert(offsetof(UCustomBulletDecalComponent, _decal) == 0x0000C8, "Member 'UCustomBulletDecalComponent::_decal' has a wrong offset!");
static_assert(offsetof(UCustomBulletDecalComponent, _groundParticleLimitAngle) == 0x0000D8, "Member 'UCustomBulletDecalComponent::_groundParticleLimitAngle' has a wrong offset!");
static_assert(offsetof(UCustomBulletDecalComponent, _groundPSC) == 0x0000E0, "Member 'UCustomBulletDecalComponent::_groundPSC' has a wrong offset!");

// Class InGameModule.AN_PlayVoice
// 0x0058 (0x0098 - 0x0040)
class UAN_PlayVoice final : public UAN_CharacterBase
{
public:
	class FString                                 _voiceName;                                        // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllMember;                                        // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _voiceNameAir;                                     // 0x0058(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _voiceNameCharge;                                  // 0x0068(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bDamageVoice;                                     // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bLipSync;                                         // 0x0079(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _WomanVoiceName;                                   // 0x0080(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAvatarVoiceType                              _avatarVoice;                                      // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_PlayVoice">();
	}
	static class UAN_PlayVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_PlayVoice>();
	}
};
static_assert(alignof(UAN_PlayVoice) == 0x000008, "Wrong alignment on UAN_PlayVoice");
static_assert(sizeof(UAN_PlayVoice) == 0x000098, "Wrong size on UAN_PlayVoice");
static_assert(offsetof(UAN_PlayVoice, _voiceName) == 0x000040, "Member 'UAN_PlayVoice::_voiceName' has a wrong offset!");
static_assert(offsetof(UAN_PlayVoice, bAllMember) == 0x000050, "Member 'UAN_PlayVoice::bAllMember' has a wrong offset!");
static_assert(offsetof(UAN_PlayVoice, _voiceNameAir) == 0x000058, "Member 'UAN_PlayVoice::_voiceNameAir' has a wrong offset!");
static_assert(offsetof(UAN_PlayVoice, _voiceNameCharge) == 0x000068, "Member 'UAN_PlayVoice::_voiceNameCharge' has a wrong offset!");
static_assert(offsetof(UAN_PlayVoice, _bDamageVoice) == 0x000078, "Member 'UAN_PlayVoice::_bDamageVoice' has a wrong offset!");
static_assert(offsetof(UAN_PlayVoice, _bLipSync) == 0x000079, "Member 'UAN_PlayVoice::_bLipSync' has a wrong offset!");
static_assert(offsetof(UAN_PlayVoice, _WomanVoiceName) == 0x000080, "Member 'UAN_PlayVoice::_WomanVoiceName' has a wrong offset!");
static_assert(offsetof(UAN_PlayVoice, _avatarVoice) == 0x000090, "Member 'UAN_PlayVoice::_avatarVoice' has a wrong offset!");

// Class InGameModule.CharacterConditionControlComponent
// 0x0038 (0x00F0 - 0x00B8)
class UCharacterConditionControlComponent final : public UCharacterBattleComponentBase
{
public:
	struct FNetworkCharacterConditionData         _serverCharacterConditionData;                     // 0x00B8(0x0018)(NativeAccessSpecifierPrivate)
	struct FNetworkCharacterConditionData         _keepCharacterConditionData;                       // 0x00D0(0x0018)(NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _instigatedPlayerInfection;                        // 0x00E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_ClearCondition(ECharacterConditionId ID);
	void BP_ClearConditionAll_Local();
	void BP_SetCondition(ECharacterConditionId ID, int32 Level, float Span, float Value, float Interval, int32 SubLevel, class APlayerStateBattle* InstigatedPlayer);
	void BP_SetConditionLocal(ECharacterConditionId ID, int32 Level, float Span, float Value, float Interval, int32 SubLevel, class APlayerStateBattle* InstigatedPlayer);
	void BP_SetInstigatedPlayerInfection(class APlayerStateBattle* InstigatedPlayer);
	void ClearCondition_NetMulticast(ECharacterConditionId ID);
	void ClearCondition_ToServer(ECharacterConditionId ID);
	void SetCondition_NetMulticast(ECharacterConditionId ID, int32 Level, float Span, float Value, float Interval, int32 SubLevel, bool bApplyAutonomousProxy, class APlayerStateBattle* InstigatedPlayer);
	void SetCondition_ToServer(ECharacterConditionId ID, int32 Level, float Span, float Value, float Interval, int32 SubLevel, bool bApplyAutonomousProxy, class APlayerStateBattle* InstigatedPlayer);

	bool BP_IsValidCondition(ECharacterConditionId ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterConditionControlComponent">();
	}
	static class UCharacterConditionControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterConditionControlComponent>();
	}
};
static_assert(alignof(UCharacterConditionControlComponent) == 0x000008, "Wrong alignment on UCharacterConditionControlComponent");
static_assert(sizeof(UCharacterConditionControlComponent) == 0x0000F0, "Wrong size on UCharacterConditionControlComponent");
static_assert(offsetof(UCharacterConditionControlComponent, _serverCharacterConditionData) == 0x0000B8, "Member 'UCharacterConditionControlComponent::_serverCharacterConditionData' has a wrong offset!");
static_assert(offsetof(UCharacterConditionControlComponent, _keepCharacterConditionData) == 0x0000D0, "Member 'UCharacterConditionControlComponent::_keepCharacterConditionData' has a wrong offset!");
static_assert(offsetof(UCharacterConditionControlComponent, _instigatedPlayerInfection) == 0x0000E8, "Member 'UCharacterConditionControlComponent::_instigatedPlayerInfection' has a wrong offset!");

// Class InGameModule.AN_ReturnToNormal
// 0x0000 (0x0040 - 0x0040)
class UAN_ReturnToNormal final : public UAN_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_ReturnToNormal">();
	}
	static class UAN_ReturnToNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_ReturnToNormal>();
	}
};
static_assert(alignof(UAN_ReturnToNormal) == 0x000008, "Wrong alignment on UAN_ReturnToNormal");
static_assert(sizeof(UAN_ReturnToNormal) == 0x000040, "Wrong size on UAN_ReturnToNormal");

// Class InGameModule.AN_SetEnableAttackLanding
// 0x0008 (0x0048 - 0x0040)
class UAN_SetEnableAttackLanding final : public UAN_BattleBase
{
public:
	bool                                          _flag;                                             // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_SetEnableAttackLanding">();
	}
	static class UAN_SetEnableAttackLanding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_SetEnableAttackLanding>();
	}
};
static_assert(alignof(UAN_SetEnableAttackLanding) == 0x000008, "Wrong alignment on UAN_SetEnableAttackLanding");
static_assert(sizeof(UAN_SetEnableAttackLanding) == 0x000048, "Wrong size on UAN_SetEnableAttackLanding");
static_assert(offsetof(UAN_SetEnableAttackLanding, _flag) == 0x000040, "Member 'UAN_SetEnableAttackLanding::_flag' has a wrong offset!");

// Class InGameModule.AN_SetGrabDamage
// 0x0008 (0x0048 - 0x0040)
class UAN_SetGrabDamage final : public UAN_BattleBase
{
public:
	class FName                                   _damageParamName;                                  // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_SetGrabDamage">();
	}
	static class UAN_SetGrabDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_SetGrabDamage>();
	}
};
static_assert(alignof(UAN_SetGrabDamage) == 0x000008, "Wrong alignment on UAN_SetGrabDamage");
static_assert(sizeof(UAN_SetGrabDamage) == 0x000048, "Wrong size on UAN_SetGrabDamage");
static_assert(offsetof(UAN_SetGrabDamage, _damageParamName) == 0x000040, "Member 'UAN_SetGrabDamage::_damageParamName' has a wrong offset!");

// Class InGameModule.CustomNavLinkProxy
// 0x0018 (0x0288 - 0x0270)
class ACustomNavLinkProxy : public ANavLinkProxy
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       _startEditorComp;                                  // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _endEditorComp;                                    // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomNavLinkProxy">();
	}
	static class ACustomNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomNavLinkProxy>();
	}
};
static_assert(alignof(ACustomNavLinkProxy) == 0x000008, "Wrong alignment on ACustomNavLinkProxy");
static_assert(sizeof(ACustomNavLinkProxy) == 0x000288, "Wrong size on ACustomNavLinkProxy");
static_assert(offsetof(ACustomNavLinkProxy, _startEditorComp) == 0x000278, "Member 'ACustomNavLinkProxy::_startEditorComp' has a wrong offset!");
static_assert(offsetof(ACustomNavLinkProxy, _endEditorComp) == 0x000280, "Member 'ACustomNavLinkProxy::_endEditorComp' has a wrong offset!");

// Class InGameModule.AN_SetGrabInfo
// 0x0018 (0x0058 - 0x0040)
class UAN_SetGrabInfo final : public UAN_BattleBase
{
public:
	class FName                                   _grabJointName;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _grabbedJointName;                                 // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationId                                  _grabbedAnimationId;                               // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_SetGrabInfo">();
	}
	static class UAN_SetGrabInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_SetGrabInfo>();
	}
};
static_assert(alignof(UAN_SetGrabInfo) == 0x000008, "Wrong alignment on UAN_SetGrabInfo");
static_assert(sizeof(UAN_SetGrabInfo) == 0x000058, "Wrong size on UAN_SetGrabInfo");
static_assert(offsetof(UAN_SetGrabInfo, _grabJointName) == 0x000040, "Member 'UAN_SetGrabInfo::_grabJointName' has a wrong offset!");
static_assert(offsetof(UAN_SetGrabInfo, _grabbedJointName) == 0x000048, "Member 'UAN_SetGrabInfo::_grabbedJointName' has a wrong offset!");
static_assert(offsetof(UAN_SetGrabInfo, _grabbedAnimationId) == 0x000050, "Member 'UAN_SetGrabInfo::_grabbedAnimationId' has a wrong offset!");

// Class InGameModule.DurableBulletComponent
// 0x0070 (0x0120 - 0x00B0)
class UDurableBulletComponent final : public UCustomBulletComponentBase
{
public:
	TArray<struct FDurableBulletInfo>             _declineList;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          _bUseHItMark;                                      // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurfaceType                                  _surface;                                          // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _soundAtomCueName;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectSize                                   _objectSize;                                       // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bNoDamageCalc;                                    // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _friendryFireDamage;                               // 0x00DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _friendryFireThrow;                                // 0x00DE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectivityHit;                                   // 0x00DF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectivityAngle;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UQuakeComponent*>                _quakeComponents;                                  // 0x00E8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _onDamageReceivedWithValue;                        // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DamageEventWithValue__DelegateSignature(class UPrimitiveComponent* HitComponent, float DamageAmount, EHitMarkType HitMarkType, const struct FHitResult& HitResult, bool IsMeleeAttack);
	float GetHp();
	void ReduceHp(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DurableBulletComponent">();
	}
	static class UDurableBulletComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDurableBulletComponent>();
	}
};
static_assert(alignof(UDurableBulletComponent) == 0x000008, "Wrong alignment on UDurableBulletComponent");
static_assert(sizeof(UDurableBulletComponent) == 0x000120, "Wrong size on UDurableBulletComponent");
static_assert(offsetof(UDurableBulletComponent, _declineList) == 0x0000B0, "Member 'UDurableBulletComponent::_declineList' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _bUseHItMark) == 0x0000C0, "Member 'UDurableBulletComponent::_bUseHItMark' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _surface) == 0x0000C1, "Member 'UDurableBulletComponent::_surface' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _soundAtomCueName) == 0x0000C8, "Member 'UDurableBulletComponent::_soundAtomCueName' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _objectSize) == 0x0000D8, "Member 'UDurableBulletComponent::_objectSize' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _bNoDamageCalc) == 0x0000DC, "Member 'UDurableBulletComponent::_bNoDamageCalc' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _friendryFireDamage) == 0x0000DD, "Member 'UDurableBulletComponent::_friendryFireDamage' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _friendryFireThrow) == 0x0000DE, "Member 'UDurableBulletComponent::_friendryFireThrow' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, bDirectivityHit) == 0x0000DF, "Member 'UDurableBulletComponent::bDirectivityHit' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, DirectivityAngle) == 0x0000E0, "Member 'UDurableBulletComponent::DirectivityAngle' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _quakeComponents) == 0x0000E8, "Member 'UDurableBulletComponent::_quakeComponents' has a wrong offset!");
static_assert(offsetof(UDurableBulletComponent, _onDamageReceivedWithValue) == 0x000110, "Member 'UDurableBulletComponent::_onDamageReceivedWithValue' has a wrong offset!");

// Class InGameModule.AN_SetGravity
// 0x0008 (0x0048 - 0x0040)
class UAN_SetGravity final : public UAN_BattleBase
{
public:
	bool                                          _flag;                                             // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_SetGravity">();
	}
	static class UAN_SetGravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_SetGravity>();
	}
};
static_assert(alignof(UAN_SetGravity) == 0x000008, "Wrong alignment on UAN_SetGravity");
static_assert(sizeof(UAN_SetGravity) == 0x000048, "Wrong size on UAN_SetGravity");
static_assert(offsetof(UAN_SetGravity, _flag) == 0x000040, "Member 'UAN_SetGravity::_flag' has a wrong offset!");

// Class InGameModule.AN_SetOnGround
// 0x0008 (0x0048 - 0x0040)
class UAN_SetOnGround final : public UAN_BattleBase
{
public:
	bool                                          _flag;                                             // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_SetOnGround">();
	}
	static class UAN_SetOnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_SetOnGround>();
	}
};
static_assert(alignof(UAN_SetOnGround) == 0x000008, "Wrong alignment on UAN_SetOnGround");
static_assert(sizeof(UAN_SetOnGround) == 0x000048, "Wrong size on UAN_SetOnGround");
static_assert(offsetof(UAN_SetOnGround, _flag) == 0x000040, "Member 'UAN_SetOnGround::_flag' has a wrong offset!");

// Class InGameModule.StageSpawnPointBase
// 0x0008 (0x0228 - 0x0220)
class AStageSpawnPointBase : public AActor
{
public:
	EStageSpawnPointType                          _type;                                             // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStageSpawnPointSRT                           _SRT;                                              // 0x0221(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_222[0x2];                                      // 0x0222(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _group;                                            // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageSpawnPointBase">();
	}
	static class AStageSpawnPointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageSpawnPointBase>();
	}
};
static_assert(alignof(AStageSpawnPointBase) == 0x000008, "Wrong alignment on AStageSpawnPointBase");
static_assert(sizeof(AStageSpawnPointBase) == 0x000228, "Wrong size on AStageSpawnPointBase");
static_assert(offsetof(AStageSpawnPointBase, _type) == 0x000220, "Member 'AStageSpawnPointBase::_type' has a wrong offset!");
static_assert(offsetof(AStageSpawnPointBase, _SRT) == 0x000221, "Member 'AStageSpawnPointBase::_SRT' has a wrong offset!");
static_assert(offsetof(AStageSpawnPointBase, _group) == 0x000224, "Member 'AStageSpawnPointBase::_group' has a wrong offset!");

// Class InGameModule.GimmickSpawnPoint
// 0x0008 (0x0230 - 0x0228)
class AGimmickSpawnPoint final : public AStageSpawnPointBase
{
public:
	EGimmickCode                                  _gimmickCode;                                      // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bAlwaysSpawn;                                     // 0x0229(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22A[0x6];                                      // 0x022A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_SetGimmickCode(EGimmickCode Code);

	bool BP_GetAlwaysSpawnFlag() const;
	EGimmickCode BP_GetGimmickCode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickSpawnPoint">();
	}
	static class AGimmickSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickSpawnPoint>();
	}
};
static_assert(alignof(AGimmickSpawnPoint) == 0x000008, "Wrong alignment on AGimmickSpawnPoint");
static_assert(sizeof(AGimmickSpawnPoint) == 0x000230, "Wrong size on AGimmickSpawnPoint");
static_assert(offsetof(AGimmickSpawnPoint, _gimmickCode) == 0x000228, "Member 'AGimmickSpawnPoint::_gimmickCode' has a wrong offset!");
static_assert(offsetof(AGimmickSpawnPoint, _bAlwaysSpawn) == 0x000229, "Member 'AGimmickSpawnPoint::_bAlwaysSpawn' has a wrong offset!");

// Class InGameModule.AN_SetRootMotionScale
// 0x0008 (0x0048 - 0x0040)
class UAN_SetRootMotionScale final : public UAN_BattleBase
{
public:
	float                                         _scale;                                            // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_SetRootMotionScale">();
	}
	static class UAN_SetRootMotionScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_SetRootMotionScale>();
	}
};
static_assert(alignof(UAN_SetRootMotionScale) == 0x000008, "Wrong alignment on UAN_SetRootMotionScale");
static_assert(sizeof(UAN_SetRootMotionScale) == 0x000048, "Wrong size on UAN_SetRootMotionScale");
static_assert(offsetof(UAN_SetRootMotionScale, _scale) == 0x000040, "Member 'UAN_SetRootMotionScale::_scale' has a wrong offset!");

// Class InGameModule.AN_SetVisiblityAddParts
// 0x0010 (0x0050 - 0x0040)
class UAN_SetVisiblityAddParts final : public UAN_BattleBase
{
public:
	bool                                          _bVisiblity;                                       // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _key;                                              // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_SetVisiblityAddParts">();
	}
	static class UAN_SetVisiblityAddParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_SetVisiblityAddParts>();
	}
};
static_assert(alignof(UAN_SetVisiblityAddParts) == 0x000008, "Wrong alignment on UAN_SetVisiblityAddParts");
static_assert(sizeof(UAN_SetVisiblityAddParts) == 0x000050, "Wrong size on UAN_SetVisiblityAddParts");
static_assert(offsetof(UAN_SetVisiblityAddParts, _bVisiblity) == 0x000040, "Member 'UAN_SetVisiblityAddParts::_bVisiblity' has a wrong offset!");
static_assert(offsetof(UAN_SetVisiblityAddParts, _key) == 0x000044, "Member 'UAN_SetVisiblityAddParts::_key' has a wrong offset!");

// Class InGameModule.GameRuleWidget
// 0x0020 (0x0370 - 0x0350)
class UGameRuleWidget final : public UWidgetBase
{
public:
	class UTextBlock*                             _gameRuleText;                                     // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _offsetPlayTime;                                   // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _showGameRuleTime;                                 // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayInAnime();
	void PlayOutAnime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameRuleWidget">();
	}
	static class UGameRuleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameRuleWidget>();
	}
};
static_assert(alignof(UGameRuleWidget) == 0x000008, "Wrong alignment on UGameRuleWidget");
static_assert(sizeof(UGameRuleWidget) == 0x000370, "Wrong size on UGameRuleWidget");
static_assert(offsetof(UGameRuleWidget, _gameRuleText) == 0x000350, "Member 'UGameRuleWidget::_gameRuleText' has a wrong offset!");
static_assert(offsetof(UGameRuleWidget, _offsetPlayTime) == 0x000368, "Member 'UGameRuleWidget::_offsetPlayTime' has a wrong offset!");
static_assert(offsetof(UGameRuleWidget, _showGameRuleTime) == 0x00036C, "Member 'UGameRuleWidget::_showGameRuleTime' has a wrong offset!");

// Class InGameModule.AN_StopEffect
// 0x0000 (0x0040 - 0x0040)
class UAN_StopEffect final : public UAN_CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_StopEffect">();
	}
	static class UAN_StopEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_StopEffect>();
	}
};
static_assert(alignof(UAN_StopEffect) == 0x000008, "Wrong alignment on UAN_StopEffect");
static_assert(sizeof(UAN_StopEffect) == 0x000040, "Wrong size on UAN_StopEffect");

// Class InGameModule.AnimInstanceCitizen
// 0x0000 (0x0460 - 0x0460)
class UAnimInstanceCitizen final : public UAnimInstanceGame
{
public:
	ENPCCitizenState                              State;                                             // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEscape;                                           // 0x0459(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45A[0x6];                                      // 0x045A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceCitizen">();
	}
	static class UAnimInstanceCitizen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceCitizen>();
	}
};
static_assert(alignof(UAnimInstanceCitizen) == 0x000010, "Wrong alignment on UAnimInstanceCitizen");
static_assert(sizeof(UAnimInstanceCitizen) == 0x000460, "Wrong size on UAnimInstanceCitizen");
static_assert(offsetof(UAnimInstanceCitizen, State) == 0x000458, "Member 'UAnimInstanceCitizen::State' has a wrong offset!");
static_assert(offsetof(UAnimInstanceCitizen, bEscape) == 0x000459, "Member 'UAnimInstanceCitizen::bEscape' has a wrong offset!");

// Class InGameModule.GroundElementDecal
// 0x0030 (0x02B0 - 0x0280)
class AGroundElementDecal : public AHeroDecalActor
{
public:
	class UMaterialCurveControl*                  _materialCurveCtrlTbl;                             // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             _decalTbl;                                         // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomZRot;                                       // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroundElementType                            _surface;                                          // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _mid;                                              // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundElementDecal">();
	}
	static class AGroundElementDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGroundElementDecal>();
	}
};
static_assert(alignof(AGroundElementDecal) == 0x000008, "Wrong alignment on AGroundElementDecal");
static_assert(sizeof(AGroundElementDecal) == 0x0002B0, "Wrong size on AGroundElementDecal");
static_assert(offsetof(AGroundElementDecal, _materialCurveCtrlTbl) == 0x000280, "Member 'AGroundElementDecal::_materialCurveCtrlTbl' has a wrong offset!");
static_assert(offsetof(AGroundElementDecal, _decalTbl) == 0x000288, "Member 'AGroundElementDecal::_decalTbl' has a wrong offset!");
static_assert(offsetof(AGroundElementDecal, _randomZRot) == 0x000290, "Member 'AGroundElementDecal::_randomZRot' has a wrong offset!");
static_assert(offsetof(AGroundElementDecal, _surface) == 0x000294, "Member 'AGroundElementDecal::_surface' has a wrong offset!");
static_assert(offsetof(AGroundElementDecal, _mid) == 0x000298, "Member 'AGroundElementDecal::_mid' has a wrong offset!");

// Class InGameModule.AnnounceWidget
// 0x00F0 (0x0440 - 0x0350)
class UAnnounceWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             _message;                                          // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x30];                                     // 0x0360(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EImportance, struct FSlateFontInfo>      _fontOnImportance;                                 // 0x0390(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<EImportance, struct FSlateColor>         _fontColorOnImportance;                            // 0x03E0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_MessageStart;                                  // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CollapseThis();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnnounceWidget">();
	}
	static class UAnnounceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnnounceWidget>();
	}
};
static_assert(alignof(UAnnounceWidget) == 0x000008, "Wrong alignment on UAnnounceWidget");
static_assert(sizeof(UAnnounceWidget) == 0x000440, "Wrong size on UAnnounceWidget");
static_assert(offsetof(UAnnounceWidget, _message) == 0x000358, "Member 'UAnnounceWidget::_message' has a wrong offset!");
static_assert(offsetof(UAnnounceWidget, _fontOnImportance) == 0x000390, "Member 'UAnnounceWidget::_fontOnImportance' has a wrong offset!");
static_assert(offsetof(UAnnounceWidget, _fontColorOnImportance) == 0x0003E0, "Member 'UAnnounceWidget::_fontColorOnImportance' has a wrong offset!");
static_assert(offsetof(UAnnounceWidget, Ani_MessageStart) == 0x000430, "Member 'UAnnounceWidget::Ani_MessageStart' has a wrong offset!");

// Class InGameModule.ANS_ActionCameraBeginBattle
// 0x0040 (0x0650 - 0x0610)
class UANS_ActionCameraBeginBattle final : public UANS_ActionCameraBegin
{
public:
	TArray<EAttackVisualLevel>                    _visualLevel;                                      // 0x0610(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          _bHitAttack;                                       // 0x0620(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x3];                                      // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _endDistance;                                      // 0x0624(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bRotationToTargetOnEnd;                           // 0x0628(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bLeverCancel;                                     // 0x0629(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableCheckBlocking;                             // 0x062A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62B[0x5];                                      // 0x062B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _tag;                                              // 0x0630(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _startTag;                                         // 0x0640(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_ActionCameraBeginBattle">();
	}
	static class UANS_ActionCameraBeginBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_ActionCameraBeginBattle>();
	}
};
static_assert(alignof(UANS_ActionCameraBeginBattle) == 0x000010, "Wrong alignment on UANS_ActionCameraBeginBattle");
static_assert(sizeof(UANS_ActionCameraBeginBattle) == 0x000650, "Wrong size on UANS_ActionCameraBeginBattle");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _visualLevel) == 0x000610, "Member 'UANS_ActionCameraBeginBattle::_visualLevel' has a wrong offset!");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _bHitAttack) == 0x000620, "Member 'UANS_ActionCameraBeginBattle::_bHitAttack' has a wrong offset!");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _endDistance) == 0x000624, "Member 'UANS_ActionCameraBeginBattle::_endDistance' has a wrong offset!");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _bRotationToTargetOnEnd) == 0x000628, "Member 'UANS_ActionCameraBeginBattle::_bRotationToTargetOnEnd' has a wrong offset!");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _bLeverCancel) == 0x000629, "Member 'UANS_ActionCameraBeginBattle::_bLeverCancel' has a wrong offset!");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _bEnableCheckBlocking) == 0x00062A, "Member 'UANS_ActionCameraBeginBattle::_bEnableCheckBlocking' has a wrong offset!");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _tag) == 0x000630, "Member 'UANS_ActionCameraBeginBattle::_tag' has a wrong offset!");
static_assert(offsetof(UANS_ActionCameraBeginBattle, _startTag) == 0x000640, "Member 'UANS_ActionCameraBeginBattle::_startTag' has a wrong offset!");

// Class InGameModule.FootSoundIndicator
// 0x0108 (0x02D0 - 0x01C8)
class UFootSoundIndicator final : public UWidgetDrawPrimitive
{
public:
	class APlayerControllerBattle*                _playerController;                                 // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _indicatorSize;                                    // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _indicatorMaterial;                                // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _footSoundBrush;                                   // 0x01F0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	float                                         _footSoundDetectionRange;                          // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootSoundIndicator">();
	}
	static class UFootSoundIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootSoundIndicator>();
	}
};
static_assert(alignof(UFootSoundIndicator) == 0x000010, "Wrong alignment on UFootSoundIndicator");
static_assert(sizeof(UFootSoundIndicator) == 0x0002D0, "Wrong size on UFootSoundIndicator");
static_assert(offsetof(UFootSoundIndicator, _playerController) == 0x0001C8, "Member 'UFootSoundIndicator::_playerController' has a wrong offset!");
static_assert(offsetof(UFootSoundIndicator, _indicatorSize) == 0x0001E0, "Member 'UFootSoundIndicator::_indicatorSize' has a wrong offset!");
static_assert(offsetof(UFootSoundIndicator, _indicatorMaterial) == 0x0001E8, "Member 'UFootSoundIndicator::_indicatorMaterial' has a wrong offset!");
static_assert(offsetof(UFootSoundIndicator, _footSoundBrush) == 0x0001F0, "Member 'UFootSoundIndicator::_footSoundBrush' has a wrong offset!");
static_assert(offsetof(UFootSoundIndicator, _footSoundDetectionRange) == 0x0002C0, "Member 'UFootSoundIndicator::_footSoundDetectionRange' has a wrong offset!");

// Class InGameModule.ANS_Attack
// 0x00E8 (0x0120 - 0x0038)
class UANS_Attack : public UANS_CharacterBase
{
public:
	class FName                                   _attackParam;                                      // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _overwriteCharaId;                                 // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _overwriteGroup;                                   // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroupLink                                    _groupLink;                                        // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _socketName;                                       // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _attached;                                         // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EANCollisionType                              _colType;                                          // 0x0059(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _radius;                                           // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _height;                                           // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterId, struct FTransform>         _offsetTRSs;                                       // 0x0068(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _damageAttenuation;                                // 0x00B8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _editCharaId;                                      // 0x00C0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, class UPrimitiveComponent*>      _savePrimTbl;                                      // 0x00C8(0x0050)(ExportObject, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _saveEditorPrim;                                   // 0x0118(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_Attack">();
	}
	static class UANS_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_Attack>();
	}
};
static_assert(alignof(UANS_Attack) == 0x000008, "Wrong alignment on UANS_Attack");
static_assert(sizeof(UANS_Attack) == 0x000120, "Wrong size on UANS_Attack");
static_assert(offsetof(UANS_Attack, _attackParam) == 0x000038, "Member 'UANS_Attack::_attackParam' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _overwriteCharaId) == 0x000040, "Member 'UANS_Attack::_overwriteCharaId' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _overwriteGroup) == 0x000044, "Member 'UANS_Attack::_overwriteGroup' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _groupLink) == 0x00004C, "Member 'UANS_Attack::_groupLink' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _socketName) == 0x000050, "Member 'UANS_Attack::_socketName' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _attached) == 0x000058, "Member 'UANS_Attack::_attached' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _colType) == 0x000059, "Member 'UANS_Attack::_colType' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _radius) == 0x00005C, "Member 'UANS_Attack::_radius' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _height) == 0x000060, "Member 'UANS_Attack::_height' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _offsetTRSs) == 0x000068, "Member 'UANS_Attack::_offsetTRSs' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _damageAttenuation) == 0x0000B8, "Member 'UANS_Attack::_damageAttenuation' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _editCharaId) == 0x0000C0, "Member 'UANS_Attack::_editCharaId' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _savePrimTbl) == 0x0000C8, "Member 'UANS_Attack::_savePrimTbl' has a wrong offset!");
static_assert(offsetof(UANS_Attack, _saveEditorPrim) == 0x000118, "Member 'UANS_Attack::_saveEditorPrim' has a wrong offset!");

// Class InGameModule.ANS_BattleBase
// 0x0000 (0x0038 - 0x0038)
class UANS_BattleBase : public UANS_CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_BattleBase">();
	}
	static class UANS_BattleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_BattleBase>();
	}
};
static_assert(alignof(UANS_BattleBase) == 0x000008, "Wrong alignment on UANS_BattleBase");
static_assert(sizeof(UANS_BattleBase) == 0x000038, "Wrong size on UANS_BattleBase");

// Class InGameModule.HairMeshComponent
// 0x00E0 (0x08E0 - 0x0800)
class UHairMeshComponent final : public UPoseableMeshComponent
{
public:
	uint8                                         Pad_800[0xA0];                                     // 0x0800(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNode>                          _nodes;                                            // 0x08A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    _baseCol;                                          // 0x08B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B8[0x28];                                     // 0x08B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HairMeshComponent">();
	}
	static class UHairMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHairMeshComponent>();
	}
};
static_assert(alignof(UHairMeshComponent) == 0x000010, "Wrong alignment on UHairMeshComponent");
static_assert(sizeof(UHairMeshComponent) == 0x0008E0, "Wrong size on UHairMeshComponent");
static_assert(offsetof(UHairMeshComponent, _nodes) == 0x0008A0, "Member 'UHairMeshComponent::_nodes' has a wrong offset!");
static_assert(offsetof(UHairMeshComponent, _baseCol) == 0x0008B0, "Member 'UHairMeshComponent::_baseCol' has a wrong offset!");

// Class InGameModule.ANS_AttackAnimSpeed
// 0x0010 (0x0048 - 0x0038)
class UANS_AttackAnimSpeed final : public UANS_BattleBase
{
public:
	float                                         _defaultRate;                                      // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bNagara;                                          // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackAnimationEventId                       _eventId;                                          // 0x003D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _defaultRateGiant;                                 // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_AttackAnimSpeed">();
	}
	static class UANS_AttackAnimSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_AttackAnimSpeed>();
	}
};
static_assert(alignof(UANS_AttackAnimSpeed) == 0x000008, "Wrong alignment on UANS_AttackAnimSpeed");
static_assert(sizeof(UANS_AttackAnimSpeed) == 0x000048, "Wrong size on UANS_AttackAnimSpeed");
static_assert(offsetof(UANS_AttackAnimSpeed, _defaultRate) == 0x000038, "Member 'UANS_AttackAnimSpeed::_defaultRate' has a wrong offset!");
static_assert(offsetof(UANS_AttackAnimSpeed, _bNagara) == 0x00003C, "Member 'UANS_AttackAnimSpeed::_bNagara' has a wrong offset!");
static_assert(offsetof(UANS_AttackAnimSpeed, _eventId) == 0x00003D, "Member 'UANS_AttackAnimSpeed::_eventId' has a wrong offset!");
static_assert(offsetof(UANS_AttackAnimSpeed, _defaultRateGiant) == 0x000040, "Member 'UANS_AttackAnimSpeed::_defaultRateGiant' has a wrong offset!");

// Class InGameModule.ANS_AttackChase
// 0x0048 (0x0080 - 0x0038)
class UANS_AttackChase final : public UANS_BattleBase
{
public:
	bool                                          _enableSetSpeed;                                   // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _initialSpeed;                                     // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lastSpeed;                                        // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _speedSpan;                                        // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _endDistance;                                      // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _addTargetOffset;                                  // 0x004C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnTime;                                         // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnRate;                                         // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _turnEasing;                                       // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _alwaysSetSpeed;                                   // 0x0061(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _clearSpeedAsEnd;                                  // 0x0062(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ignorePassing;                                    // 0x0063(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inertiaRate;                                      // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inertiaSpan;                                      // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _targetDirectionTo2D;                              // 0x006C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableUpDirectionChase;                          // 0x006D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _enablePitchRotation;                              // 0x006E(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pitchRotationSpan;                                // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionAxis                                   _pitchTargetAxis;                                  // 0x0074(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pitchRotationRate;                                // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _pitchRotationMaxDegreesPerFrame;                  // 0x007C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_AttackChase">();
	}
	static class UANS_AttackChase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_AttackChase>();
	}
};
static_assert(alignof(UANS_AttackChase) == 0x000008, "Wrong alignment on UANS_AttackChase");
static_assert(sizeof(UANS_AttackChase) == 0x000080, "Wrong size on UANS_AttackChase");
static_assert(offsetof(UANS_AttackChase, _enableSetSpeed) == 0x000038, "Member 'UANS_AttackChase::_enableSetSpeed' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _initialSpeed) == 0x00003C, "Member 'UANS_AttackChase::_initialSpeed' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _lastSpeed) == 0x000040, "Member 'UANS_AttackChase::_lastSpeed' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _speedSpan) == 0x000044, "Member 'UANS_AttackChase::_speedSpan' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _endDistance) == 0x000048, "Member 'UANS_AttackChase::_endDistance' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _addTargetOffset) == 0x00004C, "Member 'UANS_AttackChase::_addTargetOffset' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _turnTime) == 0x000058, "Member 'UANS_AttackChase::_turnTime' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _turnRate) == 0x00005C, "Member 'UANS_AttackChase::_turnRate' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _turnEasing) == 0x000060, "Member 'UANS_AttackChase::_turnEasing' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _alwaysSetSpeed) == 0x000061, "Member 'UANS_AttackChase::_alwaysSetSpeed' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _clearSpeedAsEnd) == 0x000062, "Member 'UANS_AttackChase::_clearSpeedAsEnd' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _ignorePassing) == 0x000063, "Member 'UANS_AttackChase::_ignorePassing' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _inertiaRate) == 0x000064, "Member 'UANS_AttackChase::_inertiaRate' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _inertiaSpan) == 0x000068, "Member 'UANS_AttackChase::_inertiaSpan' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _targetDirectionTo2D) == 0x00006C, "Member 'UANS_AttackChase::_targetDirectionTo2D' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _bEnableUpDirectionChase) == 0x00006D, "Member 'UANS_AttackChase::_bEnableUpDirectionChase' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _enablePitchRotation) == 0x00006E, "Member 'UANS_AttackChase::_enablePitchRotation' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _pitchRotationSpan) == 0x000070, "Member 'UANS_AttackChase::_pitchRotationSpan' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _pitchTargetAxis) == 0x000074, "Member 'UANS_AttackChase::_pitchTargetAxis' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _pitchRotationRate) == 0x000078, "Member 'UANS_AttackChase::_pitchRotationRate' has a wrong offset!");
static_assert(offsetof(UANS_AttackChase, _pitchRotationMaxDegreesPerFrame) == 0x00007C, "Member 'UANS_AttackChase::_pitchRotationMaxDegreesPerFrame' has a wrong offset!");

// Class InGameModule.GameStateBattleFiniteStateBase
// 0x0008 (0x0038 - 0x0030)
class UGameStateBattleFiniteStateBase : public UFiniteState
{
public:
	class AGameStateBattle*                       _ownerGameState;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattleFiniteStateBase">();
	}
	static class UGameStateBattleFiniteStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattleFiniteStateBase>();
	}
};
static_assert(alignof(UGameStateBattleFiniteStateBase) == 0x000008, "Wrong alignment on UGameStateBattleFiniteStateBase");
static_assert(sizeof(UGameStateBattleFiniteStateBase) == 0x000038, "Wrong size on UGameStateBattleFiniteStateBase");
static_assert(offsetof(UGameStateBattleFiniteStateBase, _ownerGameState) == 0x000030, "Member 'UGameStateBattleFiniteStateBase::_ownerGameState' has a wrong offset!");

// Class InGameModule.GameStateBattle_EndCongratulateWinner
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_EndCongratulateWinner final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_EndCongratulateWinner">();
	}
	static class UGameStateBattle_EndCongratulateWinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_EndCongratulateWinner>();
	}
};
static_assert(alignof(UGameStateBattle_EndCongratulateWinner) == 0x000008, "Wrong alignment on UGameStateBattle_EndCongratulateWinner");
static_assert(sizeof(UGameStateBattle_EndCongratulateWinner) == 0x000038, "Wrong size on UGameStateBattle_EndCongratulateWinner");

// Class InGameModule.ANS_AttackComboInputSpan
// 0x0000 (0x0038 - 0x0038)
class UANS_AttackComboInputSpan final : public UANS_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_AttackComboInputSpan">();
	}
	static class UANS_AttackComboInputSpan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_AttackComboInputSpan>();
	}
};
static_assert(alignof(UANS_AttackComboInputSpan) == 0x000008, "Wrong alignment on UANS_AttackComboInputSpan");
static_assert(sizeof(UANS_AttackComboInputSpan) == 0x000038, "Wrong size on UANS_AttackComboInputSpan");

// Class InGameModule.ANS_AttackDedicated
// 0x0010 (0x0130 - 0x0120)
class UANS_AttackDedicated final : public UANS_Attack
{
public:
	TArray<class FName>                           _damageParamNames;                                 // 0x0120(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_AttackDedicated">();
	}
	static class UANS_AttackDedicated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_AttackDedicated>();
	}
};
static_assert(alignof(UANS_AttackDedicated) == 0x000008, "Wrong alignment on UANS_AttackDedicated");
static_assert(sizeof(UANS_AttackDedicated) == 0x000130, "Wrong size on UANS_AttackDedicated");
static_assert(offsetof(UANS_AttackDedicated, _damageParamNames) == 0x000120, "Member 'UANS_AttackDedicated::_damageParamNames' has a wrong offset!");

// Class InGameModule.HeroMeshComponent
// 0x0210 (0x06F0 - 0x04E0)
class UHeroMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _gameMesh;                                         // 0x04E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroShapeImpl                         _impl;                                             // 0x04F0(0x0200)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroMeshComponent">();
	}
	static class UHeroMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroMeshComponent>();
	}
};
static_assert(alignof(UHeroMeshComponent) == 0x000010, "Wrong alignment on UHeroMeshComponent");
static_assert(sizeof(UHeroMeshComponent) == 0x0006F0, "Wrong size on UHeroMeshComponent");
static_assert(offsetof(UHeroMeshComponent, _gameMesh) == 0x0004E8, "Member 'UHeroMeshComponent::_gameMesh' has a wrong offset!");
static_assert(offsetof(UHeroMeshComponent, _impl) == 0x0004F0, "Member 'UHeroMeshComponent::_impl' has a wrong offset!");

// Class InGameModule.ANS_AttackTurnToCamera
// 0x0020 (0x0058 - 0x0038)
class UANS_AttackTurnToCamera final : public UANS_BattleBase
{
public:
	bool                                          _ignoreZ;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ignoreMovementDirection;                          // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _turnTime;                                         // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnRate;                                         // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _turnEasing;                                       // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _chargeAttackOnly;                                 // 0x0045(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _enablePitchRotation;                              // 0x0046(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pitchRotationSpan;                                // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionAxis                                   _pitchTargetAxis;                                  // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pitchRotationRate;                                // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _pitchRotationMaxDegreesPerFrame;                  // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_AttackTurnToCamera">();
	}
	static class UANS_AttackTurnToCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_AttackTurnToCamera>();
	}
};
static_assert(alignof(UANS_AttackTurnToCamera) == 0x000008, "Wrong alignment on UANS_AttackTurnToCamera");
static_assert(sizeof(UANS_AttackTurnToCamera) == 0x000058, "Wrong size on UANS_AttackTurnToCamera");
static_assert(offsetof(UANS_AttackTurnToCamera, _ignoreZ) == 0x000038, "Member 'UANS_AttackTurnToCamera::_ignoreZ' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _ignoreMovementDirection) == 0x000039, "Member 'UANS_AttackTurnToCamera::_ignoreMovementDirection' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _turnTime) == 0x00003C, "Member 'UANS_AttackTurnToCamera::_turnTime' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _turnRate) == 0x000040, "Member 'UANS_AttackTurnToCamera::_turnRate' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _turnEasing) == 0x000044, "Member 'UANS_AttackTurnToCamera::_turnEasing' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _chargeAttackOnly) == 0x000045, "Member 'UANS_AttackTurnToCamera::_chargeAttackOnly' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _enablePitchRotation) == 0x000046, "Member 'UANS_AttackTurnToCamera::_enablePitchRotation' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _pitchRotationSpan) == 0x000048, "Member 'UANS_AttackTurnToCamera::_pitchRotationSpan' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _pitchTargetAxis) == 0x00004C, "Member 'UANS_AttackTurnToCamera::_pitchTargetAxis' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _pitchRotationRate) == 0x000050, "Member 'UANS_AttackTurnToCamera::_pitchRotationRate' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToCamera, _pitchRotationMaxDegreesPerFrame) == 0x000054, "Member 'UANS_AttackTurnToCamera::_pitchRotationMaxDegreesPerFrame' has a wrong offset!");

// Class InGameModule.ANS_AttackTurnToLever
// 0x0018 (0x0050 - 0x0038)
class UANS_AttackTurnToLever final : public UANS_BattleBase
{
public:
	bool                                          _ignoreMovementDirection;                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ignoreTurnDirection;                              // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _turnTime;                                         // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnRate;                                         // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _turnEasing;                                       // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _limitDegrees;                                     // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _chargeAttackOnly;                                 // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_AttackTurnToLever">();
	}
	static class UANS_AttackTurnToLever* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_AttackTurnToLever>();
	}
};
static_assert(alignof(UANS_AttackTurnToLever) == 0x000008, "Wrong alignment on UANS_AttackTurnToLever");
static_assert(sizeof(UANS_AttackTurnToLever) == 0x000050, "Wrong size on UANS_AttackTurnToLever");
static_assert(offsetof(UANS_AttackTurnToLever, _ignoreMovementDirection) == 0x000038, "Member 'UANS_AttackTurnToLever::_ignoreMovementDirection' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToLever, _ignoreTurnDirection) == 0x000039, "Member 'UANS_AttackTurnToLever::_ignoreTurnDirection' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToLever, _turnTime) == 0x00003C, "Member 'UANS_AttackTurnToLever::_turnTime' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToLever, _turnRate) == 0x000040, "Member 'UANS_AttackTurnToLever::_turnRate' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToLever, _turnEasing) == 0x000044, "Member 'UANS_AttackTurnToLever::_turnEasing' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToLever, _limitDegrees) == 0x000048, "Member 'UANS_AttackTurnToLever::_limitDegrees' has a wrong offset!");
static_assert(offsetof(UANS_AttackTurnToLever, _chargeAttackOnly) == 0x00004C, "Member 'UANS_AttackTurnToLever::_chargeAttackOnly' has a wrong offset!");

// Class InGameModule.GameModeInGame
// 0x0010 (0x0350 - 0x0340)
class AGameModeInGame : public AHerovsGameMode
{
public:
	class FString                                 _selectedGameMode;                                 // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeInGame">();
	}
	static class AGameModeInGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeInGame>();
	}
};
static_assert(alignof(AGameModeInGame) == 0x000008, "Wrong alignment on AGameModeInGame");
static_assert(sizeof(AGameModeInGame) == 0x000350, "Wrong size on AGameModeInGame");
static_assert(offsetof(AGameModeInGame, _selectedGameMode) == 0x000340, "Member 'AGameModeInGame::_selectedGameMode' has a wrong offset!");

// Class InGameModule.GameModeBattle
// 0x0188 (0x04D8 - 0x0350)
class AGameModeBattle : public AGameModeInGame
{
public:
	class UDataTable*                             _supplyBoxSpawnRateSmall;                          // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _supplyBoxSpawnRateGold;                           // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _supplyBoxSpawnRateLarge;                          // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _NPCSupplySpawnRateHP;                             // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _NPCSupplySpawnRateGP;                             // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UDataTable*>        _supplySpawnPointMap;                              // 0x0378(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<ESupplyBoxSize, TSubclassOf<class ASupplyBox>> _supplyBoxClassMap;                                // 0x03C8(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<float>                                 _nextSpawnTimeArray;                               // 0x0418(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USupplyManagerComponent*                _supplyManagerComponent;                           // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNPCManagerComponent*                   _npcManagerComponent;                              // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AStageManager*                          _stageManager;                                     // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleSequenceComponent*               _sequenceComponent;                                // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x90];                                     // 0x0448(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeBattle">();
	}
	static class AGameModeBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeBattle>();
	}
};
static_assert(alignof(AGameModeBattle) == 0x000008, "Wrong alignment on AGameModeBattle");
static_assert(sizeof(AGameModeBattle) == 0x0004D8, "Wrong size on AGameModeBattle");
static_assert(offsetof(AGameModeBattle, _supplyBoxSpawnRateSmall) == 0x000350, "Member 'AGameModeBattle::_supplyBoxSpawnRateSmall' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _supplyBoxSpawnRateGold) == 0x000358, "Member 'AGameModeBattle::_supplyBoxSpawnRateGold' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _supplyBoxSpawnRateLarge) == 0x000360, "Member 'AGameModeBattle::_supplyBoxSpawnRateLarge' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _NPCSupplySpawnRateHP) == 0x000368, "Member 'AGameModeBattle::_NPCSupplySpawnRateHP' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _NPCSupplySpawnRateGP) == 0x000370, "Member 'AGameModeBattle::_NPCSupplySpawnRateGP' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _supplySpawnPointMap) == 0x000378, "Member 'AGameModeBattle::_supplySpawnPointMap' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _supplyBoxClassMap) == 0x0003C8, "Member 'AGameModeBattle::_supplyBoxClassMap' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _nextSpawnTimeArray) == 0x000418, "Member 'AGameModeBattle::_nextSpawnTimeArray' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _supplyManagerComponent) == 0x000428, "Member 'AGameModeBattle::_supplyManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _npcManagerComponent) == 0x000430, "Member 'AGameModeBattle::_npcManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _stageManager) == 0x000438, "Member 'AGameModeBattle::_stageManager' has a wrong offset!");
static_assert(offsetof(AGameModeBattle, _sequenceComponent) == 0x000440, "Member 'AGameModeBattle::_sequenceComponent' has a wrong offset!");

// Class InGameModule.GameModeSquadDuoBattle
// 0x0000 (0x04D8 - 0x04D8)
class AGameModeSquadDuoBattle final : public AGameModeBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeSquadDuoBattle">();
	}
	static class AGameModeSquadDuoBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeSquadDuoBattle>();
	}
};
static_assert(alignof(AGameModeSquadDuoBattle) == 0x000008, "Wrong alignment on AGameModeSquadDuoBattle");
static_assert(sizeof(AGameModeSquadDuoBattle) == 0x0004D8, "Wrong size on AGameModeSquadDuoBattle");

// Class InGameModule.ANS_CameraOffset
// 0x0028 (0x0060 - 0x0038)
class UANS_CameraOffset final : public UANS_CharacterBase
{
public:
	float                                         _beginBlendTime;                                   // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _endBlendTime;                                     // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _scale;                                            // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _beginEasingType;                                  // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _endEasingType;                                    // 0x0045(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAttackVisualLevel>                    _visualLevel;                                      // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _bCheckDedicatedState;                             // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _bDedicatedStateID;                                // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_CameraOffset">();
	}
	static class UANS_CameraOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_CameraOffset>();
	}
};
static_assert(alignof(UANS_CameraOffset) == 0x000008, "Wrong alignment on UANS_CameraOffset");
static_assert(sizeof(UANS_CameraOffset) == 0x000060, "Wrong size on UANS_CameraOffset");
static_assert(offsetof(UANS_CameraOffset, _beginBlendTime) == 0x000038, "Member 'UANS_CameraOffset::_beginBlendTime' has a wrong offset!");
static_assert(offsetof(UANS_CameraOffset, _endBlendTime) == 0x00003C, "Member 'UANS_CameraOffset::_endBlendTime' has a wrong offset!");
static_assert(offsetof(UANS_CameraOffset, _scale) == 0x000040, "Member 'UANS_CameraOffset::_scale' has a wrong offset!");
static_assert(offsetof(UANS_CameraOffset, _beginEasingType) == 0x000044, "Member 'UANS_CameraOffset::_beginEasingType' has a wrong offset!");
static_assert(offsetof(UANS_CameraOffset, _endEasingType) == 0x000045, "Member 'UANS_CameraOffset::_endEasingType' has a wrong offset!");
static_assert(offsetof(UANS_CameraOffset, _visualLevel) == 0x000048, "Member 'UANS_CameraOffset::_visualLevel' has a wrong offset!");
static_assert(offsetof(UANS_CameraOffset, _bCheckDedicatedState) == 0x000058, "Member 'UANS_CameraOffset::_bCheckDedicatedState' has a wrong offset!");
static_assert(offsetof(UANS_CameraOffset, _bDedicatedStateID) == 0x00005C, "Member 'UANS_CameraOffset::_bDedicatedStateID' has a wrong offset!");

// Class InGameModule.ANS_ControlCharacterEffect
// 0x0058 (0x0090 - 0x0038)
class UANS_ControlCharacterEffect final : public UANS_CharacterBase
{
public:
	TSoftObjectPtr<class UParticleSystem>         _softRefPSTemplate;                                // 0x0038(0x0028)(Edit, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _fadeInOutCurve;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _paramName;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAddPartsParticle*                      _workPSCParts;                                     // 0x0070(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterGame*                         _owner;                                            // 0x0078(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_ControlCharacterEffect">();
	}
	static class UANS_ControlCharacterEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_ControlCharacterEffect>();
	}
};
static_assert(alignof(UANS_ControlCharacterEffect) == 0x000008, "Wrong alignment on UANS_ControlCharacterEffect");
static_assert(sizeof(UANS_ControlCharacterEffect) == 0x000090, "Wrong size on UANS_ControlCharacterEffect");
static_assert(offsetof(UANS_ControlCharacterEffect, _softRefPSTemplate) == 0x000038, "Member 'UANS_ControlCharacterEffect::_softRefPSTemplate' has a wrong offset!");
static_assert(offsetof(UANS_ControlCharacterEffect, _fadeInOutCurve) == 0x000060, "Member 'UANS_ControlCharacterEffect::_fadeInOutCurve' has a wrong offset!");
static_assert(offsetof(UANS_ControlCharacterEffect, _paramName) == 0x000068, "Member 'UANS_ControlCharacterEffect::_paramName' has a wrong offset!");
static_assert(offsetof(UANS_ControlCharacterEffect, _workPSCParts) == 0x000070, "Member 'UANS_ControlCharacterEffect::_workPSCParts' has a wrong offset!");
static_assert(offsetof(UANS_ControlCharacterEffect, _owner) == 0x000078, "Member 'UANS_ControlCharacterEffect::_owner' has a wrong offset!");

// Class InGameModule.Ch017Unique2Base
// 0x0070 (0x1E50 - 0x1DE0)
#pragma pack(push, 0x1)
class alignas(0x10) ACh017Unique2Base : public ABullet
{
public:
	uint8                                         Pad_1DD8[0x18];                                    // 0x1DD8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        _projectileOverlap;                                // 0x1DF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _rayCheckHitActor;                                 // 0x1DF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E00[0x30];                                    // 0x1E00(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         _ignoreClasses;                                    // 0x1E30(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPinnedActorComponent*                  _pinnedActorComponent;                             // 0x1E40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2Base">();
	}
	static class ACh017Unique2Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2Base>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACh017Unique2Base) == 0x000010, "Wrong alignment on ACh017Unique2Base");
static_assert(sizeof(ACh017Unique2Base) == 0x001E50, "Wrong size on ACh017Unique2Base");
static_assert(offsetof(ACh017Unique2Base, _projectileOverlap) == 0x001DF0, "Member 'ACh017Unique2Base::_projectileOverlap' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Base, _rayCheckHitActor) == 0x001DF8, "Member 'ACh017Unique2Base::_rayCheckHitActor' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Base, _ignoreClasses) == 0x001E30, "Member 'ACh017Unique2Base::_ignoreClasses' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Base, _pinnedActorComponent) == 0x001E40, "Member 'ACh017Unique2Base::_pinnedActorComponent' has a wrong offset!");

// Class InGameModule.Ch017Unique2Child
// 0x0070 (0x1EC0 - 0x1E50)
class ACh017Unique2Child : public ACh017Unique2Base
{
public:
	class UCustomParticleSystemComponent*         _fireParticle;                                     // 0x1E48(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomParticleSystemComponent*         _fireParticleEnemy;                                // 0x1E50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomParticleSystemComponent*         _levelPartsParticle;                               // 0x1E58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E60[0x30];                                    // 0x1E60(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _detonateVoice;                                    // 0x1E90(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EB0[0x10];                                    // 0x1EB0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishTrap();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2Child">();
	}
	static class ACh017Unique2Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2Child>();
	}
};
static_assert(alignof(ACh017Unique2Child) == 0x000010, "Wrong alignment on ACh017Unique2Child");
static_assert(sizeof(ACh017Unique2Child) == 0x001EC0, "Wrong size on ACh017Unique2Child");
static_assert(offsetof(ACh017Unique2Child, _fireParticle) == 0x001E48, "Member 'ACh017Unique2Child::_fireParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Child, _fireParticleEnemy) == 0x001E50, "Member 'ACh017Unique2Child::_fireParticleEnemy' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Child, _levelPartsParticle) == 0x001E58, "Member 'ACh017Unique2Child::_levelPartsParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Child, _detonateVoice) == 0x001E90, "Member 'ACh017Unique2Child::_detonateVoice' has a wrong offset!");

// Class InGameModule.ANS_EnableSlowSpanForAction
// 0x0000 (0x0038 - 0x0038)
class UANS_EnableSlowSpanForAction final : public UANS_BattleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_EnableSlowSpanForAction">();
	}
	static class UANS_EnableSlowSpanForAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_EnableSlowSpanForAction>();
	}
};
static_assert(alignof(UANS_EnableSlowSpanForAction) == 0x000008, "Wrong alignment on UANS_EnableSlowSpanForAction");
static_assert(sizeof(UANS_EnableSlowSpanForAction) == 0x000038, "Wrong size on UANS_EnableSlowSpanForAction");

// Class InGameModule.FogShot
// 0x0050 (0x1E30 - 0x1DE0)
class AFogShot final : public ABullet
{
public:
	class UCurveFloat*                            _beginCurve;                                       // 0x1DD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _endCurve;                                         // 0x1DE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _alphaCurveTarget;                                 // 0x1DE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               _psc;                                              // 0x1DF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DF8[0x38];                                    // 0x1DF8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FogShot">();
	}
	static class AFogShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFogShot>();
	}
};
static_assert(alignof(AFogShot) == 0x000010, "Wrong alignment on AFogShot");
static_assert(sizeof(AFogShot) == 0x001E30, "Wrong size on AFogShot");
static_assert(offsetof(AFogShot, _beginCurve) == 0x001DD8, "Member 'AFogShot::_beginCurve' has a wrong offset!");
static_assert(offsetof(AFogShot, _endCurve) == 0x001DE0, "Member 'AFogShot::_endCurve' has a wrong offset!");
static_assert(offsetof(AFogShot, _alphaCurveTarget) == 0x001DE8, "Member 'AFogShot::_alphaCurveTarget' has a wrong offset!");
static_assert(offsetof(AFogShot, _psc) == 0x001DF0, "Member 'AFogShot::_psc' has a wrong offset!");

// Class InGameModule.ANS_FacialAnimation
// 0x0010 (0x0048 - 0x0038)
class UANS_FacialAnimation final : public UANS_CharacterBase
{
public:
	EAnimationId                                  _id;                                               // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blendInTime;                                      // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blendOutTime;                                     // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bContinue;                                        // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_FacialAnimation">();
	}
	static class UANS_FacialAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_FacialAnimation>();
	}
};
static_assert(alignof(UANS_FacialAnimation) == 0x000008, "Wrong alignment on UANS_FacialAnimation");
static_assert(sizeof(UANS_FacialAnimation) == 0x000048, "Wrong size on UANS_FacialAnimation");
static_assert(offsetof(UANS_FacialAnimation, _id) == 0x000038, "Member 'UANS_FacialAnimation::_id' has a wrong offset!");
static_assert(offsetof(UANS_FacialAnimation, _blendInTime) == 0x00003C, "Member 'UANS_FacialAnimation::_blendInTime' has a wrong offset!");
static_assert(offsetof(UANS_FacialAnimation, _blendOutTime) == 0x000040, "Member 'UANS_FacialAnimation::_blendOutTime' has a wrong offset!");
static_assert(offsetof(UANS_FacialAnimation, _bContinue) == 0x000044, "Member 'UANS_FacialAnimation::_bContinue' has a wrong offset!");

// Class InGameModule.GameStateBattle_WaitingCosmosMessage
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_WaitingCosmosMessage final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_WaitingCosmosMessage">();
	}
	static class UGameStateBattle_WaitingCosmosMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_WaitingCosmosMessage>();
	}
};
static_assert(alignof(UGameStateBattle_WaitingCosmosMessage) == 0x000008, "Wrong alignment on UGameStateBattle_WaitingCosmosMessage");
static_assert(sizeof(UGameStateBattle_WaitingCosmosMessage) == 0x000038, "Wrong size on UGameStateBattle_WaitingCosmosMessage");

// Class InGameModule.ANS_FacialBlendOff
// 0x0000 (0x0038 - 0x0038)
class UANS_FacialBlendOff final : public UANS_CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_FacialBlendOff">();
	}
	static class UANS_FacialBlendOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_FacialBlendOff>();
	}
};
static_assert(alignof(UANS_FacialBlendOff) == 0x000008, "Wrong alignment on UANS_FacialBlendOff");
static_assert(sizeof(UANS_FacialBlendOff) == 0x000038, "Wrong size on UANS_FacialBlendOff");

// Class InGameModule.ANS_PlayCatchedEffect
// 0x0050 (0x0088 - 0x0038)
class UANS_PlayCatchedEffect final : public UANS_BattleBase
{
public:
	TMap<ECharacterId, struct FPlayEffectOffset>  _offsets;                                          // 0x0038(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_PlayCatchedEffect">();
	}
	static class UANS_PlayCatchedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_PlayCatchedEffect>();
	}
};
static_assert(alignof(UANS_PlayCatchedEffect) == 0x000008, "Wrong alignment on UANS_PlayCatchedEffect");
static_assert(sizeof(UANS_PlayCatchedEffect) == 0x000088, "Wrong size on UANS_PlayCatchedEffect");
static_assert(offsetof(UANS_PlayCatchedEffect, _offsets) == 0x000038, "Member 'UANS_PlayCatchedEffect::_offsets' has a wrong offset!");

// Class InGameModule.Ch017Unique3_Var1Gen
// 0x0000 (0x0450 - 0x0450)
class ACh017Unique3_Var1Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique3_Var1Gen">();
	}
	static class ACh017Unique3_Var1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique3_Var1Gen>();
	}
};
static_assert(alignof(ACh017Unique3_Var1Gen) == 0x000010, "Wrong alignment on ACh017Unique3_Var1Gen");
static_assert(sizeof(ACh017Unique3_Var1Gen) == 0x000450, "Wrong size on ACh017Unique3_Var1Gen");

// Class InGameModule.ANS_PlayEffect
// 0x0100 (0x0138 - 0x0038)
class UANS_PlayEffect : public UANS_CharacterBase
{
public:
	EPlayEffectTemplate                           _writeTemplate;                                    // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _PSTemplate;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayEffectNotifyInfo                  _info;                                             // 0x0048(0x00F0)(Edit, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_PlayEffect">();
	}
	static class UANS_PlayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_PlayEffect>();
	}
};
static_assert(alignof(UANS_PlayEffect) == 0x000008, "Wrong alignment on UANS_PlayEffect");
static_assert(sizeof(UANS_PlayEffect) == 0x000138, "Wrong size on UANS_PlayEffect");
static_assert(offsetof(UANS_PlayEffect, _writeTemplate) == 0x000038, "Member 'UANS_PlayEffect::_writeTemplate' has a wrong offset!");
static_assert(offsetof(UANS_PlayEffect, _PSTemplate) == 0x000040, "Member 'UANS_PlayEffect::_PSTemplate' has a wrong offset!");
static_assert(offsetof(UANS_PlayEffect, _info) == 0x000048, "Member 'UANS_PlayEffect::_info' has a wrong offset!");

// Class InGameModule.ANS_PlayEffectMtLady
// 0x0010 (0x0148 - 0x0138)
class UANS_PlayEffectMtLady final : public UANS_PlayEffect
{
public:
	class UParticleSystem*                        _PSTemplateMtLady;                                 // 0x0138(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bGiant;                                           // 0x0140(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_PlayEffectMtLady">();
	}
	static class UANS_PlayEffectMtLady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_PlayEffectMtLady>();
	}
};
static_assert(alignof(UANS_PlayEffectMtLady) == 0x000008, "Wrong alignment on UANS_PlayEffectMtLady");
static_assert(sizeof(UANS_PlayEffectMtLady) == 0x000148, "Wrong size on UANS_PlayEffectMtLady");
static_assert(offsetof(UANS_PlayEffectMtLady, _PSTemplateMtLady) == 0x000138, "Member 'UANS_PlayEffectMtLady::_PSTemplateMtLady' has a wrong offset!");
static_assert(offsetof(UANS_PlayEffectMtLady, _bGiant) == 0x000140, "Member 'UANS_PlayEffectMtLady::_bGiant' has a wrong offset!");

// Class InGameModule.GameStateBattle_AllPlayerDecidedStartPoint
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_AllPlayerDecidedStartPoint final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_AllPlayerDecidedStartPoint">();
	}
	static class UGameStateBattle_AllPlayerDecidedStartPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_AllPlayerDecidedStartPoint>();
	}
};
static_assert(alignof(UGameStateBattle_AllPlayerDecidedStartPoint) == 0x000008, "Wrong alignment on UGameStateBattle_AllPlayerDecidedStartPoint");
static_assert(sizeof(UGameStateBattle_AllPlayerDecidedStartPoint) == 0x000038, "Wrong size on UGameStateBattle_AllPlayerDecidedStartPoint");

// Class InGameModule.ANS_PlayEffectSupply
// 0x0018 (0x0050 - 0x0038)
class UANS_PlayEffectSupply final : public UANS_CharacterBase
{
public:
	class UDataTable*                             _dataTable;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _typeName;                                         // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_PlayEffectSupply">();
	}
	static class UANS_PlayEffectSupply* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_PlayEffectSupply>();
	}
};
static_assert(alignof(UANS_PlayEffectSupply) == 0x000008, "Wrong alignment on UANS_PlayEffectSupply");
static_assert(sizeof(UANS_PlayEffectSupply) == 0x000050, "Wrong size on UANS_PlayEffectSupply");
static_assert(offsetof(UANS_PlayEffectSupply, _dataTable) == 0x000038, "Member 'UANS_PlayEffectSupply::_dataTable' has a wrong offset!");
static_assert(offsetof(UANS_PlayEffectSupply, _typeName) == 0x000040, "Member 'UANS_PlayEffectSupply::_typeName' has a wrong offset!");

// Class InGameModule.ANS_PlayParticleSet
// 0x0168 (0x01A0 - 0x0038)
class UANS_PlayParticleSet : public UANS_CharacterBase
{
public:
	class UDataTable*                             _tbl;                                              // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayEffectNotifyInfo                  _info;                                             // 0x0040(0x00F0)(Edit, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESurfaceType                                  _viewerSurfaveType;                                // 0x0130(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0xF];                                      // 0x0131(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _workTbl;                                          // 0x0140(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<uint32, class UParticleSystem*>          _PSTemplateMap;                                    // 0x0148(0x0050)(BlueprintReadOnly, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_PlayParticleSet">();
	}
	static class UANS_PlayParticleSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_PlayParticleSet>();
	}
};
static_assert(alignof(UANS_PlayParticleSet) == 0x000008, "Wrong alignment on UANS_PlayParticleSet");
static_assert(sizeof(UANS_PlayParticleSet) == 0x0001A0, "Wrong size on UANS_PlayParticleSet");
static_assert(offsetof(UANS_PlayParticleSet, _tbl) == 0x000038, "Member 'UANS_PlayParticleSet::_tbl' has a wrong offset!");
static_assert(offsetof(UANS_PlayParticleSet, _info) == 0x000040, "Member 'UANS_PlayParticleSet::_info' has a wrong offset!");
static_assert(offsetof(UANS_PlayParticleSet, _viewerSurfaveType) == 0x000130, "Member 'UANS_PlayParticleSet::_viewerSurfaveType' has a wrong offset!");
static_assert(offsetof(UANS_PlayParticleSet, _workTbl) == 0x000140, "Member 'UANS_PlayParticleSet::_workTbl' has a wrong offset!");
static_assert(offsetof(UANS_PlayParticleSet, _PSTemplateMap) == 0x000148, "Member 'UANS_PlayParticleSet::_PSTemplateMap' has a wrong offset!");

// Class InGameModule.SalvoBaseGen
// 0x0010 (0x0460 - 0x0450)
class ASalvoBaseGen : public AProjectileGeneratorBattle
{
public:
	TArray<struct FSalvoBulletSetting>            _bulletGenerateSettings;                           // 0x0448(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SalvoBaseGen">();
	}
	static class ASalvoBaseGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASalvoBaseGen>();
	}
};
static_assert(alignof(ASalvoBaseGen) == 0x000010, "Wrong alignment on ASalvoBaseGen");
static_assert(sizeof(ASalvoBaseGen) == 0x000460, "Wrong size on ASalvoBaseGen");
static_assert(offsetof(ASalvoBaseGen, _bulletGenerateSettings) == 0x000448, "Member 'ASalvoBaseGen::_bulletGenerateSettings' has a wrong offset!");

// Class InGameModule.ANS_PlayParticleSetMtLady
// 0x0010 (0x01B0 - 0x01A0)
class UANS_PlayParticleSetMtLady final : public UANS_PlayParticleSet
{
public:
	class UDataTable*                             _tblMtLady;                                        // 0x01A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bGiant;                                           // 0x01A8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_PlayParticleSetMtLady">();
	}
	static class UANS_PlayParticleSetMtLady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_PlayParticleSetMtLady>();
	}
};
static_assert(alignof(UANS_PlayParticleSetMtLady) == 0x000008, "Wrong alignment on UANS_PlayParticleSetMtLady");
static_assert(sizeof(UANS_PlayParticleSetMtLady) == 0x0001B0, "Wrong size on UANS_PlayParticleSetMtLady");
static_assert(offsetof(UANS_PlayParticleSetMtLady, _tblMtLady) == 0x0001A0, "Member 'UANS_PlayParticleSetMtLady::_tblMtLady' has a wrong offset!");
static_assert(offsetof(UANS_PlayParticleSetMtLady, _bGiant) == 0x0001A8, "Member 'UANS_PlayParticleSetMtLady::_bGiant' has a wrong offset!");

// Class InGameModule.GameModeSoloBattle
// 0x0000 (0x04D8 - 0x04D8)
class AGameModeSoloBattle final : public AGameModeBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeSoloBattle">();
	}
	static class AGameModeSoloBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeSoloBattle>();
	}
};
static_assert(alignof(AGameModeSoloBattle) == 0x000008, "Wrong alignment on AGameModeSoloBattle");
static_assert(sizeof(AGameModeSoloBattle) == 0x0004D8, "Wrong size on AGameModeSoloBattle");

// Class InGameModule.ANS_PlaySound
// 0x0098 (0x00D0 - 0x0038)
class UANS_PlaySound final : public UANS_CharacterBase
{
public:
	class FString                                 _soundName;                                        // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _stopSoundName;                                    // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlaySoundNotifyInfo                   _info;                                             // 0x0058(0x0078)(Edit, BlueprintReadOnly, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_PlaySound">();
	}
	static class UANS_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_PlaySound>();
	}
};
static_assert(alignof(UANS_PlaySound) == 0x000008, "Wrong alignment on UANS_PlaySound");
static_assert(sizeof(UANS_PlaySound) == 0x0000D0, "Wrong size on UANS_PlaySound");
static_assert(offsetof(UANS_PlaySound, _soundName) == 0x000038, "Member 'UANS_PlaySound::_soundName' has a wrong offset!");
static_assert(offsetof(UANS_PlaySound, _stopSoundName) == 0x000048, "Member 'UANS_PlaySound::_stopSoundName' has a wrong offset!");
static_assert(offsetof(UANS_PlaySound, _info) == 0x000058, "Member 'UANS_PlaySound::_info' has a wrong offset!");

// Class InGameModule.ANS_SetCharacterConditionMaterial
// 0x0008 (0x0040 - 0x0038)
class UANS_SetCharacterConditionMaterial final : public UANS_CharacterBase
{
public:
	class FName                                   _conditionPresetName;                              // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_SetCharacterConditionMaterial">();
	}
	static class UANS_SetCharacterConditionMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_SetCharacterConditionMaterial>();
	}
};
static_assert(alignof(UANS_SetCharacterConditionMaterial) == 0x000008, "Wrong alignment on UANS_SetCharacterConditionMaterial");
static_assert(sizeof(UANS_SetCharacterConditionMaterial) == 0x000040, "Wrong size on UANS_SetCharacterConditionMaterial");
static_assert(offsetof(UANS_SetCharacterConditionMaterial, _conditionPresetName) == 0x000038, "Member 'UANS_SetCharacterConditionMaterial::_conditionPresetName' has a wrong offset!");

// Class InGameModule.ANS_SetVisiblityAddParts
// 0x0010 (0x0048 - 0x0038)
class UANS_SetVisiblityAddParts final : public UANS_BattleBase
{
public:
	bool                                          _bVisiblity;                                       // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _key;                                              // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_SetVisiblityAddParts">();
	}
	static class UANS_SetVisiblityAddParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_SetVisiblityAddParts>();
	}
};
static_assert(alignof(UANS_SetVisiblityAddParts) == 0x000008, "Wrong alignment on UANS_SetVisiblityAddParts");
static_assert(sizeof(UANS_SetVisiblityAddParts) == 0x000048, "Wrong size on UANS_SetVisiblityAddParts");
static_assert(offsetof(UANS_SetVisiblityAddParts, _bVisiblity) == 0x000038, "Member 'UANS_SetVisiblityAddParts::_bVisiblity' has a wrong offset!");
static_assert(offsetof(UANS_SetVisiblityAddParts, _key) == 0x00003C, "Member 'UANS_SetVisiblityAddParts::_key' has a wrong offset!");

// Class InGameModule.Ch023Unique2Child
// 0x0090 (0x1E70 - 0x1DE0)
class ACh023Unique2Child final : public ABullet
{
public:
	class ACharacterBattle*                       _targetCharacter;                                  // 0x1DD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DE0[0x8];                                     // 0x1DE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialCurveControl*                  _materialCurveCtrlTbl;                             // 0x1DE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x1DF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameDecalComponent*                  _decalComponent;                                   // 0x1DF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxWarningScaleXY;                                // 0x1E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _maxWarningScaleZ;                                 // 0x1E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _warningSeconds;                                   // 0x1E08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _explosionSeconds;                                 // 0x1E0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultWarningEffectLocationZ;                    // 0x1E10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E14[0x4];                                     // 0x1E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBulletParticleSystemComponent*         _warningEffectForEnemy;                            // 0x1E18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletParticleSystemComponent*         _warningEffectForAlly;                             // 0x1E20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletParticleSystemComponent*         _explosionEffect;                                  // 0x1E28(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletParticleSystemComponent*         _signEffectForEnemy;                               // 0x1E30(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletParticleSystemComponent*         _signEffectForAlly;                                // 0x1E38(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletParticleSystemComponent*         _callSignEffect;                                   // 0x1E40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletParticleSystemComponent*         _lightEffect;                                      // 0x1E48(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBulletSE                              _explosionSE;                                      // 0x1E50(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void BP_OnBeginEnd();
	class UMaterialInstanceDynamic* SetMID(class UMaterialInstanceDynamic* Mid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique2Child">();
	}
	static class ACh023Unique2Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique2Child>();
	}
};
static_assert(alignof(ACh023Unique2Child) == 0x000010, "Wrong alignment on ACh023Unique2Child");
static_assert(sizeof(ACh023Unique2Child) == 0x001E70, "Wrong size on ACh023Unique2Child");
static_assert(offsetof(ACh023Unique2Child, _targetCharacter) == 0x001DD8, "Member 'ACh023Unique2Child::_targetCharacter' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _materialCurveCtrlTbl) == 0x001DE8, "Member 'ACh023Unique2Child::_materialCurveCtrlTbl' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _mid) == 0x001DF0, "Member 'ACh023Unique2Child::_mid' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _decalComponent) == 0x001DF8, "Member 'ACh023Unique2Child::_decalComponent' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _maxWarningScaleXY) == 0x001E00, "Member 'ACh023Unique2Child::_maxWarningScaleXY' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _maxWarningScaleZ) == 0x001E04, "Member 'ACh023Unique2Child::_maxWarningScaleZ' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _warningSeconds) == 0x001E08, "Member 'ACh023Unique2Child::_warningSeconds' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _explosionSeconds) == 0x001E0C, "Member 'ACh023Unique2Child::_explosionSeconds' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _defaultWarningEffectLocationZ) == 0x001E10, "Member 'ACh023Unique2Child::_defaultWarningEffectLocationZ' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _warningEffectForEnemy) == 0x001E18, "Member 'ACh023Unique2Child::_warningEffectForEnemy' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _warningEffectForAlly) == 0x001E20, "Member 'ACh023Unique2Child::_warningEffectForAlly' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _explosionEffect) == 0x001E28, "Member 'ACh023Unique2Child::_explosionEffect' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _signEffectForEnemy) == 0x001E30, "Member 'ACh023Unique2Child::_signEffectForEnemy' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _signEffectForAlly) == 0x001E38, "Member 'ACh023Unique2Child::_signEffectForAlly' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _callSignEffect) == 0x001E40, "Member 'ACh023Unique2Child::_callSignEffect' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _lightEffect) == 0x001E48, "Member 'ACh023Unique2Child::_lightEffect' has a wrong offset!");
static_assert(offsetof(ACh023Unique2Child, _explosionSE) == 0x001E50, "Member 'ACh023Unique2Child::_explosionSE' has a wrong offset!");

// Class InGameModule.ANS_TrailEffect
// 0x0060 (0x00B8 - 0x0058)
class UANS_TrailEffect final : public UAnimNotifyState_Trail
{
public:
	int32                                         _minLevel;                                         // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxLevel;                                         // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EAttackVisualLevel>                    VisualLevel;                                       // 0x0060(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0070(0x0040)(Edit, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               _trailPSC;                                         // 0x00B0(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_TrailEffect">();
	}
	static class UANS_TrailEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_TrailEffect>();
	}
};
static_assert(alignof(UANS_TrailEffect) == 0x000008, "Wrong alignment on UANS_TrailEffect");
static_assert(sizeof(UANS_TrailEffect) == 0x0000B8, "Wrong size on UANS_TrailEffect");
static_assert(offsetof(UANS_TrailEffect, _minLevel) == 0x000058, "Member 'UANS_TrailEffect::_minLevel' has a wrong offset!");
static_assert(offsetof(UANS_TrailEffect, _maxLevel) == 0x00005C, "Member 'UANS_TrailEffect::_maxLevel' has a wrong offset!");
static_assert(offsetof(UANS_TrailEffect, VisualLevel) == 0x000060, "Member 'UANS_TrailEffect::VisualLevel' has a wrong offset!");
static_assert(offsetof(UANS_TrailEffect, _graduallyAlpha) == 0x000070, "Member 'UANS_TrailEffect::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(UANS_TrailEffect, _trailPSC) == 0x0000B0, "Member 'UANS_TrailEffect::_trailPSC' has a wrong offset!");

// Class InGameModule.GameModeTraining
// 0x0038 (0x0510 - 0x04D8)
class AGameModeTraining final : public AGameModeBattle
{
public:
	TSoftObjectPtr<class UWorld>                  _supplySpawnPointLevel;                            // 0x04D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASupplySpawnController*>         _supplySpawnControllerList;                        // 0x0500(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void SpawnAllTypeSupply();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeTraining">();
	}
	static class AGameModeTraining* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeTraining>();
	}
};
static_assert(alignof(AGameModeTraining) == 0x000008, "Wrong alignment on AGameModeTraining");
static_assert(sizeof(AGameModeTraining) == 0x000510, "Wrong size on AGameModeTraining");
static_assert(offsetof(AGameModeTraining, _supplySpawnPointLevel) == 0x0004D8, "Member 'AGameModeTraining::_supplySpawnPointLevel' has a wrong offset!");
static_assert(offsetof(AGameModeTraining, _supplySpawnControllerList) == 0x000500, "Member 'AGameModeTraining::_supplySpawnControllerList' has a wrong offset!");

// Class InGameModule.APPerforateDecal
// 0x0020 (0x02A0 - 0x0280)
class AAPPerforateDecal final : public AHeroDecalActor
{
public:
	class UCurveFloat*                            _decalParameterCurve;                              // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _decalParameter;                                   // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomZRot;                                       // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0xC];                                      // 0x0294(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"APPerforateDecal">();
	}
	static class AAPPerforateDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAPPerforateDecal>();
	}
};
static_assert(alignof(AAPPerforateDecal) == 0x000008, "Wrong alignment on AAPPerforateDecal");
static_assert(sizeof(AAPPerforateDecal) == 0x0002A0, "Wrong size on AAPPerforateDecal");
static_assert(offsetof(AAPPerforateDecal, _decalParameterCurve) == 0x000280, "Member 'AAPPerforateDecal::_decalParameterCurve' has a wrong offset!");
static_assert(offsetof(AAPPerforateDecal, _decalParameter) == 0x000288, "Member 'AAPPerforateDecal::_decalParameter' has a wrong offset!");
static_assert(offsetof(AAPPerforateDecal, _randomZRot) == 0x000290, "Member 'AAPPerforateDecal::_randomZRot' has a wrong offset!");

// Class InGameModule.GameStateBattle_OnBattle
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_OnBattle final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_OnBattle">();
	}
	static class UGameStateBattle_OnBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_OnBattle>();
	}
};
static_assert(alignof(UGameStateBattle_OnBattle) == 0x000008, "Wrong alignment on UGameStateBattle_OnBattle");
static_assert(sizeof(UGameStateBattle_OnBattle) == 0x000038, "Wrong size on UGameStateBattle_OnBattle");

// Class InGameModule.AttackParamWork
// 0x0010 (0x0040 - 0x0030)
class UAttackParamWork final : public UGameInstanceSubsystem
{
public:
	TArray<struct FCharacterAttackParamData>      _characterAttackParamDataList;                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackParamWork">();
	}
	static class UAttackParamWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackParamWork>();
	}
};
static_assert(alignof(UAttackParamWork) == 0x000008, "Wrong alignment on UAttackParamWork");
static_assert(sizeof(UAttackParamWork) == 0x000040, "Wrong size on UAttackParamWork");
static_assert(offsetof(UAttackParamWork, _characterAttackParamDataList) == 0x000030, "Member 'UAttackParamWork::_characterAttackParamDataList' has a wrong offset!");

// Class InGameModule.CharacterParam
// 0x0210 (0x0238 - 0x0028)
class UCharacterParam final : public UObject
{
public:
	class ACharacterBattle*                       _ownerCharacter;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x1];                                       // 0x0030(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterGender                              _gender;                                           // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterAssign                              _assign;                                           // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterBodySize                            _bodySize;                                         // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x80];                                      // 0x0034(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _gravity;                                          // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _maxFallSpeed;                                     // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _slideAdjustSpeedForFall;                          // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x1C];                                      // 0x00C0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _actionRun_InitialSpeed;                           // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionRun_LastSpeed;                              // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionRun_AccelSpan;                              // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionRun_InitialTurnSpan;                        // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionRun_TurnRate;                               // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionRunEnd_BrakeSpan;                           // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDashBegin_BrakeSpan;                        // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDash_InitialSpeed;                          // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDash_LastSpeed;                             // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDash_AccelSpan;                             // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDash_InitialTurnSpan;                       // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDash_TurnRate;                              // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDashEnd_BrakeSpan;                          // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirDash_InitialSpeed;                       // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirDash_LastSpeed;                          // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirDash_AccelSpan;                          // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirDash_InitialTurnSpan;                    // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirDash_TurnRate;                           // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirDash_LimitTime;                          // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionHovering_TimeRate;                          // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpBegin_BrakeSpan;                        // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpForward_InitialTurnSpan;                // 0x0130(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpVertical_Span;                          // 0x0134(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpVertical_Height;                        // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpForward_Span;                           // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpForward_Height;                         // 0x0140(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpForward_InitialSpeedH;                  // 0x0144(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpForward_LastSpeedH;                     // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionJumpForward_AccelSpanH;                     // 0x014C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _actionAirJump_MaxCount;                           // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirJumpVertical_Span;                       // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirJumpVertical_Height;                     // 0x0158(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirJumpForward_Span;                        // 0x015C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirJumpForward_Height;                      // 0x0160(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirJumpForward_InitialSpeedH;               // 0x0164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirJumpForward_LastSpeedH;                  // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionAirJumpForward_AccelSpanH;                  // 0x016C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallJump_Span;                              // 0x0170(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallJump_Height;                            // 0x0174(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallJump_InitialSpeed;                      // 0x0178(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallJump_LastSpeed;                         // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallJump_AccelSpan;                         // 0x0180(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableActionHighJump;                            // 0x0184(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _actionHighJumpVertical_Span;                      // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionHighJumpVertical_Height;                    // 0x018C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionHighJumpForward_Span;                       // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionHighJumpForward_Height;                     // 0x0194(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionHighJumpForward_InitialSpeedH;              // 0x0198(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionHighJumpForward_LastSpeedH;                 // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionHighJumpForward_AccelSpanH;                 // 0x01A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x18];                                     // 0x01A4(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _actionWallCrawl_InitialSpeed;                     // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallCrawl_LastSpeed;                        // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallCrawl_AccelSpan;                        // 0x01C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallCrawl_InitialTurnSpan;                  // 0x01C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionWallCrawl_TurnRate;                         // 0x01CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDodge_InitialSpeed;                         // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDodge_LastSpeed;                            // 0x01D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionDodge_InvincibleSpan;                       // 0x01D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _aimingMoveRate;                                   // 0x01DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _actionCrouchMoveRate;                             // 0x01E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giantScale;                                       // 0x01E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giantMoveRate;                                    // 0x01E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giantAnimBaseRate;                                // 0x01EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giantAnimAttackRate;                              // 0x01F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionRun_InitialSpeed;                     // 0x01F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionRun_LastSpeed;                        // 0x01F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionRun_AccelSpan;                        // 0x01FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionRun_InitialTurnSpan;                  // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionRun_TurnRate;                         // 0x0204(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionRunEnd_BrakeSpan;                     // 0x0208(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpBegin_BrakeSpan;                  // 0x020C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpForward_InitialTurnSpan;          // 0x0210(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpVertical_Span;                    // 0x0214(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpVertical_Height;                  // 0x0218(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpForward_Span;                     // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpForward_Height;                   // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpForward_InitialSpeedH;            // 0x0224(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpForward_LastSpeedH;               // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _giant_ActionJumpForward_AccelSpanH;               // 0x022C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterParam">();
	}
	static class UCharacterParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterParam>();
	}
};
static_assert(alignof(UCharacterParam) == 0x000008, "Wrong alignment on UCharacterParam");
static_assert(sizeof(UCharacterParam) == 0x000238, "Wrong size on UCharacterParam");
static_assert(offsetof(UCharacterParam, _ownerCharacter) == 0x000028, "Member 'UCharacterParam::_ownerCharacter' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _gender) == 0x000031, "Member 'UCharacterParam::_gender' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _assign) == 0x000032, "Member 'UCharacterParam::_assign' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _bodySize) == 0x000033, "Member 'UCharacterParam::_bodySize' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _gravity) == 0x0000B4, "Member 'UCharacterParam::_gravity' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _maxFallSpeed) == 0x0000B8, "Member 'UCharacterParam::_maxFallSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _slideAdjustSpeedForFall) == 0x0000BC, "Member 'UCharacterParam::_slideAdjustSpeedForFall' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionRun_InitialSpeed) == 0x0000DC, "Member 'UCharacterParam::_actionRun_InitialSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionRun_LastSpeed) == 0x0000E0, "Member 'UCharacterParam::_actionRun_LastSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionRun_AccelSpan) == 0x0000E4, "Member 'UCharacterParam::_actionRun_AccelSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionRun_InitialTurnSpan) == 0x0000E8, "Member 'UCharacterParam::_actionRun_InitialTurnSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionRun_TurnRate) == 0x0000EC, "Member 'UCharacterParam::_actionRun_TurnRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionRunEnd_BrakeSpan) == 0x0000F0, "Member 'UCharacterParam::_actionRunEnd_BrakeSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDashBegin_BrakeSpan) == 0x0000F4, "Member 'UCharacterParam::_actionDashBegin_BrakeSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDash_InitialSpeed) == 0x0000F8, "Member 'UCharacterParam::_actionDash_InitialSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDash_LastSpeed) == 0x0000FC, "Member 'UCharacterParam::_actionDash_LastSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDash_AccelSpan) == 0x000100, "Member 'UCharacterParam::_actionDash_AccelSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDash_InitialTurnSpan) == 0x000104, "Member 'UCharacterParam::_actionDash_InitialTurnSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDash_TurnRate) == 0x000108, "Member 'UCharacterParam::_actionDash_TurnRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDashEnd_BrakeSpan) == 0x00010C, "Member 'UCharacterParam::_actionDashEnd_BrakeSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirDash_InitialSpeed) == 0x000110, "Member 'UCharacterParam::_actionAirDash_InitialSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirDash_LastSpeed) == 0x000114, "Member 'UCharacterParam::_actionAirDash_LastSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirDash_AccelSpan) == 0x000118, "Member 'UCharacterParam::_actionAirDash_AccelSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirDash_InitialTurnSpan) == 0x00011C, "Member 'UCharacterParam::_actionAirDash_InitialTurnSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirDash_TurnRate) == 0x000120, "Member 'UCharacterParam::_actionAirDash_TurnRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirDash_LimitTime) == 0x000124, "Member 'UCharacterParam::_actionAirDash_LimitTime' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHovering_TimeRate) == 0x000128, "Member 'UCharacterParam::_actionHovering_TimeRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpBegin_BrakeSpan) == 0x00012C, "Member 'UCharacterParam::_actionJumpBegin_BrakeSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpForward_InitialTurnSpan) == 0x000130, "Member 'UCharacterParam::_actionJumpForward_InitialTurnSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpVertical_Span) == 0x000134, "Member 'UCharacterParam::_actionJumpVertical_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpVertical_Height) == 0x000138, "Member 'UCharacterParam::_actionJumpVertical_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpForward_Span) == 0x00013C, "Member 'UCharacterParam::_actionJumpForward_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpForward_Height) == 0x000140, "Member 'UCharacterParam::_actionJumpForward_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpForward_InitialSpeedH) == 0x000144, "Member 'UCharacterParam::_actionJumpForward_InitialSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpForward_LastSpeedH) == 0x000148, "Member 'UCharacterParam::_actionJumpForward_LastSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionJumpForward_AccelSpanH) == 0x00014C, "Member 'UCharacterParam::_actionJumpForward_AccelSpanH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJump_MaxCount) == 0x000150, "Member 'UCharacterParam::_actionAirJump_MaxCount' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJumpVertical_Span) == 0x000154, "Member 'UCharacterParam::_actionAirJumpVertical_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJumpVertical_Height) == 0x000158, "Member 'UCharacterParam::_actionAirJumpVertical_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJumpForward_Span) == 0x00015C, "Member 'UCharacterParam::_actionAirJumpForward_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJumpForward_Height) == 0x000160, "Member 'UCharacterParam::_actionAirJumpForward_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJumpForward_InitialSpeedH) == 0x000164, "Member 'UCharacterParam::_actionAirJumpForward_InitialSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJumpForward_LastSpeedH) == 0x000168, "Member 'UCharacterParam::_actionAirJumpForward_LastSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionAirJumpForward_AccelSpanH) == 0x00016C, "Member 'UCharacterParam::_actionAirJumpForward_AccelSpanH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallJump_Span) == 0x000170, "Member 'UCharacterParam::_actionWallJump_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallJump_Height) == 0x000174, "Member 'UCharacterParam::_actionWallJump_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallJump_InitialSpeed) == 0x000178, "Member 'UCharacterParam::_actionWallJump_InitialSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallJump_LastSpeed) == 0x00017C, "Member 'UCharacterParam::_actionWallJump_LastSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallJump_AccelSpan) == 0x000180, "Member 'UCharacterParam::_actionWallJump_AccelSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _bEnableActionHighJump) == 0x000184, "Member 'UCharacterParam::_bEnableActionHighJump' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHighJumpVertical_Span) == 0x000188, "Member 'UCharacterParam::_actionHighJumpVertical_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHighJumpVertical_Height) == 0x00018C, "Member 'UCharacterParam::_actionHighJumpVertical_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHighJumpForward_Span) == 0x000190, "Member 'UCharacterParam::_actionHighJumpForward_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHighJumpForward_Height) == 0x000194, "Member 'UCharacterParam::_actionHighJumpForward_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHighJumpForward_InitialSpeedH) == 0x000198, "Member 'UCharacterParam::_actionHighJumpForward_InitialSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHighJumpForward_LastSpeedH) == 0x00019C, "Member 'UCharacterParam::_actionHighJumpForward_LastSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionHighJumpForward_AccelSpanH) == 0x0001A0, "Member 'UCharacterParam::_actionHighJumpForward_AccelSpanH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallCrawl_InitialSpeed) == 0x0001BC, "Member 'UCharacterParam::_actionWallCrawl_InitialSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallCrawl_LastSpeed) == 0x0001C0, "Member 'UCharacterParam::_actionWallCrawl_LastSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallCrawl_AccelSpan) == 0x0001C4, "Member 'UCharacterParam::_actionWallCrawl_AccelSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallCrawl_InitialTurnSpan) == 0x0001C8, "Member 'UCharacterParam::_actionWallCrawl_InitialTurnSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionWallCrawl_TurnRate) == 0x0001CC, "Member 'UCharacterParam::_actionWallCrawl_TurnRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDodge_InitialSpeed) == 0x0001D0, "Member 'UCharacterParam::_actionDodge_InitialSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDodge_LastSpeed) == 0x0001D4, "Member 'UCharacterParam::_actionDodge_LastSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionDodge_InvincibleSpan) == 0x0001D8, "Member 'UCharacterParam::_actionDodge_InvincibleSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _aimingMoveRate) == 0x0001DC, "Member 'UCharacterParam::_aimingMoveRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _actionCrouchMoveRate) == 0x0001E0, "Member 'UCharacterParam::_actionCrouchMoveRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giantScale) == 0x0001E4, "Member 'UCharacterParam::_giantScale' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giantMoveRate) == 0x0001E8, "Member 'UCharacterParam::_giantMoveRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giantAnimBaseRate) == 0x0001EC, "Member 'UCharacterParam::_giantAnimBaseRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giantAnimAttackRate) == 0x0001F0, "Member 'UCharacterParam::_giantAnimAttackRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionRun_InitialSpeed) == 0x0001F4, "Member 'UCharacterParam::_giant_ActionRun_InitialSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionRun_LastSpeed) == 0x0001F8, "Member 'UCharacterParam::_giant_ActionRun_LastSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionRun_AccelSpan) == 0x0001FC, "Member 'UCharacterParam::_giant_ActionRun_AccelSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionRun_InitialTurnSpan) == 0x000200, "Member 'UCharacterParam::_giant_ActionRun_InitialTurnSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionRun_TurnRate) == 0x000204, "Member 'UCharacterParam::_giant_ActionRun_TurnRate' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionRunEnd_BrakeSpan) == 0x000208, "Member 'UCharacterParam::_giant_ActionRunEnd_BrakeSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpBegin_BrakeSpan) == 0x00020C, "Member 'UCharacterParam::_giant_ActionJumpBegin_BrakeSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpForward_InitialTurnSpan) == 0x000210, "Member 'UCharacterParam::_giant_ActionJumpForward_InitialTurnSpan' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpVertical_Span) == 0x000214, "Member 'UCharacterParam::_giant_ActionJumpVertical_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpVertical_Height) == 0x000218, "Member 'UCharacterParam::_giant_ActionJumpVertical_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpForward_Span) == 0x00021C, "Member 'UCharacterParam::_giant_ActionJumpForward_Span' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpForward_Height) == 0x000220, "Member 'UCharacterParam::_giant_ActionJumpForward_Height' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpForward_InitialSpeedH) == 0x000224, "Member 'UCharacterParam::_giant_ActionJumpForward_InitialSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpForward_LastSpeedH) == 0x000228, "Member 'UCharacterParam::_giant_ActionJumpForward_LastSpeedH' has a wrong offset!");
static_assert(offsetof(UCharacterParam, _giant_ActionJumpForward_AccelSpanH) == 0x00022C, "Member 'UCharacterParam::_giant_ActionJumpForward_AccelSpanH' has a wrong offset!");

// Class InGameModule.BarrierSpawnPoint
// 0x0000 (0x0228 - 0x0228)
class ABarrierSpawnPoint final : public AStageSpawnPointBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarrierSpawnPoint">();
	}
	static class ABarrierSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABarrierSpawnPoint>();
	}
};
static_assert(alignof(ABarrierSpawnPoint) == 0x000008, "Wrong alignment on ABarrierSpawnPoint");
static_assert(sizeof(ABarrierSpawnPoint) == 0x000228, "Wrong size on ABarrierSpawnPoint");

// Class InGameModule.BattleAchievementComponent
// 0x0050 (0x0100 - 0x00B0)
class UBattleAchievementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleAchievementComponent">();
	}
	static class UBattleAchievementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleAchievementComponent>();
	}
};
static_assert(alignof(UBattleAchievementComponent) == 0x000008, "Wrong alignment on UBattleAchievementComponent");
static_assert(sizeof(UBattleAchievementComponent) == 0x000100, "Wrong size on UBattleAchievementComponent");

// Class InGameModule.BattleBriefingAlertWidget
// 0x0020 (0x0370 - 0x0350)
class UBattleBriefingAlertWidget : public UWidgetBase
{
public:
	float                                         _animAlertParam;                                   // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URetainerBox*                           _alertRetainerBox;                                 // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProgressAlertDirection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingAlertWidget">();
	}
	static class UBattleBriefingAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingAlertWidget>();
	}
};
static_assert(alignof(UBattleBriefingAlertWidget) == 0x000008, "Wrong alignment on UBattleBriefingAlertWidget");
static_assert(sizeof(UBattleBriefingAlertWidget) == 0x000370, "Wrong size on UBattleBriefingAlertWidget");
static_assert(offsetof(UBattleBriefingAlertWidget, _animAlertParam) == 0x000350, "Member 'UBattleBriefingAlertWidget::_animAlertParam' has a wrong offset!");
static_assert(offsetof(UBattleBriefingAlertWidget, _alertRetainerBox) == 0x000358, "Member 'UBattleBriefingAlertWidget::_alertRetainerBox' has a wrong offset!");

// Class InGameModule.BattleBriefingAlert3LeadersOtherWidget
// 0x00B0 (0x0420 - 0x0370)
class UBattleBriefingAlert3LeadersOtherWidget final : public UBattleBriefingAlertWidget
{
public:
	TSubclassOf<class UBattleBriefingPlayerNameCharaIconWidget> _playerNameClass;                                  // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _text;                                             // 0x0378(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            _textColor;                                        // 0x0390(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         _font;                                             // 0x03B8(0x0058)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleBriefingPlayerNameCharaIconWidget* _playerName;                                       // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           _verticalBox;                                      // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingAlert3LeadersOtherWidget">();
	}
	static class UBattleBriefingAlert3LeadersOtherWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingAlert3LeadersOtherWidget>();
	}
};
static_assert(alignof(UBattleBriefingAlert3LeadersOtherWidget) == 0x000008, "Wrong alignment on UBattleBriefingAlert3LeadersOtherWidget");
static_assert(sizeof(UBattleBriefingAlert3LeadersOtherWidget) == 0x000420, "Wrong size on UBattleBriefingAlert3LeadersOtherWidget");
static_assert(offsetof(UBattleBriefingAlert3LeadersOtherWidget, _playerNameClass) == 0x000370, "Member 'UBattleBriefingAlert3LeadersOtherWidget::_playerNameClass' has a wrong offset!");
static_assert(offsetof(UBattleBriefingAlert3LeadersOtherWidget, _text) == 0x000378, "Member 'UBattleBriefingAlert3LeadersOtherWidget::_text' has a wrong offset!");
static_assert(offsetof(UBattleBriefingAlert3LeadersOtherWidget, _textColor) == 0x000390, "Member 'UBattleBriefingAlert3LeadersOtherWidget::_textColor' has a wrong offset!");
static_assert(offsetof(UBattleBriefingAlert3LeadersOtherWidget, _font) == 0x0003B8, "Member 'UBattleBriefingAlert3LeadersOtherWidget::_font' has a wrong offset!");
static_assert(offsetof(UBattleBriefingAlert3LeadersOtherWidget, _playerName) == 0x000410, "Member 'UBattleBriefingAlert3LeadersOtherWidget::_playerName' has a wrong offset!");
static_assert(offsetof(UBattleBriefingAlert3LeadersOtherWidget, _verticalBox) == 0x000418, "Member 'UBattleBriefingAlert3LeadersOtherWidget::_verticalBox' has a wrong offset!");

// Class InGameModule.CharacterTutorial
// 0x0000 (0x04C8 - 0x04C8)
class ACharacterTutorial final : public ACharacterGame
{
public:
	void BP_PlayAnimation(EAnimationId AnimationId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterTutorial">();
	}
	static class ACharacterTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterTutorial>();
	}
};
static_assert(alignof(ACharacterTutorial) == 0x000008, "Wrong alignment on ACharacterTutorial");
static_assert(sizeof(ACharacterTutorial) == 0x0004C8, "Wrong size on ACharacterTutorial");

// Class InGameModule.GameStateLobby_Init
// 0x0000 (0x0030 - 0x0030)
class UGameStateLobby_Init final : public UFiniteState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateLobby_Init">();
	}
	static class UGameStateLobby_Init* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateLobby_Init>();
	}
};
static_assert(alignof(UGameStateLobby_Init) == 0x000008, "Wrong alignment on UGameStateLobby_Init");
static_assert(sizeof(UGameStateLobby_Init) == 0x000030, "Wrong size on UGameStateLobby_Init");

// Class InGameModule.BattleBriefingPlayerNameCharaIconWidget
// 0x0010 (0x0360 - 0x0350)
class UBattleBriefingPlayerNameCharaIconWidget final : public UWidgetBase
{
public:
	class UBattleBriefingPlayerNameWidget*        _playerName;                                       // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _charaIcon;                                        // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingPlayerNameCharaIconWidget">();
	}
	static class UBattleBriefingPlayerNameCharaIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingPlayerNameCharaIconWidget>();
	}
};
static_assert(alignof(UBattleBriefingPlayerNameCharaIconWidget) == 0x000008, "Wrong alignment on UBattleBriefingPlayerNameCharaIconWidget");
static_assert(sizeof(UBattleBriefingPlayerNameCharaIconWidget) == 0x000360, "Wrong size on UBattleBriefingPlayerNameCharaIconWidget");
static_assert(offsetof(UBattleBriefingPlayerNameCharaIconWidget, _playerName) == 0x000350, "Member 'UBattleBriefingPlayerNameCharaIconWidget::_playerName' has a wrong offset!");
static_assert(offsetof(UBattleBriefingPlayerNameCharaIconWidget, _charaIcon) == 0x000358, "Member 'UBattleBriefingPlayerNameCharaIconWidget::_charaIcon' has a wrong offset!");

// Class InGameModule.BattleBriefingSequenceWidget
// 0x0040 (0x0390 - 0x0350)
class UBattleBriefingSequenceWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x30];                                     // 0x0350(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class URetainerBox*                           _retainerBox;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                _title;                                            // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void TickClose(const float DeltaSeconds);
	void TickOpen(const float DeltaSeconds);
	void UpdateEvent__DelegateSignature(const float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingSequenceWidget">();
	}
	static class UBattleBriefingSequenceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingSequenceWidget>();
	}
};
static_assert(alignof(UBattleBriefingSequenceWidget) == 0x000008, "Wrong alignment on UBattleBriefingSequenceWidget");
static_assert(sizeof(UBattleBriefingSequenceWidget) == 0x000390, "Wrong size on UBattleBriefingSequenceWidget");
static_assert(offsetof(UBattleBriefingSequenceWidget, _retainerBox) == 0x000380, "Member 'UBattleBriefingSequenceWidget::_retainerBox' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSequenceWidget, _title) == 0x000388, "Member 'UBattleBriefingSequenceWidget::_title' has a wrong offset!");

// Class InGameModule.SupplyDataAsset
// 0x0050 (0x0118 - 0x00C8)
class USupplyDataAsset : public USupplyBaseDataAsset
{
public:
	int32                                         _sortPriority;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _spawnBlueprint;                                   // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _requiredTime;                                     // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSupplyFloatEffects>            _floatEffectValues;                                // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          _bAllAlly;                                         // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFloatEffectValue(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyDataAsset">();
	}
	static class USupplyDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyDataAsset>();
	}
};
static_assert(alignof(USupplyDataAsset) == 0x000008, "Wrong alignment on USupplyDataAsset");
static_assert(sizeof(USupplyDataAsset) == 0x000118, "Wrong size on USupplyDataAsset");
static_assert(offsetof(USupplyDataAsset, _sortPriority) == 0x0000C8, "Member 'USupplyDataAsset::_sortPriority' has a wrong offset!");
static_assert(offsetof(USupplyDataAsset, _spawnBlueprint) == 0x0000D0, "Member 'USupplyDataAsset::_spawnBlueprint' has a wrong offset!");
static_assert(offsetof(USupplyDataAsset, _requiredTime) == 0x0000F8, "Member 'USupplyDataAsset::_requiredTime' has a wrong offset!");
static_assert(offsetof(USupplyDataAsset, _floatEffectValues) == 0x000100, "Member 'USupplyDataAsset::_floatEffectValues' has a wrong offset!");
static_assert(offsetof(USupplyDataAsset, _bAllAlly) == 0x000110, "Member 'USupplyDataAsset::_bAllAlly' has a wrong offset!");

// Class InGameModule.CitizenDataAsset
// 0x0000 (0x0118 - 0x0118)
class UCitizenDataAsset final : public USupplyDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CitizenDataAsset">();
	}
	static class UCitizenDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCitizenDataAsset>();
	}
};
static_assert(alignof(UCitizenDataAsset) == 0x000008, "Wrong alignment on UCitizenDataAsset");
static_assert(sizeof(UCitizenDataAsset) == 0x000118, "Wrong size on UCitizenDataAsset");

// Class InGameModule.BattleBriefingSliderWidget
// 0x0050 (0x03A0 - 0x0350)
class UBattleBriefingSliderWidget final : public UWidgetBase
{
public:
	class USlider*                                _slider;                                           // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppWidget*                             _plusButton;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppWidget*                             _guideR2Button;                                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppWidget*                             _minusButton;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppWidget*                             _guideL2Button;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultSliderValue;                               // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _stepSizeRate;                                     // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _gamePadSliderSpeed;                               // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomInputKey*                        _customInputKey;                                   // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressMinusButton(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnPressPlusButton(class UAppWidget* Widget, EWidgetInputType InputType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingSliderWidget">();
	}
	static class UBattleBriefingSliderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingSliderWidget>();
	}
};
static_assert(alignof(UBattleBriefingSliderWidget) == 0x000008, "Wrong alignment on UBattleBriefingSliderWidget");
static_assert(sizeof(UBattleBriefingSliderWidget) == 0x0003A0, "Wrong size on UBattleBriefingSliderWidget");
static_assert(offsetof(UBattleBriefingSliderWidget, _slider) == 0x000350, "Member 'UBattleBriefingSliderWidget::_slider' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _plusButton) == 0x000358, "Member 'UBattleBriefingSliderWidget::_plusButton' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _guideR2Button) == 0x000360, "Member 'UBattleBriefingSliderWidget::_guideR2Button' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _minusButton) == 0x000368, "Member 'UBattleBriefingSliderWidget::_minusButton' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _guideL2Button) == 0x000370, "Member 'UBattleBriefingSliderWidget::_guideL2Button' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _defaultSliderValue) == 0x000378, "Member 'UBattleBriefingSliderWidget::_defaultSliderValue' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _stepSizeRate) == 0x00037C, "Member 'UBattleBriefingSliderWidget::_stepSizeRate' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _gamePadSliderSpeed) == 0x000380, "Member 'UBattleBriefingSliderWidget::_gamePadSliderSpeed' has a wrong offset!");
static_assert(offsetof(UBattleBriefingSliderWidget, _customInputKey) == 0x000388, "Member 'UBattleBriefingSliderWidget::_customInputKey' has a wrong offset!");

// Class InGameModule.BattleBriefingStageInfoWidget
// 0x00D0 (0x0420 - 0x0350)
class UBattleBriefingStageInfoWidget final : public UWidgetBase
{
public:
	class APlayerControllerBattle*                _playerController;                                 // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _canvasPanel;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _mapBackgroundMaterial;                            // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _unselectableAreaMaterial;                         // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              _briefingMapWidget;                                // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _selectableAreaFramePanel;                         // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _selectableAreaPanel;                              // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _mapGuideCanvasPanel;                              // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _mapWidgetSize;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _mapBgWidgetSize;                                  // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             _mapImage;                                         // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             _mapBgImage;                                       // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _startPoint;                                       // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _endPoint;                                         // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URetainerBox*                           _unselectableAreaRetainerBox;                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _selectableArea;                                   // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _teamA;                                            // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _teamB;                                            // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _squad;                                            // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x4];                                      // 0x0410(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bOverhangBG;                                      // 0x0414(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minMagnificationRate;                             // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxMagnificationRate;                             // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingStageInfoWidget">();
	}
	static class UBattleBriefingStageInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingStageInfoWidget>();
	}
};
static_assert(alignof(UBattleBriefingStageInfoWidget) == 0x000008, "Wrong alignment on UBattleBriefingStageInfoWidget");
static_assert(sizeof(UBattleBriefingStageInfoWidget) == 0x000420, "Wrong size on UBattleBriefingStageInfoWidget");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _playerController) == 0x000350, "Member 'UBattleBriefingStageInfoWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _localPlayerHudManager) == 0x000358, "Member 'UBattleBriefingStageInfoWidget::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _canvasPanel) == 0x000360, "Member 'UBattleBriefingStageInfoWidget::_canvasPanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _mapBackgroundMaterial) == 0x000368, "Member 'UBattleBriefingStageInfoWidget::_mapBackgroundMaterial' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _unselectableAreaMaterial) == 0x000370, "Member 'UBattleBriefingStageInfoWidget::_unselectableAreaMaterial' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _briefingMapWidget) == 0x000378, "Member 'UBattleBriefingStageInfoWidget::_briefingMapWidget' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _selectableAreaFramePanel) == 0x000380, "Member 'UBattleBriefingStageInfoWidget::_selectableAreaFramePanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _selectableAreaPanel) == 0x000388, "Member 'UBattleBriefingStageInfoWidget::_selectableAreaPanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _mapGuideCanvasPanel) == 0x000390, "Member 'UBattleBriefingStageInfoWidget::_mapGuideCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _mapWidgetSize) == 0x0003A8, "Member 'UBattleBriefingStageInfoWidget::_mapWidgetSize' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _mapBgWidgetSize) == 0x0003B0, "Member 'UBattleBriefingStageInfoWidget::_mapBgWidgetSize' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _mapImage) == 0x0003B8, "Member 'UBattleBriefingStageInfoWidget::_mapImage' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _mapBgImage) == 0x0003C0, "Member 'UBattleBriefingStageInfoWidget::_mapBgImage' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _startPoint) == 0x0003C8, "Member 'UBattleBriefingStageInfoWidget::_startPoint' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _endPoint) == 0x0003D0, "Member 'UBattleBriefingStageInfoWidget::_endPoint' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _unselectableAreaRetainerBox) == 0x0003E8, "Member 'UBattleBriefingStageInfoWidget::_unselectableAreaRetainerBox' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _selectableArea) == 0x0003F0, "Member 'UBattleBriefingStageInfoWidget::_selectableArea' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _teamA) == 0x0003F8, "Member 'UBattleBriefingStageInfoWidget::_teamA' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _teamB) == 0x000400, "Member 'UBattleBriefingStageInfoWidget::_teamB' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _squad) == 0x000408, "Member 'UBattleBriefingStageInfoWidget::_squad' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _bOverhangBG) == 0x000414, "Member 'UBattleBriefingStageInfoWidget::_bOverhangBG' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _minMagnificationRate) == 0x000418, "Member 'UBattleBriefingStageInfoWidget::_minMagnificationRate' has a wrong offset!");
static_assert(offsetof(UBattleBriefingStageInfoWidget, _maxMagnificationRate) == 0x00041C, "Member 'UBattleBriefingStageInfoWidget::_maxMagnificationRate' has a wrong offset!");

// Class InGameModule.WarpCopyComponent
// 0x0070 (0x0270 - 0x0200)
class UWarpCopyComponent final : public USceneComponent
{
public:
	class UMultiTraceComponent*                   _fromCopyScene;                                    // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       _MID1;                                             // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       _MID2;                                             // 0x0210(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           _copyPMC;                                          // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APortal*                                _currentHeldPortal;                                // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x40];                                     // 0x0230(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class UMultiTraceComponent* Src, EWarpCopyType CopyType);
	bool OnPortalBeginOverlap(class APortal* Portal);
	void OnPortalEndOverlap();
	void Teleportation();
	void TeleportVisualize();
	void TogglePrimitiveComponent(class UPrimitiveComponent* Component, bool On);
	void UpdateComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarpCopyComponent">();
	}
	static class UWarpCopyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWarpCopyComponent>();
	}
};
static_assert(alignof(UWarpCopyComponent) == 0x000010, "Wrong alignment on UWarpCopyComponent");
static_assert(sizeof(UWarpCopyComponent) == 0x000270, "Wrong size on UWarpCopyComponent");
static_assert(offsetof(UWarpCopyComponent, _fromCopyScene) == 0x0001F8, "Member 'UWarpCopyComponent::_fromCopyScene' has a wrong offset!");
static_assert(offsetof(UWarpCopyComponent, _MID1) == 0x000200, "Member 'UWarpCopyComponent::_MID1' has a wrong offset!");
static_assert(offsetof(UWarpCopyComponent, _MID2) == 0x000210, "Member 'UWarpCopyComponent::_MID2' has a wrong offset!");
static_assert(offsetof(UWarpCopyComponent, _copyPMC) == 0x000220, "Member 'UWarpCopyComponent::_copyPMC' has a wrong offset!");
static_assert(offsetof(UWarpCopyComponent, _currentHeldPortal) == 0x000228, "Member 'UWarpCopyComponent::_currentHeldPortal' has a wrong offset!");

// Class InGameModule.BattleBriefingStatics
// 0x0000 (0x0028 - 0x0028)
class UBattleBriefingStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingStatics">();
	}
	static class UBattleBriefingStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingStatics>();
	}
};
static_assert(alignof(UBattleBriefingStatics) == 0x000008, "Wrong alignment on UBattleBriefingStatics");
static_assert(sizeof(UBattleBriefingStatics) == 0x000028, "Wrong size on UBattleBriefingStatics");

// Class InGameModule.CommentaryVoiceComponent
// 0x0020 (0x1260 - 0x1240)
class UCommentaryVoiceComponent final : public UAtomComponent
{
public:
	TArray<struct FCommentaryVoiceInfo>           _voiceList;                                        // 0x1240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCue*>                  _countDownVoiceList;                               // 0x1250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void PlayCountDown(int32 Count);
	void PlayVoice(ECommentaryVoiceType Type, int32 CueIndex);
	void PlayVoiceList(const TArray<struct FCommentaryVoicePlayListInfo>& PlayListInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentaryVoiceComponent">();
	}
	static class UCommentaryVoiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentaryVoiceComponent>();
	}
};
static_assert(alignof(UCommentaryVoiceComponent) == 0x000010, "Wrong alignment on UCommentaryVoiceComponent");
static_assert(sizeof(UCommentaryVoiceComponent) == 0x001260, "Wrong size on UCommentaryVoiceComponent");
static_assert(offsetof(UCommentaryVoiceComponent, _voiceList) == 0x001240, "Member 'UCommentaryVoiceComponent::_voiceList' has a wrong offset!");
static_assert(offsetof(UCommentaryVoiceComponent, _countDownVoiceList) == 0x001250, "Member 'UCommentaryVoiceComponent::_countDownVoiceList' has a wrong offset!");

// Class InGameModule.GameTeamInfoComponent
// 0x0038 (0x00E8 - 0x00B0)
class UGameTeamInfoComponent final : public UActorComponent
{
public:
	class AGameStateBase*                         _ownerGameState;                                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAlivePlayerNum() const;
	int32 GetAliveTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTeamInfoComponent">();
	}
	static class UGameTeamInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTeamInfoComponent>();
	}
};
static_assert(alignof(UGameTeamInfoComponent) == 0x000008, "Wrong alignment on UGameTeamInfoComponent");
static_assert(sizeof(UGameTeamInfoComponent) == 0x0000E8, "Wrong size on UGameTeamInfoComponent");
static_assert(offsetof(UGameTeamInfoComponent, _ownerGameState) == 0x0000B0, "Member 'UGameTeamInfoComponent::_ownerGameState' has a wrong offset!");

// Class InGameModule.BattleBriefingWidget
// 0x0310 (0x0660 - 0x0350)
class alignas(0x10) UBattleBriefingWidget final : public UWidgetBase
{
public:
	class APlayerControllerBattle*                _playerController;                                 // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x1B1];                                    // 0x0360(0x01B1)(Fixing Size After Last Property [ Dumper-7 ])
	EEasingFunc                                   _startProductionBlendType;                         // 0x0511(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_512[0x2];                                      // 0x0512(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _startProductionBlendExp;                          // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _startProductionZoomRate;                          // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           _stagesCanvasPanel;                                // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleBriefingStageInfoWidget*         _briefingStageInfo;                                // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapIconsWidget*                        _briefingMapIcons;                                 // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              _verticalBarScaleBox;                              // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              _horizontalBarScaleBox;                            // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x18];                                     // 0x0548(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnchors                               _scrollOutRange;                                   // 0x0560(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UWidget*                                _cancelGuide;                                      // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMultipleDigitsWidget*                  _timer;                                            // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleBriefingSliderWidget*            _battleBriefingSlider;                             // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleBriefingSequenceWidget*          _sequenceBriefingStartTimer;                       // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleBriefingSequenceWidget*          _sequenceBriefingDispTimer;                        // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleBriefingSequenceWidget*          _sequenceBriefingStartProductionTimer;             // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBlurEffectType                               _blurEffectType;                                   // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blurStrength;                                     // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URetainerBox*                           _radialBlurRetainerBox;                            // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomInputKey*                        _customInputKey;                                   // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _enemyPinColor;                                    // 0x05C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBattleBriefingPinWidget>   _myPinWidgetClass;                                 // 0x05D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBattleBriefingPinWidget>   _otherPinWidgetClass;                              // 0x05E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _canvasPanel;                                      // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleBriefingPinWidget*               _pin;                                              // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<uint8, struct FBriefingOtherPinsInfo>    _otherPinList;                                     // 0x05F8(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           _rpcTimerHandle;                                   // 0x0648(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x8];                                      // 0x0650(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBriefingModeComponent*                 _briefingModeComponent;                            // 0x0658(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CreateOtherPins(const float DeltaSeconds);
	void Delay(const float Delay_0);
	void DispAllPins(const float DeltaSeconds);
	void Init(const float DeltaSeconds);
	void OpenSequenceBriefingDispTimer();
	void OpenSequenceBriefingStartProductionTimer();
	void PressPinUpKey(const class FName CustomName, const bool bTrg, const bool bRapidFire);
	void ReleasePinUpKey(const class FName CustomName);
	void SendBriefingInitInfo();
	void Start();
	void StartProduction(const float DeltaSeconds);
	void Update(const float DeltaSeconds);
	void UpdateEvent__DelegateSignature(const float DeltaSeconds);
	void WaitPlayerState(const float DeltaSeconds);
	void WaitProduction(const float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBriefingWidget">();
	}
	static class UBattleBriefingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBriefingWidget>();
	}
};
static_assert(alignof(UBattleBriefingWidget) == 0x000010, "Wrong alignment on UBattleBriefingWidget");
static_assert(sizeof(UBattleBriefingWidget) == 0x000660, "Wrong size on UBattleBriefingWidget");
static_assert(offsetof(UBattleBriefingWidget, _playerController) == 0x000350, "Member 'UBattleBriefingWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _playerState) == 0x000358, "Member 'UBattleBriefingWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _startProductionBlendType) == 0x000511, "Member 'UBattleBriefingWidget::_startProductionBlendType' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _startProductionBlendExp) == 0x000514, "Member 'UBattleBriefingWidget::_startProductionBlendExp' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _startProductionZoomRate) == 0x000518, "Member 'UBattleBriefingWidget::_startProductionZoomRate' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _stagesCanvasPanel) == 0x000520, "Member 'UBattleBriefingWidget::_stagesCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _briefingStageInfo) == 0x000528, "Member 'UBattleBriefingWidget::_briefingStageInfo' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _briefingMapIcons) == 0x000530, "Member 'UBattleBriefingWidget::_briefingMapIcons' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _verticalBarScaleBox) == 0x000538, "Member 'UBattleBriefingWidget::_verticalBarScaleBox' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _horizontalBarScaleBox) == 0x000540, "Member 'UBattleBriefingWidget::_horizontalBarScaleBox' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _scrollOutRange) == 0x000560, "Member 'UBattleBriefingWidget::_scrollOutRange' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _cancelGuide) == 0x000570, "Member 'UBattleBriefingWidget::_cancelGuide' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _timer) == 0x000578, "Member 'UBattleBriefingWidget::_timer' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _battleBriefingSlider) == 0x000580, "Member 'UBattleBriefingWidget::_battleBriefingSlider' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _sequenceBriefingStartTimer) == 0x000590, "Member 'UBattleBriefingWidget::_sequenceBriefingStartTimer' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _sequenceBriefingDispTimer) == 0x000598, "Member 'UBattleBriefingWidget::_sequenceBriefingDispTimer' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _sequenceBriefingStartProductionTimer) == 0x0005A0, "Member 'UBattleBriefingWidget::_sequenceBriefingStartProductionTimer' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _blurEffectType) == 0x0005A8, "Member 'UBattleBriefingWidget::_blurEffectType' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _blurStrength) == 0x0005AC, "Member 'UBattleBriefingWidget::_blurStrength' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _radialBlurRetainerBox) == 0x0005B0, "Member 'UBattleBriefingWidget::_radialBlurRetainerBox' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _customInputKey) == 0x0005C0, "Member 'UBattleBriefingWidget::_customInputKey' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _enemyPinColor) == 0x0005C8, "Member 'UBattleBriefingWidget::_enemyPinColor' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _myPinWidgetClass) == 0x0005D8, "Member 'UBattleBriefingWidget::_myPinWidgetClass' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _otherPinWidgetClass) == 0x0005E0, "Member 'UBattleBriefingWidget::_otherPinWidgetClass' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _canvasPanel) == 0x0005E8, "Member 'UBattleBriefingWidget::_canvasPanel' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _pin) == 0x0005F0, "Member 'UBattleBriefingWidget::_pin' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _otherPinList) == 0x0005F8, "Member 'UBattleBriefingWidget::_otherPinList' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _rpcTimerHandle) == 0x000648, "Member 'UBattleBriefingWidget::_rpcTimerHandle' has a wrong offset!");
static_assert(offsetof(UBattleBriefingWidget, _briefingModeComponent) == 0x000658, "Member 'UBattleBriefingWidget::_briefingModeComponent' has a wrong offset!");

// Class InGameModule.BattleCustomParticleSystemComponent
// 0x00A0 (0x0840 - 0x07A0)
class UBattleCustomParticleSystemComponent : public UCustomParticleSystemComponent
{
public:
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0798(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAvaterOverride                        _avaterOverride;                                   // 0x07D8(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_800[0x40];                                     // 0x0800(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeCharacterAction(class UAnimMontage* Montage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCustomParticleSystemComponent">();
	}
	static class UBattleCustomParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleCustomParticleSystemComponent>();
	}
};
static_assert(alignof(UBattleCustomParticleSystemComponent) == 0x000010, "Wrong alignment on UBattleCustomParticleSystemComponent");
static_assert(sizeof(UBattleCustomParticleSystemComponent) == 0x000840, "Wrong size on UBattleCustomParticleSystemComponent");
static_assert(offsetof(UBattleCustomParticleSystemComponent, _graduallyAlpha) == 0x000798, "Member 'UBattleCustomParticleSystemComponent::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(UBattleCustomParticleSystemComponent, _avaterOverride) == 0x0007D8, "Member 'UBattleCustomParticleSystemComponent::_avaterOverride' has a wrong offset!");

// Class InGameModule.GameStateLeadersBattle
// 0x00D8 (0x06E8 - 0x0610)
class AGameStateLeadersBattle final : public AGameStateBattle
{
public:
	uint8                                         Pad_610[0x40];                                     // 0x0610(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ULeadersManagerComponent*               _leadersManagerComponent;                          // 0x0650(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x30];                                     // 0x0658(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ULeadersBattleScoreManagerComponent*    _leadersBattleScoreManagerComponent;               // 0x0688(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0x18];                                     // 0x0690(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _rotationTimer;                                    // 0x06A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _battleTimer;                                      // 0x06AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _victoryPoint;                                     // 0x06B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B4[0x34];                                     // 0x06B4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecideLeaders_RPC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateLeadersBattle">();
	}
	static class AGameStateLeadersBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateLeadersBattle>();
	}
};
static_assert(alignof(AGameStateLeadersBattle) == 0x000008, "Wrong alignment on AGameStateLeadersBattle");
static_assert(sizeof(AGameStateLeadersBattle) == 0x0006E8, "Wrong size on AGameStateLeadersBattle");
static_assert(offsetof(AGameStateLeadersBattle, _leadersManagerComponent) == 0x000650, "Member 'AGameStateLeadersBattle::_leadersManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameStateLeadersBattle, _leadersBattleScoreManagerComponent) == 0x000688, "Member 'AGameStateLeadersBattle::_leadersBattleScoreManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameStateLeadersBattle, _rotationTimer) == 0x0006A8, "Member 'AGameStateLeadersBattle::_rotationTimer' has a wrong offset!");
static_assert(offsetof(AGameStateLeadersBattle, _battleTimer) == 0x0006AC, "Member 'AGameStateLeadersBattle::_battleTimer' has a wrong offset!");
static_assert(offsetof(AGameStateLeadersBattle, _victoryPoint) == 0x0006B0, "Member 'AGameStateLeadersBattle::_victoryPoint' has a wrong offset!");

// Class InGameModule.BattleHitMeshComponent
// 0x0000 (0x04E0 - 0x04E0)
class UBattleHitMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleHitMeshComponent">();
	}
	static class UBattleHitMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleHitMeshComponent>();
	}
};
static_assert(alignof(UBattleHitMeshComponent) == 0x000010, "Wrong alignment on UBattleHitMeshComponent");
static_assert(sizeof(UBattleHitMeshComponent) == 0x0004E0, "Wrong size on UBattleHitMeshComponent");

// Class InGameModule.GameStateLobby_Traveling
// 0x0000 (0x0030 - 0x0030)
class UGameStateLobby_Traveling final : public UFiniteState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateLobby_Traveling">();
	}
	static class UGameStateLobby_Traveling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateLobby_Traveling>();
	}
};
static_assert(alignof(UGameStateLobby_Traveling) == 0x000008, "Wrong alignment on UGameStateLobby_Traveling");
static_assert(sizeof(UGameStateLobby_Traveling) == 0x000030, "Wrong size on UGameStateLobby_Traveling");

// Class InGameModule.BattleTimerWidget
// 0x00C0 (0x0410 - 0x0350)
class UBattleTimerWidget final : public UWidgetBase
{
public:
	class AGameStateBattle*                       _gameState;                                        // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _minSecDrawFlag;                                   // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _digitMinute10;                                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _digitMinute1;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _digitSecond10;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _digitSecond1;                                     // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _colon;                                            // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _timerBase;                                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _tintWhite;                                        // 0x0390(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _tintYellow;                                       // 0x03B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _tintRed;                                          // 0x03E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleTimerWidget">();
	}
	static class UBattleTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleTimerWidget>();
	}
};
static_assert(alignof(UBattleTimerWidget) == 0x000008, "Wrong alignment on UBattleTimerWidget");
static_assert(sizeof(UBattleTimerWidget) == 0x000410, "Wrong size on UBattleTimerWidget");
static_assert(offsetof(UBattleTimerWidget, _gameState) == 0x000350, "Member 'UBattleTimerWidget::_gameState' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _minSecDrawFlag) == 0x000358, "Member 'UBattleTimerWidget::_minSecDrawFlag' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _digitMinute10) == 0x000360, "Member 'UBattleTimerWidget::_digitMinute10' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _digitMinute1) == 0x000368, "Member 'UBattleTimerWidget::_digitMinute1' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _digitSecond10) == 0x000370, "Member 'UBattleTimerWidget::_digitSecond10' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _digitSecond1) == 0x000378, "Member 'UBattleTimerWidget::_digitSecond1' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _colon) == 0x000380, "Member 'UBattleTimerWidget::_colon' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _timerBase) == 0x000388, "Member 'UBattleTimerWidget::_timerBase' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _tintWhite) == 0x000390, "Member 'UBattleTimerWidget::_tintWhite' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _tintYellow) == 0x0003B8, "Member 'UBattleTimerWidget::_tintYellow' has a wrong offset!");
static_assert(offsetof(UBattleTimerWidget, _tintRed) == 0x0003E0, "Member 'UBattleTimerWidget::_tintRed' has a wrong offset!");

// Class InGameModule.BeamParticleSystemComponent
// 0x0770 (0x0FB0 - 0x0840)
class UBeamParticleSystemComponent final : public UBattleCustomParticleSystemComponent
{
public:
	class USceneComponent*                        _attachTarget;                                     // 0x0840(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_848[0x6F8];                                    // 0x0848(0x06F8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sorceTangentDistanceRate;                         // 0x0F40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F44[0x4];                                      // 0x0F44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSimpleKeyVectorData>           _sourceTangentWhipKeyData;                         // 0x0F48(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyScalarData>           _sourceStrangthWhipKeyData;                        // 0x0F58(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyVectorData>           _sourceOffsetWhipKeyData;                          // 0x0F68(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _targetTangentDistanceRate;                        // 0x0F78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F7C[0x4];                                      // 0x0F7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSimpleKeyVectorData>           _targetTangentWhipKeyData;                         // 0x0F80(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyScalarData>           _targetStrangthWhipKeyData;                        // 0x0F90(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyVectorData>           _targetOffsetWhipKeyData;                          // 0x0FA0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BP_AttachTargetMesh(class USceneComponent* Target, const class FName SocketName);
	void BP_ClearAllSimpleKey();
	void BP_DetachTarget(bool Release);
	void BP_Release(float Span, EEasingFunc Type);
	void BP_SetSourceLocation(const struct FVector& Location);
	void BP_SetSourceStrength(float Strength);
	void BP_SetSourceTangent(const struct FVector& Tangent);
	void BP_SetTargetLocation(const struct FVector& Location);
	void BP_SetTargetStrength(float Strength);
	void BP_SetTargetTangent(const struct FVector& Tangent);
	void BP_SetUpSourceStrangthKeyData(const TArray<struct FSimpleKeyScalarData>& Data);
	void BP_SetUpSourceTangentKeyData(const TArray<struct FSimpleKeyVectorData>& Data);
	void BP_SetUpTargetStrangthKeyData(const TArray<struct FSimpleKeyScalarData>& Data);
	void BP_SetUpTargetTangentKeyData(const TArray<struct FSimpleKeyVectorData>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeamParticleSystemComponent">();
	}
	static class UBeamParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBeamParticleSystemComponent>();
	}
};
static_assert(alignof(UBeamParticleSystemComponent) == 0x000010, "Wrong alignment on UBeamParticleSystemComponent");
static_assert(sizeof(UBeamParticleSystemComponent) == 0x000FB0, "Wrong size on UBeamParticleSystemComponent");
static_assert(offsetof(UBeamParticleSystemComponent, _attachTarget) == 0x000840, "Member 'UBeamParticleSystemComponent::_attachTarget' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _sorceTangentDistanceRate) == 0x000F40, "Member 'UBeamParticleSystemComponent::_sorceTangentDistanceRate' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _sourceTangentWhipKeyData) == 0x000F48, "Member 'UBeamParticleSystemComponent::_sourceTangentWhipKeyData' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _sourceStrangthWhipKeyData) == 0x000F58, "Member 'UBeamParticleSystemComponent::_sourceStrangthWhipKeyData' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _sourceOffsetWhipKeyData) == 0x000F68, "Member 'UBeamParticleSystemComponent::_sourceOffsetWhipKeyData' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _targetTangentDistanceRate) == 0x000F78, "Member 'UBeamParticleSystemComponent::_targetTangentDistanceRate' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _targetTangentWhipKeyData) == 0x000F80, "Member 'UBeamParticleSystemComponent::_targetTangentWhipKeyData' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _targetStrangthWhipKeyData) == 0x000F90, "Member 'UBeamParticleSystemComponent::_targetStrangthWhipKeyData' has a wrong offset!");
static_assert(offsetof(UBeamParticleSystemComponent, _targetOffsetWhipKeyData) == 0x000FA0, "Member 'UBeamParticleSystemComponent::_targetOffsetWhipKeyData' has a wrong offset!");

// Class InGameModule.BgAreaSoundVolume
// 0x0000 (0x0298 - 0x0298)
class ABgAreaSoundVolume final : public AAtomAreaSoundVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgAreaSoundVolume">();
	}
	static class ABgAreaSoundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABgAreaSoundVolume>();
	}
};
static_assert(alignof(ABgAreaSoundVolume) == 0x000008, "Wrong alignment on ABgAreaSoundVolume");
static_assert(sizeof(ABgAreaSoundVolume) == 0x000298, "Wrong size on ABgAreaSoundVolume");

// Class InGameModule.GameStateTraining
// 0x0008 (0x0618 - 0x0610)
class AGameStateTraining final : public AGameStateBattle
{
public:
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeTrainingSetting_NetMulticast();
	void OnViewTargetChanged_NetMulti();
	void SetActiveFriendlyFire_NetMulticast(bool IsActive);
	void SetCharacterId_NetMulti(class APlayerStateBattle* PlayerStateBattle, ECharacterId CharaID, int32 VariationNo);
	void StoreAITrainingType_NetMulti(class APlayerStateBattle* PlayerState, EAITrainingType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateTraining">();
	}
	static class AGameStateTraining* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateTraining>();
	}
};
static_assert(alignof(AGameStateTraining) == 0x000008, "Wrong alignment on AGameStateTraining");
static_assert(sizeof(AGameStateTraining) == 0x000618, "Wrong size on AGameStateTraining");

// Class InGameModule.BgBarrier
// 0x0008 (0x0228 - 0x0220)
class ABgBarrier final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgBarrier">();
	}
	static class ABgBarrier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABgBarrier>();
	}
};
static_assert(alignof(ABgBarrier) == 0x000008, "Wrong alignment on ABgBarrier");
static_assert(sizeof(ABgBarrier) == 0x000228, "Wrong size on ABgBarrier");

// Class InGameModule.GameModeLeadersBattle
// 0x0000 (0x04D8 - 0x04D8)
class AGameModeLeadersBattle final : public AGameModeBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeLeadersBattle">();
	}
	static class AGameModeLeadersBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeLeadersBattle>();
	}
};
static_assert(alignof(AGameModeLeadersBattle) == 0x000008, "Wrong alignment on AGameModeLeadersBattle");
static_assert(sizeof(AGameModeLeadersBattle) == 0x0004D8, "Wrong size on AGameModeLeadersBattle");

// Class InGameModule.BgBase
// 0x0000 (0x0220 - 0x0220)
class ABgBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgBase">();
	}
	static class ABgBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABgBase>();
	}
};
static_assert(alignof(ABgBase) == 0x000008, "Wrong alignment on ABgBase");
static_assert(sizeof(ABgBase) == 0x000220, "Wrong size on ABgBase");

// Class InGameModule.GimmickActorBase
// 0x0000 (0x0220 - 0x0220)
class AGimmickActorBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickActorBase">();
	}
	static class AGimmickActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickActorBase>();
	}
};
static_assert(alignof(AGimmickActorBase) == 0x000008, "Wrong alignment on AGimmickActorBase");
static_assert(sizeof(AGimmickActorBase) == 0x000220, "Wrong size on AGimmickActorBase");

// Class InGameModule.BgLayoutCircleComponent
// 0x0010 (0x06D0 - 0x06C0)
class UBgLayoutCircleComponent final : public UBgHismComponent
{
public:
	float                                         _radiusMin;                                        // 0x06C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _radiusMax;                                        // 0x06C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        _objectNum;                                        // 0x06C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _startAngle;                                       // 0x06CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgLayoutCircleComponent">();
	}
	static class UBgLayoutCircleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgLayoutCircleComponent>();
	}
};
static_assert(alignof(UBgLayoutCircleComponent) == 0x000010, "Wrong alignment on UBgLayoutCircleComponent");
static_assert(sizeof(UBgLayoutCircleComponent) == 0x0006D0, "Wrong size on UBgLayoutCircleComponent");
static_assert(offsetof(UBgLayoutCircleComponent, _radiusMin) == 0x0006C0, "Member 'UBgLayoutCircleComponent::_radiusMin' has a wrong offset!");
static_assert(offsetof(UBgLayoutCircleComponent, _radiusMax) == 0x0006C4, "Member 'UBgLayoutCircleComponent::_radiusMax' has a wrong offset!");
static_assert(offsetof(UBgLayoutCircleComponent, _objectNum) == 0x0006C8, "Member 'UBgLayoutCircleComponent::_objectNum' has a wrong offset!");
static_assert(offsetof(UBgLayoutCircleComponent, _startAngle) == 0x0006CC, "Member 'UBgLayoutCircleComponent::_startAngle' has a wrong offset!");

// Class InGameModule.BgLayoutComponent
// 0x0000 (0x06C0 - 0x06C0)
class UBgLayoutComponent final : public UBgHismComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgLayoutComponent">();
	}
	static class UBgLayoutComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgLayoutComponent>();
	}
};
static_assert(alignof(UBgLayoutComponent) == 0x000010, "Wrong alignment on UBgLayoutComponent");
static_assert(sizeof(UBgLayoutComponent) == 0x0006C0, "Wrong size on UBgLayoutComponent");

// Class InGameModule.BgLayoutSquareComponent
// 0x0040 (0x0700 - 0x06C0)
class UBgLayoutSquareComponent final : public UBgHismComponent
{
public:
	struct FVector                                _unitSize;                                         // 0x06C0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _loopX;                                            // 0x06CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _loopY;                                            // 0x06D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _shiftCountX;                                      // 0x06D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _shiftCountY;                                      // 0x06D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _shiftX;                                           // 0x06DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _shiftY;                                           // 0x06E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bUseInstanceLayoutRandomScale;                    // 0x06E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E5[0x3];                                      // 0x06E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _instanceLayoutRandomScaleMin;                     // 0x06E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _instanceLayoutRandomScaleMax;                     // 0x06EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bInstanceLayoutRandomRotateZ;                     // 0x06F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F1[0xF];                                      // 0x06F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgLayoutSquareComponent">();
	}
	static class UBgLayoutSquareComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgLayoutSquareComponent>();
	}
};
static_assert(alignof(UBgLayoutSquareComponent) == 0x000010, "Wrong alignment on UBgLayoutSquareComponent");
static_assert(sizeof(UBgLayoutSquareComponent) == 0x000700, "Wrong size on UBgLayoutSquareComponent");
static_assert(offsetof(UBgLayoutSquareComponent, _unitSize) == 0x0006C0, "Member 'UBgLayoutSquareComponent::_unitSize' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _loopX) == 0x0006CC, "Member 'UBgLayoutSquareComponent::_loopX' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _loopY) == 0x0006D0, "Member 'UBgLayoutSquareComponent::_loopY' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _shiftCountX) == 0x0006D4, "Member 'UBgLayoutSquareComponent::_shiftCountX' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _shiftCountY) == 0x0006D8, "Member 'UBgLayoutSquareComponent::_shiftCountY' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _shiftX) == 0x0006DC, "Member 'UBgLayoutSquareComponent::_shiftX' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _shiftY) == 0x0006E0, "Member 'UBgLayoutSquareComponent::_shiftY' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _bUseInstanceLayoutRandomScale) == 0x0006E4, "Member 'UBgLayoutSquareComponent::_bUseInstanceLayoutRandomScale' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _instanceLayoutRandomScaleMin) == 0x0006E8, "Member 'UBgLayoutSquareComponent::_instanceLayoutRandomScaleMin' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _instanceLayoutRandomScaleMax) == 0x0006EC, "Member 'UBgLayoutSquareComponent::_instanceLayoutRandomScaleMax' has a wrong offset!");
static_assert(offsetof(UBgLayoutSquareComponent, _bInstanceLayoutRandomRotateZ) == 0x0006F0, "Member 'UBgLayoutSquareComponent::_bInstanceLayoutRandomRotateZ' has a wrong offset!");

// Class InGameModule.BgPostProcessVolume
// 0x0010 (0x07E0 - 0x07D0)
class ABgPostProcessVolume final : public APostProcessVolume
{
public:
	class FName                                   _collisionProfile;                                 // 0x07D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D8[0x8];                                      // 0x07D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgPostProcessVolume">();
	}
	static class ABgPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABgPostProcessVolume>();
	}
};
static_assert(alignof(ABgPostProcessVolume) == 0x000010, "Wrong alignment on ABgPostProcessVolume");
static_assert(sizeof(ABgPostProcessVolume) == 0x0007E0, "Wrong size on ABgPostProcessVolume");
static_assert(offsetof(ABgPostProcessVolume, _collisionProfile) == 0x0007D0, "Member 'ABgPostProcessVolume::_collisionProfile' has a wrong offset!");

// Class InGameModule.Ch016Unique3Base
// 0x0070 (0x1E50 - 0x1DE0)
class ACh016Unique3Base : public ABullet
{
public:
	class UCurveFloat*                            _endCurve;                                         // 0x1DD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE0[0x50];                                    // 0x1DE0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UBulletParticleSystemComponent*         _mainParticle;                                     // 0x1E30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _beginTeleportParticle;                            // 0x1E38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _attachTeleportParticle;                           // 0x1E40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E48[0x8];                                     // 0x1E48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch016Unique3Base">();
	}
	static class ACh016Unique3Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh016Unique3Base>();
	}
};
static_assert(alignof(ACh016Unique3Base) == 0x000010, "Wrong alignment on ACh016Unique3Base");
static_assert(sizeof(ACh016Unique3Base) == 0x001E50, "Wrong size on ACh016Unique3Base");
static_assert(offsetof(ACh016Unique3Base, _endCurve) == 0x001DD8, "Member 'ACh016Unique3Base::_endCurve' has a wrong offset!");
static_assert(offsetof(ACh016Unique3Base, _mainParticle) == 0x001E30, "Member 'ACh016Unique3Base::_mainParticle' has a wrong offset!");
static_assert(offsetof(ACh016Unique3Base, _beginTeleportParticle) == 0x001E38, "Member 'ACh016Unique3Base::_beginTeleportParticle' has a wrong offset!");
static_assert(offsetof(ACh016Unique3Base, _attachTeleportParticle) == 0x001E40, "Member 'ACh016Unique3Base::_attachTeleportParticle' has a wrong offset!");

// Class InGameModule.BgProp
// 0x0148 (0x0368 - 0x0220)
class ABgProp final : public AActor
{
public:
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	EObjectSize                                   ObjectSize;                                        // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bNoEffect;                                        // 0x0274(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bNoClimb;                                         // 0x0275(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bNoDashClimb;                                     // 0x0276(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bElectric;                                        // 0x0277(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABgProp*                                _destruct;                                         // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bCanDestruct;                                     // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDestructLevel                                _destructLevel;                                    // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bUseDebris;                                       // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABgProp*>                        _dependPropList;                                   // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _bSpawnNpcCitizen;                                 // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _spawnNpcCitizenCheckDistance;                     // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bNoBuildingObject;                                // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          _destructMesh;                                     // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationAsset*                        _destructAnim;                                     // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            _debrisMesh;                                       // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _hitEffect;                                        // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPropDestructInfo>              _propDestructListTmp;                              // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FPropDestructInfo                      _propDestruct;                                     // 0x02E0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UParticleSystemComponent*>       _levelEffectList;                                  // 0x0300(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _destructDisappearSec;                             // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x1C];                                     // 0x0314(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bBroken;                                          // 0x0330(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331[0x17];                                     // 0x0331(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bAlreadyDamaged;                                  // 0x0348(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_349[0x17];                                     // 0x0349(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOutOfArea;                                        // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BgDestruct();
	void OnDependDestroyed(class AActor* Actor);
	void OnRep_AlreadyDamaged();
	void OnRep_Broken();
	void OnThawedEvent();
	void PlayBrokenSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgProp">();
	}
	static class ABgProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABgProp>();
	}
};
static_assert(alignof(ABgProp) == 0x000008, "Wrong alignment on ABgProp");
static_assert(sizeof(ABgProp) == 0x000368, "Wrong size on ABgProp");
static_assert(offsetof(ABgProp, ObjectSize) == 0x000270, "Member 'ABgProp::ObjectSize' has a wrong offset!");
static_assert(offsetof(ABgProp, _bNoEffect) == 0x000274, "Member 'ABgProp::_bNoEffect' has a wrong offset!");
static_assert(offsetof(ABgProp, _bNoClimb) == 0x000275, "Member 'ABgProp::_bNoClimb' has a wrong offset!");
static_assert(offsetof(ABgProp, _bNoDashClimb) == 0x000276, "Member 'ABgProp::_bNoDashClimb' has a wrong offset!");
static_assert(offsetof(ABgProp, _bElectric) == 0x000277, "Member 'ABgProp::_bElectric' has a wrong offset!");
static_assert(offsetof(ABgProp, _destruct) == 0x000278, "Member 'ABgProp::_destruct' has a wrong offset!");
static_assert(offsetof(ABgProp, _bCanDestruct) == 0x000280, "Member 'ABgProp::_bCanDestruct' has a wrong offset!");
static_assert(offsetof(ABgProp, _destructLevel) == 0x000284, "Member 'ABgProp::_destructLevel' has a wrong offset!");
static_assert(offsetof(ABgProp, _bUseDebris) == 0x000288, "Member 'ABgProp::_bUseDebris' has a wrong offset!");
static_assert(offsetof(ABgProp, _dependPropList) == 0x000290, "Member 'ABgProp::_dependPropList' has a wrong offset!");
static_assert(offsetof(ABgProp, _bSpawnNpcCitizen) == 0x0002A0, "Member 'ABgProp::_bSpawnNpcCitizen' has a wrong offset!");
static_assert(offsetof(ABgProp, _spawnNpcCitizenCheckDistance) == 0x0002A4, "Member 'ABgProp::_spawnNpcCitizenCheckDistance' has a wrong offset!");
static_assert(offsetof(ABgProp, _bNoBuildingObject) == 0x0002A8, "Member 'ABgProp::_bNoBuildingObject' has a wrong offset!");
static_assert(offsetof(ABgProp, _destructMesh) == 0x0002B0, "Member 'ABgProp::_destructMesh' has a wrong offset!");
static_assert(offsetof(ABgProp, _destructAnim) == 0x0002B8, "Member 'ABgProp::_destructAnim' has a wrong offset!");
static_assert(offsetof(ABgProp, _debrisMesh) == 0x0002C0, "Member 'ABgProp::_debrisMesh' has a wrong offset!");
static_assert(offsetof(ABgProp, _hitEffect) == 0x0002C8, "Member 'ABgProp::_hitEffect' has a wrong offset!");
static_assert(offsetof(ABgProp, _propDestructListTmp) == 0x0002D0, "Member 'ABgProp::_propDestructListTmp' has a wrong offset!");
static_assert(offsetof(ABgProp, _propDestruct) == 0x0002E0, "Member 'ABgProp::_propDestruct' has a wrong offset!");
static_assert(offsetof(ABgProp, _levelEffectList) == 0x000300, "Member 'ABgProp::_levelEffectList' has a wrong offset!");
static_assert(offsetof(ABgProp, _destructDisappearSec) == 0x000310, "Member 'ABgProp::_destructDisappearSec' has a wrong offset!");
static_assert(offsetof(ABgProp, _bBroken) == 0x000330, "Member 'ABgProp::_bBroken' has a wrong offset!");
static_assert(offsetof(ABgProp, _bAlreadyDamaged) == 0x000348, "Member 'ABgProp::_bAlreadyDamaged' has a wrong offset!");
static_assert(offsetof(ABgProp, bOutOfArea) == 0x000360, "Member 'ABgProp::bOutOfArea' has a wrong offset!");

// Class InGameModule.CrawlBaseGen
// 0x0120 (0x0570 - 0x0450)
class ACrawlBaseGen : public AProjectileGeneratorBattle
{
public:
	int32                                         _loopCheckNum;                                     // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _groundIgnoreDist;                                 // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkHeight;                                      // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkLow;                                         // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _wallDegThreshold;                                 // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _spawnDecalOffset;                                 // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScale;                                  // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScaleLast;                              // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABullet*>                        SpawnBulletList;                                   // 0x0480(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0xC8];                                     // 0x0490(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _spawnBulletList;                                  // 0x0558(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrawlBaseGen">();
	}
	static class ACrawlBaseGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrawlBaseGen>();
	}
};
static_assert(alignof(ACrawlBaseGen) == 0x000010, "Wrong alignment on ACrawlBaseGen");
static_assert(sizeof(ACrawlBaseGen) == 0x000570, "Wrong size on ACrawlBaseGen");
static_assert(offsetof(ACrawlBaseGen, _loopCheckNum) == 0x000448, "Member 'ACrawlBaseGen::_loopCheckNum' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _groundIgnoreDist) == 0x00044C, "Member 'ACrawlBaseGen::_groundIgnoreDist' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _checkHeight) == 0x000450, "Member 'ACrawlBaseGen::_checkHeight' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _checkLow) == 0x000454, "Member 'ACrawlBaseGen::_checkLow' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _wallDegThreshold) == 0x000458, "Member 'ACrawlBaseGen::_wallDegThreshold' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _spawnDecalOffset) == 0x00045C, "Member 'ACrawlBaseGen::_spawnDecalOffset' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _spawnDecalScale) == 0x000460, "Member 'ACrawlBaseGen::_spawnDecalScale' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _spawnDecalScaleLast) == 0x000470, "Member 'ACrawlBaseGen::_spawnDecalScaleLast' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, SpawnBulletList) == 0x000480, "Member 'ACrawlBaseGen::SpawnBulletList' has a wrong offset!");
static_assert(offsetof(ACrawlBaseGen, _spawnBulletList) == 0x000558, "Member 'ACrawlBaseGen::_spawnBulletList' has a wrong offset!");

// Class InGameModule.CrawlBaseMultiGen
// 0x0070 (0x05E0 - 0x0570)
class ACrawlBaseMultiGen : public ACrawlBaseGen
{
public:
	uint8                                         Pad_570[0x70];                                     // 0x0570(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrawlBaseMultiGen">();
	}
	static class ACrawlBaseMultiGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrawlBaseMultiGen>();
	}
};
static_assert(alignof(ACrawlBaseMultiGen) == 0x000010, "Wrong alignment on ACrawlBaseMultiGen");
static_assert(sizeof(ACrawlBaseMultiGen) == 0x0005E0, "Wrong size on ACrawlBaseMultiGen");

// Class InGameModule.Ch015Unique1ChildGen_Var1
// 0x0000 (0x05E0 - 0x05E0)
class ACh015Unique1ChildGen_Var1 final : public ACrawlBaseMultiGen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique1ChildGen_Var1">();
	}
	static class ACh015Unique1ChildGen_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique1ChildGen_Var1>();
	}
};
static_assert(alignof(ACh015Unique1ChildGen_Var1) == 0x000010, "Wrong alignment on ACh015Unique1ChildGen_Var1");
static_assert(sizeof(ACh015Unique1ChildGen_Var1) == 0x0005E0, "Wrong size on ACh015Unique1ChildGen_Var1");

// Class InGameModule.BgPropDataAsset
// 0x0050 (0x0080 - 0x0030)
class UBgPropDataAsset final : public UDataAsset
{
public:
	TMap<EDestructLevel, int32>                   _bgProbHealth;                                     // 0x0030(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgPropDataAsset">();
	}
	static class UBgPropDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgPropDataAsset>();
	}
};
static_assert(alignof(UBgPropDataAsset) == 0x000008, "Wrong alignment on UBgPropDataAsset");
static_assert(sizeof(UBgPropDataAsset) == 0x000080, "Wrong size on UBgPropDataAsset");
static_assert(offsetof(UBgPropDataAsset, _bgProbHealth) == 0x000030, "Member 'UBgPropDataAsset::_bgProbHealth' has a wrong offset!");

// Class InGameModule.BgVfxComponent
// 0x0280 (0x0330 - 0x00B0)
class alignas(0x10) UBgVfxComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ABgProp*                                _owner;                                            // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 _meshComponentList;                                // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EDamageAttribute                              _damageAttribute;                                  // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         _atomComponent;                                    // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _fireCurve;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             _fireCurvePtr;                                     // 0x0110(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimelineComponent*                     _fireFxTimeline;                                   // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               _fireEffectObj;                                    // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               _fireEndEffectObj;                                 // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x50];                                     // 0x0150(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bCanBeBurned;                                     // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPropVfxMaterial>               _fireMaterialOnStates;                             // 0x01A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _fireEffect;                                       // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _fireEndEffect;                                    // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fireColor;                                        // 0x01C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _damageFireEM;                                     // 0x01D8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _blueFireEffect;                                   // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _blueFireEndEffect;                                // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _blueFireColor;                                    // 0x01F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _damageBlueFireEM;                                 // 0x0208(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stopSpawningFireParticleTime;                     // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _leavesBurnedOutTime;                              // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _beginExtinguishTime;                              // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _debrisMeshMatSlotName;                            // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bCanBeFrozen;                                     // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _freezingCurve;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             _freezingCurvePtr;                                 // 0x0240(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimelineComponent*                     _freezeFxTimeline;                                 // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x30];                                     // 0x0270(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _bpOnSpawnIceEffect;                               // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _bpWhileIceEffectBeingExist;                       // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _bpOnEndIceEffect;                                 // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _bpOnBeginMelt;                                    // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _iceEffect;                                        // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               _iceEffectObj;                                     // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _iceEndEffect;                                     // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               _iceEndEffectObj;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPropVfxMaterial>               _frozenMaterialOnStates;                           // 0x0300(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPropVfxMaterial>               _frozenMaterialOnStatesAfterBurned;                // 0x0310(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _timeToBeginMelt;                                  // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          _onFrozenSound;                                    // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplyEffects(const struct FPropDamageParam& DamageParamProp);
	void BgVfxEventNoParam__DelegateSignature();
	void BgVfxEventOneParam__DelegateSignature(float Value);
	void DEBUG_SetVFXStateBoolTrue_OnServer(const EDamageAttribute Element);
	void FinishBurning();
	void FinishFreezing();
	void FireTimelineFloatReturn(float Value);
	void FreezeTimelineFloatReturn(float Value);
	void OnBeginExtinguish();
	void OnBeginMelt();
	void OnLeavesBurnedOut();
	void OnRep_ElementalDamageApplied();
	void ResetVfxElementFlag();
	void SpawnIceEffect();
	void StopSpawnFireParticle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgVfxComponent">();
	}
	static class UBgVfxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgVfxComponent>();
	}
};
static_assert(alignof(UBgVfxComponent) == 0x000010, "Wrong alignment on UBgVfxComponent");
static_assert(sizeof(UBgVfxComponent) == 0x000330, "Wrong size on UBgVfxComponent");
static_assert(offsetof(UBgVfxComponent, _owner) == 0x0000E0, "Member 'UBgVfxComponent::_owner' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _meshComponentList) == 0x0000E8, "Member 'UBgVfxComponent::_meshComponentList' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _damageAttribute) == 0x0000F8, "Member 'UBgVfxComponent::_damageAttribute' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _atomComponent) == 0x000100, "Member 'UBgVfxComponent::_atomComponent' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireCurve) == 0x000108, "Member 'UBgVfxComponent::_fireCurve' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireCurvePtr) == 0x000110, "Member 'UBgVfxComponent::_fireCurvePtr' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireFxTimeline) == 0x000138, "Member 'UBgVfxComponent::_fireFxTimeline' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireEffectObj) == 0x000140, "Member 'UBgVfxComponent::_fireEffectObj' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireEndEffectObj) == 0x000148, "Member 'UBgVfxComponent::_fireEndEffectObj' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _bCanBeBurned) == 0x0001A0, "Member 'UBgVfxComponent::_bCanBeBurned' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireMaterialOnStates) == 0x0001A8, "Member 'UBgVfxComponent::_fireMaterialOnStates' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireEffect) == 0x0001B8, "Member 'UBgVfxComponent::_fireEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireEndEffect) == 0x0001C0, "Member 'UBgVfxComponent::_fireEndEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _fireColor) == 0x0001C8, "Member 'UBgVfxComponent::_fireColor' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _damageFireEM) == 0x0001D8, "Member 'UBgVfxComponent::_damageFireEM' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _blueFireEffect) == 0x0001E8, "Member 'UBgVfxComponent::_blueFireEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _blueFireEndEffect) == 0x0001F0, "Member 'UBgVfxComponent::_blueFireEndEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _blueFireColor) == 0x0001F8, "Member 'UBgVfxComponent::_blueFireColor' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _damageBlueFireEM) == 0x000208, "Member 'UBgVfxComponent::_damageBlueFireEM' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _stopSpawningFireParticleTime) == 0x000218, "Member 'UBgVfxComponent::_stopSpawningFireParticleTime' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _leavesBurnedOutTime) == 0x00021C, "Member 'UBgVfxComponent::_leavesBurnedOutTime' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _beginExtinguishTime) == 0x000220, "Member 'UBgVfxComponent::_beginExtinguishTime' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _debrisMeshMatSlotName) == 0x000228, "Member 'UBgVfxComponent::_debrisMeshMatSlotName' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _bCanBeFrozen) == 0x000230, "Member 'UBgVfxComponent::_bCanBeFrozen' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _freezingCurve) == 0x000238, "Member 'UBgVfxComponent::_freezingCurve' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _freezingCurvePtr) == 0x000240, "Member 'UBgVfxComponent::_freezingCurvePtr' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _freezeFxTimeline) == 0x000268, "Member 'UBgVfxComponent::_freezeFxTimeline' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _bpOnSpawnIceEffect) == 0x0002A0, "Member 'UBgVfxComponent::_bpOnSpawnIceEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _bpWhileIceEffectBeingExist) == 0x0002B0, "Member 'UBgVfxComponent::_bpWhileIceEffectBeingExist' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _bpOnEndIceEffect) == 0x0002C0, "Member 'UBgVfxComponent::_bpOnEndIceEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _bpOnBeginMelt) == 0x0002D0, "Member 'UBgVfxComponent::_bpOnBeginMelt' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _iceEffect) == 0x0002E0, "Member 'UBgVfxComponent::_iceEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _iceEffectObj) == 0x0002E8, "Member 'UBgVfxComponent::_iceEffectObj' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _iceEndEffect) == 0x0002F0, "Member 'UBgVfxComponent::_iceEndEffect' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _iceEndEffectObj) == 0x0002F8, "Member 'UBgVfxComponent::_iceEndEffectObj' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _frozenMaterialOnStates) == 0x000300, "Member 'UBgVfxComponent::_frozenMaterialOnStates' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _frozenMaterialOnStatesAfterBurned) == 0x000310, "Member 'UBgVfxComponent::_frozenMaterialOnStatesAfterBurned' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _timeToBeginMelt) == 0x000320, "Member 'UBgVfxComponent::_timeToBeginMelt' has a wrong offset!");
static_assert(offsetof(UBgVfxComponent, _onFrozenSound) == 0x000328, "Member 'UBgVfxComponent::_onFrozenSound' has a wrong offset!");

// Class InGameModule.BgWater
// 0x0000 (0x0220 - 0x0220)
class ABgWater final : public AActor
{
public:
	void OnBeginUnderwaterEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndUnderwaterEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgWater">();
	}
	static class ABgWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABgWater>();
	}
};
static_assert(alignof(ABgWater) == 0x000008, "Wrong alignment on ABgWater");
static_assert(sizeof(ABgWater) == 0x000220, "Wrong size on ABgWater");

// Class InGameModule.Ch017Unique1
// 0x0050 (0x2020 - 0x1FD0)
class ACh017Unique1 final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x18];                                    // 0x1FD0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UHeroSphereComponent*                   _h1BulletComponent;                                // 0x1FE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeroSphereComponent*                   _b1BulletComponent;                                // 0x1FF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _bulletParticle;                                   // 0x1FF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _explosionParticle;                                // 0x2000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2008[0x18];                                    // 0x2008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishExplosionEvent(class UParticleSystemComponent* Particle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique1">();
	}
	static class ACh017Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique1>();
	}
};
static_assert(alignof(ACh017Unique1) == 0x000010, "Wrong alignment on ACh017Unique1");
static_assert(sizeof(ACh017Unique1) == 0x002020, "Wrong size on ACh017Unique1");
static_assert(offsetof(ACh017Unique1, _h1BulletComponent) == 0x001FE8, "Member 'ACh017Unique1::_h1BulletComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique1, _b1BulletComponent) == 0x001FF0, "Member 'ACh017Unique1::_b1BulletComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique1, _bulletParticle) == 0x001FF8, "Member 'ACh017Unique1::_bulletParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique1, _explosionParticle) == 0x002000, "Member 'ACh017Unique1::_explosionParticle' has a wrong offset!");

// Class InGameModule.BgWaterVolume
// 0x0000 (0x0258 - 0x0258)
class ABgWaterVolume final : public ATriggerVolume
{
public:
	void OnBeginUnderwaterEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndUnderwaterEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgWaterVolume">();
	}
	static class ABgWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABgWaterVolume>();
	}
};
static_assert(alignof(ABgWaterVolume) == 0x000008, "Wrong alignment on ABgWaterVolume");
static_assert(sizeof(ABgWaterVolume) == 0x000258, "Wrong size on ABgWaterVolume");

// Class InGameModule.Ch025Unique3Gen
// 0x0050 (0x04A0 - 0x0450)
class ACh025Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	TMap<class FName, float>                      _eventNameToScaleList;                             // 0x0448(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _spawnScale;                                       // 0x0498(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpawnBullet();
	void SpawnBullet_RPC(float SpawnScale);
	void SpawnMainBullet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch025Unique3Gen">();
	}
	static class ACh025Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh025Unique3Gen>();
	}
};
static_assert(alignof(ACh025Unique3Gen) == 0x000010, "Wrong alignment on ACh025Unique3Gen");
static_assert(sizeof(ACh025Unique3Gen) == 0x0004A0, "Wrong size on ACh025Unique3Gen");
static_assert(offsetof(ACh025Unique3Gen, _eventNameToScaleList) == 0x000448, "Member 'ACh025Unique3Gen::_eventNameToScaleList' has a wrong offset!");
static_assert(offsetof(ACh025Unique3Gen, _spawnScale) == 0x000498, "Member 'ACh025Unique3Gen::_spawnScale' has a wrong offset!");

// Class InGameModule.BotManager
// 0x0050 (0x0100 - 0x00B0)
class UBotManager final : public UActorComponent
{
public:
	TMap<class APlayerStateBattle*, EAITrainingType> _trainingAIMap;                                    // 0x00B0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotManager">();
	}
	static class UBotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotManager>();
	}
};
static_assert(alignof(UBotManager) == 0x000008, "Wrong alignment on UBotManager");
static_assert(sizeof(UBotManager) == 0x000100, "Wrong size on UBotManager");
static_assert(offsetof(UBotManager, _trainingAIMap) == 0x0000B0, "Member 'UBotManager::_trainingAIMap' has a wrong offset!");

// Class InGameModule.BPInGameActorUtilityComponent
// 0x0000 (0x00B0 - 0x00B0)
class UBPInGameActorUtilityComponent final : public UBPActorUtilityComponent
{
public:
	class UBeamParticleSystemComponent* BP_SpawnBeamEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy);

	ECommandId BP_ConverAttackIdToChargeCommand(EAttackId AttackId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPInGameActorUtilityComponent">();
	}
	static class UBPInGameActorUtilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPInGameActorUtilityComponent>();
	}
};
static_assert(alignof(UBPInGameActorUtilityComponent) == 0x000008, "Wrong alignment on UBPInGameActorUtilityComponent");
static_assert(sizeof(UBPInGameActorUtilityComponent) == 0x0000B0, "Wrong size on UBPInGameActorUtilityComponent");

// Class InGameModule.BriefingComponent
// 0x0028 (0x00D8 - 0x00B0)
class UBriefingComponent : public UActorComponent
{
public:
	bool                                          _bInit;                                            // 0x00B0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bDecision;                                        // 0x00B1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _spawnLocation;                                    // 0x00B4(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SendCancel_Server();
	void SendDecision_NetMulticast(const bool bDecision, const struct FVector2D& Location);
	void SendDecision_Server();
	void SendDecisionLocation_Server(const struct FVector& Location);
	void SendInitEnd_Server(const struct FVector& Location);
	void SendSpawnLocation_Server(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefingComponent">();
	}
	static class UBriefingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefingComponent>();
	}
};
static_assert(alignof(UBriefingComponent) == 0x000008, "Wrong alignment on UBriefingComponent");
static_assert(sizeof(UBriefingComponent) == 0x0000D8, "Wrong size on UBriefingComponent");
static_assert(offsetof(UBriefingComponent, _bInit) == 0x0000B0, "Member 'UBriefingComponent::_bInit' has a wrong offset!");
static_assert(offsetof(UBriefingComponent, _bDecision) == 0x0000B1, "Member 'UBriefingComponent::_bDecision' has a wrong offset!");
static_assert(offsetof(UBriefingComponent, _spawnLocation) == 0x0000B4, "Member 'UBriefingComponent::_spawnLocation' has a wrong offset!");

// Class InGameModule.Ch017Unique1Gen_Var01
// 0x0030 (0x05A0 - 0x0570)
class ACh017Unique1Gen_Var01 final : public ACrawlBaseGen
{
public:
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _targetPositions;                                  // 0x0578(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     _nowTransforms;                                    // 0x0588(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique1Gen_Var01">();
	}
	static class ACh017Unique1Gen_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique1Gen_Var01>();
	}
};
static_assert(alignof(ACh017Unique1Gen_Var01) == 0x000010, "Wrong alignment on ACh017Unique1Gen_Var01");
static_assert(sizeof(ACh017Unique1Gen_Var01) == 0x0005A0, "Wrong size on ACh017Unique1Gen_Var01");
static_assert(offsetof(ACh017Unique1Gen_Var01, _targetPositions) == 0x000578, "Member 'ACh017Unique1Gen_Var01::_targetPositions' has a wrong offset!");
static_assert(offsetof(ACh017Unique1Gen_Var01, _nowTransforms) == 0x000588, "Member 'ACh017Unique1Gen_Var01::_nowTransforms' has a wrong offset!");

// Class InGameModule.BriefingComponentLeadersBattle
// 0x0038 (0x0110 - 0x00D8)
class UBriefingComponentLeadersBattle final : public UBriefingComponent
{
public:
	int8                                          _order;                                            // 0x00D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x37];                                      // 0x00D9(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SendChangeLeaderOrder_NetMulticast(const int8 Order);
	void SendDecideLeaderOrder_NetMulticast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefingComponentLeadersBattle">();
	}
	static class UBriefingComponentLeadersBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefingComponentLeadersBattle>();
	}
};
static_assert(alignof(UBriefingComponentLeadersBattle) == 0x000008, "Wrong alignment on UBriefingComponentLeadersBattle");
static_assert(sizeof(UBriefingComponentLeadersBattle) == 0x000110, "Wrong size on UBriefingComponentLeadersBattle");
static_assert(offsetof(UBriefingComponentLeadersBattle, _order) == 0x0000D8, "Member 'UBriefingComponentLeadersBattle::_order' has a wrong offset!");

// Class InGameModule.Ch016Unique2Gen
// 0x0010 (0x0460 - 0x0450)
class ACh016Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACh016Unique2Shot*                      _bullet;                                           // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch016Unique2Gen">();
	}
	static class ACh016Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh016Unique2Gen>();
	}
};
static_assert(alignof(ACh016Unique2Gen) == 0x000010, "Wrong alignment on ACh016Unique2Gen");
static_assert(sizeof(ACh016Unique2Gen) == 0x000460, "Wrong size on ACh016Unique2Gen");
static_assert(offsetof(ACh016Unique2Gen, _bullet) == 0x000450, "Member 'ACh016Unique2Gen::_bullet' has a wrong offset!");

// Class InGameModule.BriefingModeComponent
// 0x0008 (0x0030 - 0x0028)
class UBriefingModeComponent : public UObject
{
public:
	class UBattleBriefingWidget*                  _briefingWidget;                                   // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefingModeComponent">();
	}
	static class UBriefingModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefingModeComponent>();
	}
};
static_assert(alignof(UBriefingModeComponent) == 0x000008, "Wrong alignment on UBriefingModeComponent");
static_assert(sizeof(UBriefingModeComponent) == 0x000030, "Wrong size on UBriefingModeComponent");
static_assert(offsetof(UBriefingModeComponent, _briefingWidget) == 0x000028, "Member 'UBriefingModeComponent::_briefingWidget' has a wrong offset!");

// Class InGameModule.BriefingModeComponentLeadersBattle
// 0x0010 (0x0040 - 0x0030)
class UBriefingModeComponentLeadersBattle final : public UBriefingModeComponent
{
public:
	TScriptInterface<class IInterface>            _poisonMistInterface;                              // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefingModeComponentLeadersBattle">();
	}
	static class UBriefingModeComponentLeadersBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefingModeComponentLeadersBattle>();
	}
};
static_assert(alignof(UBriefingModeComponentLeadersBattle) == 0x000008, "Wrong alignment on UBriefingModeComponentLeadersBattle");
static_assert(sizeof(UBriefingModeComponentLeadersBattle) == 0x000040, "Wrong size on UBriefingModeComponentLeadersBattle");
static_assert(offsetof(UBriefingModeComponentLeadersBattle, _poisonMistInterface) == 0x000030, "Member 'UBriefingModeComponentLeadersBattle::_poisonMistInterface' has a wrong offset!");

// Class InGameModule.BuffParam
// 0x0060 (0x0088 - 0x0028)
class UBuffParam final : public UObject
{
public:
	class APlayerStateBattle*                     _owner;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _attackAdjustRate;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _attackAdjustRate_PlusUltra;                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _attackAdjustRate_SpecialRule;                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _attackAdjustRate_GuardPoint;                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _attackAdjustRate_TeamRole;                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _attackAdjustRate_WearBlueFlame;                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durableAdjustRate;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durableAdjustRate_Poisonmist;                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durableAdjustRate_Unbreakable;                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durableAdjustRate_CharacterProperty;              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durableAdjustRate_TeamRole;                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reloadAdjustRate;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reloadAdjustRate_PlusUltra;                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reloadAdjustRate_TeamRole;                        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reloadAdjustRate_SpecialRule;                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _reloadAdjustRate_WearBlueFlame;                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _gravityAdjustRate;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _jumpAdjustRate;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _moveSpeedAdjustRate_TeamRole;                     // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _regenerationAdjustRate_TeamRole;                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healingAdjustRate_TeamRole;                       // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_SetAttackAdjustRate(float Rate);
	void BP_SetAttackAdjustRate_PlusUltra(float Rate);
	void BP_SetAttackAdjustRate_SpecialRule(float Rate);
	void BP_SetAttackAdjustRate_WearBlueFlame(float Rate);
	void BP_SetDurableAdjustRate(float Rate);
	void BP_SetDurableAdjustRate_CharacterProperty(float Rate);
	void BP_SetDurableAdjustRate_Poisonmist(float Rate);
	void BP_SetDurableAdjustRate_Unbreakable(float Rate);
	void BP_SetGravityAdjustRate(float Rate);
	void BP_SetJumpAdjustRate(float Rate);
	void BP_SetJumpAdjustRateDivision(float Rate);
	void BP_SetJumpAdjustRateMultiply(float Rate);
	void BP_SetMoveSpeedAdjustRate_TeamRole(float Rate);
	void BP_SetReloadAdjustRate(float Rate);
	void BP_SetReloadAdjustRate_PlusUltra(float Rate);
	void BP_SetReloadAdjustRate_SpecialRule(float Rate);
	void BP_SetReloadAdjustRate_TeamRole(float Rate);
	void BP_SetReloadAdjustRate_WearBlueFlame(float Rate);

	float BP_GetAttackAdjustRate() const;
	float BP_GetAttackAdjustRate_GuardPoint() const;
	float BP_GetAttackAdjustRate_PlusUltra() const;
	float BP_GetAttackAdjustRate_SpecialRule() const;
	float BP_GetAttackAdjustRate_TeamRole() const;
	float BP_GetAttackAdjustRate_WearBlueFlame() const;
	float BP_GetDurableAdjustRate() const;
	float BP_GetDurableAdjustRate_CharacterProperty() const;
	float BP_GetDurableAdjustRate_PoisonMist() const;
	float BP_GetDurableAdjustRate_TeamRole() const;
	float BP_GetDurableAdjustRate_Unbreakable() const;
	float BP_GetGravityAdjustRate() const;
	float BP_GetJumpAdjustRate() const;
	float BP_GetMoveSpeedAdjustRate_TeamRole() const;
	float BP_GetRegenerationAdjustRate_TeamRole() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffParam">();
	}
	static class UBuffParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffParam>();
	}
};
static_assert(alignof(UBuffParam) == 0x000008, "Wrong alignment on UBuffParam");
static_assert(sizeof(UBuffParam) == 0x000088, "Wrong size on UBuffParam");
static_assert(offsetof(UBuffParam, _owner) == 0x000028, "Member 'UBuffParam::_owner' has a wrong offset!");
static_assert(offsetof(UBuffParam, _attackAdjustRate) == 0x000030, "Member 'UBuffParam::_attackAdjustRate' has a wrong offset!");
static_assert(offsetof(UBuffParam, _attackAdjustRate_PlusUltra) == 0x000034, "Member 'UBuffParam::_attackAdjustRate_PlusUltra' has a wrong offset!");
static_assert(offsetof(UBuffParam, _attackAdjustRate_SpecialRule) == 0x000038, "Member 'UBuffParam::_attackAdjustRate_SpecialRule' has a wrong offset!");
static_assert(offsetof(UBuffParam, _attackAdjustRate_GuardPoint) == 0x00003C, "Member 'UBuffParam::_attackAdjustRate_GuardPoint' has a wrong offset!");
static_assert(offsetof(UBuffParam, _attackAdjustRate_TeamRole) == 0x000040, "Member 'UBuffParam::_attackAdjustRate_TeamRole' has a wrong offset!");
static_assert(offsetof(UBuffParam, _attackAdjustRate_WearBlueFlame) == 0x000044, "Member 'UBuffParam::_attackAdjustRate_WearBlueFlame' has a wrong offset!");
static_assert(offsetof(UBuffParam, _durableAdjustRate) == 0x000048, "Member 'UBuffParam::_durableAdjustRate' has a wrong offset!");
static_assert(offsetof(UBuffParam, _durableAdjustRate_Poisonmist) == 0x00004C, "Member 'UBuffParam::_durableAdjustRate_Poisonmist' has a wrong offset!");
static_assert(offsetof(UBuffParam, _durableAdjustRate_Unbreakable) == 0x000050, "Member 'UBuffParam::_durableAdjustRate_Unbreakable' has a wrong offset!");
static_assert(offsetof(UBuffParam, _durableAdjustRate_CharacterProperty) == 0x000054, "Member 'UBuffParam::_durableAdjustRate_CharacterProperty' has a wrong offset!");
static_assert(offsetof(UBuffParam, _durableAdjustRate_TeamRole) == 0x000058, "Member 'UBuffParam::_durableAdjustRate_TeamRole' has a wrong offset!");
static_assert(offsetof(UBuffParam, _reloadAdjustRate) == 0x00005C, "Member 'UBuffParam::_reloadAdjustRate' has a wrong offset!");
static_assert(offsetof(UBuffParam, _reloadAdjustRate_PlusUltra) == 0x000060, "Member 'UBuffParam::_reloadAdjustRate_PlusUltra' has a wrong offset!");
static_assert(offsetof(UBuffParam, _reloadAdjustRate_TeamRole) == 0x000064, "Member 'UBuffParam::_reloadAdjustRate_TeamRole' has a wrong offset!");
static_assert(offsetof(UBuffParam, _reloadAdjustRate_SpecialRule) == 0x000068, "Member 'UBuffParam::_reloadAdjustRate_SpecialRule' has a wrong offset!");
static_assert(offsetof(UBuffParam, _reloadAdjustRate_WearBlueFlame) == 0x00006C, "Member 'UBuffParam::_reloadAdjustRate_WearBlueFlame' has a wrong offset!");
static_assert(offsetof(UBuffParam, _gravityAdjustRate) == 0x000070, "Member 'UBuffParam::_gravityAdjustRate' has a wrong offset!");
static_assert(offsetof(UBuffParam, _jumpAdjustRate) == 0x000074, "Member 'UBuffParam::_jumpAdjustRate' has a wrong offset!");
static_assert(offsetof(UBuffParam, _moveSpeedAdjustRate_TeamRole) == 0x000078, "Member 'UBuffParam::_moveSpeedAdjustRate_TeamRole' has a wrong offset!");
static_assert(offsetof(UBuffParam, _regenerationAdjustRate_TeamRole) == 0x00007C, "Member 'UBuffParam::_regenerationAdjustRate_TeamRole' has a wrong offset!");
static_assert(offsetof(UBuffParam, _healingAdjustRate_TeamRole) == 0x000080, "Member 'UBuffParam::_healingAdjustRate_TeamRole' has a wrong offset!");

// Class InGameModule.Ch017Unique2Gen
// 0x0060 (0x04B0 - 0x0450)
#pragma pack(push, 0x1)
class alignas(0x10) ACh017Unique2Gen : public AProjectileGeneratorBattle
{
public:
	class ACh017Unique2*                          _spawnedTrap;                                      // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bCreateChildBullet;                               // 0x0450(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _rayHitActor;                                      // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x48];                                     // 0x0460(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRepCreateBullet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2Gen">();
	}
	static class ACh017Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2Gen>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACh017Unique2Gen) == 0x000010, "Wrong alignment on ACh017Unique2Gen");
static_assert(sizeof(ACh017Unique2Gen) == 0x0004B0, "Wrong size on ACh017Unique2Gen");
static_assert(offsetof(ACh017Unique2Gen, _spawnedTrap) == 0x000448, "Member 'ACh017Unique2Gen::_spawnedTrap' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Gen, _bCreateChildBullet) == 0x000450, "Member 'ACh017Unique2Gen::_bCreateChildBullet' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Gen, _rayHitActor) == 0x000458, "Member 'ACh017Unique2Gen::_rayHitActor' has a wrong offset!");

// Class InGameModule.Ch013Unique3
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh013Unique3 final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch013Unique3">();
	}
	static class ACh013Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh013Unique3>();
	}
};
static_assert(alignof(ACh013Unique3) == 0x000010, "Wrong alignment on ACh013Unique3");
static_assert(sizeof(ACh013Unique3) == 0x001FD0, "Wrong size on ACh013Unique3");

// Class InGameModule.BulletCable
// 0x0010 (0x1FE0 - 0x1FD0)
class ABulletCable final : public ACustomBullet
{
public:
	class UCableComponent*                        _cable;                                            // 0x1FD0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialControlComponent*              _materialControl;                                  // 0x1FD8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletCable">();
	}
	static class ABulletCable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletCable>();
	}
};
static_assert(alignof(ABulletCable) == 0x000010, "Wrong alignment on ABulletCable");
static_assert(sizeof(ABulletCable) == 0x001FE0, "Wrong size on ABulletCable");
static_assert(offsetof(ABulletCable, _cable) == 0x001FD0, "Member 'ABulletCable::_cable' has a wrong offset!");
static_assert(offsetof(ABulletCable, _materialControl) == 0x001FD8, "Member 'ABulletCable::_materialControl' has a wrong offset!");

// Class InGameModule.Ch102Unique1
// 0x0160 (0x1F40 - 0x1DE0)
class ACh102Unique1 final : public ABullet
{
public:
	class UHairMeshComponent*                     _hairMain;                                         // 0x1DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHairMeshSetup                         _mainSetup;                                        // 0x1DE0(0x00A0)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _endCurve;                                         // 0x1E80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _alphaCurveTarget;                                 // 0x1E88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x1E90(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    _baseHitPrimitive;                                 // 0x1ED0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _ownerMeshComp;                                    // 0x1ED8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _nodeName;                                         // 0x1EE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EE8[0x10];                                    // 0x1EE8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _mid;                                              // 0x1EF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F00[0x40];                                    // 0x1F00(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch102Unique1">();
	}
	static class ACh102Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh102Unique1>();
	}
};
static_assert(alignof(ACh102Unique1) == 0x000010, "Wrong alignment on ACh102Unique1");
static_assert(sizeof(ACh102Unique1) == 0x001F40, "Wrong size on ACh102Unique1");
static_assert(offsetof(ACh102Unique1, _hairMain) == 0x001DD8, "Member 'ACh102Unique1::_hairMain' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _mainSetup) == 0x001DE0, "Member 'ACh102Unique1::_mainSetup' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _endCurve) == 0x001E80, "Member 'ACh102Unique1::_endCurve' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _alphaCurveTarget) == 0x001E88, "Member 'ACh102Unique1::_alphaCurveTarget' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _graduallyAlpha) == 0x001E90, "Member 'ACh102Unique1::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _baseHitPrimitive) == 0x001ED0, "Member 'ACh102Unique1::_baseHitPrimitive' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _ownerMeshComp) == 0x001ED8, "Member 'ACh102Unique1::_ownerMeshComp' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _nodeName) == 0x001EE0, "Member 'ACh102Unique1::_nodeName' has a wrong offset!");
static_assert(offsetof(ACh102Unique1, _mid) == 0x001EF8, "Member 'ACh102Unique1::_mid' has a wrong offset!");

// Class InGameModule.BulletCameraShakeComponent
// 0x00E0 (0x0190 - 0x00B0)
class UBulletCameraShakeComponent final : public UCustomBulletComponentBase
{
public:
	struct FBulletCameraShakeInfo                 _shakeMyself;                                      // 0x00B0(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBulletCameraShakeInfo                 _shakeOther;                                       // 0x0120(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void OnHitBackground(const struct FHitResult& HitResult);
	void OnHitCharacter(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletCameraShakeComponent">();
	}
	static class UBulletCameraShakeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletCameraShakeComponent>();
	}
};
static_assert(alignof(UBulletCameraShakeComponent) == 0x000008, "Wrong alignment on UBulletCameraShakeComponent");
static_assert(sizeof(UBulletCameraShakeComponent) == 0x000190, "Wrong size on UBulletCameraShakeComponent");
static_assert(offsetof(UBulletCameraShakeComponent, _shakeMyself) == 0x0000B0, "Member 'UBulletCameraShakeComponent::_shakeMyself' has a wrong offset!");
static_assert(offsetof(UBulletCameraShakeComponent, _shakeOther) == 0x000120, "Member 'UBulletCameraShakeComponent::_shakeOther' has a wrong offset!");

// Class InGameModule.Ch017Unique1ChargeChild
// 0x0080 (0x1E60 - 0x1DE0)
class ACh017Unique1ChargeChild final : public ABullet
{
public:
	class UHeroSphereComponent*                   _b1Collision;                                      // 0x1DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroCapsuleComponent*                  _h1Collision;                                      // 0x1DE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroCapsuleComponent*                  _h2Collision;                                      // 0x1DE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DF0[0x30];                                    // 0x1DF0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _hitSE;                                            // 0x1E20(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _hitSeComponent;                                   // 0x1E40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _bulletParticle;                                   // 0x1E48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _explosionParticle;                                // 0x1E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E58[0x8];                                     // 0x1E58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishExplosionEffectEvent(class UParticleSystemComponent* Particle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique1ChargeChild">();
	}
	static class ACh017Unique1ChargeChild* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique1ChargeChild>();
	}
};
static_assert(alignof(ACh017Unique1ChargeChild) == 0x000010, "Wrong alignment on ACh017Unique1ChargeChild");
static_assert(sizeof(ACh017Unique1ChargeChild) == 0x001E60, "Wrong size on ACh017Unique1ChargeChild");
static_assert(offsetof(ACh017Unique1ChargeChild, _b1Collision) == 0x001DD8, "Member 'ACh017Unique1ChargeChild::_b1Collision' has a wrong offset!");
static_assert(offsetof(ACh017Unique1ChargeChild, _h1Collision) == 0x001DE0, "Member 'ACh017Unique1ChargeChild::_h1Collision' has a wrong offset!");
static_assert(offsetof(ACh017Unique1ChargeChild, _h2Collision) == 0x001DE8, "Member 'ACh017Unique1ChargeChild::_h2Collision' has a wrong offset!");
static_assert(offsetof(ACh017Unique1ChargeChild, _hitSE) == 0x001E20, "Member 'ACh017Unique1ChargeChild::_hitSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique1ChargeChild, _hitSeComponent) == 0x001E40, "Member 'ACh017Unique1ChargeChild::_hitSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique1ChargeChild, _bulletParticle) == 0x001E48, "Member 'ACh017Unique1ChargeChild::_bulletParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique1ChargeChild, _explosionParticle) == 0x001E50, "Member 'ACh017Unique1ChargeChild::_explosionParticle' has a wrong offset!");

// Class InGameModule.BulletHoming
// 0x0110 (0x1EF0 - 0x1DE0)
class ABulletHoming final : public ABullet
{
public:
	float                                         _homingRateInitial;                                // 0x1DD8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingRateEnd;                                    // 0x1DDC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingTime;                                       // 0x1DE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingMaxDistance;                                // 0x1DE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bAdjustHomingRateByDistance;                      // 0x1DE8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _transitionEasingType;                             // 0x1DE9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bPassingedDestroy;                                // 0x1DEA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DEB[0x105];                                   // 0x1DEB(0x0105)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACharacterBattle* BP_GetOwnerBtl();
	void BP_PostBeginPlay();

	class FName BP_GetSocketName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletHoming">();
	}
	static class ABulletHoming* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletHoming>();
	}
};
static_assert(alignof(ABulletHoming) == 0x000010, "Wrong alignment on ABulletHoming");
static_assert(sizeof(ABulletHoming) == 0x001EF0, "Wrong size on ABulletHoming");
static_assert(offsetof(ABulletHoming, _homingRateInitial) == 0x001DD8, "Member 'ABulletHoming::_homingRateInitial' has a wrong offset!");
static_assert(offsetof(ABulletHoming, _homingRateEnd) == 0x001DDC, "Member 'ABulletHoming::_homingRateEnd' has a wrong offset!");
static_assert(offsetof(ABulletHoming, _homingTime) == 0x001DE0, "Member 'ABulletHoming::_homingTime' has a wrong offset!");
static_assert(offsetof(ABulletHoming, _homingMaxDistance) == 0x001DE4, "Member 'ABulletHoming::_homingMaxDistance' has a wrong offset!");
static_assert(offsetof(ABulletHoming, _bAdjustHomingRateByDistance) == 0x001DE8, "Member 'ABulletHoming::_bAdjustHomingRateByDistance' has a wrong offset!");
static_assert(offsetof(ABulletHoming, _transitionEasingType) == 0x001DE9, "Member 'ABulletHoming::_transitionEasingType' has a wrong offset!");
static_assert(offsetof(ABulletHoming, _bPassingedDestroy) == 0x001DEA, "Member 'ABulletHoming::_bPassingedDestroy' has a wrong offset!");

// Class InGameModule.BulletManageList
// 0x0050 (0x0080 - 0x0030)
class UBulletManageList final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletManageList">();
	}
	static class UBulletManageList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletManageList>();
	}
};
static_assert(alignof(UBulletManageList) == 0x000008, "Wrong alignment on UBulletManageList");
static_assert(sizeof(UBulletManageList) == 0x000080, "Wrong size on UBulletManageList");

// Class InGameModule.BulletParticleSetComponent
// 0x00A0 (0x0150 - 0x00B0)
class UBulletParticleSetComponent final : public UActorComponent
{
public:
	struct FTransform                             _offsetTRS;                                        // 0x00B0(0x0030)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EViewType                                     _viewType;                                         // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayTiming                                   _playTiming;                                       // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _tbl;                                              // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _onGround;                                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _turnToBullet;                                     // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _onGroundHeight;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x00F8(0x0040)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          _bIsPlayEffect;                                    // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _ownerCharacter;                                   // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletParticleSetComponent">();
	}
	static class UBulletParticleSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletParticleSetComponent>();
	}
};
static_assert(alignof(UBulletParticleSetComponent) == 0x000010, "Wrong alignment on UBulletParticleSetComponent");
static_assert(sizeof(UBulletParticleSetComponent) == 0x000150, "Wrong size on UBulletParticleSetComponent");
static_assert(offsetof(UBulletParticleSetComponent, _offsetTRS) == 0x0000B0, "Member 'UBulletParticleSetComponent::_offsetTRS' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _viewType) == 0x0000E0, "Member 'UBulletParticleSetComponent::_viewType' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _playTiming) == 0x0000E1, "Member 'UBulletParticleSetComponent::_playTiming' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _tbl) == 0x0000E8, "Member 'UBulletParticleSetComponent::_tbl' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _onGround) == 0x0000F0, "Member 'UBulletParticleSetComponent::_onGround' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _turnToBullet) == 0x0000F1, "Member 'UBulletParticleSetComponent::_turnToBullet' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _onGroundHeight) == 0x0000F4, "Member 'UBulletParticleSetComponent::_onGroundHeight' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _graduallyAlpha) == 0x0000F8, "Member 'UBulletParticleSetComponent::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _bIsPlayEffect) == 0x000138, "Member 'UBulletParticleSetComponent::_bIsPlayEffect' has a wrong offset!");
static_assert(offsetof(UBulletParticleSetComponent, _ownerCharacter) == 0x000140, "Member 'UBulletParticleSetComponent::_ownerCharacter' has a wrong offset!");

// Class InGameModule.Ch102Unique2Gen
// 0x0040 (0x0490 - 0x0450)
class ACh102Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	TArray<class FName>                           _shotNodes;                                        // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x38];                                     // 0x0458(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch102Unique2Gen">();
	}
	static class ACh102Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh102Unique2Gen>();
	}
};
static_assert(alignof(ACh102Unique2Gen) == 0x000010, "Wrong alignment on ACh102Unique2Gen");
static_assert(sizeof(ACh102Unique2Gen) == 0x000490, "Wrong size on ACh102Unique2Gen");
static_assert(offsetof(ACh102Unique2Gen, _shotNodes) == 0x000448, "Member 'ACh102Unique2Gen::_shotNodes' has a wrong offset!");

// Class InGameModule.BulletParticleSystemComponent
// 0x00B0 (0x08F0 - 0x0840)
class UBulletParticleSystemComponent final : public UBattleCustomParticleSystemComponent
{
public:
	struct FTransform                             _attachOffset;                                     // 0x0840(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   _attachCharacterNode;                              // 0x0870(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _effectRoot;                                       // 0x0878(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_879[0x3];                                      // 0x0879(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _detachTimer;                                      // 0x087C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _locateOnly;                                       // 0x0880(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _turnToBullet;                                     // 0x0881(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_882[0x6];                                      // 0x0882(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileGeneratorBattle*             _ownerGenerator;                                   // 0x0888(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABullet*                                _ownerBullet;                                      // 0x0890(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_898[0x8];                                      // 0x0898(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _effRootMat;                                       // 0x08A0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               _rotOffset;                                        // 0x08D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8DC[0x14];                                     // 0x08DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletParticleSystemComponent">();
	}
	static class UBulletParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletParticleSystemComponent>();
	}
};
static_assert(alignof(UBulletParticleSystemComponent) == 0x000010, "Wrong alignment on UBulletParticleSystemComponent");
static_assert(sizeof(UBulletParticleSystemComponent) == 0x0008F0, "Wrong size on UBulletParticleSystemComponent");
static_assert(offsetof(UBulletParticleSystemComponent, _attachOffset) == 0x000840, "Member 'UBulletParticleSystemComponent::_attachOffset' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _attachCharacterNode) == 0x000870, "Member 'UBulletParticleSystemComponent::_attachCharacterNode' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _effectRoot) == 0x000878, "Member 'UBulletParticleSystemComponent::_effectRoot' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _detachTimer) == 0x00087C, "Member 'UBulletParticleSystemComponent::_detachTimer' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _locateOnly) == 0x000880, "Member 'UBulletParticleSystemComponent::_locateOnly' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _turnToBullet) == 0x000881, "Member 'UBulletParticleSystemComponent::_turnToBullet' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _ownerGenerator) == 0x000888, "Member 'UBulletParticleSystemComponent::_ownerGenerator' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _ownerBullet) == 0x000890, "Member 'UBulletParticleSystemComponent::_ownerBullet' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _effRootMat) == 0x0008A0, "Member 'UBulletParticleSystemComponent::_effRootMat' has a wrong offset!");
static_assert(offsetof(UBulletParticleSystemComponent, _rotOffset) == 0x0008D0, "Member 'UBulletParticleSystemComponent::_rotOffset' has a wrong offset!");

// Class InGameModule.Ch015Unique2ChildGen_Var1
// 0x0060 (0x04B0 - 0x0450)
class ACh015Unique2ChildGen_Var1 final : public AProjectileGeneratorBattle
{
public:
	float                                         _searchHeightOffset;                               // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxHitDepth;                                      // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x60];                                     // 0x0450(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique2ChildGen_Var1">();
	}
	static class ACh015Unique2ChildGen_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique2ChildGen_Var1>();
	}
};
static_assert(alignof(ACh015Unique2ChildGen_Var1) == 0x000010, "Wrong alignment on ACh015Unique2ChildGen_Var1");
static_assert(sizeof(ACh015Unique2ChildGen_Var1) == 0x0004B0, "Wrong size on ACh015Unique2ChildGen_Var1");
static_assert(offsetof(ACh015Unique2ChildGen_Var1, _searchHeightOffset) == 0x000448, "Member 'ACh015Unique2ChildGen_Var1::_searchHeightOffset' has a wrong offset!");
static_assert(offsetof(ACh015Unique2ChildGen_Var1, _maxHitDepth) == 0x00044C, "Member 'ACh015Unique2ChildGen_Var1::_maxHitDepth' has a wrong offset!");

// Class InGameModule.BulletRestoreComponent
// 0x0038 (0x00E8 - 0x00B0)
class UBulletRestoreComponent final : public UActorComponent
{
public:
	class ABullet*                                _ownerBullet;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletRestoreComponent">();
	}
	static class UBulletRestoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletRestoreComponent>();
	}
};
static_assert(alignof(UBulletRestoreComponent) == 0x000008, "Wrong alignment on UBulletRestoreComponent");
static_assert(sizeof(UBulletRestoreComponent) == 0x0000E8, "Wrong size on UBulletRestoreComponent");
static_assert(offsetof(UBulletRestoreComponent, _ownerBullet) == 0x0000B0, "Member 'UBulletRestoreComponent::_ownerBullet' has a wrong offset!");

// Class InGameModule.BulletSpawnInfoBase
// 0x00B0 (0x02B0 - 0x0200)
class UBulletSpawnInfoBase final : public USceneComponent
{
public:
	TArray<class UParticleSystem*>                _spawnParticleList;                                // 0x01F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        _particleScaleList;                                // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _bCastShadow;                                      // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _spawnIndex;                                       // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        _arrowComponent;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBulletSpawnEffectInfoList             _battleEventInfo;                                  // 0x0228(0x0060)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGraduallyAlpha>                _graduallyAlpha;                                   // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletSpawnInfoBase">();
	}
	static class UBulletSpawnInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletSpawnInfoBase>();
	}
};
static_assert(alignof(UBulletSpawnInfoBase) == 0x000010, "Wrong alignment on UBulletSpawnInfoBase");
static_assert(sizeof(UBulletSpawnInfoBase) == 0x0002B0, "Wrong size on UBulletSpawnInfoBase");
static_assert(offsetof(UBulletSpawnInfoBase, _spawnParticleList) == 0x0001F8, "Member 'UBulletSpawnInfoBase::_spawnParticleList' has a wrong offset!");
static_assert(offsetof(UBulletSpawnInfoBase, _particleScaleList) == 0x000208, "Member 'UBulletSpawnInfoBase::_particleScaleList' has a wrong offset!");
static_assert(offsetof(UBulletSpawnInfoBase, _bCastShadow) == 0x000218, "Member 'UBulletSpawnInfoBase::_bCastShadow' has a wrong offset!");
static_assert(offsetof(UBulletSpawnInfoBase, _spawnIndex) == 0x00021C, "Member 'UBulletSpawnInfoBase::_spawnIndex' has a wrong offset!");
static_assert(offsetof(UBulletSpawnInfoBase, _arrowComponent) == 0x000220, "Member 'UBulletSpawnInfoBase::_arrowComponent' has a wrong offset!");
static_assert(offsetof(UBulletSpawnInfoBase, _battleEventInfo) == 0x000228, "Member 'UBulletSpawnInfoBase::_battleEventInfo' has a wrong offset!");
static_assert(offsetof(UBulletSpawnInfoBase, _graduallyAlpha) == 0x000288, "Member 'UBulletSpawnInfoBase::_graduallyAlpha' has a wrong offset!");

// Class InGameModule.BulletTimeEventComponent
// 0x00B0 (0x0160 - 0x00B0)
class alignas(0x10) UBulletTimeEventComponent final : public UActorComponent
{
public:
	class ABullet*                                _ownerBullet;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<uint32, struct FEventData>               _timeEventData;                                    // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x58];                                     // 0x0108(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletTimeEventComponent">();
	}
	static class UBulletTimeEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletTimeEventComponent>();
	}
};
static_assert(alignof(UBulletTimeEventComponent) == 0x000010, "Wrong alignment on UBulletTimeEventComponent");
static_assert(sizeof(UBulletTimeEventComponent) == 0x000160, "Wrong size on UBulletTimeEventComponent");
static_assert(offsetof(UBulletTimeEventComponent, _ownerBullet) == 0x0000B0, "Member 'UBulletTimeEventComponent::_ownerBullet' has a wrong offset!");
static_assert(offsetof(UBulletTimeEventComponent, _timeEventData) == 0x0000B8, "Member 'UBulletTimeEventComponent::_timeEventData' has a wrong offset!");

// Class InGameModule.PortalGen
// 0x0010 (0x0460 - 0x0450)
#pragma pack(push, 0x1)
class alignas(0x10) APortalGen : public AProjectileGeneratorBattle
{
public:
	struct FPortalGenRep                          _portalParamRep;                                   // 0x0448(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	class APortal*                                _portal;                                           // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_WarpUsing();
	void WarpUsing_RPC(const struct FPortalGenRep& GenPortal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PortalGen">();
	}
	static class APortalGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<APortalGen>();
	}
};
#pragma pack(pop)
static_assert(alignof(APortalGen) == 0x000010, "Wrong alignment on APortalGen");
static_assert(sizeof(APortalGen) == 0x000460, "Wrong size on APortalGen");
static_assert(offsetof(APortalGen, _portalParamRep) == 0x000448, "Member 'APortalGen::_portalParamRep' has a wrong offset!");
static_assert(offsetof(APortalGen, _portal) == 0x000450, "Member 'APortalGen::_portal' has a wrong offset!");

// Class InGameModule.Ch103SpecialGen
// 0x0020 (0x0480 - 0x0460)
class ACh103SpecialGen final : public APortalGen
{
public:
	TArray<class ABullet*>                        _spawnedPortalList;                                // 0x0458(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ACharacterBattle*                       _targetCharacterBattle;                            // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spawnDistance;                                    // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _efficacyRadius;                                   // 0x0474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rayCheckDistance;                                 // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableDyingCheck;                                 // 0x047C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enablePoisonMistAreaCheck;                        // 0x047D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47E[0x2];                                      // 0x047E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch103SpecialGen">();
	}
	static class ACh103SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh103SpecialGen>();
	}
};
static_assert(alignof(ACh103SpecialGen) == 0x000010, "Wrong alignment on ACh103SpecialGen");
static_assert(sizeof(ACh103SpecialGen) == 0x000480, "Wrong size on ACh103SpecialGen");
static_assert(offsetof(ACh103SpecialGen, _spawnedPortalList) == 0x000458, "Member 'ACh103SpecialGen::_spawnedPortalList' has a wrong offset!");
static_assert(offsetof(ACh103SpecialGen, _targetCharacterBattle) == 0x000468, "Member 'ACh103SpecialGen::_targetCharacterBattle' has a wrong offset!");
static_assert(offsetof(ACh103SpecialGen, _spawnDistance) == 0x000470, "Member 'ACh103SpecialGen::_spawnDistance' has a wrong offset!");
static_assert(offsetof(ACh103SpecialGen, _efficacyRadius) == 0x000474, "Member 'ACh103SpecialGen::_efficacyRadius' has a wrong offset!");
static_assert(offsetof(ACh103SpecialGen, _rayCheckDistance) == 0x000478, "Member 'ACh103SpecialGen::_rayCheckDistance' has a wrong offset!");
static_assert(offsetof(ACh103SpecialGen, _enableDyingCheck) == 0x00047C, "Member 'ACh103SpecialGen::_enableDyingCheck' has a wrong offset!");
static_assert(offsetof(ACh103SpecialGen, _enablePoisonMistAreaCheck) == 0x00047D, "Member 'ACh103SpecialGen::_enablePoisonMistAreaCheck' has a wrong offset!");

// Class InGameModule.CameraControllerBattle
// 0x0420 (0x04D0 - 0x00B0)
class alignas(0x10) UCameraControllerBattle final : public UActorComponent
{
public:
	class UGameOption*                            _gameOption;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerBattle*                _playerController;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _cameraSpeedCurveOnDeltaRot;                       // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _normalCameraInputCurve;                           // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _easyTurnCameraAdditionalRate;                     // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x30];                                     // 0x0110(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _prevViewTarget;                                   // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x388];                                    // 0x0148(0x0388)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraControllerBattle">();
	}
	static class UCameraControllerBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraControllerBattle>();
	}
};
static_assert(alignof(UCameraControllerBattle) == 0x000010, "Wrong alignment on UCameraControllerBattle");
static_assert(sizeof(UCameraControllerBattle) == 0x0004D0, "Wrong size on UCameraControllerBattle");
static_assert(offsetof(UCameraControllerBattle, _gameOption) == 0x0000B0, "Member 'UCameraControllerBattle::_gameOption' has a wrong offset!");
static_assert(offsetof(UCameraControllerBattle, _playerController) == 0x0000C8, "Member 'UCameraControllerBattle::_playerController' has a wrong offset!");
static_assert(offsetof(UCameraControllerBattle, _cameraSpeedCurveOnDeltaRot) == 0x0000F8, "Member 'UCameraControllerBattle::_cameraSpeedCurveOnDeltaRot' has a wrong offset!");
static_assert(offsetof(UCameraControllerBattle, _normalCameraInputCurve) == 0x000100, "Member 'UCameraControllerBattle::_normalCameraInputCurve' has a wrong offset!");
static_assert(offsetof(UCameraControllerBattle, _easyTurnCameraAdditionalRate) == 0x000108, "Member 'UCameraControllerBattle::_easyTurnCameraAdditionalRate' has a wrong offset!");
static_assert(offsetof(UCameraControllerBattle, _prevViewTarget) == 0x000140, "Member 'UCameraControllerBattle::_prevViewTarget' has a wrong offset!");

// Class InGameModule.Ch017Unique2Charge
// 0x0100 (0x1F50 - 0x1E50)
class ACh017Unique2Charge final : public ACh017Unique2Base
{
public:
	struct FBulletSE                              _hitSE;                                            // 0x1E48(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _hitSeComponent;                                   // 0x1E68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _fireSE;                                           // 0x1E70(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _fireSeComponent;                                  // 0x1E90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _loopFireSE;                                       // 0x1E98(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _loopFireSeComponent;                              // 0x1EB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _finishSE;                                         // 0x1EC0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _finishSeComponent;                                // 0x1EE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _trapTemplate;                                     // 0x1EE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _fireTemplate;                                     // 0x1EF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _destroyTemplate;                                  // 0x1EF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _trapParticle;                                     // 0x1F00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _fireParticle;                                     // 0x1F08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _destroyParticle;                                  // 0x1F10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F18[0x38];                                    // 0x1F18(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishTrap();
	void StopFire();
	void StopTrap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2Charge">();
	}
	static class ACh017Unique2Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2Charge>();
	}
};
static_assert(alignof(ACh017Unique2Charge) == 0x000010, "Wrong alignment on ACh017Unique2Charge");
static_assert(sizeof(ACh017Unique2Charge) == 0x001F50, "Wrong size on ACh017Unique2Charge");
static_assert(offsetof(ACh017Unique2Charge, _hitSE) == 0x001E48, "Member 'ACh017Unique2Charge::_hitSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _hitSeComponent) == 0x001E68, "Member 'ACh017Unique2Charge::_hitSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _fireSE) == 0x001E70, "Member 'ACh017Unique2Charge::_fireSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _fireSeComponent) == 0x001E90, "Member 'ACh017Unique2Charge::_fireSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _loopFireSE) == 0x001E98, "Member 'ACh017Unique2Charge::_loopFireSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _loopFireSeComponent) == 0x001EB8, "Member 'ACh017Unique2Charge::_loopFireSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _finishSE) == 0x001EC0, "Member 'ACh017Unique2Charge::_finishSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _finishSeComponent) == 0x001EE0, "Member 'ACh017Unique2Charge::_finishSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _trapTemplate) == 0x001EE8, "Member 'ACh017Unique2Charge::_trapTemplate' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _fireTemplate) == 0x001EF0, "Member 'ACh017Unique2Charge::_fireTemplate' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _destroyTemplate) == 0x001EF8, "Member 'ACh017Unique2Charge::_destroyTemplate' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _trapParticle) == 0x001F00, "Member 'ACh017Unique2Charge::_trapParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _fireParticle) == 0x001F08, "Member 'ACh017Unique2Charge::_fireParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2Charge, _destroyParticle) == 0x001F10, "Member 'ACh017Unique2Charge::_destroyParticle' has a wrong offset!");

// Class InGameModule.CameraShaker
// 0x0000 (0x00B0 - 0x00B0)
class UCameraShaker final : public UCameraModifier_CameraShake
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraShaker">();
	}
	static class UCameraShaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraShaker>();
	}
};
static_assert(alignof(UCameraShaker) == 0x000008, "Wrong alignment on UCameraShaker");
static_assert(sizeof(UCameraShaker) == 0x0000B0, "Wrong size on UCameraShaker");

// Class InGameModule.CementBase
// 0x00A0 (0x2070 - 0x1FD0)
class ACementBase : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x38];                                    // 0x1FD0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x2008(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       _mids;                                             // 0x2048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _meshProfile;                                      // 0x2058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2068[0x8];                                     // 0x2068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCrackHP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CementBase">();
	}
	static class ACementBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACementBase>();
	}
};
static_assert(alignof(ACementBase) == 0x000010, "Wrong alignment on ACementBase");
static_assert(sizeof(ACementBase) == 0x002070, "Wrong size on ACementBase");
static_assert(offsetof(ACementBase, _graduallyAlpha) == 0x002008, "Member 'ACementBase::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(ACementBase, _mids) == 0x002048, "Member 'ACementBase::_mids' has a wrong offset!");
static_assert(offsetof(ACementBase, _meshProfile) == 0x002058, "Member 'ACementBase::_meshProfile' has a wrong offset!");

// Class InGameModule.Cement
// 0x0040 (0x20B0 - 0x2070)
class ACement final : public ACementBase
{
public:
	uint8                                         Pad_2070[0x40];                                    // 0x2070(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cement">();
	}
	static class ACement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACement>();
	}
};
static_assert(alignof(ACement) == 0x000010, "Wrong alignment on ACement");
static_assert(sizeof(ACement) == 0x0020B0, "Wrong size on ACement");

// Class InGameModule.ChampionWidget
// 0x0008 (0x0358 - 0x0350)
class UChampionWidget final : public UWidgetBase
{
public:
	class UHorizontalBox*                         _emoteBox;                                         // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChampionWidget">();
	}
	static class UChampionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChampionWidget>();
	}
};
static_assert(alignof(UChampionWidget) == 0x000008, "Wrong alignment on UChampionWidget");
static_assert(sizeof(UChampionWidget) == 0x000358, "Wrong size on UChampionWidget");
static_assert(offsetof(UChampionWidget, _emoteBox) == 0x000350, "Member 'UChampionWidget::_emoteBox' has a wrong offset!");

// Class InGameModule.Cement3
// 0x0120 (0x2190 - 0x2070)
class ACement3 final : public ACementBase
{
public:
	struct FBulletSE                              _spawnSE;                                          // 0x2070(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _spawnSEComp;                                      // 0x2090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _enemyMaterial;                                    // 0x2098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _allyMaterial;                                     // 0x20A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroMeshComponent*                     _warningMesh;                                      // 0x20A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOutlineStaticMeshComponent*            _bulletMesh;                                       // 0x20B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _topAppearParticle;                                // 0x20B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _sizeAppearParticle;                               // 0x20C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C8[0xC8];                                    // 0x20C8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cement3">();
	}
	static class ACement3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACement3>();
	}
};
static_assert(alignof(ACement3) == 0x000010, "Wrong alignment on ACement3");
static_assert(sizeof(ACement3) == 0x002190, "Wrong size on ACement3");
static_assert(offsetof(ACement3, _spawnSE) == 0x002070, "Member 'ACement3::_spawnSE' has a wrong offset!");
static_assert(offsetof(ACement3, _spawnSEComp) == 0x002090, "Member 'ACement3::_spawnSEComp' has a wrong offset!");
static_assert(offsetof(ACement3, _enemyMaterial) == 0x002098, "Member 'ACement3::_enemyMaterial' has a wrong offset!");
static_assert(offsetof(ACement3, _allyMaterial) == 0x0020A0, "Member 'ACement3::_allyMaterial' has a wrong offset!");
static_assert(offsetof(ACement3, _warningMesh) == 0x0020A8, "Member 'ACement3::_warningMesh' has a wrong offset!");
static_assert(offsetof(ACement3, _bulletMesh) == 0x0020B0, "Member 'ACement3::_bulletMesh' has a wrong offset!");
static_assert(offsetof(ACement3, _topAppearParticle) == 0x0020B8, "Member 'ACement3::_topAppearParticle' has a wrong offset!");
static_assert(offsetof(ACement3, _sizeAppearParticle) == 0x0020C0, "Member 'ACement3::_sizeAppearParticle' has a wrong offset!");

// Class InGameModule.Ch016Unique3ShotDistract
// 0x0000 (0x1E50 - 0x1E50)
class ACh016Unique3ShotDistract final : public ACh016Unique3Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch016Unique3ShotDistract">();
	}
	static class ACh016Unique3ShotDistract* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh016Unique3ShotDistract>();
	}
};
static_assert(alignof(ACh016Unique3ShotDistract) == 0x000010, "Wrong alignment on ACh016Unique3ShotDistract");
static_assert(sizeof(ACh016Unique3ShotDistract) == 0x001E50, "Wrong size on ACh016Unique3ShotDistract");

// Class InGameModule.WinDemoControllerComponent
// 0x0018 (0x00C8 - 0x00B0)
class UWinDemoControllerComponent final : public UActorComponent
{
public:
	class APlayerControllerBattle*                _playerController;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _hudCommandControlComponent;                       // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        _winDemoInputComponent;                            // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinDemoControllerComponent">();
	}
	static class UWinDemoControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinDemoControllerComponent>();
	}
};
static_assert(alignof(UWinDemoControllerComponent) == 0x000008, "Wrong alignment on UWinDemoControllerComponent");
static_assert(sizeof(UWinDemoControllerComponent) == 0x0000C8, "Wrong size on UWinDemoControllerComponent");
static_assert(offsetof(UWinDemoControllerComponent, _playerController) == 0x0000B0, "Member 'UWinDemoControllerComponent::_playerController' has a wrong offset!");
static_assert(offsetof(UWinDemoControllerComponent, _hudCommandControlComponent) == 0x0000B8, "Member 'UWinDemoControllerComponent::_hudCommandControlComponent' has a wrong offset!");
static_assert(offsetof(UWinDemoControllerComponent, _winDemoInputComponent) == 0x0000C0, "Member 'UWinDemoControllerComponent::_winDemoInputComponent' has a wrong offset!");

// Class InGameModule.ProjectileReconstructGenerator
// 0x0000 (0x0450 - 0x0450)
class AProjectileReconstructGenerator : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileReconstructGenerator">();
	}
	static class AProjectileReconstructGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileReconstructGenerator>();
	}
};
static_assert(alignof(AProjectileReconstructGenerator) == 0x000010, "Wrong alignment on AProjectileReconstructGenerator");
static_assert(sizeof(AProjectileReconstructGenerator) == 0x000450, "Wrong size on AProjectileReconstructGenerator");

// Class InGameModule.Cement3Gen
// 0x0080 (0x04D0 - 0x0450)
class ACement3Gen final : public AProjectileReconstructGenerator
{
public:
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABullet*                                _cement;                                           // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCement3GenRep                         _cement3Rep;                                       // 0x0470(0x0050)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenCement3_RPC(const struct FCement3GenRep& Rep);
	void OnRep_GenCement3();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cement3Gen">();
	}
	static class ACement3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACement3Gen>();
	}
};
static_assert(alignof(ACement3Gen) == 0x000010, "Wrong alignment on ACement3Gen");
static_assert(sizeof(ACement3Gen) == 0x0004D0, "Wrong size on ACement3Gen");
static_assert(offsetof(ACement3Gen, _cement) == 0x000460, "Member 'ACement3Gen::_cement' has a wrong offset!");
static_assert(offsetof(ACement3Gen, _cement3Rep) == 0x000470, "Member 'ACement3Gen::_cement3Rep' has a wrong offset!");

// Class InGameModule.Ch023Unique2Shot
// 0x0020 (0x1FF0 - 0x1FD0)
class ACh023Unique2Shot final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x8];                                     // 0x1FD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _hitActor;                                         // 0x1FD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FE0[0x10];                                    // 0x1FE0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique2Shot">();
	}
	static class ACh023Unique2Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique2Shot>();
	}
};
static_assert(alignof(ACh023Unique2Shot) == 0x000010, "Wrong alignment on ACh023Unique2Shot");
static_assert(sizeof(ACh023Unique2Shot) == 0x001FF0, "Wrong size on ACh023Unique2Shot");
static_assert(offsetof(ACh023Unique2Shot, _hitActor) == 0x001FD8, "Member 'ACh023Unique2Shot::_hitActor' has a wrong offset!");

// Class InGameModule.Cement3Shot
// 0x0000 (0x1FD0 - 0x1FD0)
class ACement3Shot final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cement3Shot">();
	}
	static class ACement3Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACement3Shot>();
	}
};
static_assert(alignof(ACement3Shot) == 0x000010, "Wrong alignment on ACement3Shot");
static_assert(sizeof(ACement3Shot) == 0x001FD0, "Wrong size on ACement3Shot");

// Class InGameModule.Ch018_ActionAttack_Special
// 0x0008 (0x0368 - 0x0360)
class UCh018_ActionAttack_Special final : public UActionAttack_Special_Coop
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch018_ActionAttack_Special">();
	}
	static class UCh018_ActionAttack_Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCh018_ActionAttack_Special>();
	}
};
static_assert(alignof(UCh018_ActionAttack_Special) == 0x000008, "Wrong alignment on UCh018_ActionAttack_Special");
static_assert(sizeof(UCh018_ActionAttack_Special) == 0x000368, "Wrong size on UCh018_ActionAttack_Special");
static_assert(offsetof(UCh018_ActionAttack_Special, _playerState) == 0x000360, "Member 'UCh018_ActionAttack_Special::_playerState' has a wrong offset!");

// Class InGameModule.CementGen
// 0x0020 (0x0470 - 0x0450)
class ACementGen final : public AProjectileReconstructGenerator
{
public:
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABullet*                                _cement;                                           // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CementGen">();
	}
	static class ACementGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACementGen>();
	}
};
static_assert(alignof(ACementGen) == 0x000010, "Wrong alignment on ACementGen");
static_assert(sizeof(ACementGen) == 0x000470, "Wrong size on ACementGen");
static_assert(offsetof(ACementGen, _cement) == 0x000460, "Member 'ACementGen::_cement' has a wrong offset!");

// Class InGameModule.CementShot
// 0x0000 (0x1FD0 - 0x1FD0)
class ACementShot final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CementShot">();
	}
	static class ACementShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACementShot>();
	}
};
static_assert(alignof(ACementShot) == 0x000010, "Wrong alignment on ACementShot");
static_assert(sizeof(ACementShot) == 0x001FD0, "Wrong size on ACementShot");

// Class InGameModule.Ch001Unique1Gen_Var1
// 0x0040 (0x0490 - 0x0450)
class ACh001Unique1Gen_Var1 final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x48];                                     // 0x0448(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique1Gen_Var1">();
	}
	static class ACh001Unique1Gen_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique1Gen_Var1>();
	}
};
static_assert(alignof(ACh001Unique1Gen_Var1) == 0x000010, "Wrong alignment on ACh001Unique1Gen_Var1");
static_assert(sizeof(ACh001Unique1Gen_Var1) == 0x000490, "Wrong size on ACh001Unique1Gen_Var1");

// Class InGameModule.Ch025Unique1
// 0x0020 (0x1FF0 - 0x1FD0)
class ACh025Unique1 final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x8];                                     // 0x1FD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _hitActor;                                         // 0x1FD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomBulletHomingComponent*           _homingComponent;                                  // 0x1FE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FE8[0x8];                                     // 0x1FE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch025Unique1">();
	}
	static class ACh025Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh025Unique1>();
	}
};
static_assert(alignof(ACh025Unique1) == 0x000010, "Wrong alignment on ACh025Unique1");
static_assert(sizeof(ACh025Unique1) == 0x001FF0, "Wrong size on ACh025Unique1");
static_assert(offsetof(ACh025Unique1, _hitActor) == 0x001FD8, "Member 'ACh025Unique1::_hitActor' has a wrong offset!");
static_assert(offsetof(ACh025Unique1, _homingComponent) == 0x001FE0, "Member 'ACh025Unique1::_homingComponent' has a wrong offset!");

// Class InGameModule.Ch001Unique1Shot
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh001Unique1Shot final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique1Shot">();
	}
	static class ACh001Unique1Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique1Shot>();
	}
};
static_assert(alignof(ACh001Unique1Shot) == 0x000010, "Wrong alignment on ACh001Unique1Shot");
static_assert(sizeof(ACh001Unique1Shot) == 0x001FD0, "Wrong size on ACh001Unique1Shot");

// Class InGameModule.GameStateBattle_DecideStartPoint
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_DecideStartPoint final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_DecideStartPoint">();
	}
	static class UGameStateBattle_DecideStartPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_DecideStartPoint>();
	}
};
static_assert(alignof(UGameStateBattle_DecideStartPoint) == 0x000008, "Wrong alignment on UGameStateBattle_DecideStartPoint");
static_assert(sizeof(UGameStateBattle_DecideStartPoint) == 0x000038, "Wrong size on UGameStateBattle_DecideStartPoint");

// Class InGameModule.Ch001Unique2Child_Var1
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh001Unique2Child_Var1 final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique2Child_Var1">();
	}
	static class ACh001Unique2Child_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique2Child_Var1>();
	}
};
static_assert(alignof(ACh001Unique2Child_Var1) == 0x000010, "Wrong alignment on ACh001Unique2Child_Var1");
static_assert(sizeof(ACh001Unique2Child_Var1) == 0x001DE0, "Wrong size on ACh001Unique2Child_Var1");

// Class InGameModule.Ch001Unique2ChildGen_Var1
// 0x0010 (0x0460 - 0x0450)
class ACh001Unique2ChildGen_Var1 final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique2ChildGen_Var1">();
	}
	static class ACh001Unique2ChildGen_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique2ChildGen_Var1>();
	}
};
static_assert(alignof(ACh001Unique2ChildGen_Var1) == 0x000010, "Wrong alignment on ACh001Unique2ChildGen_Var1");
static_assert(sizeof(ACh001Unique2ChildGen_Var1) == 0x000460, "Wrong size on ACh001Unique2ChildGen_Var1");

// Class InGameModule.Ch001Unique2Gen_Var1
// 0x0050 (0x04A0 - 0x0450)
class ACh001Unique2Gen_Var1 final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x28];                                     // 0x0448(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ACh001Unique2Shot_Var1*                 _kickBullet;                                       // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACh001Unique2Child_Var1*                _childBullet;                                      // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x20];                                     // 0x0480(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique2Gen_Var1">();
	}
	static class ACh001Unique2Gen_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique2Gen_Var1>();
	}
};
static_assert(alignof(ACh001Unique2Gen_Var1) == 0x000010, "Wrong alignment on ACh001Unique2Gen_Var1");
static_assert(sizeof(ACh001Unique2Gen_Var1) == 0x0004A0, "Wrong size on ACh001Unique2Gen_Var1");
static_assert(offsetof(ACh001Unique2Gen_Var1, _kickBullet) == 0x000470, "Member 'ACh001Unique2Gen_Var1::_kickBullet' has a wrong offset!");
static_assert(offsetof(ACh001Unique2Gen_Var1, _childBullet) == 0x000478, "Member 'ACh001Unique2Gen_Var1::_childBullet' has a wrong offset!");

// Class InGameModule.Ch025Unique3Child
// 0x0040 (0x1E20 - 0x1DE0)
class ACh025Unique3Child final : public ABullet
{
public:
	uint8                                         Pad_1DD8[0x48];                                    // 0x1DD8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch025Unique3Child">();
	}
	static class ACh025Unique3Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh025Unique3Child>();
	}
};
static_assert(alignof(ACh025Unique3Child) == 0x000010, "Wrong alignment on ACh025Unique3Child");
static_assert(sizeof(ACh025Unique3Child) == 0x001E20, "Wrong size on ACh025Unique3Child");

// Class InGameModule.Ch001Unique2Shot_Var1
// 0x0010 (0x1FE0 - 0x1FD0)
class ACh001Unique2Shot_Var1 final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x10];                                    // 0x1FD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique2Shot_Var1">();
	}
	static class ACh001Unique2Shot_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique2Shot_Var1>();
	}
};
static_assert(alignof(ACh001Unique2Shot_Var1) == 0x000010, "Wrong alignment on ACh001Unique2Shot_Var1");
static_assert(sizeof(ACh001Unique2Shot_Var1) == 0x001FE0, "Wrong size on ACh001Unique2Shot_Var1");

// Class InGameModule.GameStateBattle_FinishBattleScene
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_FinishBattleScene final : public UGameStateBattleFiniteStateBase
{
public:
	void DisplayWinLose();
	void EndDemoSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_FinishBattleScene">();
	}
	static class UGameStateBattle_FinishBattleScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_FinishBattleScene>();
	}
};
static_assert(alignof(UGameStateBattle_FinishBattleScene) == 0x000008, "Wrong alignment on UGameStateBattle_FinishBattleScene");
static_assert(sizeof(UGameStateBattle_FinishBattleScene) == 0x000038, "Wrong size on UGameStateBattle_FinishBattleScene");

// Class InGameModule.WrappedCh023Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class AWrappedCh023Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrappedCh023Unique2Gen">();
	}
	static class AWrappedCh023Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWrappedCh023Unique2Gen>();
	}
};
static_assert(alignof(AWrappedCh023Unique2Gen) == 0x000010, "Wrong alignment on AWrappedCh023Unique2Gen");
static_assert(sizeof(AWrappedCh023Unique2Gen) == 0x000450, "Wrong size on AWrappedCh023Unique2Gen");

// Class InGameModule.Ch001Unique3
// 0x0160 (0x1F40 - 0x1DE0)
class ACh001Unique3 final : public ABullet
{
public:
	uint8                                         Pad_1DD8[0x40];                                    // 0x1DD8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x1E18(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _beamTemplate;                                     // 0x1E58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _returnBeamTemplate;                               // 0x1E60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _beamViewFriendTemplate;                           // 0x1E68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _returnBeamViewFriendTemplate;                     // 0x1E70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _beamViewEnemyTemplate;                            // 0x1E78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _returnBeamViewEnemyTemplate;                      // 0x1E80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBeamParticleSystemComponent*           _currentBeamParticle;                              // 0x1E88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBeamParticleSystemComponent*           _currentBeamParticle2;                             // 0x1E90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyVectorData>           _injectionSourceTangentWhipKeyData;                // 0x1E98(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyScalarData>           _injectionSourceStrangthWhipKeyData;               // 0x1EA8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyVectorData>           _injectionTargetTangentWhipKeyData;                // 0x1EB8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyScalarData>           _injectionTargetStrangthWhipKeyData;               // 0x1EC8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyVectorData>           _returnSourceTangentWhipKeyData;                   // 0x1ED8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyScalarData>           _returnSourceStrangthWhipKeyData;                  // 0x1EE8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyVectorData>           _returnTargetTangentWhipKeyData;                   // 0x1EF8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyScalarData>           _returnTargetStrangthWhipKeyData;                  // 0x1F08(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleKeyVectorData>           _returnTargetOffSetWhipKeyData;                    // 0x1F18(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _returnSpan;                                       // 0x1F28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _returnEasing;                                     // 0x1F2C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F2D[0x3];                                     // 0x1F2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _injectionStartLocationRate;                       // 0x1F30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F34[0xC];                                     // 0x1F34(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnHitItem(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique3">();
	}
	static class ACh001Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique3>();
	}
};
static_assert(alignof(ACh001Unique3) == 0x000010, "Wrong alignment on ACh001Unique3");
static_assert(sizeof(ACh001Unique3) == 0x001F40, "Wrong size on ACh001Unique3");
static_assert(offsetof(ACh001Unique3, _graduallyAlpha) == 0x001E18, "Member 'ACh001Unique3::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _beamTemplate) == 0x001E58, "Member 'ACh001Unique3::_beamTemplate' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnBeamTemplate) == 0x001E60, "Member 'ACh001Unique3::_returnBeamTemplate' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _beamViewFriendTemplate) == 0x001E68, "Member 'ACh001Unique3::_beamViewFriendTemplate' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnBeamViewFriendTemplate) == 0x001E70, "Member 'ACh001Unique3::_returnBeamViewFriendTemplate' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _beamViewEnemyTemplate) == 0x001E78, "Member 'ACh001Unique3::_beamViewEnemyTemplate' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnBeamViewEnemyTemplate) == 0x001E80, "Member 'ACh001Unique3::_returnBeamViewEnemyTemplate' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _currentBeamParticle) == 0x001E88, "Member 'ACh001Unique3::_currentBeamParticle' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _currentBeamParticle2) == 0x001E90, "Member 'ACh001Unique3::_currentBeamParticle2' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _injectionSourceTangentWhipKeyData) == 0x001E98, "Member 'ACh001Unique3::_injectionSourceTangentWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _injectionSourceStrangthWhipKeyData) == 0x001EA8, "Member 'ACh001Unique3::_injectionSourceStrangthWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _injectionTargetTangentWhipKeyData) == 0x001EB8, "Member 'ACh001Unique3::_injectionTargetTangentWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _injectionTargetStrangthWhipKeyData) == 0x001EC8, "Member 'ACh001Unique3::_injectionTargetStrangthWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnSourceTangentWhipKeyData) == 0x001ED8, "Member 'ACh001Unique3::_returnSourceTangentWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnSourceStrangthWhipKeyData) == 0x001EE8, "Member 'ACh001Unique3::_returnSourceStrangthWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnTargetTangentWhipKeyData) == 0x001EF8, "Member 'ACh001Unique3::_returnTargetTangentWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnTargetStrangthWhipKeyData) == 0x001F08, "Member 'ACh001Unique3::_returnTargetStrangthWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnTargetOffSetWhipKeyData) == 0x001F18, "Member 'ACh001Unique3::_returnTargetOffSetWhipKeyData' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnSpan) == 0x001F28, "Member 'ACh001Unique3::_returnSpan' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _returnEasing) == 0x001F2C, "Member 'ACh001Unique3::_returnEasing' has a wrong offset!");
static_assert(offsetof(ACh001Unique3, _injectionStartLocationRate) == 0x001F30, "Member 'ACh001Unique3::_injectionStartLocationRate' has a wrong offset!");

// Class InGameModule.Ch001Unique3Gen_Var1
// 0x0010 (0x0460 - 0x0450)
class ACh001Unique3Gen_Var1 final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique3Gen_Var1">();
	}
	static class ACh001Unique3Gen_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique3Gen_Var1>();
	}
};
static_assert(alignof(ACh001Unique3Gen_Var1) == 0x000010, "Wrong alignment on ACh001Unique3Gen_Var1");
static_assert(sizeof(ACh001Unique3Gen_Var1) == 0x000460, "Wrong size on ACh001Unique3Gen_Var1");

// Class InGameModule.Ch001Unique3Shot_Var1
// 0x0040 (0x2010 - 0x1FD0)
class ACh001Unique3Shot_Var1 final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x40];                                    // 0x1FD0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch001Unique3Shot_Var1">();
	}
	static class ACh001Unique3Shot_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh001Unique3Shot_Var1>();
	}
};
static_assert(alignof(ACh001Unique3Shot_Var1) == 0x000010, "Wrong alignment on ACh001Unique3Shot_Var1");
static_assert(sizeof(ACh001Unique3Shot_Var1) == 0x002010, "Wrong size on ACh001Unique3Shot_Var1");

// Class InGameModule.Ch034Unique1
// 0x00B0 (0x2080 - 0x1FD0)
class ACh034Unique1 final : public ACustomBullet
{
public:
	class UParticleSystem*                        _beginGroundParticle;                              // 0x1FD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeroProjectileMovementComponent*       _projectileMovement;                               // 0x1FD8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomBulletHomingComponent*           _homingComponent;                                  // 0x1FE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _bulletGroundParticle;                             // 0x1FE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF0[0x2C];                                    // 0x1FF0(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _endCollisionSize;                                 // 0x201C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2020[0x8];                                     // 0x2020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _timeUpSound;                                      // 0x2028(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _timeUpSoundComponent;                             // 0x2048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBulletSE                              _onHitBackGroundSound;                             // 0x2050(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _onHitBackGroundSoundComponent;                    // 0x2070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2078[0x8];                                     // 0x2078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034Unique1">();
	}
	static class ACh034Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034Unique1>();
	}
};
static_assert(alignof(ACh034Unique1) == 0x000010, "Wrong alignment on ACh034Unique1");
static_assert(sizeof(ACh034Unique1) == 0x002080, "Wrong size on ACh034Unique1");
static_assert(offsetof(ACh034Unique1, _beginGroundParticle) == 0x001FD0, "Member 'ACh034Unique1::_beginGroundParticle' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _projectileMovement) == 0x001FD8, "Member 'ACh034Unique1::_projectileMovement' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _homingComponent) == 0x001FE0, "Member 'ACh034Unique1::_homingComponent' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _bulletGroundParticle) == 0x001FE8, "Member 'ACh034Unique1::_bulletGroundParticle' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _endCollisionSize) == 0x00201C, "Member 'ACh034Unique1::_endCollisionSize' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _timeUpSound) == 0x002028, "Member 'ACh034Unique1::_timeUpSound' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _timeUpSoundComponent) == 0x002048, "Member 'ACh034Unique1::_timeUpSoundComponent' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _onHitBackGroundSound) == 0x002050, "Member 'ACh034Unique1::_onHitBackGroundSound' has a wrong offset!");
static_assert(offsetof(ACh034Unique1, _onHitBackGroundSoundComponent) == 0x002070, "Member 'ACh034Unique1::_onHitBackGroundSoundComponent' has a wrong offset!");

// Class InGameModule.Ch002Unique1
// 0x0090 (0x1E70 - 0x1DE0)
class ACh002Unique1 final : public ABullet
{
public:
	float                                         _particleBaseSize;                                 // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0x4];                                     // 0x1DDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _endScaleCurve;                                    // 0x1DE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    _decalObject;                                      // 0x1DE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _mi;                                               // 0x1DF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x1DF8(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCustomParticleSystemComponent*         _particle;                                         // 0x1E38(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E40[0x30];                                    // 0x1E40(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique1">();
	}
	static class ACh002Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique1>();
	}
};
static_assert(alignof(ACh002Unique1) == 0x000010, "Wrong alignment on ACh002Unique1");
static_assert(sizeof(ACh002Unique1) == 0x001E70, "Wrong size on ACh002Unique1");
static_assert(offsetof(ACh002Unique1, _particleBaseSize) == 0x001DD8, "Member 'ACh002Unique1::_particleBaseSize' has a wrong offset!");
static_assert(offsetof(ACh002Unique1, _endScaleCurve) == 0x001DE0, "Member 'ACh002Unique1::_endScaleCurve' has a wrong offset!");
static_assert(offsetof(ACh002Unique1, _decalObject) == 0x001DE8, "Member 'ACh002Unique1::_decalObject' has a wrong offset!");
static_assert(offsetof(ACh002Unique1, _mi) == 0x001DF0, "Member 'ACh002Unique1::_mi' has a wrong offset!");
static_assert(offsetof(ACh002Unique1, _graduallyAlpha) == 0x001DF8, "Member 'ACh002Unique1::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(ACh002Unique1, _particle) == 0x001E38, "Member 'ACh002Unique1::_particle' has a wrong offset!");

// Class InGameModule.GameStateBattle_PrepareCongratulateWinner
// 0x0018 (0x0050 - 0x0038)
class UGameStateBattle_PrepareCongratulateWinner final : public UGameStateBattleFiniteStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingDynamic*                 _winDemoLevelStreamingDynamic;                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void WinDemoSetting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_PrepareCongratulateWinner">();
	}
	static class UGameStateBattle_PrepareCongratulateWinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_PrepareCongratulateWinner>();
	}
};
static_assert(alignof(UGameStateBattle_PrepareCongratulateWinner) == 0x000008, "Wrong alignment on UGameStateBattle_PrepareCongratulateWinner");
static_assert(sizeof(UGameStateBattle_PrepareCongratulateWinner) == 0x000050, "Wrong size on UGameStateBattle_PrepareCongratulateWinner");
static_assert(offsetof(UGameStateBattle_PrepareCongratulateWinner, _winDemoLevelStreamingDynamic) == 0x000048, "Member 'UGameStateBattle_PrepareCongratulateWinner::_winDemoLevelStreamingDynamic' has a wrong offset!");

// Class InGameModule.WrappedCh017Unique2_AirBeforeGen
// 0x0000 (0x0450 - 0x0450)
class AWrappedCh017Unique2_AirBeforeGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrappedCh017Unique2_AirBeforeGen">();
	}
	static class AWrappedCh017Unique2_AirBeforeGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWrappedCh017Unique2_AirBeforeGen>();
	}
};
static_assert(alignof(AWrappedCh017Unique2_AirBeforeGen) == 0x000010, "Wrong alignment on AWrappedCh017Unique2_AirBeforeGen");
static_assert(sizeof(AWrappedCh017Unique2_AirBeforeGen) == 0x000450, "Wrong size on AWrappedCh017Unique2_AirBeforeGen");

// Class InGameModule.Ch002Unique1_Var1
// 0x0050 (0x1E30 - 0x1DE0)
class ACh002Unique1_Var1 final : public ABullet
{
public:
	TSubclassOf<class UObject>                    _decalObject;                                      // 0x1DD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _mi;                                               // 0x1DE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x1DE8(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E28[0x8];                                     // 0x1E28(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique1_Var1">();
	}
	static class ACh002Unique1_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique1_Var1>();
	}
};
static_assert(alignof(ACh002Unique1_Var1) == 0x000010, "Wrong alignment on ACh002Unique1_Var1");
static_assert(sizeof(ACh002Unique1_Var1) == 0x001E30, "Wrong size on ACh002Unique1_Var1");
static_assert(offsetof(ACh002Unique1_Var1, _decalObject) == 0x001DD8, "Member 'ACh002Unique1_Var1::_decalObject' has a wrong offset!");
static_assert(offsetof(ACh002Unique1_Var1, _mi) == 0x001DE0, "Member 'ACh002Unique1_Var1::_mi' has a wrong offset!");
static_assert(offsetof(ACh002Unique1_Var1, _graduallyAlpha) == 0x001DE8, "Member 'ACh002Unique1_Var1::_graduallyAlpha' has a wrong offset!");

// Class InGameModule.Ch002Unique1_Var1Gen
// 0x0010 (0x0460 - 0x0450)
class ACh002Unique1_Var1Gen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique1_Var1Gen">();
	}
	static class ACh002Unique1_Var1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique1_Var1Gen>();
	}
};
static_assert(alignof(ACh002Unique1_Var1Gen) == 0x000010, "Wrong alignment on ACh002Unique1_Var1Gen");
static_assert(sizeof(ACh002Unique1_Var1Gen) == 0x000460, "Wrong size on ACh002Unique1_Var1Gen");

// Class InGameModule.Ch002Unique1ChargeGen
// 0x0080 (0x04D0 - 0x0450)
class ACh002Unique1ChargeGen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x88];                                     // 0x0448(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique1ChargeGen">();
	}
	static class ACh002Unique1ChargeGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique1ChargeGen>();
	}
};
static_assert(alignof(ACh002Unique1ChargeGen) == 0x000010, "Wrong alignment on ACh002Unique1ChargeGen");
static_assert(sizeof(ACh002Unique1ChargeGen) == 0x0004D0, "Wrong size on ACh002Unique1ChargeGen");

// Class InGameModule.Ch013Unique1Gen
// 0x0000 (0x0450 - 0x0450)
class ACh013Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch013Unique1Gen">();
	}
	static class ACh013Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh013Unique1Gen>();
	}
};
static_assert(alignof(ACh013Unique1Gen) == 0x000010, "Wrong alignment on ACh013Unique1Gen");
static_assert(sizeof(ACh013Unique1Gen) == 0x000450, "Wrong size on ACh013Unique1Gen");

// Class InGameModule.Ch002Unique2_Var1Gen
// 0x0000 (0x0450 - 0x0450)
class ACh002Unique2_Var1Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique2_Var1Gen">();
	}
	static class ACh002Unique2_Var1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique2_Var1Gen>();
	}
};
static_assert(alignof(ACh002Unique2_Var1Gen) == 0x000010, "Wrong alignment on ACh002Unique2_Var1Gen");
static_assert(sizeof(ACh002Unique2_Var1Gen) == 0x000450, "Wrong size on ACh002Unique2_Var1Gen");

// Class InGameModule.Ch025Unique2Gen
// 0x0080 (0x04D0 - 0x0450)
class ACh025Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x50];                                     // 0x0448(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABullet*>                        _spawnBulletList;                                  // 0x0498(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBulletSE                              _shotLoopSE;                                       // 0x04A8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _shotLoopSeComponent;                              // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch025Unique2Gen">();
	}
	static class ACh025Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh025Unique2Gen>();
	}
};
static_assert(alignof(ACh025Unique2Gen) == 0x000010, "Wrong alignment on ACh025Unique2Gen");
static_assert(sizeof(ACh025Unique2Gen) == 0x0004D0, "Wrong size on ACh025Unique2Gen");
static_assert(offsetof(ACh025Unique2Gen, _spawnBulletList) == 0x000498, "Member 'ACh025Unique2Gen::_spawnBulletList' has a wrong offset!");
static_assert(offsetof(ACh025Unique2Gen, _shotLoopSE) == 0x0004A8, "Member 'ACh025Unique2Gen::_shotLoopSE' has a wrong offset!");
static_assert(offsetof(ACh025Unique2Gen, _shotLoopSeComponent) == 0x0004C8, "Member 'ACh025Unique2Gen::_shotLoopSeComponent' has a wrong offset!");

// Class InGameModule.Ch002Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class ACh002Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique2Gen">();
	}
	static class ACh002Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique2Gen>();
	}
};
static_assert(alignof(ACh002Unique2Gen) == 0x000010, "Wrong alignment on ACh002Unique2Gen");
static_assert(sizeof(ACh002Unique2Gen) == 0x000450, "Wrong size on ACh002Unique2Gen");

// Class InGameModule.Ch002Unique2Shot
// 0x0060 (0x2030 - 0x1FD0)
class ACh002Unique2Shot final : public ACustomBullet
{
public:
	float                                         _maxRotSpeed;                                      // 0x1FD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _maxMoveCriteriaSpeed;                             // 0x1FD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _worningEffect;                                    // 0x1FD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _signTubeCriteriaSize;                             // 0x1FE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _hitBackGroundReturnDist;                          // 0x1FE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE8[0x30];                                    // 0x1FE8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleCustomParticleSystemComponent*   _bulletPSC;                                        // 0x2018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _SignTubePSC;                                      // 0x2020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2028[0x8];                                     // 0x2028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique2Shot">();
	}
	static class ACh002Unique2Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique2Shot>();
	}
};
static_assert(alignof(ACh002Unique2Shot) == 0x000010, "Wrong alignment on ACh002Unique2Shot");
static_assert(sizeof(ACh002Unique2Shot) == 0x002030, "Wrong size on ACh002Unique2Shot");
static_assert(offsetof(ACh002Unique2Shot, _maxRotSpeed) == 0x001FD0, "Member 'ACh002Unique2Shot::_maxRotSpeed' has a wrong offset!");
static_assert(offsetof(ACh002Unique2Shot, _maxMoveCriteriaSpeed) == 0x001FD4, "Member 'ACh002Unique2Shot::_maxMoveCriteriaSpeed' has a wrong offset!");
static_assert(offsetof(ACh002Unique2Shot, _worningEffect) == 0x001FD8, "Member 'ACh002Unique2Shot::_worningEffect' has a wrong offset!");
static_assert(offsetof(ACh002Unique2Shot, _signTubeCriteriaSize) == 0x001FE0, "Member 'ACh002Unique2Shot::_signTubeCriteriaSize' has a wrong offset!");
static_assert(offsetof(ACh002Unique2Shot, _hitBackGroundReturnDist) == 0x001FE4, "Member 'ACh002Unique2Shot::_hitBackGroundReturnDist' has a wrong offset!");
static_assert(offsetof(ACh002Unique2Shot, _bulletPSC) == 0x002018, "Member 'ACh002Unique2Shot::_bulletPSC' has a wrong offset!");
static_assert(offsetof(ACh002Unique2Shot, _SignTubePSC) == 0x002020, "Member 'ACh002Unique2Shot::_SignTubePSC' has a wrong offset!");

// Class InGameModule.Ch002Unique2Shot_Var1
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh002Unique2Shot_Var1 final : public ABullet
{
public:
	float                                         _hitBackGroundReturnDist;                          // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0x4];                                     // 0x1DDC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique2Shot_Var1">();
	}
	static class ACh002Unique2Shot_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique2Shot_Var1>();
	}
};
static_assert(alignof(ACh002Unique2Shot_Var1) == 0x000010, "Wrong alignment on ACh002Unique2Shot_Var1");
static_assert(sizeof(ACh002Unique2Shot_Var1) == 0x001DE0, "Wrong size on ACh002Unique2Shot_Var1");
static_assert(offsetof(ACh002Unique2Shot_Var1, _hitBackGroundReturnDist) == 0x001DD8, "Member 'ACh002Unique2Shot_Var1::_hitBackGroundReturnDist' has a wrong offset!");

// Class InGameModule.Ch015Unique1Child_Var1
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh015Unique1Child_Var1 final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique1Child_Var1">();
	}
	static class ACh015Unique1Child_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique1Child_Var1>();
	}
};
static_assert(alignof(ACh015Unique1Child_Var1) == 0x000010, "Wrong alignment on ACh015Unique1Child_Var1");
static_assert(sizeof(ACh015Unique1Child_Var1) == 0x001FD0, "Wrong size on ACh015Unique1Child_Var1");

// Class InGameModule.Ch002Unique3_Var1Gen
// 0x0000 (0x0450 - 0x0450)
class ACh002Unique3_Var1Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique3_Var1Gen">();
	}
	static class ACh002Unique3_Var1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique3_Var1Gen>();
	}
};
static_assert(alignof(ACh002Unique3_Var1Gen) == 0x000010, "Wrong alignment on ACh002Unique3_Var1Gen");
static_assert(sizeof(ACh002Unique3_Var1Gen) == 0x000450, "Wrong size on ACh002Unique3_Var1Gen");

// Class InGameModule.Ch023Unique1Gen
// 0x0010 (0x0460 - 0x0450)
class ACh023Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABullet*                                _bullet;                                           // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique1Gen">();
	}
	static class ACh023Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique1Gen>();
	}
};
static_assert(alignof(ACh023Unique1Gen) == 0x000010, "Wrong alignment on ACh023Unique1Gen");
static_assert(sizeof(ACh023Unique1Gen) == 0x000460, "Wrong size on ACh023Unique1Gen");
static_assert(offsetof(ACh023Unique1Gen, _bullet) == 0x000450, "Member 'ACh023Unique1Gen::_bullet' has a wrong offset!");

// Class InGameModule.Ch002Unique3Gen
// 0x0000 (0x0450 - 0x0450)
class ACh002Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	class ABullet*                                Bullet;                                            // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique3Gen">();
	}
	static class ACh002Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique3Gen>();
	}
};
static_assert(alignof(ACh002Unique3Gen) == 0x000010, "Wrong alignment on ACh002Unique3Gen");
static_assert(sizeof(ACh002Unique3Gen) == 0x000450, "Wrong size on ACh002Unique3Gen");
static_assert(offsetof(ACh002Unique3Gen, Bullet) == 0x000448, "Member 'ACh002Unique3Gen::Bullet' has a wrong offset!");

// Class InGameModule.Ch002Unique3LastGen
// 0x0010 (0x0460 - 0x0450)
class ACh002Unique3LastGen final : public AProjectileGeneratorBattle
{
public:
	class FName                                   _shotNodes;                                        // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch002Unique3LastGen">();
	}
	static class ACh002Unique3LastGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh002Unique3LastGen>();
	}
};
static_assert(alignof(ACh002Unique3LastGen) == 0x000010, "Wrong alignment on ACh002Unique3LastGen");
static_assert(sizeof(ACh002Unique3LastGen) == 0x000460, "Wrong size on ACh002Unique3LastGen");
static_assert(offsetof(ACh002Unique3LastGen, _shotNodes) == 0x000448, "Member 'ACh002Unique3LastGen::_shotNodes' has a wrong offset!");

// Class InGameModule.Ch003Unique1
// 0x01C0 (0x1FA0 - 0x1DE0)
class ACh003Unique1 : public ABullet
{
public:
	class UCableComponent*                        _cableComponent;                                   // 0x1DD8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomParticleSystemComponent*         _ballisticParticle;                                // 0x1DE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomParticleSystemComponent*         _topParticle;                                      // 0x1DE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DF0[0x150];                                   // 0x1DF0(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _onHitSe;                                          // 0x1F40(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F60[0x40];                                    // 0x1F60(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique1">();
	}
	static class ACh003Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique1>();
	}
};
static_assert(alignof(ACh003Unique1) == 0x000010, "Wrong alignment on ACh003Unique1");
static_assert(sizeof(ACh003Unique1) == 0x001FA0, "Wrong size on ACh003Unique1");
static_assert(offsetof(ACh003Unique1, _cableComponent) == 0x001DD8, "Member 'ACh003Unique1::_cableComponent' has a wrong offset!");
static_assert(offsetof(ACh003Unique1, _ballisticParticle) == 0x001DE0, "Member 'ACh003Unique1::_ballisticParticle' has a wrong offset!");
static_assert(offsetof(ACh003Unique1, _topParticle) == 0x001DE8, "Member 'ACh003Unique1::_topParticle' has a wrong offset!");
static_assert(offsetof(ACh003Unique1, _onHitSe) == 0x001F40, "Member 'ACh003Unique1::_onHitSe' has a wrong offset!");

// Class InGameModule.Ch015Unique2_Var1ChildCrack
// 0x0100 (0x20D0 - 0x1FD0)
class ACh015Unique2_Var1ChildCrack final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x28];                                    // 0x1FD0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _deActiveAreaEffectSeconds;                        // 0x1FF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FFC[0x4];                                     // 0x1FFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialCurveControl*                  _materialCurveCtrlTbl;                             // 0x2000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomZRot;                                       // 0x2008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200C[0x4];                                     // 0x200C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInGameDecalComponent*                  _decalComponent;                                   // 0x2010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _signParticle;                                     // 0x2018(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _dustParticle;                                     // 0x2020(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _signFriendParticle;                               // 0x2028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _disappearParticle;                                // 0x2030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _teamAreaEffect;                                   // 0x2038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _enemyAreaEffect;                                  // 0x2040(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroSphereComponent*                   _h1;                                               // 0x2048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2050[0x50];                                    // 0x2050(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _mid;                                              // 0x20A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20A8[0x28];                                    // 0x20A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBeginEnd();
	void DeActiveAreaEffect();
	class UMaterialInstanceDynamic* GetMID();
	float GetRandomZRot();
	class UMaterialInstanceDynamic* SetMID(class UMaterialInstanceDynamic* Mid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique2_Var1ChildCrack">();
	}
	static class ACh015Unique2_Var1ChildCrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique2_Var1ChildCrack>();
	}
};
static_assert(alignof(ACh015Unique2_Var1ChildCrack) == 0x000010, "Wrong alignment on ACh015Unique2_Var1ChildCrack");
static_assert(sizeof(ACh015Unique2_Var1ChildCrack) == 0x0020D0, "Wrong size on ACh015Unique2_Var1ChildCrack");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _deActiveAreaEffectSeconds) == 0x001FF8, "Member 'ACh015Unique2_Var1ChildCrack::_deActiveAreaEffectSeconds' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _materialCurveCtrlTbl) == 0x002000, "Member 'ACh015Unique2_Var1ChildCrack::_materialCurveCtrlTbl' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _randomZRot) == 0x002008, "Member 'ACh015Unique2_Var1ChildCrack::_randomZRot' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _decalComponent) == 0x002010, "Member 'ACh015Unique2_Var1ChildCrack::_decalComponent' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _signParticle) == 0x002018, "Member 'ACh015Unique2_Var1ChildCrack::_signParticle' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _dustParticle) == 0x002020, "Member 'ACh015Unique2_Var1ChildCrack::_dustParticle' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _signFriendParticle) == 0x002028, "Member 'ACh015Unique2_Var1ChildCrack::_signFriendParticle' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _disappearParticle) == 0x002030, "Member 'ACh015Unique2_Var1ChildCrack::_disappearParticle' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _teamAreaEffect) == 0x002038, "Member 'ACh015Unique2_Var1ChildCrack::_teamAreaEffect' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _enemyAreaEffect) == 0x002040, "Member 'ACh015Unique2_Var1ChildCrack::_enemyAreaEffect' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _h1) == 0x002048, "Member 'ACh015Unique2_Var1ChildCrack::_h1' has a wrong offset!");
static_assert(offsetof(ACh015Unique2_Var1ChildCrack, _mid) == 0x0020A0, "Member 'ACh015Unique2_Var1ChildCrack::_mid' has a wrong offset!");

// Class InGameModule.Ch003Unique1Charge
// 0x0060 (0x2000 - 0x1FA0)
class ACh003Unique1Charge final : public ACh003Unique1
{
public:
	uint8                                         Pad_1FA0[0x60];                                    // 0x1FA0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique1Charge">();
	}
	static class ACh003Unique1Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique1Charge>();
	}
};
static_assert(alignof(ACh003Unique1Charge) == 0x000010, "Wrong alignment on ACh003Unique1Charge");
static_assert(sizeof(ACh003Unique1Charge) == 0x002000, "Wrong size on ACh003Unique1Charge");

// Class InGameModule.Ch017Unique2
// 0x0090 (0x1EE0 - 0x1E50)
class ACh017Unique2 : public ACh017Unique2Base
{
public:
	class UCustomParticleSystemComponent*         _trapParticle;                                     // 0x1E48(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomParticleSystemComponent*         _enemyTrapParticle;                                // 0x1E50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E58[0x8];                                     // 0x1E58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _fireSE;                                           // 0x1E60(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _fireSeComponent;                                  // 0x1E80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBulletSE                              _loopFireSE;                                       // 0x1E88(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _loopFireSeComponent;                              // 0x1EA8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBulletSE                              _finishSE;                                         // 0x1EB0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _finishSeComponent;                                // 0x1ED0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1ED8[0x8];                                     // 0x1ED8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActiveCollisionEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2">();
	}
	static class ACh017Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2>();
	}
};
static_assert(alignof(ACh017Unique2) == 0x000010, "Wrong alignment on ACh017Unique2");
static_assert(sizeof(ACh017Unique2) == 0x001EE0, "Wrong size on ACh017Unique2");
static_assert(offsetof(ACh017Unique2, _trapParticle) == 0x001E48, "Member 'ACh017Unique2::_trapParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2, _enemyTrapParticle) == 0x001E50, "Member 'ACh017Unique2::_enemyTrapParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2, _fireSE) == 0x001E60, "Member 'ACh017Unique2::_fireSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2, _fireSeComponent) == 0x001E80, "Member 'ACh017Unique2::_fireSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2, _loopFireSE) == 0x001E88, "Member 'ACh017Unique2::_loopFireSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2, _loopFireSeComponent) == 0x001EA8, "Member 'ACh017Unique2::_loopFireSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2, _finishSE) == 0x001EB0, "Member 'ACh017Unique2::_finishSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2, _finishSeComponent) == 0x001ED0, "Member 'ACh017Unique2::_finishSeComponent' has a wrong offset!");

// Class InGameModule.Ch034Unique2
// 0x0000 (0x1EE0 - 0x1EE0)
class ACh034Unique2 final : public ACh017Unique2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034Unique2">();
	}
	static class ACh034Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034Unique2>();
	}
};
static_assert(alignof(ACh034Unique2) == 0x000010, "Wrong alignment on ACh034Unique2");
static_assert(sizeof(ACh034Unique2) == 0x001EE0, "Wrong size on ACh034Unique2");

// Class InGameModule.Ch003Unique1ChargeGen
// 0x0010 (0x0460 - 0x0450)
class ACh003Unique1ChargeGen final : public AProjectileGeneratorBattle
{
public:
	class ACh003Unique1*                          _unique1Bullet;                                    // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECh003Unique1ChargeState                      _currentGenState;                                  // 0x0450(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0xF];                                      // 0x0451(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeState_RPC(ECh003Unique1ChargeState State);
	void OnRep_ChangeState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique1ChargeGen">();
	}
	static class ACh003Unique1ChargeGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique1ChargeGen>();
	}
};
static_assert(alignof(ACh003Unique1ChargeGen) == 0x000010, "Wrong alignment on ACh003Unique1ChargeGen");
static_assert(sizeof(ACh003Unique1ChargeGen) == 0x000460, "Wrong size on ACh003Unique1ChargeGen");
static_assert(offsetof(ACh003Unique1ChargeGen, _unique1Bullet) == 0x000448, "Member 'ACh003Unique1ChargeGen::_unique1Bullet' has a wrong offset!");
static_assert(offsetof(ACh003Unique1ChargeGen, _currentGenState) == 0x000450, "Member 'ACh003Unique1ChargeGen::_currentGenState' has a wrong offset!");

// Class InGameModule.Ch003Unique1Gen
// 0x0000 (0x0450 - 0x0450)
class ACh003Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	class ACh003Unique1*                          _unique1Bullet;                                    // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique1Gen">();
	}
	static class ACh003Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique1Gen>();
	}
};
static_assert(alignof(ACh003Unique1Gen) == 0x000010, "Wrong alignment on ACh003Unique1Gen");
static_assert(sizeof(ACh003Unique1Gen) == 0x000450, "Wrong size on ACh003Unique1Gen");
static_assert(offsetof(ACh003Unique1Gen, _unique1Bullet) == 0x000448, "Member 'ACh003Unique1Gen::_unique1Bullet' has a wrong offset!");

// Class InGameModule.Ch003Unique2Base
// 0x0010 (0x1FE0 - 0x1FD0)
class ACh003Unique2Base final : public ACustomBullet
{
public:
	class UBattleCustomParticleSystemComponent*   _weaponParticle;                                   // 0x1FD0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD8[0x8];                                     // 0x1FD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique2Base">();
	}
	static class ACh003Unique2Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique2Base>();
	}
};
static_assert(alignof(ACh003Unique2Base) == 0x000010, "Wrong alignment on ACh003Unique2Base");
static_assert(sizeof(ACh003Unique2Base) == 0x001FE0, "Wrong size on ACh003Unique2Base");
static_assert(offsetof(ACh003Unique2Base, _weaponParticle) == 0x001FD0, "Member 'ACh003Unique2Base::_weaponParticle' has a wrong offset!");

// Class InGameModule.Ch016
// 0x0000 (0x0B10 - 0x0B10)
class ACh016 final : public ACharacterBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch016">();
	}
	static class ACh016* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh016>();
	}
};
static_assert(alignof(ACh016) == 0x000010, "Wrong alignment on ACh016");
static_assert(sizeof(ACh016) == 0x000B10, "Wrong size on ACh016");

// Class InGameModule.Ch003Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class ACh003Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	class ACh003Unique2Base*                      _spawnBullet;                                      // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique2Gen">();
	}
	static class ACh003Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique2Gen>();
	}
};
static_assert(alignof(ACh003Unique2Gen) == 0x000010, "Wrong alignment on ACh003Unique2Gen");
static_assert(sizeof(ACh003Unique2Gen) == 0x000450, "Wrong size on ACh003Unique2Gen");
static_assert(offsetof(ACh003Unique2Gen, _spawnBullet) == 0x000448, "Member 'ACh003Unique2Gen::_spawnBullet' has a wrong offset!");

// Class InGameModule.Ch023Unique3Shot
// 0x0060 (0x2030 - 0x1FD0)
class ACh023Unique3Shot final : public ACustomBullet
{
public:
	class UMaterialCurveControl*                  _materialCurveCtrlTbl;                             // 0x1FD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _bulletEffect;                                     // 0x1FD8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _fireEffect;                                       // 0x1FE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _bulletLightEffect;                                // 0x1FE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _subfireEffect;                                    // 0x1FF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _signEffectMyself;                                 // 0x1FF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _signEffectEnemy;                                  // 0x2000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameDecalComponent*                  _bulletDecal;                                      // 0x2008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameDecalComponent*                  _signDecalForEnemy;                                // 0x2010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameDecalComponent*                  _signDecalForAlly;                                 // 0x2018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x2020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _waitTime;                                         // 0x2028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202C[0x4];                                     // 0x202C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBeginEnd();
	class UMaterialInstanceDynamic* SetMID(class UMaterialInstanceDynamic* Mid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique3Shot">();
	}
	static class ACh023Unique3Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique3Shot>();
	}
};
static_assert(alignof(ACh023Unique3Shot) == 0x000010, "Wrong alignment on ACh023Unique3Shot");
static_assert(sizeof(ACh023Unique3Shot) == 0x002030, "Wrong size on ACh023Unique3Shot");
static_assert(offsetof(ACh023Unique3Shot, _materialCurveCtrlTbl) == 0x001FD0, "Member 'ACh023Unique3Shot::_materialCurveCtrlTbl' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _bulletEffect) == 0x001FD8, "Member 'ACh023Unique3Shot::_bulletEffect' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _fireEffect) == 0x001FE0, "Member 'ACh023Unique3Shot::_fireEffect' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _bulletLightEffect) == 0x001FE8, "Member 'ACh023Unique3Shot::_bulletLightEffect' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _subfireEffect) == 0x001FF0, "Member 'ACh023Unique3Shot::_subfireEffect' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _signEffectMyself) == 0x001FF8, "Member 'ACh023Unique3Shot::_signEffectMyself' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _signEffectEnemy) == 0x002000, "Member 'ACh023Unique3Shot::_signEffectEnemy' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _bulletDecal) == 0x002008, "Member 'ACh023Unique3Shot::_bulletDecal' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _signDecalForEnemy) == 0x002010, "Member 'ACh023Unique3Shot::_signDecalForEnemy' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _signDecalForAlly) == 0x002018, "Member 'ACh023Unique3Shot::_signDecalForAlly' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _mid) == 0x002020, "Member 'ACh023Unique3Shot::_mid' has a wrong offset!");
static_assert(offsetof(ACh023Unique3Shot, _waitTime) == 0x002028, "Member 'ACh023Unique3Shot::_waitTime' has a wrong offset!");

// Class InGameModule.Ch003Unique2Release
// 0x01B0 (0x2180 - 0x1FD0)
class ACh003Unique2Release final : public ACustomBullet
{
public:
	class UCustomBulletPhysicsLikeComponent*      _customBulletPhysLike;                             // 0x1FD0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD8[0x1A8];                                   // 0x1FD8(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StopShake();
	void Vanish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique2Release">();
	}
	static class ACh003Unique2Release* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique2Release>();
	}
};
static_assert(alignof(ACh003Unique2Release) == 0x000010, "Wrong alignment on ACh003Unique2Release");
static_assert(sizeof(ACh003Unique2Release) == 0x002180, "Wrong size on ACh003Unique2Release");
static_assert(offsetof(ACh003Unique2Release, _customBulletPhysLike) == 0x001FD0, "Member 'ACh003Unique2Release::_customBulletPhysLike' has a wrong offset!");

// Class InGameModule.Ch003Unique3Base
// 0x0210 (0x1FF0 - 0x1DE0)
class ACh003Unique3Base : public ABullet
{
public:
	uint8                                         Pad_1DD8[0x3C];                                    // 0x1DD8(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _landEffectScalingRate;                            // 0x1E14(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _doScalingLandEffectMinRadius;                     // 0x1E18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _doScalingLandEffectMaxRadius;                     // 0x1E1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultImpactParticleScale;                       // 0x1E20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultSpawnParticleScale;                        // 0x1E24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E28[0x4];                                     // 0x1E28(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _impactParticleScale;                              // 0x1E2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E30[0xD8];                                    // 0x1E30(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UBulletParticleSystemComponent*         _forecast_Particle;                                // 0x1F08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBulletParticleSystemComponent*         _forecastFriendParticle;                           // 0x1F10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBulletParticleSystemComponent*         _debris_ParticleComponent;                         // 0x1F18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBulletParticleSystemComponent*         _smokeParticle;                                    // 0x1F20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOutlineStaticMeshComponent*            _staticMeshComponent;                              // 0x1F28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBulletParticleSystemComponent*         _bulletParticle;                                   // 0x1F30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x1F38(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x1F78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBulletSE                              _floatingStartSE;                                  // 0x1F80(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _floatingSeComponent;                              // 0x1FA0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBulletSE                              _fallStartSE;                                      // 0x1FA8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBulletSE                              _impactSE;                                         // 0x1FC8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _fallStartSeComponent;                             // 0x1FE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFinishImpactParticle(class UParticleSystemComponent* Particle);
	void StartFallInternal(const struct FVector& StartLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique3Base">();
	}
	static class ACh003Unique3Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique3Base>();
	}
};
static_assert(alignof(ACh003Unique3Base) == 0x000010, "Wrong alignment on ACh003Unique3Base");
static_assert(sizeof(ACh003Unique3Base) == 0x001FF0, "Wrong size on ACh003Unique3Base");
static_assert(offsetof(ACh003Unique3Base, _landEffectScalingRate) == 0x001E14, "Member 'ACh003Unique3Base::_landEffectScalingRate' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _doScalingLandEffectMinRadius) == 0x001E18, "Member 'ACh003Unique3Base::_doScalingLandEffectMinRadius' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _doScalingLandEffectMaxRadius) == 0x001E1C, "Member 'ACh003Unique3Base::_doScalingLandEffectMaxRadius' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _defaultImpactParticleScale) == 0x001E20, "Member 'ACh003Unique3Base::_defaultImpactParticleScale' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _defaultSpawnParticleScale) == 0x001E24, "Member 'ACh003Unique3Base::_defaultSpawnParticleScale' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _impactParticleScale) == 0x001E2C, "Member 'ACh003Unique3Base::_impactParticleScale' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _forecast_Particle) == 0x001F08, "Member 'ACh003Unique3Base::_forecast_Particle' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _forecastFriendParticle) == 0x001F10, "Member 'ACh003Unique3Base::_forecastFriendParticle' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _debris_ParticleComponent) == 0x001F18, "Member 'ACh003Unique3Base::_debris_ParticleComponent' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _smokeParticle) == 0x001F20, "Member 'ACh003Unique3Base::_smokeParticle' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _staticMeshComponent) == 0x001F28, "Member 'ACh003Unique3Base::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _bulletParticle) == 0x001F30, "Member 'ACh003Unique3Base::_bulletParticle' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _graduallyAlpha) == 0x001F38, "Member 'ACh003Unique3Base::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _mid) == 0x001F78, "Member 'ACh003Unique3Base::_mid' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _floatingStartSE) == 0x001F80, "Member 'ACh003Unique3Base::_floatingStartSE' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _floatingSeComponent) == 0x001FA0, "Member 'ACh003Unique3Base::_floatingSeComponent' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _fallStartSE) == 0x001FA8, "Member 'ACh003Unique3Base::_fallStartSE' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _impactSE) == 0x001FC8, "Member 'ACh003Unique3Base::_impactSE' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Base, _fallStartSeComponent) == 0x001FE8, "Member 'ACh003Unique3Base::_fallStartSeComponent' has a wrong offset!");

// Class InGameModule.Ch003Unique3Decoration
// 0x0030 (0x2020 - 0x1FF0)
class ACh003Unique3Decoration final : public ACh003Unique3Base
{
public:
	class UHeroSphereComponent*                   _hitCollision1;                                    // 0x1FF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeroSphereComponent*                   _backGroundCollision1;                             // 0x1FF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCh003Unique3DecorationBulletInfo> _bulletInfo;                                       // 0x2000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2010[0x10];                                    // 0x2010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique3Decoration">();
	}
	static class ACh003Unique3Decoration* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique3Decoration>();
	}
};
static_assert(alignof(ACh003Unique3Decoration) == 0x000010, "Wrong alignment on ACh003Unique3Decoration");
static_assert(sizeof(ACh003Unique3Decoration) == 0x002020, "Wrong size on ACh003Unique3Decoration");
static_assert(offsetof(ACh003Unique3Decoration, _hitCollision1) == 0x001FF0, "Member 'ACh003Unique3Decoration::_hitCollision1' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Decoration, _backGroundCollision1) == 0x001FF8, "Member 'ACh003Unique3Decoration::_backGroundCollision1' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Decoration, _bulletInfo) == 0x002000, "Member 'ACh003Unique3Decoration::_bulletInfo' has a wrong offset!");

// Class InGameModule.Ch043Unique1ShotGen
// 0x0110 (0x0560 - 0x0450)
class ACh043Unique1ShotGen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _shotNodes;                                        // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         _randOffset;                                       // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCh043Unique1ShotGenRep                _rep;                                              // 0x0468(0x0028)(Net, RepNotify, NativeAccessSpecifierPrivate)
	class AActor*                                 _forceTarget;                                      // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x40];                                     // 0x0498(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _shotEffect;                                       // 0x04D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _shotEffectLeftOffset;                             // 0x04E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _shotEffectRightOffset;                            // 0x04EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _shotEffectScale;                                  // 0x04F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0508(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         _detachTimer;                                      // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleCustomParticleSystemComponent*   _ShotPSC;                                          // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Ch043Unique1ShotGenRep_RPC(const struct FCh043Unique1ShotGenRep& Rep);
	void OnRep_Ch043Unique1ShotGenRep();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch043Unique1ShotGen">();
	}
	static class ACh043Unique1ShotGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh043Unique1ShotGen>();
	}
};
static_assert(alignof(ACh043Unique1ShotGen) == 0x000010, "Wrong alignment on ACh043Unique1ShotGen");
static_assert(sizeof(ACh043Unique1ShotGen) == 0x000560, "Wrong size on ACh043Unique1ShotGen");
static_assert(offsetof(ACh043Unique1ShotGen, _shotNodes) == 0x000450, "Member 'ACh043Unique1ShotGen::_shotNodes' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _randOffset) == 0x000460, "Member 'ACh043Unique1ShotGen::_randOffset' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _rep) == 0x000468, "Member 'ACh043Unique1ShotGen::_rep' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _forceTarget) == 0x000490, "Member 'ACh043Unique1ShotGen::_forceTarget' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _shotEffect) == 0x0004D8, "Member 'ACh043Unique1ShotGen::_shotEffect' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _shotEffectLeftOffset) == 0x0004E0, "Member 'ACh043Unique1ShotGen::_shotEffectLeftOffset' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _shotEffectRightOffset) == 0x0004EC, "Member 'ACh043Unique1ShotGen::_shotEffectRightOffset' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _shotEffectScale) == 0x0004F8, "Member 'ACh043Unique1ShotGen::_shotEffectScale' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _graduallyAlpha) == 0x000508, "Member 'ACh043Unique1ShotGen::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _detachTimer) == 0x000548, "Member 'ACh043Unique1ShotGen::_detachTimer' has a wrong offset!");
static_assert(offsetof(ACh043Unique1ShotGen, _ShotPSC) == 0x000550, "Member 'ACh043Unique1ShotGen::_ShotPSC' has a wrong offset!");

// Class InGameModule.Ch003Unique3FloatGen
// 0x0000 (0x0450 - 0x0450)
class ACh003Unique3FloatGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique3FloatGen">();
	}
	static class ACh003Unique3FloatGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique3FloatGen>();
	}
};
static_assert(alignof(ACh003Unique3FloatGen) == 0x000010, "Wrong alignment on ACh003Unique3FloatGen");
static_assert(sizeof(ACh003Unique3FloatGen) == 0x000450, "Wrong size on ACh003Unique3FloatGen");

// Class InGameModule.SpreadBaseGen
// 0x0020 (0x0470 - 0x0450)
class ASpreadBaseGen : public AProjectileGeneratorBattle
{
public:
	bool                                          _bIsRandomSpread;                                  // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _spreadRandomOffset;                               // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _spreadRatio;                                      // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBulletSpawnInfoBase*>           _spawnInfoList;                                    // 0x0458(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpreadBaseGen">();
	}
	static class ASpreadBaseGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpreadBaseGen>();
	}
};
static_assert(alignof(ASpreadBaseGen) == 0x000010, "Wrong alignment on ASpreadBaseGen");
static_assert(sizeof(ASpreadBaseGen) == 0x000470, "Wrong size on ASpreadBaseGen");
static_assert(offsetof(ASpreadBaseGen, _bIsRandomSpread) == 0x000448, "Member 'ASpreadBaseGen::_bIsRandomSpread' has a wrong offset!");
static_assert(offsetof(ASpreadBaseGen, _spreadRandomOffset) == 0x00044C, "Member 'ASpreadBaseGen::_spreadRandomOffset' has a wrong offset!");
static_assert(offsetof(ASpreadBaseGen, _spreadRatio) == 0x000450, "Member 'ASpreadBaseGen::_spreadRatio' has a wrong offset!");
static_assert(offsetof(ASpreadBaseGen, _spawnInfoList) == 0x000458, "Member 'ASpreadBaseGen::_spawnInfoList' has a wrong offset!");

// Class InGameModule.Ch003Unique3FloatingArea
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh003Unique3FloatingArea final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique3FloatingArea">();
	}
	static class ACh003Unique3FloatingArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique3FloatingArea>();
	}
};
static_assert(alignof(ACh003Unique3FloatingArea) == 0x000010, "Wrong alignment on ACh003Unique3FloatingArea");
static_assert(sizeof(ACh003Unique3FloatingArea) == 0x001DE0, "Wrong size on ACh003Unique3FloatingArea");

// Class InGameModule.Ch003Unique3Gen
// 0x0120 (0x0570 - 0x0450)
class ACh003Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	TArray<class ACh003Unique3Base*>              _spawnProjectileList;                              // 0x0448(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ACh003Unique3Base*                      _mainBullet;                                       // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x98];                                     // 0x0460(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _signAreaRedParticle;                              // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _signAreaBlueParticle;                             // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _signParticle;                                     // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x60];                                     // 0x0510(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnForciblyFallEvent();
	void StartFall();

	float GetSpawnDecorationRangeRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch003Unique3Gen">();
	}
	static class ACh003Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh003Unique3Gen>();
	}
};
static_assert(alignof(ACh003Unique3Gen) == 0x000010, "Wrong alignment on ACh003Unique3Gen");
static_assert(sizeof(ACh003Unique3Gen) == 0x000570, "Wrong size on ACh003Unique3Gen");
static_assert(offsetof(ACh003Unique3Gen, _spawnProjectileList) == 0x000448, "Member 'ACh003Unique3Gen::_spawnProjectileList' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Gen, _mainBullet) == 0x000458, "Member 'ACh003Unique3Gen::_mainBullet' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Gen, _signAreaRedParticle) == 0x0004F8, "Member 'ACh003Unique3Gen::_signAreaRedParticle' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Gen, _signAreaBlueParticle) == 0x000500, "Member 'ACh003Unique3Gen::_signAreaBlueParticle' has a wrong offset!");
static_assert(offsetof(ACh003Unique3Gen, _signParticle) == 0x000508, "Member 'ACh003Unique3Gen::_signParticle' has a wrong offset!");

// Class InGameModule.Ch004Special
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh004Special final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Special">();
	}
	static class ACh004Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Special>();
	}
};
static_assert(alignof(ACh004Special) == 0x000010, "Wrong alignment on ACh004Special");
static_assert(sizeof(ACh004Special) == 0x001FD0, "Wrong size on ACh004Special");

// Class InGameModule.Ch043Unique3TrapGen
// 0x0020 (0x0470 - 0x0450)
class ACh043Unique3TrapGen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0xC];                                      // 0x0448(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FResponceHitRep                        _responceRep;                                      // 0x0454(0x0004)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x18];                                     // 0x0458(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ResponceHit();
	void ResponceHit_RPC(const struct FResponceHitRep& Rep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch043Unique3TrapGen">();
	}
	static class ACh043Unique3TrapGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh043Unique3TrapGen>();
	}
};
static_assert(alignof(ACh043Unique3TrapGen) == 0x000010, "Wrong alignment on ACh043Unique3TrapGen");
static_assert(sizeof(ACh043Unique3TrapGen) == 0x000470, "Wrong size on ACh043Unique3TrapGen");
static_assert(offsetof(ACh043Unique3TrapGen, _responceRep) == 0x000454, "Member 'ACh043Unique3TrapGen::_responceRep' has a wrong offset!");

// Class InGameModule.Ch004SpecialGen
// 0x0010 (0x0460 - 0x0450)
class ACh004SpecialGen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004SpecialGen">();
	}
	static class ACh004SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004SpecialGen>();
	}
};
static_assert(alignof(ACh004SpecialGen) == 0x000010, "Wrong alignment on ACh004SpecialGen");
static_assert(sizeof(ACh004SpecialGen) == 0x000460, "Wrong size on ACh004SpecialGen");

// Class InGameModule.CharacterAttackComponent
// 0x0520 (0x05D8 - 0x00B8)
class UCharacterAttackComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovementComponentBattle*               _movementComponent;                                // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _realtimeTargetActor;                              // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _attackTargetActor;                                // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttackTargetData                      _copyTargetData;                                   // 0x0130(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FNetAttackTargetData                   _serverTargetData;                                 // 0x0148(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector_NetQuantize                    _netAimingTargetDirection;                         // 0x0160(0x000C)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0xA4];                                     // 0x016C(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttackTargetData>              _lockOnTarget;                                     // 0x0210(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x20];                                     // 0x0220(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    _lockOnStacks;                                     // 0x0240(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x160];                                    // 0x0290(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetAttackHitData                      _serverHitAttackData;                              // 0x03F0(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FNetAttackHitData                      _serverHitProjectileData;                          // 0x0408(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x110];                                    // 0x0420(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class ACustomBullet*                          _lastBullet;                                       // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0xC];                                      // 0x0538(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentRandomSeed;                                // 0x0544(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x38];                                     // 0x0548(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _specialActionTarget;                              // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x50];                                     // 0x0588(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_BeginMultiLockOn();
	void BP_ChaseEnd();
	void BP_ChaseStart(const struct FAttackChaseInfo& Info);
	void BP_ClearGrabDamageChain();
	void BP_DisableOnHitToServer();
	void BP_DuplicateInto(bool UseStock, const struct FVector& Position);
	void BP_EnableChainComboFlag(float Time);
	void BP_EnableOnHitToServer();
	void BP_EndMultiLockOn();
	void BP_FinishCurrentAttackPhase();
	void BP_InitializeAttackPhase();
	bool BP_IsStockingDuplication();
	bool BP_IsStockingTransform();
	void BP_LoadMagazineParam(EAttackId AttackId, const class FString& ActionName, ECharacterId CharacterId, int32 AttackLevel);
	class UAtomComponent* BP_PlayAttackSound(const class FString& CueName, const class FName SocketName);
	void BP_RefreshAttackTargetInfo();
	void BP_RemoveStockTransformation(int32 Index_0);
	void BP_ResetCatchedBulle();
	void BP_SendToProjectileEvent(class FName EventName);
	void BP_SetAttackAnimationRate(float Rate, bool bNagara);
	void BP_SetAttackPhaseEndCondition(bool ComboCommand, bool Grabed, float EndTimer, bool Landing, bool EndAnim, EAnimationSlot EndAnimSlot);
	void BP_SetChargeCommandTime(float Time, EAttackId AttackId);
	void BP_SetDisableShiftActionAttack(EAttackId AttackId, EAttackDisabledFlags Flag);
	void BP_SetEnableAttackLanding(bool Flag);
	void BP_SetEnableChaseFlag(bool Flag);
	void BP_SetEnableShiftActionAttack(EAttackId AttackId, EAttackDisabledFlags Flag);
	void BP_SetEnableShiftAttackAction(EAttackId AttackId, bool Flag);
	void BP_SetEndAttackOnAirial(bool bEnable);
	void BP_SetGrabDamageContinuity(const class FName DamageParamName, int32 HitCount, float HitSpan);
	void BP_SetHoldTimeIndex(float Index_0);
	void BP_SetIgnoreAdjustMoveRate(bool Flag);
	void BP_SetLockOnData(float Span, float Distance, int32 MaxLockOnCount, const struct FVector2D& RaticleSize);
	void BP_SetSpeedHForAttack(float Initial, float Last, float Span);
	void BP_SetSpeedVForAttack(float Initial, float Last, float Span);
	void BP_SetSuperArmor(bool bEnable);
	void BP_SetTarget_ToServer();
	void BP_SetTransfromTimer(float Timer);
	void BP_SetUpRotationPitchToDirection(float Time, EActionAxis TargetAxis, float Rate, float MaxDegreesPerFrame, const struct FVector& Direction);
	void BP_ShiftAttackPhase(uint8 NextPhase);
	void BP_ShiftAttackPhaseForRemote(uint8 NextPhase);
	void BP_StartMultiLockOn();
	void BP_StockDuplication(class ACharacterBattle* Character);
	void BP_StockTransformation(class ACharacterBattle* Character);
	void BP_TransformInto();
	void GenerateRandomSeed_OnServer(int32 NewSeed);
	void OnHitAttack_ToServer(const struct FNetAttackHitData& Data);
	void OnHitProjectile_ToServer(const struct FNetAttackHitData& Data);
	void OnRep_Replicated_currentRandomSeed();
	void OnRep_Replicated_netAimingTargetDirection();
	void OnRep_Replicated_serverHitAttackData();
	void OnRep_Replicated_serverHitProjectileData();
	void OnRep_Replicated_serverTargetData();
	void SendAttackSerial_ToClient(uint8 SerialNo);
	void SendAttackSerial_ToServer(uint8 SerialNo);
	void SetNextAttackPhase_ToClient(uint8 NextPhase, uint8 AttackSerial);
	void SetNextAttackPhase_ToServer(uint8 NextPhase, uint8 AttackSerial);
	void SetTarget_ToServer(const struct FNetAttackTargetData& TargetData);
	void SetTargetLocal(class AActor* TargetActor, const struct FVector& TargetLocation, const struct FVector& RealtimeTargetLocation);

	bool BP_GetAttackParamAsBool(const class FString& ActionName, const class FString& ParamPath, int32 AttackLevel, ECharacterId MasterId) const;
	float BP_GetAttackParamAsFloat(const class FString& ActionName, const class FString& ParamPath, int32 AttackLevel, ECharacterId MasterId) const;
	int32 BP_GetAttackParamAsInt(const class FString& ActionName, const class FString& ParamPath, int32 AttackLevel, ECharacterId MasterId) const;
	class FString BP_GetAttackParamAsString(const class FString& ActionName, const class FString& ParamPath, int32 AttackLevel, ECharacterId MasterId) const;
	float BP_GetAttackPhaseCurrentTimeSeconds() const;
	EAttackPhaseEndFlag BP_GetAttackPhaseFinished() const;
	class AActor* BP_GetAttackTargetActor() const;
	const struct FVector BP_GetAttackTargetLocation() const;
	ECommandId BP_GetCurrentAttackCommandId() const;
	int32 BP_GetCurrentAttackPhase() const;
	int32 BP_GetCurrentAttackUniqueLevel() const;
	int32 BP_GetCurrentLockOnCount() const;
	class ACustomBullet* BP_GetLastBullet() const;
	struct FVector BP_GetLastBulletLocation(bool* bValidity) const;
	float BP_GetMultiLockOnEnableTime() const;
	const struct FRandomStream BP_GetRandomStream() const;
	struct FVector BP_GetRealtimeTargetDirection() const;
	struct FVector2D BP_GetStickDirection() const;
	struct FVector2D BP_GetStickDirectionSimple() const;
	struct FVector BP_GetTargetDirection() const;
	bool BP_IsCatchedBullet() const;
	bool BP_IsChaseState() const;
	bool BP_IsEnableAttackLanding() const;
	bool BP_IsEndAttackOnAirial() const;
	bool BP_IsHItAttack() const;
	bool BP_IsSatisfiedHoldCommand() const;
	bool BP_IsValidAttackCommand() const;
	const struct FVector GetRealtimeTargetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAttackComponent">();
	}
	static class UCharacterAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAttackComponent>();
	}
};
static_assert(alignof(UCharacterAttackComponent) == 0x000008, "Wrong alignment on UCharacterAttackComponent");
static_assert(sizeof(UCharacterAttackComponent) == 0x0005D8, "Wrong size on UCharacterAttackComponent");
static_assert(offsetof(UCharacterAttackComponent, _movementComponent) == 0x0000D8, "Member 'UCharacterAttackComponent::_movementComponent' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _realtimeTargetActor) == 0x000100, "Member 'UCharacterAttackComponent::_realtimeTargetActor' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _attackTargetActor) == 0x000118, "Member 'UCharacterAttackComponent::_attackTargetActor' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _copyTargetData) == 0x000130, "Member 'UCharacterAttackComponent::_copyTargetData' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _serverTargetData) == 0x000148, "Member 'UCharacterAttackComponent::_serverTargetData' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _netAimingTargetDirection) == 0x000160, "Member 'UCharacterAttackComponent::_netAimingTargetDirection' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _lockOnTarget) == 0x000210, "Member 'UCharacterAttackComponent::_lockOnTarget' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _lockOnStacks) == 0x000240, "Member 'UCharacterAttackComponent::_lockOnStacks' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _serverHitAttackData) == 0x0003F0, "Member 'UCharacterAttackComponent::_serverHitAttackData' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _serverHitProjectileData) == 0x000408, "Member 'UCharacterAttackComponent::_serverHitProjectileData' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _lastBullet) == 0x000530, "Member 'UCharacterAttackComponent::_lastBullet' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _currentRandomSeed) == 0x000544, "Member 'UCharacterAttackComponent::_currentRandomSeed' has a wrong offset!");
static_assert(offsetof(UCharacterAttackComponent, _specialActionTarget) == 0x000580, "Member 'UCharacterAttackComponent::_specialActionTarget' has a wrong offset!");

// Class InGameModule.Ch004Unique1Charge
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh004Unique1Charge final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique1Charge">();
	}
	static class ACh004Unique1Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique1Charge>();
	}
};
static_assert(alignof(ACh004Unique1Charge) == 0x000010, "Wrong alignment on ACh004Unique1Charge");
static_assert(sizeof(ACh004Unique1Charge) == 0x001DE0, "Wrong size on ACh004Unique1Charge");

// Class InGameModule.Ch004Unique1ChargeGen
// 0x00A0 (0x04F0 - 0x0450)
class ACh004Unique1ChargeGen final : public AProjectileGeneratorBattle
{
public:
	class FName                                   _shotNodes;                                        // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _shotEffect;                                       // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _shotEffectLocate;                                 // 0x0458(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _shotEffectRotator;                                // 0x0464(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0470(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _ShotPSC;                                          // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x38];                                     // 0x04B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique1ChargeGen">();
	}
	static class ACh004Unique1ChargeGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique1ChargeGen>();
	}
};
static_assert(alignof(ACh004Unique1ChargeGen) == 0x000010, "Wrong alignment on ACh004Unique1ChargeGen");
static_assert(sizeof(ACh004Unique1ChargeGen) == 0x0004F0, "Wrong size on ACh004Unique1ChargeGen");
static_assert(offsetof(ACh004Unique1ChargeGen, _shotNodes) == 0x000448, "Member 'ACh004Unique1ChargeGen::_shotNodes' has a wrong offset!");
static_assert(offsetof(ACh004Unique1ChargeGen, _shotEffect) == 0x000450, "Member 'ACh004Unique1ChargeGen::_shotEffect' has a wrong offset!");
static_assert(offsetof(ACh004Unique1ChargeGen, _shotEffectLocate) == 0x000458, "Member 'ACh004Unique1ChargeGen::_shotEffectLocate' has a wrong offset!");
static_assert(offsetof(ACh004Unique1ChargeGen, _shotEffectRotator) == 0x000464, "Member 'ACh004Unique1ChargeGen::_shotEffectRotator' has a wrong offset!");
static_assert(offsetof(ACh004Unique1ChargeGen, _graduallyAlpha) == 0x000470, "Member 'ACh004Unique1ChargeGen::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(ACh004Unique1ChargeGen, _ShotPSC) == 0x0004B0, "Member 'ACh004Unique1ChargeGen::_ShotPSC' has a wrong offset!");

// Class InGameModule.Ch004Unique1Gen_Var01
// 0x0000 (0x0450 - 0x0450)
class ACh004Unique1Gen_Var01 final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique1Gen_Var01">();
	}
	static class ACh004Unique1Gen_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique1Gen_Var01>();
	}
};
static_assert(alignof(ACh004Unique1Gen_Var01) == 0x000010, "Wrong alignment on ACh004Unique1Gen_Var01");
static_assert(sizeof(ACh004Unique1Gen_Var01) == 0x000450, "Wrong size on ACh004Unique1Gen_Var01");

// Class InGameModule.WrappedCh046Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class AWrappedCh046Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrappedCh046Unique2Gen">();
	}
	static class AWrappedCh046Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWrappedCh046Unique2Gen>();
	}
};
static_assert(alignof(AWrappedCh046Unique2Gen) == 0x000010, "Wrong alignment on AWrappedCh046Unique2Gen");
static_assert(sizeof(AWrappedCh046Unique2Gen) == 0x000450, "Wrong size on AWrappedCh046Unique2Gen");

// Class InGameModule.Ch004Unique1Ground_Var01
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh004Unique1Ground_Var01 final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique1Ground_Var01">();
	}
	static class ACh004Unique1Ground_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique1Ground_Var01>();
	}
};
static_assert(alignof(ACh004Unique1Ground_Var01) == 0x000010, "Wrong alignment on ACh004Unique1Ground_Var01");
static_assert(sizeof(ACh004Unique1Ground_Var01) == 0x001DE0, "Wrong size on ACh004Unique1Ground_Var01");

// Class InGameModule.Ch038Unique3Gen
// 0x0000 (0x0450 - 0x0450)
class ACh038Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	class FName                                   _socketName;                                       // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch038Unique3Gen">();
	}
	static class ACh038Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh038Unique3Gen>();
	}
};
static_assert(alignof(ACh038Unique3Gen) == 0x000010, "Wrong alignment on ACh038Unique3Gen");
static_assert(sizeof(ACh038Unique3Gen) == 0x000450, "Wrong size on ACh038Unique3Gen");
static_assert(offsetof(ACh038Unique3Gen, _socketName) == 0x000448, "Member 'ACh038Unique3Gen::_socketName' has a wrong offset!");

// Class InGameModule.Ch004Unique1GroundGen_Var01
// 0x0340 (0x0790 - 0x0450)
class ACh004Unique1GroundGen_Var01 final : public AProjectileGeneratorBattle
{
public:
	float                                         _checkHeight;                                      // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _spawnToleranceHight;                              // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _spawnToleranceLow;                                // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _spawnDecalScaleSubFront;                          // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScaleSubInterim;                        // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScaleSubRear;                           // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDPostionScale;                               // 0x0488(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                _spawnRFrontPosition;                              // 0x0498(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnRInterimPosition;                            // 0x04A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnRRearPosition;                               // 0x04B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnLFrontPosition;                              // 0x04BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnLInterimPosition;                            // 0x04C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnLRearPosition;                               // 0x04D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnAngleYawFront;                               // 0x04E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnAngleYawInterim;                             // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnAngleYawRear;                                // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x268];                                    // 0x0510(0x0268)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _ignoreList;                                       // 0x0778(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UGroundElementAccessor*                 _groundElementAccessor;                            // 0x0788(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique1GroundGen_Var01">();
	}
	static class ACh004Unique1GroundGen_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique1GroundGen_Var01>();
	}
};
static_assert(alignof(ACh004Unique1GroundGen_Var01) == 0x000010, "Wrong alignment on ACh004Unique1GroundGen_Var01");
static_assert(sizeof(ACh004Unique1GroundGen_Var01) == 0x000790, "Wrong size on ACh004Unique1GroundGen_Var01");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _checkHeight) == 0x000448, "Member 'ACh004Unique1GroundGen_Var01::_checkHeight' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnToleranceHight) == 0x00044C, "Member 'ACh004Unique1GroundGen_Var01::_spawnToleranceHight' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnToleranceLow) == 0x000450, "Member 'ACh004Unique1GroundGen_Var01::_spawnToleranceLow' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnDecalScaleSubFront) == 0x000458, "Member 'ACh004Unique1GroundGen_Var01::_spawnDecalScaleSubFront' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnDecalScaleSubInterim) == 0x000468, "Member 'ACh004Unique1GroundGen_Var01::_spawnDecalScaleSubInterim' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnDecalScaleSubRear) == 0x000478, "Member 'ACh004Unique1GroundGen_Var01::_spawnDecalScaleSubRear' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnDPostionScale) == 0x000488, "Member 'ACh004Unique1GroundGen_Var01::_spawnDPostionScale' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnRFrontPosition) == 0x000498, "Member 'ACh004Unique1GroundGen_Var01::_spawnRFrontPosition' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnRInterimPosition) == 0x0004A4, "Member 'ACh004Unique1GroundGen_Var01::_spawnRInterimPosition' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnRRearPosition) == 0x0004B0, "Member 'ACh004Unique1GroundGen_Var01::_spawnRRearPosition' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnLFrontPosition) == 0x0004BC, "Member 'ACh004Unique1GroundGen_Var01::_spawnLFrontPosition' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnLInterimPosition) == 0x0004C8, "Member 'ACh004Unique1GroundGen_Var01::_spawnLInterimPosition' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnLRearPosition) == 0x0004D4, "Member 'ACh004Unique1GroundGen_Var01::_spawnLRearPosition' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnAngleYawFront) == 0x0004E0, "Member 'ACh004Unique1GroundGen_Var01::_spawnAngleYawFront' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnAngleYawInterim) == 0x0004F0, "Member 'ACh004Unique1GroundGen_Var01::_spawnAngleYawInterim' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _spawnAngleYawRear) == 0x000500, "Member 'ACh004Unique1GroundGen_Var01::_spawnAngleYawRear' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _ignoreList) == 0x000778, "Member 'ACh004Unique1GroundGen_Var01::_ignoreList' has a wrong offset!");
static_assert(offsetof(ACh004Unique1GroundGen_Var01, _groundElementAccessor) == 0x000788, "Member 'ACh004Unique1GroundGen_Var01::_groundElementAccessor' has a wrong offset!");

// Class InGameModule.Ch004Unique1Shot_Var01
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh004Unique1Shot_Var01 final : public ABullet
{
public:
	uint8                                         Pad_1DD8[0x18];                                    // 0x1DD8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique1Shot_Var01">();
	}
	static class ACh004Unique1Shot_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique1Shot_Var01>();
	}
};
static_assert(alignof(ACh004Unique1Shot_Var01) == 0x000010, "Wrong alignment on ACh004Unique1Shot_Var01");
static_assert(sizeof(ACh004Unique1Shot_Var01) == 0x001DF0, "Wrong size on ACh004Unique1Shot_Var01");

// Class InGameModule.Ch004UniqueBase
// 0x0010 (0x2080 - 0x2070)
class ACh004UniqueBase : public ACementBase
{
public:
	float                                         _checkHight;                                       // 0x2070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkDist;                                        // 0x2074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bUseRandumSize;                                   // 0x2078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2079[0x7];                                     // 0x2079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004UniqueBase">();
	}
	static class ACh004UniqueBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004UniqueBase>();
	}
};
static_assert(alignof(ACh004UniqueBase) == 0x000010, "Wrong alignment on ACh004UniqueBase");
static_assert(sizeof(ACh004UniqueBase) == 0x002080, "Wrong size on ACh004UniqueBase");
static_assert(offsetof(ACh004UniqueBase, _checkHight) == 0x002070, "Member 'ACh004UniqueBase::_checkHight' has a wrong offset!");
static_assert(offsetof(ACh004UniqueBase, _checkDist) == 0x002074, "Member 'ACh004UniqueBase::_checkDist' has a wrong offset!");
static_assert(offsetof(ACh004UniqueBase, _bUseRandumSize) == 0x002078, "Member 'ACh004UniqueBase::_bUseRandumSize' has a wrong offset!");

// Class InGameModule.Ch100_ActionAttack_Special
// 0x0000 (0x0358 - 0x0358)
class UCh100_ActionAttack_Special final : public UActionAttackSpecialBase
{
public:
	void BP_OnReceiveAbortOrder();
	void BP_SetGiantLocal(bool bGiant);
	void BP_SetParticleScale(float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch100_ActionAttack_Special">();
	}
	static class UCh100_ActionAttack_Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCh100_ActionAttack_Special>();
	}
};
static_assert(alignof(UCh100_ActionAttack_Special) == 0x000008, "Wrong alignment on UCh100_ActionAttack_Special");
static_assert(sizeof(UCh100_ActionAttack_Special) == 0x000358, "Wrong size on UCh100_ActionAttack_Special");

// Class InGameModule.Ch004Unique2
// 0x0000 (0x2080 - 0x2080)
class ACh004Unique2 final : public ACh004UniqueBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique2">();
	}
	static class ACh004Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique2>();
	}
};
static_assert(alignof(ACh004Unique2) == 0x000010, "Wrong alignment on ACh004Unique2");
static_assert(sizeof(ACh004Unique2) == 0x002080, "Wrong size on ACh004Unique2");

// Class InGameModule.FanShapedGen
// 0x01B0 (0x0600 - 0x0450)
class AFanShapedGen : public AProjectileGeneratorBattle
{
public:
	float                                         _stratHight;                                       // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _loopCheckNum;                                     // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _groundIgnoreDist;                                 // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkHight;                                       // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkLow;                                         // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _wallDegThreshold;                                 // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScale;                                  // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EGroundElementType                            _elementType;                                      // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGroundElementAccessor*                 _groundElementAccessor;                            // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x150];                                    // 0x0480(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _decalBullets;                                     // 0x05D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x20];                                     // 0x05E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FanShapedGen">();
	}
	static class AFanShapedGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFanShapedGen>();
	}
};
static_assert(alignof(AFanShapedGen) == 0x000010, "Wrong alignment on AFanShapedGen");
static_assert(sizeof(AFanShapedGen) == 0x000600, "Wrong size on AFanShapedGen");
static_assert(offsetof(AFanShapedGen, _stratHight) == 0x000448, "Member 'AFanShapedGen::_stratHight' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _loopCheckNum) == 0x00044C, "Member 'AFanShapedGen::_loopCheckNum' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _groundIgnoreDist) == 0x000450, "Member 'AFanShapedGen::_groundIgnoreDist' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _checkHight) == 0x000454, "Member 'AFanShapedGen::_checkHight' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _checkLow) == 0x000458, "Member 'AFanShapedGen::_checkLow' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _wallDegThreshold) == 0x00045C, "Member 'AFanShapedGen::_wallDegThreshold' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _spawnDecalScale) == 0x000460, "Member 'AFanShapedGen::_spawnDecalScale' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _elementType) == 0x000470, "Member 'AFanShapedGen::_elementType' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _groundElementAccessor) == 0x000478, "Member 'AFanShapedGen::_groundElementAccessor' has a wrong offset!");
static_assert(offsetof(AFanShapedGen, _decalBullets) == 0x0005D0, "Member 'AFanShapedGen::_decalBullets' has a wrong offset!");

// Class InGameModule.Ch004Unique2Gen
// 0x0130 (0x0580 - 0x0450)
class ACh004Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	float                                         _stratHight;                                       // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _loopCheckNum;                                     // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _groundIgnoreDist;                                 // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkHight;                                       // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkLow;                                         // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _wallDegThreshold;                                 // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScale;                                  // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGroundElementAccessor*                 _groundElementAccessor;                            // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0xF8];                                     // 0x0478(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _iceBullets;                                       // 0x0570(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique2Gen">();
	}
	static class ACh004Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique2Gen>();
	}
};
static_assert(alignof(ACh004Unique2Gen) == 0x000010, "Wrong alignment on ACh004Unique2Gen");
static_assert(sizeof(ACh004Unique2Gen) == 0x000580, "Wrong size on ACh004Unique2Gen");
static_assert(offsetof(ACh004Unique2Gen, _stratHight) == 0x000448, "Member 'ACh004Unique2Gen::_stratHight' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _loopCheckNum) == 0x00044C, "Member 'ACh004Unique2Gen::_loopCheckNum' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _groundIgnoreDist) == 0x000450, "Member 'ACh004Unique2Gen::_groundIgnoreDist' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _checkHight) == 0x000454, "Member 'ACh004Unique2Gen::_checkHight' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _checkLow) == 0x000458, "Member 'ACh004Unique2Gen::_checkLow' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _wallDegThreshold) == 0x00045C, "Member 'ACh004Unique2Gen::_wallDegThreshold' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _spawnDecalScale) == 0x000460, "Member 'ACh004Unique2Gen::_spawnDecalScale' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _groundElementAccessor) == 0x000470, "Member 'ACh004Unique2Gen::_groundElementAccessor' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen, _iceBullets) == 0x000570, "Member 'ACh004Unique2Gen::_iceBullets' has a wrong offset!");

// Class InGameModule.Ch004Unique2Gen_Var01
// 0x0260 (0x06B0 - 0x0450)
class ACh004Unique2Gen_Var01 final : public AProjectileGeneratorBattle
{
public:
	float                                         _spawnToleranceHight;                              // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _spawnToleranceLow;                                // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScale;                                  // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScaleSubFront;                          // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDecalScaleSubRear;                           // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDPostionScale;                               // 0x0480(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                _spawnRFPos;                                       // 0x0490(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnRRPos;                                       // 0x049C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnLFPos;                                       // 0x04A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _spawnLRPos;                                       // 0x04B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C0[0x20];                                     // 0x04C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGroundElementAccessor*                 _groundElementAccessor;                            // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x1B8];                                    // 0x04E8(0x01B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _iceBullets;                                       // 0x06A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique2Gen_Var01">();
	}
	static class ACh004Unique2Gen_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique2Gen_Var01>();
	}
};
static_assert(alignof(ACh004Unique2Gen_Var01) == 0x000010, "Wrong alignment on ACh004Unique2Gen_Var01");
static_assert(sizeof(ACh004Unique2Gen_Var01) == 0x0006B0, "Wrong size on ACh004Unique2Gen_Var01");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnToleranceHight) == 0x000448, "Member 'ACh004Unique2Gen_Var01::_spawnToleranceHight' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnToleranceLow) == 0x00044C, "Member 'ACh004Unique2Gen_Var01::_spawnToleranceLow' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnDecalScale) == 0x000450, "Member 'ACh004Unique2Gen_Var01::_spawnDecalScale' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnDecalScaleSubFront) == 0x000460, "Member 'ACh004Unique2Gen_Var01::_spawnDecalScaleSubFront' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnDecalScaleSubRear) == 0x000470, "Member 'ACh004Unique2Gen_Var01::_spawnDecalScaleSubRear' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnDPostionScale) == 0x000480, "Member 'ACh004Unique2Gen_Var01::_spawnDPostionScale' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnRFPos) == 0x000490, "Member 'ACh004Unique2Gen_Var01::_spawnRFPos' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnRRPos) == 0x00049C, "Member 'ACh004Unique2Gen_Var01::_spawnRRPos' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnLFPos) == 0x0004A8, "Member 'ACh004Unique2Gen_Var01::_spawnLFPos' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _spawnLRPos) == 0x0004B4, "Member 'ACh004Unique2Gen_Var01::_spawnLRPos' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _groundElementAccessor) == 0x0004E0, "Member 'ACh004Unique2Gen_Var01::_groundElementAccessor' has a wrong offset!");
static_assert(offsetof(ACh004Unique2Gen_Var01, _iceBullets) == 0x0006A0, "Member 'ACh004Unique2Gen_Var01::_iceBullets' has a wrong offset!");

// Class InGameModule.Ch004Unique3_Child_Var01
// 0x00D0 (0x20A0 - 0x1FD0)
class ACh004Unique3_Child_Var01 final : public ACustomBullet
{
public:
	class USphereComponent*                       _physicsRoot;                                      // 0x1FD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reflectionSpan;                                   // 0x1FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _dotToleranceDownHill;                             // 0x1FDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defultReflectionSpeedLimitValue;                  // 0x1FE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lossReflection;                                   // 0x1FE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lossAccelerationValueMax;                         // 0x1FE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lossDownHillValueMax;                             // 0x1FEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _groundMass;                                       // 0x1FF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _airMass;                                          // 0x1FF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF8[0x90];                                    // 0x1FF8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _ignoreList;                                       // 0x2088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2098[0x8];                                     // 0x2098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_PhysicsOnHitBackground(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique3_Child_Var01">();
	}
	static class ACh004Unique3_Child_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique3_Child_Var01>();
	}
};
static_assert(alignof(ACh004Unique3_Child_Var01) == 0x000010, "Wrong alignment on ACh004Unique3_Child_Var01");
static_assert(sizeof(ACh004Unique3_Child_Var01) == 0x0020A0, "Wrong size on ACh004Unique3_Child_Var01");
static_assert(offsetof(ACh004Unique3_Child_Var01, _physicsRoot) == 0x001FD0, "Member 'ACh004Unique3_Child_Var01::_physicsRoot' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _reflectionSpan) == 0x001FD8, "Member 'ACh004Unique3_Child_Var01::_reflectionSpan' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _dotToleranceDownHill) == 0x001FDC, "Member 'ACh004Unique3_Child_Var01::_dotToleranceDownHill' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _defultReflectionSpeedLimitValue) == 0x001FE0, "Member 'ACh004Unique3_Child_Var01::_defultReflectionSpeedLimitValue' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _lossReflection) == 0x001FE4, "Member 'ACh004Unique3_Child_Var01::_lossReflection' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _lossAccelerationValueMax) == 0x001FE8, "Member 'ACh004Unique3_Child_Var01::_lossAccelerationValueMax' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _lossDownHillValueMax) == 0x001FEC, "Member 'ACh004Unique3_Child_Var01::_lossDownHillValueMax' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _groundMass) == 0x001FF0, "Member 'ACh004Unique3_Child_Var01::_groundMass' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _airMass) == 0x001FF4, "Member 'ACh004Unique3_Child_Var01::_airMass' has a wrong offset!");
static_assert(offsetof(ACh004Unique3_Child_Var01, _ignoreList) == 0x002088, "Member 'ACh004Unique3_Child_Var01::_ignoreList' has a wrong offset!");

// Class InGameModule.ConditionDataWork
// 0x0050 (0x0080 - 0x0030)
class UConditionDataWork final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionDataWork">();
	}
	static class UConditionDataWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionDataWork>();
	}
};
static_assert(alignof(UConditionDataWork) == 0x000008, "Wrong alignment on UConditionDataWork");
static_assert(sizeof(UConditionDataWork) == 0x000080, "Wrong size on UConditionDataWork");

// Class InGameModule.Ch004Unique3_Var01
// 0x0010 (0x1FE0 - 0x1FD0)
class ACh004Unique3_Var01 final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x10];                                    // 0x1FD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique3_Var01">();
	}
	static class ACh004Unique3_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique3_Var01>();
	}
};
static_assert(alignof(ACh004Unique3_Var01) == 0x000010, "Wrong alignment on ACh004Unique3_Var01");
static_assert(sizeof(ACh004Unique3_Var01) == 0x001FE0, "Wrong size on ACh004Unique3_Var01");

// Class InGameModule.Ch046Unique1Gen
// 0x0060 (0x04B0 - 0x0450)
class ACh046Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x68];                                     // 0x0448(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Fire(const struct FCh046BulletInfo& bulletInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch046Unique1Gen">();
	}
	static class ACh046Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh046Unique1Gen>();
	}
};
static_assert(alignof(ACh046Unique1Gen) == 0x000010, "Wrong alignment on ACh046Unique1Gen");
static_assert(sizeof(ACh046Unique1Gen) == 0x0004B0, "Wrong size on ACh046Unique1Gen");

// Class InGameModule.Ch004Unique3Gen
// 0x0010 (0x0580 - 0x0570)
class ACh004Unique3Gen final : public ACrawlBaseGen
{
public:
	class UGroundElementAccessor*                 _groundElementAccessor;                            // 0x0570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique3Gen">();
	}
	static class ACh004Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique3Gen>();
	}
};
static_assert(alignof(ACh004Unique3Gen) == 0x000010, "Wrong alignment on ACh004Unique3Gen");
static_assert(sizeof(ACh004Unique3Gen) == 0x000580, "Wrong size on ACh004Unique3Gen");
static_assert(offsetof(ACh004Unique3Gen, _groundElementAccessor) == 0x000570, "Member 'ACh004Unique3Gen::_groundElementAccessor' has a wrong offset!");

// Class InGameModule.Ch004Unique3Gen_Child_Var01
// 0x0000 (0x0450 - 0x0450)
class ACh004Unique3Gen_Child_Var01 final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique3Gen_Child_Var01">();
	}
	static class ACh004Unique3Gen_Child_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique3Gen_Child_Var01>();
	}
};
static_assert(alignof(ACh004Unique3Gen_Child_Var01) == 0x000010, "Wrong alignment on ACh004Unique3Gen_Child_Var01");
static_assert(sizeof(ACh004Unique3Gen_Child_Var01) == 0x000450, "Wrong size on ACh004Unique3Gen_Child_Var01");

// Class InGameModule.Cracks
// 0x00B0 (0x1E90 - 0x1DE0)
class ACracks : public ABullet
{
public:
	float                                         _signParticleSizeMul;                              // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0x4];                                     // 0x1DDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialCurveControl*                  _materialCurveCtrlTbl;                             // 0x1DE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomZRot;                                       // 0x1DE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DEC[0x4];                                     // 0x1DEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInGameDecalComponent*                  _decalComponent;                                   // 0x1DF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _signParticle;                                     // 0x1DF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _signFriendParticle;                               // 0x1E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _disappearParticle;                                // 0x1E08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _teamAreaEffect;                                   // 0x1E10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBulletParticleSystemComponent*         _enemyAreaEffect;                                  // 0x1E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroSphereComponent*                   _h1;                                               // 0x1E20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E28[0x38];                                    // 0x1E28(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _mid;                                              // 0x1E60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E68[0x28];                                    // 0x1E68(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBeginEnd();
	class UMaterialInstanceDynamic* GetMID();
	float GetRandomZRot();
	class UMaterialInstanceDynamic* SetMID(class UMaterialInstanceDynamic* Mid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cracks">();
	}
	static class ACracks* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACracks>();
	}
};
static_assert(alignof(ACracks) == 0x000010, "Wrong alignment on ACracks");
static_assert(sizeof(ACracks) == 0x001E90, "Wrong size on ACracks");
static_assert(offsetof(ACracks, _signParticleSizeMul) == 0x001DD8, "Member 'ACracks::_signParticleSizeMul' has a wrong offset!");
static_assert(offsetof(ACracks, _materialCurveCtrlTbl) == 0x001DE0, "Member 'ACracks::_materialCurveCtrlTbl' has a wrong offset!");
static_assert(offsetof(ACracks, _randomZRot) == 0x001DE8, "Member 'ACracks::_randomZRot' has a wrong offset!");
static_assert(offsetof(ACracks, _decalComponent) == 0x001DF0, "Member 'ACracks::_decalComponent' has a wrong offset!");
static_assert(offsetof(ACracks, _signParticle) == 0x001DF8, "Member 'ACracks::_signParticle' has a wrong offset!");
static_assert(offsetof(ACracks, _signFriendParticle) == 0x001E00, "Member 'ACracks::_signFriendParticle' has a wrong offset!");
static_assert(offsetof(ACracks, _disappearParticle) == 0x001E08, "Member 'ACracks::_disappearParticle' has a wrong offset!");
static_assert(offsetof(ACracks, _teamAreaEffect) == 0x001E10, "Member 'ACracks::_teamAreaEffect' has a wrong offset!");
static_assert(offsetof(ACracks, _enemyAreaEffect) == 0x001E18, "Member 'ACracks::_enemyAreaEffect' has a wrong offset!");
static_assert(offsetof(ACracks, _h1) == 0x001E20, "Member 'ACracks::_h1' has a wrong offset!");
static_assert(offsetof(ACracks, _mid) == 0x001E60, "Member 'ACracks::_mid' has a wrong offset!");

// Class InGameModule.CracksRange
// 0x0030 (0x1EC0 - 0x1E90)
class ACracksRange final : public ACracks
{
public:
	uint8                                         Pad_1E90[0x28];                                    // 0x1E90(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _deActiveAreaEffectSeconds;                        // 0x1EB8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EBC[0x4];                                     // 0x1EBC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeActiveAreaEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CracksRange">();
	}
	static class ACracksRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACracksRange>();
	}
};
static_assert(alignof(ACracksRange) == 0x000010, "Wrong alignment on ACracksRange");
static_assert(sizeof(ACracksRange) == 0x001EC0, "Wrong size on ACracksRange");
static_assert(offsetof(ACracksRange, _deActiveAreaEffectSeconds) == 0x001EB8, "Member 'ACracksRange::_deActiveAreaEffectSeconds' has a wrong offset!");

// Class InGameModule.Ch004Unique3Gen_Var01
// 0x0030 (0x0480 - 0x0450)
class ACh004Unique3Gen_Var01 final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCh004Unique3TransformRep>      _transformsRep;                                    // 0x0460(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           _hReplicateTimer;                                  // 0x0470(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004Unique3Gen_Var01">();
	}
	static class ACh004Unique3Gen_Var01* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004Unique3Gen_Var01>();
	}
};
static_assert(alignof(ACh004Unique3Gen_Var01) == 0x000010, "Wrong alignment on ACh004Unique3Gen_Var01");
static_assert(sizeof(ACh004Unique3Gen_Var01) == 0x000480, "Wrong size on ACh004Unique3Gen_Var01");
static_assert(offsetof(ACh004Unique3Gen_Var01, _transformsRep) == 0x000460, "Member 'ACh004Unique3Gen_Var01::_transformsRep' has a wrong offset!");
static_assert(offsetof(ACh004Unique3Gen_Var01, _hReplicateTimer) == 0x000470, "Member 'ACh004Unique3Gen_Var01::_hReplicateTimer' has a wrong offset!");

// Class InGameModule.Ch038
// 0x0010 (0x0B20 - 0x0B10)
class ACh038 final : public ACharacterBattle
{
public:
	uint8                                         Pad_B10[0x8];                                      // 0x0B10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _CarriedCharacter;                                 // 0x0B18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CatchSuccessed_ToClient(class ACharacterBattle* Target);
	void CatchSuccessed_ToSever(class ACharacterBattle* Target);
	void Released_ToClient();
	void Released_ToSever();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch038">();
	}
	static class ACh038* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh038>();
	}
};
static_assert(alignof(ACh038) == 0x000010, "Wrong alignment on ACh038");
static_assert(sizeof(ACh038) == 0x000B20, "Wrong size on ACh038");
static_assert(offsetof(ACh038, _CarriedCharacter) == 0x000B18, "Member 'ACh038::_CarriedCharacter' has a wrong offset!");

// Class InGameModule.Ch004UniqueWater
// 0x00E0 (0x2160 - 0x2080)
class ACh004UniqueWater final : public ACh004UniqueBase
{
public:
	float                                         _BaseSize;                                         // 0x2080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AddPosHight;                                      // 0x2084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2088[0xD8];                                    // 0x2088(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch004UniqueWater">();
	}
	static class ACh004UniqueWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh004UniqueWater>();
	}
};
static_assert(alignof(ACh004UniqueWater) == 0x000010, "Wrong alignment on ACh004UniqueWater");
static_assert(sizeof(ACh004UniqueWater) == 0x002160, "Wrong size on ACh004UniqueWater");
static_assert(offsetof(ACh004UniqueWater, _BaseSize) == 0x002080, "Member 'ACh004UniqueWater::_BaseSize' has a wrong offset!");
static_assert(offsetof(ACh004UniqueWater, _AddPosHight) == 0x002084, "Member 'ACh004UniqueWater::_AddPosHight' has a wrong offset!");

// Class InGameModule.Ch005Unique2
// 0x0030 (0x1E10 - 0x1DE0)
class ACh005Unique2 final : public ABullet
{
public:
	uint8                                         Pad_1DD8[0x8];                                     // 0x1DD8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  _addGroundQuat;                                    // 0x1DE0(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  _addAirQuat;                                       // 0x1DF0(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCustomParticleSystemComponent*         _particle;                                         // 0x1E00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E08[0x8];                                     // 0x1E08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch005Unique2">();
	}
	static class ACh005Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh005Unique2>();
	}
};
static_assert(alignof(ACh005Unique2) == 0x000010, "Wrong alignment on ACh005Unique2");
static_assert(sizeof(ACh005Unique2) == 0x001E10, "Wrong size on ACh005Unique2");
static_assert(offsetof(ACh005Unique2, _addGroundQuat) == 0x001DE0, "Member 'ACh005Unique2::_addGroundQuat' has a wrong offset!");
static_assert(offsetof(ACh005Unique2, _addAirQuat) == 0x001DF0, "Member 'ACh005Unique2::_addAirQuat' has a wrong offset!");
static_assert(offsetof(ACh005Unique2, _particle) == 0x001E00, "Member 'ACh005Unique2::_particle' has a wrong offset!");

// Class InGameModule.Ch006Unique1Shot
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh006Unique1Shot final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch006Unique1Shot">();
	}
	static class ACh006Unique1Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh006Unique1Shot>();
	}
};
static_assert(alignof(ACh006Unique1Shot) == 0x000010, "Wrong alignment on ACh006Unique1Shot");
static_assert(sizeof(ACh006Unique1Shot) == 0x001FD0, "Wrong size on ACh006Unique1Shot");

// Class InGameModule.CustomBulletHomingComponent
// 0x0230 (0x02E0 - 0x00B0)
class UCustomBulletHomingComponent final : public UCustomBulletComponentBase
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _homingSpanInitial;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpanMid;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpanEnd;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpanInitialToMidTime;                       // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpanMidToEndTime;                           // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _homingSpanToMidEasingType;                        // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _homingSpanToEndEasingType;                        // 0x00D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _homingSpeedInitial;                               // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpeedMid;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpeedEnd;                                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpeedInitialToMidTime;                      // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingSpeedMidToEndTime;                          // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _homingSpeedToMidEasingType;                       // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _homingSpeedToEndEasingType;                       // 0x00ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _homingMaxDistance;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _homingMinDistance;                                // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bAdjustHomingRateByDistance;                      // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   _transitionEasingType;                             // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _limitHomingAngleDegree;                           // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bPassedDestroy;                                   // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x1DF];                                    // 0x0101(0x01DF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomBulletHomingComponent">();
	}
	static class UCustomBulletHomingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomBulletHomingComponent>();
	}
};
static_assert(alignof(UCustomBulletHomingComponent) == 0x000008, "Wrong alignment on UCustomBulletHomingComponent");
static_assert(sizeof(UCustomBulletHomingComponent) == 0x0002E0, "Wrong size on UCustomBulletHomingComponent");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpanInitial) == 0x0000C0, "Member 'UCustomBulletHomingComponent::_homingSpanInitial' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpanMid) == 0x0000C4, "Member 'UCustomBulletHomingComponent::_homingSpanMid' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpanEnd) == 0x0000C8, "Member 'UCustomBulletHomingComponent::_homingSpanEnd' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpanInitialToMidTime) == 0x0000CC, "Member 'UCustomBulletHomingComponent::_homingSpanInitialToMidTime' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpanMidToEndTime) == 0x0000D0, "Member 'UCustomBulletHomingComponent::_homingSpanMidToEndTime' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpanToMidEasingType) == 0x0000D4, "Member 'UCustomBulletHomingComponent::_homingSpanToMidEasingType' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpanToEndEasingType) == 0x0000D5, "Member 'UCustomBulletHomingComponent::_homingSpanToEndEasingType' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpeedInitial) == 0x0000D8, "Member 'UCustomBulletHomingComponent::_homingSpeedInitial' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpeedMid) == 0x0000DC, "Member 'UCustomBulletHomingComponent::_homingSpeedMid' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpeedEnd) == 0x0000E0, "Member 'UCustomBulletHomingComponent::_homingSpeedEnd' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpeedInitialToMidTime) == 0x0000E4, "Member 'UCustomBulletHomingComponent::_homingSpeedInitialToMidTime' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpeedMidToEndTime) == 0x0000E8, "Member 'UCustomBulletHomingComponent::_homingSpeedMidToEndTime' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpeedToMidEasingType) == 0x0000EC, "Member 'UCustomBulletHomingComponent::_homingSpeedToMidEasingType' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingSpeedToEndEasingType) == 0x0000ED, "Member 'UCustomBulletHomingComponent::_homingSpeedToEndEasingType' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingMaxDistance) == 0x0000F0, "Member 'UCustomBulletHomingComponent::_homingMaxDistance' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _homingMinDistance) == 0x0000F4, "Member 'UCustomBulletHomingComponent::_homingMinDistance' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _bAdjustHomingRateByDistance) == 0x0000F8, "Member 'UCustomBulletHomingComponent::_bAdjustHomingRateByDistance' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _transitionEasingType) == 0x0000F9, "Member 'UCustomBulletHomingComponent::_transitionEasingType' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _limitHomingAngleDegree) == 0x0000FC, "Member 'UCustomBulletHomingComponent::_limitHomingAngleDegree' has a wrong offset!");
static_assert(offsetof(UCustomBulletHomingComponent, _bPassedDestroy) == 0x000100, "Member 'UCustomBulletHomingComponent::_bPassedDestroy' has a wrong offset!");

// Class InGameModule.Ch007BackGroundHit
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh007BackGroundHit final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007BackGroundHit">();
	}
	static class ACh007BackGroundHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007BackGroundHit>();
	}
};
static_assert(alignof(ACh007BackGroundHit) == 0x000010, "Wrong alignment on ACh007BackGroundHit");
static_assert(sizeof(ACh007BackGroundHit) == 0x001DE0, "Wrong size on ACh007BackGroundHit");

// Class InGameModule.Ch101SpecialGen
// 0x0020 (0x0470 - 0x0450)
class ACh101SpecialGen final : public AProjectileGeneratorBattle
{
public:
	float                                         _checkStartPosHight;                               // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkHight;                                       // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x4];                                      // 0x0450(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCh101SpecialGenRep                    _createCh101SpecialRep;                            // 0x0454(0x0014)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateCh101Special_RPC(const struct FCh101SpecialGenRep& Gen);
	void OnRep_CreateCh101Special();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch101SpecialGen">();
	}
	static class ACh101SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh101SpecialGen>();
	}
};
static_assert(alignof(ACh101SpecialGen) == 0x000010, "Wrong alignment on ACh101SpecialGen");
static_assert(sizeof(ACh101SpecialGen) == 0x000470, "Wrong size on ACh101SpecialGen");
static_assert(offsetof(ACh101SpecialGen, _checkStartPosHight) == 0x000448, "Member 'ACh101SpecialGen::_checkStartPosHight' has a wrong offset!");
static_assert(offsetof(ACh101SpecialGen, _checkHight) == 0x00044C, "Member 'ACh101SpecialGen::_checkHight' has a wrong offset!");
static_assert(offsetof(ACh101SpecialGen, _createCh101SpecialRep) == 0x000454, "Member 'ACh101SpecialGen::_createCh101SpecialRep' has a wrong offset!");

// Class InGameModule.Ch007BackGroundHitGen
// 0x0000 (0x0450 - 0x0450)
class ACh007BackGroundHitGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007BackGroundHitGen">();
	}
	static class ACh007BackGroundHitGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007BackGroundHitGen>();
	}
};
static_assert(alignof(ACh007BackGroundHitGen) == 0x000010, "Wrong alignment on ACh007BackGroundHitGen");
static_assert(sizeof(ACh007BackGroundHitGen) == 0x000450, "Wrong size on ACh007BackGroundHitGen");

// Class InGameModule.Ch007UniqueBase
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh007UniqueBase : public ABullet
{
public:
	float                                         _ImpactDistance;                                   // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0x4];                                     // 0x1DDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _hitBgPropList;                                    // 0x1DE0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007UniqueBase">();
	}
	static class ACh007UniqueBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007UniqueBase>();
	}
};
static_assert(alignof(ACh007UniqueBase) == 0x000010, "Wrong alignment on ACh007UniqueBase");
static_assert(sizeof(ACh007UniqueBase) == 0x001DF0, "Wrong size on ACh007UniqueBase");
static_assert(offsetof(ACh007UniqueBase, _ImpactDistance) == 0x001DD8, "Member 'ACh007UniqueBase::_ImpactDistance' has a wrong offset!");
static_assert(offsetof(ACh007UniqueBase, _hitBgPropList) == 0x001DE0, "Member 'ACh007UniqueBase::_hitBgPropList' has a wrong offset!");

// Class InGameModule.Ch007Special
// 0x0000 (0x1DF0 - 0x1DF0)
class ACh007Special final : public ACh007UniqueBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Special">();
	}
	static class ACh007Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Special>();
	}
};
static_assert(alignof(ACh007Special) == 0x000010, "Wrong alignment on ACh007Special");
static_assert(sizeof(ACh007Special) == 0x001DF0, "Wrong size on ACh007Special");

// Class InGameModule.CustomProjectileMovementComponent
// 0x0010 (0x01E0 - 0x01D0)
class UCustomProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	uint8                                         Pad_1D0[0x8];                                      // 0x01D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABullet*                                _ownerBullet;                                      // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomProjectileMovementComponent">();
	}
	static class UCustomProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomProjectileMovementComponent>();
	}
};
static_assert(alignof(UCustomProjectileMovementComponent) == 0x000010, "Wrong alignment on UCustomProjectileMovementComponent");
static_assert(sizeof(UCustomProjectileMovementComponent) == 0x0001E0, "Wrong size on UCustomProjectileMovementComponent");
static_assert(offsetof(UCustomProjectileMovementComponent, _ownerBullet) == 0x0001D8, "Member 'UCustomProjectileMovementComponent::_ownerBullet' has a wrong offset!");

// Class InGameModule.Ch007SpecialGen
// 0x0010 (0x0460 - 0x0450)
class ACh007SpecialGen final : public AProjectileGeneratorBattle
{
public:
	class ABullet*                                _bullet;                                           // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007SpecialGen">();
	}
	static class ACh007SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007SpecialGen>();
	}
};
static_assert(alignof(ACh007SpecialGen) == 0x000010, "Wrong alignment on ACh007SpecialGen");
static_assert(sizeof(ACh007SpecialGen) == 0x000460, "Wrong size on ACh007SpecialGen");
static_assert(offsetof(ACh007SpecialGen, _bullet) == 0x000448, "Member 'ACh007SpecialGen::_bullet' has a wrong offset!");
static_assert(offsetof(ACh007SpecialGen, _playerState) == 0x000450, "Member 'ACh007SpecialGen::_playerState' has a wrong offset!");

// Class InGameModule.Ch043Unique3Shot
// 0x0020 (0x1E00 - 0x1DE0)
class ACh043Unique3Shot final : public ABullet
{
public:
	struct FBulletSE                              _detonateVoice;                                    // 0x1DD8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DF8[0x8];                                     // 0x1DF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch043Unique3Shot">();
	}
	static class ACh043Unique3Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh043Unique3Shot>();
	}
};
static_assert(alignof(ACh043Unique3Shot) == 0x000010, "Wrong alignment on ACh043Unique3Shot");
static_assert(sizeof(ACh043Unique3Shot) == 0x001E00, "Wrong size on ACh043Unique3Shot");
static_assert(offsetof(ACh043Unique3Shot, _detonateVoice) == 0x001DD8, "Member 'ACh043Unique3Shot::_detonateVoice' has a wrong offset!");

// Class InGameModule.Ch007Unique1
// 0x0030 (0x1E20 - 0x1DF0)
class ACh007Unique1 final : public ACh007UniqueBase
{
public:
	float                                         _ThunderLineBaseSize;                              // 0x1DF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _endTime;                                          // 0x1DF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _endLineSpan;                                      // 0x1DF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DFC[0x4];                                     // 0x1DFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomParticleSystemComponent*         _lineParticle;                                     // 0x1E00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E08[0x18];                                    // 0x1E08(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique1">();
	}
	static class ACh007Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique1>();
	}
};
static_assert(alignof(ACh007Unique1) == 0x000010, "Wrong alignment on ACh007Unique1");
static_assert(sizeof(ACh007Unique1) == 0x001E20, "Wrong size on ACh007Unique1");
static_assert(offsetof(ACh007Unique1, _ThunderLineBaseSize) == 0x001DF0, "Member 'ACh007Unique1::_ThunderLineBaseSize' has a wrong offset!");
static_assert(offsetof(ACh007Unique1, _endTime) == 0x001DF4, "Member 'ACh007Unique1::_endTime' has a wrong offset!");
static_assert(offsetof(ACh007Unique1, _endLineSpan) == 0x001DF8, "Member 'ACh007Unique1::_endLineSpan' has a wrong offset!");
static_assert(offsetof(ACh007Unique1, _lineParticle) == 0x001E00, "Member 'ACh007Unique1::_lineParticle' has a wrong offset!");

// Class InGameModule.Ch007Unique1ConnectPointGen
// 0x0020 (0x0470 - 0x0450)
class ACh007Unique1ConnectPointGen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACh007Unique1Point*>             _connectTarget;                                    // 0x0450(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ACh007Unique1Point*                     _connectOwner;                                     // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique1ConnectPointGen">();
	}
	static class ACh007Unique1ConnectPointGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique1ConnectPointGen>();
	}
};
static_assert(alignof(ACh007Unique1ConnectPointGen) == 0x000010, "Wrong alignment on ACh007Unique1ConnectPointGen");
static_assert(sizeof(ACh007Unique1ConnectPointGen) == 0x000470, "Wrong size on ACh007Unique1ConnectPointGen");
static_assert(offsetof(ACh007Unique1ConnectPointGen, _connectTarget) == 0x000450, "Member 'ACh007Unique1ConnectPointGen::_connectTarget' has a wrong offset!");
static_assert(offsetof(ACh007Unique1ConnectPointGen, _connectOwner) == 0x000460, "Member 'ACh007Unique1ConnectPointGen::_connectOwner' has a wrong offset!");

// Class InGameModule.Ch007Unique1Gen
// 0x0020 (0x0470 - 0x0450)
class ACh007Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	struct FThunderShotGenRep                     _createConnectPointRep;                            // 0x0448(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	class ACh007Unique1*                          _ThunderShot;                                      // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateConnectPoint_RPC(const struct FThunderShotGenRep& Gen);
	void OnRep_CreateConnectPoint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique1Gen">();
	}
	static class ACh007Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique1Gen>();
	}
};
static_assert(alignof(ACh007Unique1Gen) == 0x000010, "Wrong alignment on ACh007Unique1Gen");
static_assert(sizeof(ACh007Unique1Gen) == 0x000470, "Wrong size on ACh007Unique1Gen");
static_assert(offsetof(ACh007Unique1Gen, _createConnectPointRep) == 0x000448, "Member 'ACh007Unique1Gen::_createConnectPointRep' has a wrong offset!");
static_assert(offsetof(ACh007Unique1Gen, _ThunderShot) == 0x000458, "Member 'ACh007Unique1Gen::_ThunderShot' has a wrong offset!");

// Class InGameModule.CharacterActingComponent
// 0x0010 (0x00C8 - 0x00B8)
class UCharacterActingComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterActingComponent">();
	}
	static class UCharacterActingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterActingComponent>();
	}
};
static_assert(alignof(UCharacterActingComponent) == 0x000008, "Wrong alignment on UCharacterActingComponent");
static_assert(sizeof(UCharacterActingComponent) == 0x0000C8, "Wrong size on UCharacterActingComponent");

// Class InGameModule.Ch007Unique1Line
// 0x00D0 (0x1EB0 - 0x1DE0)
class ACh007Unique1Line final : public ABullet
{
public:
	float                                         _ThunderLineBaseSize;                              // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _extendTime;                                       // 0x1DDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABullet*                                _ownerBullet;                                      // 0x1DE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABullet*                                _targetBullet;                                     // 0x1DE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DF0[0xC0];                                    // 0x1DF0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique1Line">();
	}
	static class ACh007Unique1Line* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique1Line>();
	}
};
static_assert(alignof(ACh007Unique1Line) == 0x000010, "Wrong alignment on ACh007Unique1Line");
static_assert(sizeof(ACh007Unique1Line) == 0x001EB0, "Wrong size on ACh007Unique1Line");
static_assert(offsetof(ACh007Unique1Line, _ThunderLineBaseSize) == 0x001DD8, "Member 'ACh007Unique1Line::_ThunderLineBaseSize' has a wrong offset!");
static_assert(offsetof(ACh007Unique1Line, _extendTime) == 0x001DDC, "Member 'ACh007Unique1Line::_extendTime' has a wrong offset!");
static_assert(offsetof(ACh007Unique1Line, _ownerBullet) == 0x001DE0, "Member 'ACh007Unique1Line::_ownerBullet' has a wrong offset!");
static_assert(offsetof(ACh007Unique1Line, _targetBullet) == 0x001DE8, "Member 'ACh007Unique1Line::_targetBullet' has a wrong offset!");

// Class InGameModule.Portal
// 0x00E0 (0x1EC0 - 0x1DE0)
class APortal : public ABullet
{
public:
	TArray<class ABullet*>                        _inPortalList;                                     // 0x1DD8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DE8[0x8];                                     // 0x1DE8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHeroCapsuleComponent*                  _gateCollision;                                    // 0x1DF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _cameraEffect;                                     // 0x1DF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _cameraEffectOffset;                               // 0x1E00(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0C[0x4];                                     // 0x1E0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _inEff;                                            // 0x1E10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _outEff;                                           // 0x1E18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _outEffChara;                                      // 0x1E20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _beginCurve;                                       // 0x1E28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _endCurve;                                         // 0x1E30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _alphaCurveTarget;                                 // 0x1E38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APortal*                                _targetPortal;                                     // 0x1E40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        _debugArrowComponent;                              // 0x1E48(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMultiTraceComponent*                   _multiTraceComponent;                              // 0x1E50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               _psc;                                              // 0x1E58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _portalInSE;                                       // 0x1E60(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTimerHandle                           _portalWarpResume;                                 // 0x1E80(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UActorComponent*>                _overlapTypeShapes;                                // 0x1E88(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ACharacterBattle*>               _overlappedCharacterTbl;                           // 0x1E98(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EA8[0x18];                                    // 0x1EA8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CharacterOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnParticleEnd(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction);
	void UpdateArrowPointer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Portal">();
	}
	static class APortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<APortal>();
	}
};
static_assert(alignof(APortal) == 0x000010, "Wrong alignment on APortal");
static_assert(sizeof(APortal) == 0x001EC0, "Wrong size on APortal");
static_assert(offsetof(APortal, _inPortalList) == 0x001DD8, "Member 'APortal::_inPortalList' has a wrong offset!");
static_assert(offsetof(APortal, _gateCollision) == 0x001DF0, "Member 'APortal::_gateCollision' has a wrong offset!");
static_assert(offsetof(APortal, _cameraEffect) == 0x001DF8, "Member 'APortal::_cameraEffect' has a wrong offset!");
static_assert(offsetof(APortal, _cameraEffectOffset) == 0x001E00, "Member 'APortal::_cameraEffectOffset' has a wrong offset!");
static_assert(offsetof(APortal, _inEff) == 0x001E10, "Member 'APortal::_inEff' has a wrong offset!");
static_assert(offsetof(APortal, _outEff) == 0x001E18, "Member 'APortal::_outEff' has a wrong offset!");
static_assert(offsetof(APortal, _outEffChara) == 0x001E20, "Member 'APortal::_outEffChara' has a wrong offset!");
static_assert(offsetof(APortal, _beginCurve) == 0x001E28, "Member 'APortal::_beginCurve' has a wrong offset!");
static_assert(offsetof(APortal, _endCurve) == 0x001E30, "Member 'APortal::_endCurve' has a wrong offset!");
static_assert(offsetof(APortal, _alphaCurveTarget) == 0x001E38, "Member 'APortal::_alphaCurveTarget' has a wrong offset!");
static_assert(offsetof(APortal, _targetPortal) == 0x001E40, "Member 'APortal::_targetPortal' has a wrong offset!");
static_assert(offsetof(APortal, _debugArrowComponent) == 0x001E48, "Member 'APortal::_debugArrowComponent' has a wrong offset!");
static_assert(offsetof(APortal, _multiTraceComponent) == 0x001E50, "Member 'APortal::_multiTraceComponent' has a wrong offset!");
static_assert(offsetof(APortal, _psc) == 0x001E58, "Member 'APortal::_psc' has a wrong offset!");
static_assert(offsetof(APortal, _portalInSE) == 0x001E60, "Member 'APortal::_portalInSE' has a wrong offset!");
static_assert(offsetof(APortal, _portalWarpResume) == 0x001E80, "Member 'APortal::_portalWarpResume' has a wrong offset!");
static_assert(offsetof(APortal, _overlapTypeShapes) == 0x001E88, "Member 'APortal::_overlapTypeShapes' has a wrong offset!");
static_assert(offsetof(APortal, _overlappedCharacterTbl) == 0x001E98, "Member 'APortal::_overlappedCharacterTbl' has a wrong offset!");

// Class InGameModule.Ch103Special
// 0x0050 (0x1F10 - 0x1EC0)
class ACh103Special final : public APortal
{
public:
	uint8                                         Pad_1EC0[0x30];                                    // 0x1EC0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _targetCharacter;                                  // 0x1EF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _enableCollisionTimeSeconds;                       // 0x1EF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EFC[0x4];                                     // 0x1EFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           _enableOverlapTimer;                               // 0x1F00(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F08[0x8];                                     // 0x1F08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch103Special">();
	}
	static class ACh103Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh103Special>();
	}
};
static_assert(alignof(ACh103Special) == 0x000010, "Wrong alignment on ACh103Special");
static_assert(sizeof(ACh103Special) == 0x001F10, "Wrong size on ACh103Special");
static_assert(offsetof(ACh103Special, _targetCharacter) == 0x001EF0, "Member 'ACh103Special::_targetCharacter' has a wrong offset!");
static_assert(offsetof(ACh103Special, _enableCollisionTimeSeconds) == 0x001EF8, "Member 'ACh103Special::_enableCollisionTimeSeconds' has a wrong offset!");
static_assert(offsetof(ACh103Special, _enableOverlapTimer) == 0x001F00, "Member 'ACh103Special::_enableOverlapTimer' has a wrong offset!");

// Class InGameModule.Ch007Unique1Point
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh007Unique1Point final : public ABullet
{
public:
	int32                                         _pointMaxNum;                                      // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0x4];                                     // 0x1DDC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique1Point">();
	}
	static class ACh007Unique1Point* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique1Point>();
	}
};
static_assert(alignof(ACh007Unique1Point) == 0x000010, "Wrong alignment on ACh007Unique1Point");
static_assert(sizeof(ACh007Unique1Point) == 0x001DE0, "Wrong size on ACh007Unique1Point");
static_assert(offsetof(ACh007Unique1Point, _pointMaxNum) == 0x001DD8, "Member 'ACh007Unique1Point::_pointMaxNum' has a wrong offset!");

// Class InGameModule.Ch007Unique2
// 0x0010 (0x1E00 - 0x1DF0)
class ACh007Unique2 final : public ACh007UniqueBase
{
public:
	uint8                                         Pad_1DF0[0x10];                                    // 0x1DF0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFoolVanish(bool IsFool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique2">();
	}
	static class ACh007Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique2>();
	}
};
static_assert(alignof(ACh007Unique2) == 0x000010, "Wrong alignment on ACh007Unique2");
static_assert(sizeof(ACh007Unique2) == 0x001E00, "Wrong size on ACh007Unique2");

// Class InGameModule.Ch007Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class ACh007Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	class ACh007Unique2*                          _pBullet;                                          // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique2Gen">();
	}
	static class ACh007Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique2Gen>();
	}
};
static_assert(alignof(ACh007Unique2Gen) == 0x000010, "Wrong alignment on ACh007Unique2Gen");
static_assert(sizeof(ACh007Unique2Gen) == 0x000450, "Wrong size on ACh007Unique2Gen");
static_assert(offsetof(ACh007Unique2Gen, _pBullet) == 0x000448, "Member 'ACh007Unique2Gen::_pBullet' has a wrong offset!");

// Class InGameModule.AddParts
// 0x0020 (0x0048 - 0x0028)
class UAddParts : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 _ownerMesh;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _attachedComponent;                                // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddParts">();
	}
	static class UAddParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddParts>();
	}
};
static_assert(alignof(UAddParts) == 0x000008, "Wrong alignment on UAddParts");
static_assert(sizeof(UAddParts) == 0x000048, "Wrong size on UAddParts");
static_assert(offsetof(UAddParts, _ownerMesh) == 0x000030, "Member 'UAddParts::_ownerMesh' has a wrong offset!");
static_assert(offsetof(UAddParts, _attachedComponent) == 0x000038, "Member 'UAddParts::_attachedComponent' has a wrong offset!");

// Class InGameModule.Ch007Unique3Gen
// 0x0000 (0x0450 - 0x0450)
class ACh007Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	class ABullet*                                Bullet;                                            // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch007Unique3Gen">();
	}
	static class ACh007Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh007Unique3Gen>();
	}
};
static_assert(alignof(ACh007Unique3Gen) == 0x000010, "Wrong alignment on ACh007Unique3Gen");
static_assert(sizeof(ACh007Unique3Gen) == 0x000450, "Wrong size on ACh007Unique3Gen");
static_assert(offsetof(ACh007Unique3Gen, Bullet) == 0x000448, "Member 'ACh007Unique3Gen::Bullet' has a wrong offset!");

// Class InGameModule.Ch008
// 0x0010 (0x0B20 - 0x0B10)
class ACh008 final : public ACharacterBattle
{
public:
	uint8                                         Pad_B10[0x8];                                      // 0x0B10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             _pUnbreakaTexture;                                 // 0x0B18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool BP_IsUnbreakable();
	void BP_SetUnbreakable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch008">();
	}
	static class ACh008* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh008>();
	}
};
static_assert(alignof(ACh008) == 0x000010, "Wrong alignment on ACh008");
static_assert(sizeof(ACh008) == 0x000B20, "Wrong size on ACh008");
static_assert(offsetof(ACh008, _pUnbreakaTexture) == 0x000B18, "Member 'ACh008::_pUnbreakaTexture' has a wrong offset!");

// Class InGameModule.Ch008Unique3Gen
// 0x0010 (0x0460 - 0x0450)
class ACh008Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	struct FVector                                _addSpawnPosition;                                 // 0x0448(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0xC];                                      // 0x0454(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch008Unique3Gen">();
	}
	static class ACh008Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh008Unique3Gen>();
	}
};
static_assert(alignof(ACh008Unique3Gen) == 0x000010, "Wrong alignment on ACh008Unique3Gen");
static_assert(sizeof(ACh008Unique3Gen) == 0x000460, "Wrong size on ACh008Unique3Gen");
static_assert(offsetof(ACh008Unique3Gen, _addSpawnPosition) == 0x000448, "Member 'ACh008Unique3Gen::_addSpawnPosition' has a wrong offset!");

// Class InGameModule.CharacterAddPartsComponent
// 0x0050 (0x0108 - 0x00B8)
class UCharacterAddPartsComponent final : public UCharacterBattleComponentBase
{
public:
	TMap<class FName, class UAddParts*>           _addPartsList;                                     // 0x00B8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BP_DisableAddParts(const class FName Key);
	void BP_EnableAddParts(const class FName Key);
	bool BP_IsEnableAddParts(const class FName Key);
	void BP_RegisterParticle(const class FName Key, class UParticleSystem* ParticleSystem, const class FName SocketName, const struct FTransform& Transform, EAttachLocation LocationType, bool bAutoDestroy);
	void BP_RegisterSkeletalMesh(const class FName Key, class USkeletalMesh* Asset, const class FName SocketName, const struct FTransform& Transform);
	void BP_RegisterStaticMesh(const class FName Key, class UStaticMesh* Asset, const class FName SocketName, const struct FTransform& Transform);
	void BP_UnregisterParts(const class FName Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAddPartsComponent">();
	}
	static class UCharacterAddPartsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAddPartsComponent>();
	}
};
static_assert(alignof(UCharacterAddPartsComponent) == 0x000008, "Wrong alignment on UCharacterAddPartsComponent");
static_assert(sizeof(UCharacterAddPartsComponent) == 0x000108, "Wrong size on UCharacterAddPartsComponent");
static_assert(offsetof(UCharacterAddPartsComponent, _addPartsList) == 0x0000B8, "Member 'UCharacterAddPartsComponent::_addPartsList' has a wrong offset!");

// Class InGameModule.Ch010Special
// 0x00B0 (0x1E90 - 0x1DE0)
class ACh010Special final : public ABullet
{
public:
	float                                         _supplySpeed;                                      // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0xB4];                                    // 0x1DDC(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Special">();
	}
	static class ACh010Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Special>();
	}
};
static_assert(alignof(ACh010Special) == 0x000010, "Wrong alignment on ACh010Special");
static_assert(sizeof(ACh010Special) == 0x001E90, "Wrong size on ACh010Special");
static_assert(offsetof(ACh010Special, _supplySpeed) == 0x001DD8, "Member 'ACh010Special::_supplySpeed' has a wrong offset!");

// Class InGameModule.CharacterAbilityWidget
// 0x0030 (0x0418 - 0x03E8)
class UCharacterAbilityWidget final : public UAppWidget
{
public:
	class UInGameAbilityWidget*                   _ability1;                                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameAbilityWidget*                   _ability2;                                         // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameAbilityWidget*                   _ability3;                                         // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             _scrollBox;                                        // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _scrollSpeed;                                      // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bShowLevelList;                                   // 0x040C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _scrollWidth_ShowLevelList;                        // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _scrollWidth_HiddenLevelList;                      // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_AnalogValueScroll(const struct FAnalogInputEvent& InAnalogEvent);
	void BP_UpdateCharacter(ECharacterId CharacterId, int32 VariationNo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAbilityWidget">();
	}
	static class UCharacterAbilityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAbilityWidget>();
	}
};
static_assert(alignof(UCharacterAbilityWidget) == 0x000008, "Wrong alignment on UCharacterAbilityWidget");
static_assert(sizeof(UCharacterAbilityWidget) == 0x000418, "Wrong size on UCharacterAbilityWidget");
static_assert(offsetof(UCharacterAbilityWidget, _ability1) == 0x0003E8, "Member 'UCharacterAbilityWidget::_ability1' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityWidget, _ability2) == 0x0003F0, "Member 'UCharacterAbilityWidget::_ability2' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityWidget, _ability3) == 0x0003F8, "Member 'UCharacterAbilityWidget::_ability3' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityWidget, _scrollBox) == 0x000400, "Member 'UCharacterAbilityWidget::_scrollBox' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityWidget, _scrollSpeed) == 0x000408, "Member 'UCharacterAbilityWidget::_scrollSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityWidget, _bShowLevelList) == 0x00040C, "Member 'UCharacterAbilityWidget::_bShowLevelList' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityWidget, _scrollWidth_ShowLevelList) == 0x000410, "Member 'UCharacterAbilityWidget::_scrollWidth_ShowLevelList' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityWidget, _scrollWidth_HiddenLevelList) == 0x000414, "Member 'UCharacterAbilityWidget::_scrollWidth_HiddenLevelList' has a wrong offset!");

// Class InGameModule.Ch010SpecialGen
// 0x0010 (0x0460 - 0x0450)
class ACh010SpecialGen final : public AProjectileGeneratorBattle
{
public:
	struct FVector                                _PutPosition;                                      // 0x0448(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _returnDist;                                       // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010SpecialGen">();
	}
	static class ACh010SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010SpecialGen>();
	}
};
static_assert(alignof(ACh010SpecialGen) == 0x000010, "Wrong alignment on ACh010SpecialGen");
static_assert(sizeof(ACh010SpecialGen) == 0x000460, "Wrong size on ACh010SpecialGen");
static_assert(offsetof(ACh010SpecialGen, _PutPosition) == 0x000448, "Member 'ACh010SpecialGen::_PutPosition' has a wrong offset!");
static_assert(offsetof(ACh010SpecialGen, _returnDist) == 0x000454, "Member 'ACh010SpecialGen::_returnDist' has a wrong offset!");

// Class InGameModule.Ch010Unique1
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh010Unique1 final : public ABullet
{
public:
	float                                         _checkHight;                                       // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkInterval;                                    // 0x1DDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE0[0x10];                                    // 0x1DE0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique1">();
	}
	static class ACh010Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique1>();
	}
};
static_assert(alignof(ACh010Unique1) == 0x000010, "Wrong alignment on ACh010Unique1");
static_assert(sizeof(ACh010Unique1) == 0x001DF0, "Wrong size on ACh010Unique1");
static_assert(offsetof(ACh010Unique1, _checkHight) == 0x001DD8, "Member 'ACh010Unique1::_checkHight' has a wrong offset!");
static_assert(offsetof(ACh010Unique1, _checkInterval) == 0x001DDC, "Member 'ACh010Unique1::_checkInterval' has a wrong offset!");

// Class InGameModule.Ch010Unique1Gen
// 0x0000 (0x0450 - 0x0450)
class ACh010Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique1Gen">();
	}
	static class ACh010Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique1Gen>();
	}
};
static_assert(alignof(ACh010Unique1Gen) == 0x000010, "Wrong alignment on ACh010Unique1Gen");
static_assert(sizeof(ACh010Unique1Gen) == 0x000450, "Wrong size on ACh010Unique1Gen");

// Class InGameModule.CharacterBadge
// 0x0008 (0x0358 - 0x0350)
class UCharacterBadge final : public UWidgetBase
{
public:
	class UImage*                                 _characterFace;                                    // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayGetBudgeAnim();
	void PlayGetBudgeAnim_Internal();
	void PlayLoopAnim();
	void PlayLoopAnim_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBadge">();
	}
	static class UCharacterBadge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBadge>();
	}
};
static_assert(alignof(UCharacterBadge) == 0x000008, "Wrong alignment on UCharacterBadge");
static_assert(sizeof(UCharacterBadge) == 0x000358, "Wrong size on UCharacterBadge");
static_assert(offsetof(UCharacterBadge, _characterFace) == 0x000350, "Member 'UCharacterBadge::_characterFace' has a wrong offset!");

// Class InGameModule.Ch010Unique2
// 0x0020 (0x1FF0 - 0x1FD0)
class ACh010Unique2 final : public ACustomBullet
{
public:
	class UShapeComponent*                        _pProjectileBlock;                                 // 0x1FD0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomParticleSystemComponent*         _pShieldSonic;                                     // 0x1FD8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FE0[0x10];                                    // 0x1FE0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique2">();
	}
	static class ACh010Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique2>();
	}
};
static_assert(alignof(ACh010Unique2) == 0x000010, "Wrong alignment on ACh010Unique2");
static_assert(sizeof(ACh010Unique2) == 0x001FF0, "Wrong size on ACh010Unique2");
static_assert(offsetof(ACh010Unique2, _pProjectileBlock) == 0x001FD0, "Member 'ACh010Unique2::_pProjectileBlock' has a wrong offset!");
static_assert(offsetof(ACh010Unique2, _pShieldSonic) == 0x001FD8, "Member 'ACh010Unique2::_pShieldSonic' has a wrong offset!");

// Class InGameModule.StateSwitchGen
// 0x0000 (0x0450 - 0x0450)
#pragma pack(push, 0x1)
class alignas(0x10) AStateSwitchGen : public AProjectileGeneratorBattle
{
public:
	int32 BP_DecideJsonIndex() const;
	class ACharacterBattle* BP_GetOwnerCharacterBattle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateSwitchGen">();
	}
	static class AStateSwitchGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStateSwitchGen>();
	}
};
#pragma pack(pop)
static_assert(alignof(AStateSwitchGen) == 0x000010, "Wrong alignment on AStateSwitchGen");
static_assert(sizeof(AStateSwitchGen) == 0x000450, "Wrong size on AStateSwitchGen");

// Class InGameModule.Ch102Unique1Gen
// 0x0060 (0x04B0 - 0x0450)
class ACh102Unique1Gen final : public AStateSwitchGen
{
public:
	TArray<class FName>                           _shotNodes;                                        // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x10];                                     // 0x0458(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHairShotGenRep                        _genRep;                                           // 0x0468(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class ACh102Unique1*>                  _hairShots;                                        // 0x0478(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _targets;                                          // 0x0488(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x18];                                     // 0x0498(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Spawn();
	void Spawn_RPC(const struct FHairShotGenRep& Rep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch102Unique1Gen">();
	}
	static class ACh102Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh102Unique1Gen>();
	}
};
static_assert(alignof(ACh102Unique1Gen) == 0x000010, "Wrong alignment on ACh102Unique1Gen");
static_assert(sizeof(ACh102Unique1Gen) == 0x0004B0, "Wrong size on ACh102Unique1Gen");
static_assert(offsetof(ACh102Unique1Gen, _shotNodes) == 0x000448, "Member 'ACh102Unique1Gen::_shotNodes' has a wrong offset!");
static_assert(offsetof(ACh102Unique1Gen, _genRep) == 0x000468, "Member 'ACh102Unique1Gen::_genRep' has a wrong offset!");
static_assert(offsetof(ACh102Unique1Gen, _hairShots) == 0x000478, "Member 'ACh102Unique1Gen::_hairShots' has a wrong offset!");
static_assert(offsetof(ACh102Unique1Gen, _targets) == 0x000488, "Member 'ACh102Unique1Gen::_targets' has a wrong offset!");

// Class InGameModule.Ch010Unique2Gen
// 0x0010 (0x0460 - 0x0450)
class ACh010Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	struct FRotator                               _SpawnBulletRotatorf;                              // 0x0448(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACh010Unique2*                          _pBullet;                                          // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique2Gen">();
	}
	static class ACh010Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique2Gen>();
	}
};
static_assert(alignof(ACh010Unique2Gen) == 0x000010, "Wrong alignment on ACh010Unique2Gen");
static_assert(sizeof(ACh010Unique2Gen) == 0x000460, "Wrong size on ACh010Unique2Gen");
static_assert(offsetof(ACh010Unique2Gen, _SpawnBulletRotatorf) == 0x000448, "Member 'ACh010Unique2Gen::_SpawnBulletRotatorf' has a wrong offset!");
static_assert(offsetof(ACh010Unique2Gen, _pBullet) == 0x000458, "Member 'ACh010Unique2Gen::_pBullet' has a wrong offset!");

// Class InGameModule.Ch010Unique2Put
// 0x0100 (0x20D0 - 0x1FD0)
class ACh010Unique2Put final : public ACustomBullet
{
public:
	TArray<struct FCh010Unique2PutParts>          _RPartsTbl;                                        // 0x1FD0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FCh010Unique2PutParts>          _LPartsTbl;                                        // 0x1FE0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FF0[0xE0];                                    // 0x1FF0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique2Put">();
	}
	static class ACh010Unique2Put* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique2Put>();
	}
};
static_assert(alignof(ACh010Unique2Put) == 0x000010, "Wrong alignment on ACh010Unique2Put");
static_assert(sizeof(ACh010Unique2Put) == 0x0020D0, "Wrong size on ACh010Unique2Put");
static_assert(offsetof(ACh010Unique2Put, _RPartsTbl) == 0x001FD0, "Member 'ACh010Unique2Put::_RPartsTbl' has a wrong offset!");
static_assert(offsetof(ACh010Unique2Put, _LPartsTbl) == 0x001FE0, "Member 'ACh010Unique2Put::_LPartsTbl' has a wrong offset!");

// Class InGameModule.Ch010Unique2PutGen
// 0x0030 (0x0480 - 0x0450)
class ACh010Unique2PutGen final : public AProjectileGeneratorBattle
{
public:
	int32                                         _oneSideShieldNum;                                 // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkShieldWidth;                                 // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _putHight;                                         // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x14];                                     // 0x0454(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class ACh010Unique2Put*                       _pBullet;                                          // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique2PutGen">();
	}
	static class ACh010Unique2PutGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique2PutGen>();
	}
};
static_assert(alignof(ACh010Unique2PutGen) == 0x000010, "Wrong alignment on ACh010Unique2PutGen");
static_assert(sizeof(ACh010Unique2PutGen) == 0x000480, "Wrong size on ACh010Unique2PutGen");
static_assert(offsetof(ACh010Unique2PutGen, _oneSideShieldNum) == 0x000448, "Member 'ACh010Unique2PutGen::_oneSideShieldNum' has a wrong offset!");
static_assert(offsetof(ACh010Unique2PutGen, _checkShieldWidth) == 0x00044C, "Member 'ACh010Unique2PutGen::_checkShieldWidth' has a wrong offset!");
static_assert(offsetof(ACh010Unique2PutGen, _putHight) == 0x000450, "Member 'ACh010Unique2PutGen::_putHight' has a wrong offset!");
static_assert(offsetof(ACh010Unique2PutGen, _pBullet) == 0x000468, "Member 'ACh010Unique2PutGen::_pBullet' has a wrong offset!");

// Class InGameModule.Ch034Unique2Gen
// 0x0010 (0x04C0 - 0x04B0)
class ACh034Unique2Gen final : public ACh017Unique2Gen
{
public:
	float                                         _maxSpawnDistance;                                 // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _rayCastHeight;                                    // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _rayCastLength;                                    // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B4[0xC];                                      // 0x04B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034Unique2Gen">();
	}
	static class ACh034Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034Unique2Gen>();
	}
};
static_assert(alignof(ACh034Unique2Gen) == 0x000010, "Wrong alignment on ACh034Unique2Gen");
static_assert(sizeof(ACh034Unique2Gen) == 0x0004C0, "Wrong size on ACh034Unique2Gen");
static_assert(offsetof(ACh034Unique2Gen, _maxSpawnDistance) == 0x0004A8, "Member 'ACh034Unique2Gen::_maxSpawnDistance' has a wrong offset!");
static_assert(offsetof(ACh034Unique2Gen, _rayCastHeight) == 0x0004AC, "Member 'ACh034Unique2Gen::_rayCastHeight' has a wrong offset!");
static_assert(offsetof(ACh034Unique2Gen, _rayCastLength) == 0x0004B0, "Member 'ACh034Unique2Gen::_rayCastLength' has a wrong offset!");

// Class InGameModule.Ch010Unique3
// 0x0290 (0x2260 - 0x1FD0)
class ACh010Unique3 final : public ACustomBullet
{
public:
	float                                         _easingDelayTime;                                  // 0x1FD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _baseEasingType;                                   // 0x1FD4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD5[0x3];                                     // 0x1FD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _baseEasingRate;                                   // 0x1FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _baseEasingTime;                                   // 0x1FDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _barrelEasingType;                                 // 0x1FE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE1[0x3];                                     // 0x1FE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _barrelEasingRate;                                 // 0x1FE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _barrelEasingTime;                                 // 0x1FE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _ShotBarrelPosition;                               // 0x1FEC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _barrelPichMin;                                    // 0x1FF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _barrelPichMax;                                    // 0x1FFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _onEasingSe;                                       // 0x2000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _shotKnockBackCurve;                               // 0x2020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _shotKnockBackDist;                                // 0x2028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _barrelEndPitchAng;                                // 0x202C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2030[0x1F0];                                   // 0x2030(0x01F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomParticleSystemComponent*         _baseParticle;                                     // 0x2220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomParticleSystemComponent*         _barrelParticle;                                   // 0x2228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPredictionLineComponent*               _pPredictionLine;                                  // 0x2230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2238[0x28];                                    // 0x2238(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique3">();
	}
	static class ACh010Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique3>();
	}
};
static_assert(alignof(ACh010Unique3) == 0x000010, "Wrong alignment on ACh010Unique3");
static_assert(sizeof(ACh010Unique3) == 0x002260, "Wrong size on ACh010Unique3");
static_assert(offsetof(ACh010Unique3, _easingDelayTime) == 0x001FD0, "Member 'ACh010Unique3::_easingDelayTime' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _baseEasingType) == 0x001FD4, "Member 'ACh010Unique3::_baseEasingType' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _baseEasingRate) == 0x001FD8, "Member 'ACh010Unique3::_baseEasingRate' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _baseEasingTime) == 0x001FDC, "Member 'ACh010Unique3::_baseEasingTime' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _barrelEasingType) == 0x001FE0, "Member 'ACh010Unique3::_barrelEasingType' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _barrelEasingRate) == 0x001FE4, "Member 'ACh010Unique3::_barrelEasingRate' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _barrelEasingTime) == 0x001FE8, "Member 'ACh010Unique3::_barrelEasingTime' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _ShotBarrelPosition) == 0x001FEC, "Member 'ACh010Unique3::_ShotBarrelPosition' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _barrelPichMin) == 0x001FF8, "Member 'ACh010Unique3::_barrelPichMin' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _barrelPichMax) == 0x001FFC, "Member 'ACh010Unique3::_barrelPichMax' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _onEasingSe) == 0x002000, "Member 'ACh010Unique3::_onEasingSe' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _shotKnockBackCurve) == 0x002020, "Member 'ACh010Unique3::_shotKnockBackCurve' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _shotKnockBackDist) == 0x002028, "Member 'ACh010Unique3::_shotKnockBackDist' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _barrelEndPitchAng) == 0x00202C, "Member 'ACh010Unique3::_barrelEndPitchAng' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _baseParticle) == 0x002220, "Member 'ACh010Unique3::_baseParticle' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _barrelParticle) == 0x002228, "Member 'ACh010Unique3::_barrelParticle' has a wrong offset!");
static_assert(offsetof(ACh010Unique3, _pPredictionLine) == 0x002230, "Member 'ACh010Unique3::_pPredictionLine' has a wrong offset!");

// Class InGameModule.AddPartsSkeletalMesh
// 0x0008 (0x0050 - 0x0048)
class UAddPartsSkeletalMesh final : public UAddParts
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddPartsSkeletalMesh">();
	}
	static class UAddPartsSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddPartsSkeletalMesh>();
	}
};
static_assert(alignof(UAddPartsSkeletalMesh) == 0x000008, "Wrong alignment on UAddPartsSkeletalMesh");
static_assert(sizeof(UAddPartsSkeletalMesh) == 0x000050, "Wrong size on UAddPartsSkeletalMesh");

// Class InGameModule.Ch010Unique3Gen
// 0x00A0 (0x04F0 - 0x0450)
class ACh010Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	struct FVector                                _makePosition;                                     // 0x0448(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkDownDist;                                    // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x28];                                     // 0x0458(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ACh010Unique3*                          _pBullet;                                          // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x68];                                     // 0x0488(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique3Gen">();
	}
	static class ACh010Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique3Gen>();
	}
};
static_assert(alignof(ACh010Unique3Gen) == 0x000010, "Wrong alignment on ACh010Unique3Gen");
static_assert(sizeof(ACh010Unique3Gen) == 0x0004F0, "Wrong size on ACh010Unique3Gen");
static_assert(offsetof(ACh010Unique3Gen, _makePosition) == 0x000448, "Member 'ACh010Unique3Gen::_makePosition' has a wrong offset!");
static_assert(offsetof(ACh010Unique3Gen, _checkDownDist) == 0x000454, "Member 'ACh010Unique3Gen::_checkDownDist' has a wrong offset!");
static_assert(offsetof(ACh010Unique3Gen, _pBullet) == 0x000480, "Member 'ACh010Unique3Gen::_pBullet' has a wrong offset!");

// Class InGameModule.Ch010Unique3Shot
// 0x00A0 (0x2070 - 0x1FD0)
class ACh010Unique3Shot final : public ACustomBullet
{
public:
	class FName                                   _childGeneratorName;                               // 0x1FD0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _grandChildGeneratorName;                          // 0x1FD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE0[0x90];                                    // 0x1FE0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique3Shot">();
	}
	static class ACh010Unique3Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique3Shot>();
	}
};
static_assert(alignof(ACh010Unique3Shot) == 0x000010, "Wrong alignment on ACh010Unique3Shot");
static_assert(sizeof(ACh010Unique3Shot) == 0x002070, "Wrong size on ACh010Unique3Shot");
static_assert(offsetof(ACh010Unique3Shot, _childGeneratorName) == 0x001FD0, "Member 'ACh010Unique3Shot::_childGeneratorName' has a wrong offset!");
static_assert(offsetof(ACh010Unique3Shot, _grandChildGeneratorName) == 0x001FD8, "Member 'ACh010Unique3Shot::_grandChildGeneratorName' has a wrong offset!");

// Class InGameModule.Ch010Unique3ShotChildGen
// 0x0000 (0x0450 - 0x0450)
class ACh010Unique3ShotChildGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique3ShotChildGen">();
	}
	static class ACh010Unique3ShotChildGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique3ShotChildGen>();
	}
};
static_assert(alignof(ACh010Unique3ShotChildGen) == 0x000010, "Wrong alignment on ACh010Unique3ShotChildGen");
static_assert(sizeof(ACh010Unique3ShotChildGen) == 0x000450, "Wrong size on ACh010Unique3ShotChildGen");

// Class InGameModule.Ch037
// 0x0000 (0x0B10 - 0x0B10)
class ACh037 final : public ACharacterBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch037">();
	}
	static class ACh037* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh037>();
	}
};
static_assert(alignof(ACh037) == 0x000010, "Wrong alignment on ACh037");
static_assert(sizeof(ACh037) == 0x000B10, "Wrong size on ACh037");

// Class InGameModule.Ch010Unique3ShotGen
// 0x0010 (0x0460 - 0x0450)
class ACh010Unique3ShotGen final : public AProjectileGeneratorBattle
{
public:
	struct FCh010Unique3ShotGenRep                _createRep;                                        // 0x0448(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_454[0xC];                                      // 0x0454(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Create_RPC(const struct FCh010Unique3ShotGenRep& Gen);
	void OnRep_Create();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique3ShotGen">();
	}
	static class ACh010Unique3ShotGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique3ShotGen>();
	}
};
static_assert(alignof(ACh010Unique3ShotGen) == 0x000010, "Wrong alignment on ACh010Unique3ShotGen");
static_assert(sizeof(ACh010Unique3ShotGen) == 0x000460, "Wrong size on ACh010Unique3ShotGen");
static_assert(offsetof(ACh010Unique3ShotGen, _createRep) == 0x000448, "Member 'ACh010Unique3ShotGen::_createRep' has a wrong offset!");

// Class InGameModule.Ch109SpecialGen
// 0x0020 (0x0470 - 0x0450)
class ACh109SpecialGen final : public AProjectileGeneratorBattle
{
public:
	struct FCh109SpecialGenRep                    _putPointRep;                                      // 0x0448(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACh109Special*                          _pBullet;                                          // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PutPoint();
	void PutPoint_RPC(const struct FCh109SpecialGenRep& Gen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch109SpecialGen">();
	}
	static class ACh109SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh109SpecialGen>();
	}
};
static_assert(alignof(ACh109SpecialGen) == 0x000010, "Wrong alignment on ACh109SpecialGen");
static_assert(sizeof(ACh109SpecialGen) == 0x000470, "Wrong size on ACh109SpecialGen");
static_assert(offsetof(ACh109SpecialGen, _putPointRep) == 0x000448, "Member 'ACh109SpecialGen::_putPointRep' has a wrong offset!");
static_assert(offsetof(ACh109SpecialGen, _pBullet) == 0x000460, "Member 'ACh109SpecialGen::_pBullet' has a wrong offset!");

// Class InGameModule.Ch010Unique3ShotGrandChildGen
// 0x0040 (0x0490 - 0x0450)
class ACh010Unique3ShotGrandChildGen final : public AProjectileGeneratorBattle
{
public:
	struct FCh010Unique3ShotGrandChildGenRep      _createRep;                                        // 0x0448(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x38];                                     // 0x0458(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Create_RPC(const struct FCh010Unique3ShotGrandChildGenRep& Gen);
	void OnRep_Create();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch010Unique3ShotGrandChildGen">();
	}
	static class ACh010Unique3ShotGrandChildGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh010Unique3ShotGrandChildGen>();
	}
};
static_assert(alignof(ACh010Unique3ShotGrandChildGen) == 0x000010, "Wrong alignment on ACh010Unique3ShotGrandChildGen");
static_assert(sizeof(ACh010Unique3ShotGrandChildGen) == 0x000490, "Wrong size on ACh010Unique3ShotGrandChildGen");
static_assert(offsetof(ACh010Unique3ShotGrandChildGen, _createRep) == 0x000448, "Member 'ACh010Unique3ShotGrandChildGen::_createRep' has a wrong offset!");

// Class InGameModule.Ch012Unique1
// 0x0040 (0x1E20 - 0x1DE0)
class ACh012Unique1 final : public ABullet
{
public:
	class UBattleCustomParticleSystemComponent*   _groundParticleSystemComponent;                    // 0x1DD8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UObject>                    _hitBGDecalObject;                                 // 0x1DE0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      _hitBGMaterialInstance;                            // 0x1DE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBulletSE                              _bgHitSE;                                          // 0x1DF0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _bgHitSeComponent;                                 // 0x1E10(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E18[0x8];                                     // 0x1E18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique1">();
	}
	static class ACh012Unique1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique1>();
	}
};
static_assert(alignof(ACh012Unique1) == 0x000010, "Wrong alignment on ACh012Unique1");
static_assert(sizeof(ACh012Unique1) == 0x001E20, "Wrong size on ACh012Unique1");
static_assert(offsetof(ACh012Unique1, _groundParticleSystemComponent) == 0x001DD8, "Member 'ACh012Unique1::_groundParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(ACh012Unique1, _hitBGDecalObject) == 0x001DE0, "Member 'ACh012Unique1::_hitBGDecalObject' has a wrong offset!");
static_assert(offsetof(ACh012Unique1, _hitBGMaterialInstance) == 0x001DE8, "Member 'ACh012Unique1::_hitBGMaterialInstance' has a wrong offset!");
static_assert(offsetof(ACh012Unique1, _bgHitSE) == 0x001DF0, "Member 'ACh012Unique1::_bgHitSE' has a wrong offset!");
static_assert(offsetof(ACh012Unique1, _bgHitSeComponent) == 0x001E10, "Member 'ACh012Unique1::_bgHitSeComponent' has a wrong offset!");

// Class InGameModule.Ch012Unique1Child
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh012Unique1Child final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique1Child">();
	}
	static class ACh012Unique1Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique1Child>();
	}
};
static_assert(alignof(ACh012Unique1Child) == 0x000010, "Wrong alignment on ACh012Unique1Child");
static_assert(sizeof(ACh012Unique1Child) == 0x001DE0, "Wrong size on ACh012Unique1Child");

// Class InGameModule.Ch037Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class ACh037Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	float                                         _shotLocationOffset;                               // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _spawnHightOffset;                                 // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch037Unique2Gen">();
	}
	static class ACh037Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh037Unique2Gen>();
	}
};
static_assert(alignof(ACh037Unique2Gen) == 0x000010, "Wrong alignment on ACh037Unique2Gen");
static_assert(sizeof(ACh037Unique2Gen) == 0x000450, "Wrong size on ACh037Unique2Gen");
static_assert(offsetof(ACh037Unique2Gen, _shotLocationOffset) == 0x000448, "Member 'ACh037Unique2Gen::_shotLocationOffset' has a wrong offset!");
static_assert(offsetof(ACh037Unique2Gen, _spawnHightOffset) == 0x00044C, "Member 'ACh037Unique2Gen::_spawnHightOffset' has a wrong offset!");

// Class InGameModule.Ch012Unique1Gen
// 0x0000 (0x0450 - 0x0450)
class ACh012Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique1Gen">();
	}
	static class ACh012Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique1Gen>();
	}
};
static_assert(alignof(ACh012Unique1Gen) == 0x000010, "Wrong alignment on ACh012Unique1Gen");
static_assert(sizeof(ACh012Unique1Gen) == 0x000450, "Wrong size on ACh012Unique1Gen");

// Class InGameModule.CharacterBattleSoundComponent
// 0x0000 (0x1250 - 0x1250)
class UCharacterBattleSoundComponent final : public UCharacterSoundComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBattleSoundComponent">();
	}
	static class UCharacterBattleSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBattleSoundComponent>();
	}
};
static_assert(alignof(UCharacterBattleSoundComponent) == 0x000010, "Wrong alignment on UCharacterBattleSoundComponent");
static_assert(sizeof(UCharacterBattleSoundComponent) == 0x001250, "Wrong size on UCharacterBattleSoundComponent");

// Class InGameModule.Ch012Unique2
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh012Unique2 final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique2">();
	}
	static class ACh012Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique2>();
	}
};
static_assert(alignof(ACh012Unique2) == 0x000010, "Wrong alignment on ACh012Unique2");
static_assert(sizeof(ACh012Unique2) == 0x001DE0, "Wrong size on ACh012Unique2");

// Class InGameModule.Ch012Unique2AirGen
// 0x0000 (0x0450 - 0x0450)
class ACh012Unique2AirGen final : public AProjectileGeneratorBattle
{
public:
	class ABullet*                                _airBullet;                                        // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique2AirGen">();
	}
	static class ACh012Unique2AirGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique2AirGen>();
	}
};
static_assert(alignof(ACh012Unique2AirGen) == 0x000010, "Wrong alignment on ACh012Unique2AirGen");
static_assert(sizeof(ACh012Unique2AirGen) == 0x000450, "Wrong size on ACh012Unique2AirGen");
static_assert(offsetof(ACh012Unique2AirGen, _airBullet) == 0x000448, "Member 'ACh012Unique2AirGen::_airBullet' has a wrong offset!");

// Class InGameModule.Ch012Unique2Child
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh012Unique2Child final : public ABullet
{
public:
	TSubclassOf<class UObject>                    _decalObject;                                      // 0x1DD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      _materialInstance;                                 // 0x1DE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _smokeParticle;                                    // 0x1DE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique2Child">();
	}
	static class ACh012Unique2Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique2Child>();
	}
};
static_assert(alignof(ACh012Unique2Child) == 0x000010, "Wrong alignment on ACh012Unique2Child");
static_assert(sizeof(ACh012Unique2Child) == 0x001DF0, "Wrong size on ACh012Unique2Child");
static_assert(offsetof(ACh012Unique2Child, _decalObject) == 0x001DD8, "Member 'ACh012Unique2Child::_decalObject' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Child, _materialInstance) == 0x001DE0, "Member 'ACh012Unique2Child::_materialInstance' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Child, _smokeParticle) == 0x001DE8, "Member 'ACh012Unique2Child::_smokeParticle' has a wrong offset!");

// Class InGameModule.Ch038Unique1Shot
// 0x0010 (0x1FE0 - 0x1FD0)
class ACh038Unique1Shot final : public ACustomBullet
{
public:
	class USphereComponent*                       _physicsRoot;                                      // 0x1FD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _hitLimit;                                         // 0x1FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDC[0x4];                                     // 0x1FDC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch038Unique1Shot">();
	}
	static class ACh038Unique1Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh038Unique1Shot>();
	}
};
static_assert(alignof(ACh038Unique1Shot) == 0x000010, "Wrong alignment on ACh038Unique1Shot");
static_assert(sizeof(ACh038Unique1Shot) == 0x001FE0, "Wrong size on ACh038Unique1Shot");
static_assert(offsetof(ACh038Unique1Shot, _physicsRoot) == 0x001FD0, "Member 'ACh038Unique1Shot::_physicsRoot' has a wrong offset!");
static_assert(offsetof(ACh038Unique1Shot, _hitLimit) == 0x001FD8, "Member 'ACh038Unique1Shot::_hitLimit' has a wrong offset!");

// Class InGameModule.Ch012Unique2Gen
// 0x00D0 (0x0520 - 0x0450)
class ACh012Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	int32                                         _loopCheckNum;                                     // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _groundIgnoreDist;                                 // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkHeight;                                      // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkLow;                                         // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _wallDegThreshold;                                 // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _spawnDecalScale;                                  // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x40];                                     // 0x0470(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCh012Unique2Info>              _fanBulletInfo;                                    // 0x04B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCh012Unique2Info                      _firstShotBulletInfo;                              // 0x04C0(0x0060)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique2Gen">();
	}
	static class ACh012Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique2Gen>();
	}
};
static_assert(alignof(ACh012Unique2Gen) == 0x000010, "Wrong alignment on ACh012Unique2Gen");
static_assert(sizeof(ACh012Unique2Gen) == 0x000520, "Wrong size on ACh012Unique2Gen");
static_assert(offsetof(ACh012Unique2Gen, _loopCheckNum) == 0x000448, "Member 'ACh012Unique2Gen::_loopCheckNum' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Gen, _groundIgnoreDist) == 0x00044C, "Member 'ACh012Unique2Gen::_groundIgnoreDist' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Gen, _checkHeight) == 0x000450, "Member 'ACh012Unique2Gen::_checkHeight' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Gen, _checkLow) == 0x000454, "Member 'ACh012Unique2Gen::_checkLow' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Gen, _wallDegThreshold) == 0x000458, "Member 'ACh012Unique2Gen::_wallDegThreshold' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Gen, _spawnDecalScale) == 0x000460, "Member 'ACh012Unique2Gen::_spawnDecalScale' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Gen, _fanBulletInfo) == 0x0004B0, "Member 'ACh012Unique2Gen::_fanBulletInfo' has a wrong offset!");
static_assert(offsetof(ACh012Unique2Gen, _firstShotBulletInfo) == 0x0004C0, "Member 'ACh012Unique2Gen::_firstShotBulletInfo' has a wrong offset!");

// Class InGameModule.WidgetAttachToActor
// 0x0040 (0x02B8 - 0x0278)
class UWidgetAttachToActor : public UUserWidget
{
public:
	class APlayerController*                      _playerController;                                 // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGameStateBattle*                       _gameState;                                        // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _currentTargetActor;                               // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacterBase*                         _currentTargetCharacter;                           // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       _rootCanvasPanelSlot;                              // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformRichTextBlock*                 _command;                                          // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _offsetFromTarget;                                 // 0x02A8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetAttachToActor">();
	}
	static class UWidgetAttachToActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetAttachToActor>();
	}
};
static_assert(alignof(UWidgetAttachToActor) == 0x000008, "Wrong alignment on UWidgetAttachToActor");
static_assert(sizeof(UWidgetAttachToActor) == 0x0002B8, "Wrong size on UWidgetAttachToActor");
static_assert(offsetof(UWidgetAttachToActor, _playerController) == 0x000278, "Member 'UWidgetAttachToActor::_playerController' has a wrong offset!");
static_assert(offsetof(UWidgetAttachToActor, _gameState) == 0x000280, "Member 'UWidgetAttachToActor::_gameState' has a wrong offset!");
static_assert(offsetof(UWidgetAttachToActor, _currentTargetActor) == 0x000288, "Member 'UWidgetAttachToActor::_currentTargetActor' has a wrong offset!");
static_assert(offsetof(UWidgetAttachToActor, _currentTargetCharacter) == 0x000290, "Member 'UWidgetAttachToActor::_currentTargetCharacter' has a wrong offset!");
static_assert(offsetof(UWidgetAttachToActor, _rootCanvasPanelSlot) == 0x000298, "Member 'UWidgetAttachToActor::_rootCanvasPanelSlot' has a wrong offset!");
static_assert(offsetof(UWidgetAttachToActor, _command) == 0x0002A0, "Member 'UWidgetAttachToActor::_command' has a wrong offset!");
static_assert(offsetof(UWidgetAttachToActor, _offsetFromTarget) == 0x0002A8, "Member 'UWidgetAttachToActor::_offsetFromTarget' has a wrong offset!");

// Class InGameModule.Ch012Unique3
// 0x0040 (0x1E20 - 0x1DE0)
class ACh012Unique3 final : public ABullet
{
public:
	struct FBulletSE                              _loopSe;                                           // 0x1DD8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAtomComponent*                         _loopSeComponent;                                  // 0x1DF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeroCapsuleComponent*                  _reflectField;                                     // 0x1E00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _hitColPrimitive;                                  // 0x1E08(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E10[0x10];                                    // 0x1E10(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique3">();
	}
	static class ACh012Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique3>();
	}
};
static_assert(alignof(ACh012Unique3) == 0x000010, "Wrong alignment on ACh012Unique3");
static_assert(sizeof(ACh012Unique3) == 0x001E20, "Wrong size on ACh012Unique3");
static_assert(offsetof(ACh012Unique3, _loopSe) == 0x001DD8, "Member 'ACh012Unique3::_loopSe' has a wrong offset!");
static_assert(offsetof(ACh012Unique3, _loopSeComponent) == 0x001DF8, "Member 'ACh012Unique3::_loopSeComponent' has a wrong offset!");
static_assert(offsetof(ACh012Unique3, _reflectField) == 0x001E00, "Member 'ACh012Unique3::_reflectField' has a wrong offset!");
static_assert(offsetof(ACh012Unique3, _hitColPrimitive) == 0x001E08, "Member 'ACh012Unique3::_hitColPrimitive' has a wrong offset!");

// Class InGameModule.Ch012Unique3Gen
// 0x0030 (0x0480 - 0x0450)
class ACh012Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	int32                                         _loopCheckNum;                                     // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _groundIgnoreDist;                                 // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkHeight;                                      // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkLow;                                         // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _wallDegThreshold;                                 // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _spawnDecalScale;                                  // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ACh012Unique3*                          _spawnBullet;                                      // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch012Unique3Gen">();
	}
	static class ACh012Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh012Unique3Gen>();
	}
};
static_assert(alignof(ACh012Unique3Gen) == 0x000010, "Wrong alignment on ACh012Unique3Gen");
static_assert(sizeof(ACh012Unique3Gen) == 0x000480, "Wrong size on ACh012Unique3Gen");
static_assert(offsetof(ACh012Unique3Gen, _loopCheckNum) == 0x000448, "Member 'ACh012Unique3Gen::_loopCheckNum' has a wrong offset!");
static_assert(offsetof(ACh012Unique3Gen, _groundIgnoreDist) == 0x00044C, "Member 'ACh012Unique3Gen::_groundIgnoreDist' has a wrong offset!");
static_assert(offsetof(ACh012Unique3Gen, _checkHeight) == 0x000450, "Member 'ACh012Unique3Gen::_checkHeight' has a wrong offset!");
static_assert(offsetof(ACh012Unique3Gen, _checkLow) == 0x000454, "Member 'ACh012Unique3Gen::_checkLow' has a wrong offset!");
static_assert(offsetof(ACh012Unique3Gen, _wallDegThreshold) == 0x000458, "Member 'ACh012Unique3Gen::_wallDegThreshold' has a wrong offset!");
static_assert(offsetof(ACh012Unique3Gen, _spawnDecalScale) == 0x000460, "Member 'ACh012Unique3Gen::_spawnDecalScale' has a wrong offset!");
static_assert(offsetof(ACh012Unique3Gen, _spawnBullet) == 0x000470, "Member 'ACh012Unique3Gen::_spawnBullet' has a wrong offset!");

// Class InGameModule.Ch013_ActionAttack_Special
// 0x0008 (0x0360 - 0x0358)
class UCh013_ActionAttack_Special final : public UActionAttackSpecialBase
{
public:
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SealUniqueOfGazeTargets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch013_ActionAttack_Special">();
	}
	static class UCh013_ActionAttack_Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCh013_ActionAttack_Special>();
	}
};
static_assert(alignof(UCh013_ActionAttack_Special) == 0x000008, "Wrong alignment on UCh013_ActionAttack_Special");
static_assert(sizeof(UCh013_ActionAttack_Special) == 0x000360, "Wrong size on UCh013_ActionAttack_Special");

// Class InGameModule.Ch013Unique1Shot
// 0x0010 (0x1FE0 - 0x1FD0)
class ACh013Unique1Shot final : public ACustomBullet
{
public:
	uint8                                         Pad_1FD0[0x10];                                    // 0x1FD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch013Unique1Shot">();
	}
	static class ACh013Unique1Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh013Unique1Shot>();
	}
};
static_assert(alignof(ACh013Unique1Shot) == 0x000010, "Wrong alignment on ACh013Unique1Shot");
static_assert(sizeof(ACh013Unique1Shot) == 0x001FE0, "Wrong size on ACh013Unique1Shot");

// Class InGameModule.Ch015Unique1_Var1
// 0x0010 (0x1FE0 - 0x1FD0)
class ACh015Unique1_Var1 final : public ACustomBullet
{
public:
	float                                         _offsetDirection;                                  // 0x1FD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD4[0xC];                                     // 0x1FD4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique1_Var1">();
	}
	static class ACh015Unique1_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique1_Var1>();
	}
};
static_assert(alignof(ACh015Unique1_Var1) == 0x000010, "Wrong alignment on ACh015Unique1_Var1");
static_assert(sizeof(ACh015Unique1_Var1) == 0x001FE0, "Wrong size on ACh015Unique1_Var1");
static_assert(offsetof(ACh015Unique1_Var1, _offsetDirection) == 0x001FD0, "Member 'ACh015Unique1_Var1::_offsetDirection' has a wrong offset!");

// Class InGameModule.Ch015Unique2_Var1
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh015Unique2_Var1 final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique2_Var1">();
	}
	static class ACh015Unique2_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique2_Var1>();
	}
};
static_assert(alignof(ACh015Unique2_Var1) == 0x000010, "Wrong alignment on ACh015Unique2_Var1");
static_assert(sizeof(ACh015Unique2_Var1) == 0x001FD0, "Wrong size on ACh015Unique2_Var1");

// Class InGameModule.Ch015Unique2ChildCracksGen_Var1
// 0x0000 (0x0450 - 0x0450)
class ACh015Unique2ChildCracksGen_Var1 final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique2ChildCracksGen_Var1">();
	}
	static class ACh015Unique2ChildCracksGen_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique2ChildCracksGen_Var1>();
	}
};
static_assert(alignof(ACh015Unique2ChildCracksGen_Var1) == 0x000010, "Wrong alignment on ACh015Unique2ChildCracksGen_Var1");
static_assert(sizeof(ACh015Unique2ChildCracksGen_Var1) == 0x000450, "Wrong size on ACh015Unique2ChildCracksGen_Var1");

// Class InGameModule.Ch015Unique3_Var1
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh015Unique3_Var1 final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch015Unique3_Var1">();
	}
	static class ACh015Unique3_Var1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh015Unique3_Var1>();
	}
};
static_assert(alignof(ACh015Unique3_Var1) == 0x000010, "Wrong alignment on ACh015Unique3_Var1");
static_assert(sizeof(ACh015Unique3_Var1) == 0x001FD0, "Wrong size on ACh015Unique3_Var1");

// Class InGameModule.Ch016_ActionAttack_Special
// 0x0008 (0x0368 - 0x0360)
class UCh016_ActionAttack_Special final : public UActionAttack_Special_Coop
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch016_ActionAttack_Special">();
	}
	static class UCh016_ActionAttack_Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCh016_ActionAttack_Special>();
	}
};
static_assert(alignof(UCh016_ActionAttack_Special) == 0x000008, "Wrong alignment on UCh016_ActionAttack_Special");
static_assert(sizeof(UCh016_ActionAttack_Special) == 0x000368, "Wrong size on UCh016_ActionAttack_Special");
static_assert(offsetof(UCh016_ActionAttack_Special, _playerState) == 0x000360, "Member 'UCh016_ActionAttack_Special::_playerState' has a wrong offset!");

// Class InGameModule.Ch016Unique2Shot
// 0x0030 (0x1E10 - 0x1DE0)
class ACh016Unique2Shot final : public ABullet
{
public:
	class UMaterialCurveControl*                  _materialCurveCtrlTblEnemy;                        // 0x1DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialCurveControl*                  _materialCurveCtrlTblFriend;                       // 0x1DE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               _MIDForEnemy;                                      // 0x1DE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _MIDForFriend;                                     // 0x1DF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DF8[0x8];                                     // 0x1DF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBulletParticleSystemComponent*         _bulletParticle;                                   // 0x1E00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E08[0x8];                                     // 0x1E08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBeginEnd();
	class UMaterialInstanceDynamic* SetMIDEnemy(class UMaterialInstanceDynamic* Mid);
	class UMaterialInstanceDynamic* SetMIDFriend(class UMaterialInstanceDynamic* Mid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch016Unique2Shot">();
	}
	static class ACh016Unique2Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh016Unique2Shot>();
	}
};
static_assert(alignof(ACh016Unique2Shot) == 0x000010, "Wrong alignment on ACh016Unique2Shot");
static_assert(sizeof(ACh016Unique2Shot) == 0x001E10, "Wrong size on ACh016Unique2Shot");
static_assert(offsetof(ACh016Unique2Shot, _materialCurveCtrlTblEnemy) == 0x001DD8, "Member 'ACh016Unique2Shot::_materialCurveCtrlTblEnemy' has a wrong offset!");
static_assert(offsetof(ACh016Unique2Shot, _materialCurveCtrlTblFriend) == 0x001DE0, "Member 'ACh016Unique2Shot::_materialCurveCtrlTblFriend' has a wrong offset!");
static_assert(offsetof(ACh016Unique2Shot, _MIDForEnemy) == 0x001DE8, "Member 'ACh016Unique2Shot::_MIDForEnemy' has a wrong offset!");
static_assert(offsetof(ACh016Unique2Shot, _MIDForFriend) == 0x001DF0, "Member 'ACh016Unique2Shot::_MIDForFriend' has a wrong offset!");
static_assert(offsetof(ACh016Unique2Shot, _bulletParticle) == 0x001E00, "Member 'ACh016Unique2Shot::_bulletParticle' has a wrong offset!");

// Class InGameModule.Ch016Unique3ShotAttract
// 0x0010 (0x1E60 - 0x1E50)
class ACh016Unique3ShotAttract final : public ACh016Unique3Base
{
public:
	uint8                                         Pad_1E50[0x10];                                    // 0x1E50(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch016Unique3ShotAttract">();
	}
	static class ACh016Unique3ShotAttract* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh016Unique3ShotAttract>();
	}
};
static_assert(alignof(ACh016Unique3ShotAttract) == 0x000010, "Wrong alignment on ACh016Unique3ShotAttract");
static_assert(sizeof(ACh016Unique3ShotAttract) == 0x001E60, "Wrong size on ACh016Unique3ShotAttract");

// Class InGameModule.Ch017SpecialSub
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh017SpecialSub final : public ABullet
{
public:
	class UHeroCapsuleComponent*                  _h1;                                               // 0x1DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _damageAreaWidth;                                  // 0x1DE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE4[0xC];                                     // 0x1DE4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017SpecialSub">();
	}
	static class ACh017SpecialSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017SpecialSub>();
	}
};
static_assert(alignof(ACh017SpecialSub) == 0x000010, "Wrong alignment on ACh017SpecialSub");
static_assert(sizeof(ACh017SpecialSub) == 0x001DF0, "Wrong size on ACh017SpecialSub");
static_assert(offsetof(ACh017SpecialSub, _h1) == 0x001DD8, "Member 'ACh017SpecialSub::_h1' has a wrong offset!");
static_assert(offsetof(ACh017SpecialSub, _damageAreaWidth) == 0x001DE0, "Member 'ACh017SpecialSub::_damageAreaWidth' has a wrong offset!");

// Class InGameModule.Ch017Unique1Charge
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh017Unique1Charge final : public ABullet
{
public:
	class UBattleCustomParticleSystemComponent*   _bulletParticle;                                   // 0x1DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _muzzleParticle;                                   // 0x1DE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DE8[0x8];                                     // 0x1DE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique1Charge">();
	}
	static class ACh017Unique1Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique1Charge>();
	}
};
static_assert(alignof(ACh017Unique1Charge) == 0x000010, "Wrong alignment on ACh017Unique1Charge");
static_assert(sizeof(ACh017Unique1Charge) == 0x001DF0, "Wrong size on ACh017Unique1Charge");
static_assert(offsetof(ACh017Unique1Charge, _bulletParticle) == 0x001DD8, "Member 'ACh017Unique1Charge::_bulletParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique1Charge, _muzzleParticle) == 0x001DE0, "Member 'ACh017Unique1Charge::_muzzleParticle' has a wrong offset!");

// Class InGameModule.Ch017Unique1Child
// 0x00A0 (0x1E80 - 0x1DE0)
class ACh017Unique1Child final : public ABullet
{
public:
	struct FBulletSE                              _hitSE;                                            // 0x1DD8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _hitSeComponent;                                   // 0x1DF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E00[0x58];                                    // 0x1E00(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UHeroSphereComponent*                   _b1;                                               // 0x1E58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeroCapsuleComponent*                  _h1;                                               // 0x1E60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeroSphereComponent*                   _h2;                                               // 0x1E68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleCustomParticleSystemComponent*   _fireParticle;                                     // 0x1E70(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E78[0x8];                                     // 0x1E78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique1Child">();
	}
	static class ACh017Unique1Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique1Child>();
	}
};
static_assert(alignof(ACh017Unique1Child) == 0x000010, "Wrong alignment on ACh017Unique1Child");
static_assert(sizeof(ACh017Unique1Child) == 0x001E80, "Wrong size on ACh017Unique1Child");
static_assert(offsetof(ACh017Unique1Child, _hitSE) == 0x001DD8, "Member 'ACh017Unique1Child::_hitSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique1Child, _hitSeComponent) == 0x001DF8, "Member 'ACh017Unique1Child::_hitSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique1Child, _b1) == 0x001E58, "Member 'ACh017Unique1Child::_b1' has a wrong offset!");
static_assert(offsetof(ACh017Unique1Child, _h1) == 0x001E60, "Member 'ACh017Unique1Child::_h1' has a wrong offset!");
static_assert(offsetof(ACh017Unique1Child, _h2) == 0x001E68, "Member 'ACh017Unique1Child::_h2' has a wrong offset!");
static_assert(offsetof(ACh017Unique1Child, _fireParticle) == 0x001E70, "Member 'ACh017Unique1Child::_fireParticle' has a wrong offset!");

// Class InGameModule.Ch017Unique2Air
// 0x0000 (0x1EE0 - 0x1EE0)
class ACh017Unique2Air final : public ACh017Unique2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2Air">();
	}
	static class ACh017Unique2Air* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2Air>();
	}
};
static_assert(alignof(ACh017Unique2Air) == 0x000010, "Wrong alignment on ACh017Unique2Air");
static_assert(sizeof(ACh017Unique2Air) == 0x001EE0, "Wrong size on ACh017Unique2Air");

// Class InGameModule.Ch017Unique2AirGen
// 0x0000 (0x04B0 - 0x04B0)
class ACh017Unique2AirGen final : public ACh017Unique2Gen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2AirGen">();
	}
	static class ACh017Unique2AirGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2AirGen>();
	}
};
static_assert(alignof(ACh017Unique2AirGen) == 0x000010, "Wrong alignment on ACh017Unique2AirGen");
static_assert(sizeof(ACh017Unique2AirGen) == 0x0004B0, "Wrong size on ACh017Unique2AirGen");

// Class InGameModule.Ch017Unique2ChargeAir
// 0x0100 (0x1F50 - 0x1E50)
class ACh017Unique2ChargeAir final : public ACh017Unique2Base
{
public:
	class UParticleSystem*                        _trapTemplate;                                     // 0x1E48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _fireTemplate;                                     // 0x1E50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _destroyTemplate;                                  // 0x1E58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _trapParticle;                                     // 0x1E60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _fireParticle;                                     // 0x1E68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _destroyParticle;                                  // 0x1E70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _hitSE;                                            // 0x1E78(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _hitSeComponent;                                   // 0x1E98(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _fireSE;                                           // 0x1EA0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _fireSeComponent;                                  // 0x1EC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _loopFireSE;                                       // 0x1EC8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _loopFireSeComponent;                              // 0x1EE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletSE                              _finishSE;                                         // 0x1EF0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _finishSeComponent;                                // 0x1F10(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F18[0x38];                                    // 0x1F18(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishTrap();
	void StopFire();
	void StopTrap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique2ChargeAir">();
	}
	static class ACh017Unique2ChargeAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique2ChargeAir>();
	}
};
static_assert(alignof(ACh017Unique2ChargeAir) == 0x000010, "Wrong alignment on ACh017Unique2ChargeAir");
static_assert(sizeof(ACh017Unique2ChargeAir) == 0x001F50, "Wrong size on ACh017Unique2ChargeAir");
static_assert(offsetof(ACh017Unique2ChargeAir, _trapTemplate) == 0x001E48, "Member 'ACh017Unique2ChargeAir::_trapTemplate' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _fireTemplate) == 0x001E50, "Member 'ACh017Unique2ChargeAir::_fireTemplate' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _destroyTemplate) == 0x001E58, "Member 'ACh017Unique2ChargeAir::_destroyTemplate' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _trapParticle) == 0x001E60, "Member 'ACh017Unique2ChargeAir::_trapParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _fireParticle) == 0x001E68, "Member 'ACh017Unique2ChargeAir::_fireParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _destroyParticle) == 0x001E70, "Member 'ACh017Unique2ChargeAir::_destroyParticle' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _hitSE) == 0x001E78, "Member 'ACh017Unique2ChargeAir::_hitSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _hitSeComponent) == 0x001E98, "Member 'ACh017Unique2ChargeAir::_hitSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _fireSE) == 0x001EA0, "Member 'ACh017Unique2ChargeAir::_fireSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _fireSeComponent) == 0x001EC0, "Member 'ACh017Unique2ChargeAir::_fireSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _loopFireSE) == 0x001EC8, "Member 'ACh017Unique2ChargeAir::_loopFireSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _loopFireSeComponent) == 0x001EE8, "Member 'ACh017Unique2ChargeAir::_loopFireSeComponent' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _finishSE) == 0x001EF0, "Member 'ACh017Unique2ChargeAir::_finishSE' has a wrong offset!");
static_assert(offsetof(ACh017Unique2ChargeAir, _finishSeComponent) == 0x001F10, "Member 'ACh017Unique2ChargeAir::_finishSeComponent' has a wrong offset!");

// Class InGameModule.WrappedCh017Unique2_BeforeGen
// 0x0000 (0x0450 - 0x0450)
class AWrappedCh017Unique2_BeforeGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrappedCh017Unique2_BeforeGen">();
	}
	static class AWrappedCh017Unique2_BeforeGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWrappedCh017Unique2_BeforeGen>();
	}
};
static_assert(alignof(AWrappedCh017Unique2_BeforeGen) == 0x000010, "Wrong alignment on AWrappedCh017Unique2_BeforeGen");
static_assert(sizeof(AWrappedCh017Unique2_BeforeGen) == 0x000450, "Wrong size on AWrappedCh017Unique2_BeforeGen");

// Class InGameModule.Ch017Unique3
// 0x0060 (0x1E40 - 0x1DE0)
class ACh017Unique3 final : public ABullet
{
public:
	float                                         _damageAreaWidth;                                  // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _blockHeightLimit;                                 // 0x1DDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomParticleSystemComponent*         _fireParticle;                                     // 0x1DE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DE8[0x58];                                    // 0x1DE8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch017Unique3">();
	}
	static class ACh017Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh017Unique3>();
	}
};
static_assert(alignof(ACh017Unique3) == 0x000010, "Wrong alignment on ACh017Unique3");
static_assert(sizeof(ACh017Unique3) == 0x001E40, "Wrong size on ACh017Unique3");
static_assert(offsetof(ACh017Unique3, _damageAreaWidth) == 0x001DD8, "Member 'ACh017Unique3::_damageAreaWidth' has a wrong offset!");
static_assert(offsetof(ACh017Unique3, _blockHeightLimit) == 0x001DDC, "Member 'ACh017Unique3::_blockHeightLimit' has a wrong offset!");
static_assert(offsetof(ACh017Unique3, _fireParticle) == 0x001DE0, "Member 'ACh017Unique3::_fireParticle' has a wrong offset!");

// Class InGameModule.Ch018
// 0x0000 (0x0B10 - 0x0B10)
class ACh018 final : public ACharacterBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch018">();
	}
	static class ACh018* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh018>();
	}
};
static_assert(alignof(ACh018) == 0x000010, "Wrong alignment on ACh018");
static_assert(sizeof(ACh018) == 0x000B10, "Wrong size on ACh018");

// Class InGameModule.Ch018Unique3
// 0x0260 (0x2230 - 0x1FD0)
class ACh018Unique3 final : public ACustomBullet
{
public:
	float                                         _reverseForcePowerInitial;                         // 0x1FD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseForcePowerEnd;                             // 0x1FD4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseForceLimitTime;                            // 0x1FD8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _reverseForceEasingType;                           // 0x1FDC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDD[0x3];                                     // 0x1FDD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _reverseSpeed;                                     // 0x1FE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseHomingRateInitial;                         // 0x1FE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseHomingRateEnd;                             // 0x1FE8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseHomingTime;                                // 0x1FEC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _shotSolveIteration;                               // 0x1FF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _connectSolveIteration;                            // 0x1FF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseSolveIteration;                            // 0x1FF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseSolveIterationEnd;                         // 0x1FFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reverseEndDist;                                   // 0x2000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2004[0x4];                                     // 0x2004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _drainCurve;                                       // 0x2008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomParticleSystemComponent*         _topParticle;                                      // 0x2010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCableComponent*                        _cable;                                            // 0x2018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomBulletHomingComponent*           _homingComponent;                                  // 0x2020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x2028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2030[0x1E0];                                   // 0x2030(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _pHitChara;                                        // 0x2210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _pTargetChara;                                     // 0x2218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2220[0x10];                                    // 0x2220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch018Unique3">();
	}
	static class ACh018Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh018Unique3>();
	}
};
static_assert(alignof(ACh018Unique3) == 0x000010, "Wrong alignment on ACh018Unique3");
static_assert(sizeof(ACh018Unique3) == 0x002230, "Wrong size on ACh018Unique3");
static_assert(offsetof(ACh018Unique3, _reverseForcePowerInitial) == 0x001FD0, "Member 'ACh018Unique3::_reverseForcePowerInitial' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseForcePowerEnd) == 0x001FD4, "Member 'ACh018Unique3::_reverseForcePowerEnd' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseForceLimitTime) == 0x001FD8, "Member 'ACh018Unique3::_reverseForceLimitTime' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseForceEasingType) == 0x001FDC, "Member 'ACh018Unique3::_reverseForceEasingType' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseSpeed) == 0x001FE0, "Member 'ACh018Unique3::_reverseSpeed' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseHomingRateInitial) == 0x001FE4, "Member 'ACh018Unique3::_reverseHomingRateInitial' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseHomingRateEnd) == 0x001FE8, "Member 'ACh018Unique3::_reverseHomingRateEnd' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseHomingTime) == 0x001FEC, "Member 'ACh018Unique3::_reverseHomingTime' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _shotSolveIteration) == 0x001FF0, "Member 'ACh018Unique3::_shotSolveIteration' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _connectSolveIteration) == 0x001FF4, "Member 'ACh018Unique3::_connectSolveIteration' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseSolveIteration) == 0x001FF8, "Member 'ACh018Unique3::_reverseSolveIteration' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseSolveIterationEnd) == 0x001FFC, "Member 'ACh018Unique3::_reverseSolveIterationEnd' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _reverseEndDist) == 0x002000, "Member 'ACh018Unique3::_reverseEndDist' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _drainCurve) == 0x002008, "Member 'ACh018Unique3::_drainCurve' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _topParticle) == 0x002010, "Member 'ACh018Unique3::_topParticle' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _cable) == 0x002018, "Member 'ACh018Unique3::_cable' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _homingComponent) == 0x002020, "Member 'ACh018Unique3::_homingComponent' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _mid) == 0x002028, "Member 'ACh018Unique3::_mid' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _pHitChara) == 0x002210, "Member 'ACh018Unique3::_pHitChara' has a wrong offset!");
static_assert(offsetof(ACh018Unique3, _pTargetChara) == 0x002218, "Member 'ACh018Unique3::_pTargetChara' has a wrong offset!");

// Class InGameModule.Ch018Unique3Gen
// 0x0000 (0x0460 - 0x0460)
class ACh018Unique3Gen final : public ASalvoBaseGen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch018Unique3Gen">();
	}
	static class ACh018Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh018Unique3Gen>();
	}
};
static_assert(alignof(ACh018Unique3Gen) == 0x000010, "Wrong alignment on ACh018Unique3Gen");
static_assert(sizeof(ACh018Unique3Gen) == 0x000460, "Wrong size on ACh018Unique3Gen");

// Class InGameModule.Ch023Unique1Shot
// 0x0060 (0x1E40 - 0x1DE0)
class ACh023Unique1Shot final : public ABullet
{
public:
	uint8                                         Pad_1DD8[0x38];                                    // 0x1DD8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBulletParticleSystemComponent*         _headParticle;                                     // 0x1E10(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletParticleSystemComponent*         _hitParticle;                                      // 0x1E18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E20[0x4];                                     // 0x1E20(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _defaultCollisionAxisX;                            // 0x1E24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _maxHitCollisionScaleZ;                            // 0x1E28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _headParticleAxisX;                                // 0x1E2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _beamParticleScale;                                // 0x1E30(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E3C[0x4];                                     // 0x1E3C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique1Shot">();
	}
	static class ACh023Unique1Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique1Shot>();
	}
};
static_assert(alignof(ACh023Unique1Shot) == 0x000010, "Wrong alignment on ACh023Unique1Shot");
static_assert(sizeof(ACh023Unique1Shot) == 0x001E40, "Wrong size on ACh023Unique1Shot");
static_assert(offsetof(ACh023Unique1Shot, _headParticle) == 0x001E10, "Member 'ACh023Unique1Shot::_headParticle' has a wrong offset!");
static_assert(offsetof(ACh023Unique1Shot, _hitParticle) == 0x001E18, "Member 'ACh023Unique1Shot::_hitParticle' has a wrong offset!");
static_assert(offsetof(ACh023Unique1Shot, _defaultCollisionAxisX) == 0x001E24, "Member 'ACh023Unique1Shot::_defaultCollisionAxisX' has a wrong offset!");
static_assert(offsetof(ACh023Unique1Shot, _maxHitCollisionScaleZ) == 0x001E28, "Member 'ACh023Unique1Shot::_maxHitCollisionScaleZ' has a wrong offset!");
static_assert(offsetof(ACh023Unique1Shot, _headParticleAxisX) == 0x001E2C, "Member 'ACh023Unique1Shot::_headParticleAxisX' has a wrong offset!");
static_assert(offsetof(ACh023Unique1Shot, _beamParticleScale) == 0x001E30, "Member 'ACh023Unique1Shot::_beamParticleScale' has a wrong offset!");

// Class InGameModule.Ch023Unique2ChildGen
// 0x0030 (0x0480 - 0x0450)
class ACh023Unique2ChildGen final : public AProjectileGeneratorBattle
{
public:
	struct FCh023Unique2ShotChildGenRep           _createRep;                                        // 0x0448(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x18];                                     // 0x0460(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _hitCharacter;                                     // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_Create();
	void SetCreateInfo_ToServer(const struct FCh023Unique2ShotChildGenRep& Gen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique2ChildGen">();
	}
	static class ACh023Unique2ChildGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique2ChildGen>();
	}
};
static_assert(alignof(ACh023Unique2ChildGen) == 0x000010, "Wrong alignment on ACh023Unique2ChildGen");
static_assert(sizeof(ACh023Unique2ChildGen) == 0x000480, "Wrong size on ACh023Unique2ChildGen");
static_assert(offsetof(ACh023Unique2ChildGen, _createRep) == 0x000448, "Member 'ACh023Unique2ChildGen::_createRep' has a wrong offset!");
static_assert(offsetof(ACh023Unique2ChildGen, _hitCharacter) == 0x000478, "Member 'ACh023Unique2ChildGen::_hitCharacter' has a wrong offset!");

// Class InGameModule.Ch023Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class ACh023Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique2Gen">();
	}
	static class ACh023Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique2Gen>();
	}
};
static_assert(alignof(ACh023Unique2Gen) == 0x000010, "Wrong alignment on ACh023Unique2Gen");
static_assert(sizeof(ACh023Unique2Gen) == 0x000450, "Wrong size on ACh023Unique2Gen");

// Class InGameModule.Ch023Unique3Gen
// 0x0000 (0x0450 - 0x0450)
class ACh023Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	class ACh023Unique3Shot*                      _bullet;                                           // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch023Unique3Gen">();
	}
	static class ACh023Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh023Unique3Gen>();
	}
};
static_assert(alignof(ACh023Unique3Gen) == 0x000010, "Wrong alignment on ACh023Unique3Gen");
static_assert(sizeof(ACh023Unique3Gen) == 0x000450, "Wrong size on ACh023Unique3Gen");
static_assert(offsetof(ACh023Unique3Gen, _bullet) == 0x000448, "Member 'ACh023Unique3Gen::_bullet' has a wrong offset!");

// Class InGameModule.Ch024Unique3
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh024Unique3 final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch024Unique3">();
	}
	static class ACh024Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh024Unique3>();
	}
};
static_assert(alignof(ACh024Unique3) == 0x000010, "Wrong alignment on ACh024Unique3");
static_assert(sizeof(ACh024Unique3) == 0x001FD0, "Wrong size on ACh024Unique3");

// Class InGameModule.Ch025Unique2
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh025Unique2 final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch025Unique2">();
	}
	static class ACh025Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh025Unique2>();
	}
};
static_assert(alignof(ACh025Unique2) == 0x000010, "Wrong alignment on ACh025Unique2");
static_assert(sizeof(ACh025Unique2) == 0x001DE0, "Wrong size on ACh025Unique2");

// Class InGameModule.Ch025Unique3
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh025Unique3 final : public ABullet
{
public:
	float                                         _childScale;                                       // 0x1DD8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0x4];                                     // 0x1DDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBulletParticleSystemComponent*         _bulletParticle;                                   // 0x1DE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE8[0x8];                                     // 0x1DE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch025Unique3">();
	}
	static class ACh025Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh025Unique3>();
	}
};
static_assert(alignof(ACh025Unique3) == 0x000010, "Wrong alignment on ACh025Unique3");
static_assert(sizeof(ACh025Unique3) == 0x001DF0, "Wrong size on ACh025Unique3");
static_assert(offsetof(ACh025Unique3, _childScale) == 0x001DD8, "Member 'ACh025Unique3::_childScale' has a wrong offset!");
static_assert(offsetof(ACh025Unique3, _bulletParticle) == 0x001DE0, "Member 'ACh025Unique3::_bulletParticle' has a wrong offset!");

// Class InGameModule.Ch025Unique3ChildGen
// 0x0000 (0x0450 - 0x0450)
class ACh025Unique3ChildGen final : public AProjectileGeneratorBattle
{
public:
	float                                         _spawnScale;                                       // 0x0448(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch025Unique3ChildGen">();
	}
	static class ACh025Unique3ChildGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh025Unique3ChildGen>();
	}
};
static_assert(alignof(ACh025Unique3ChildGen) == 0x000010, "Wrong alignment on ACh025Unique3ChildGen");
static_assert(sizeof(ACh025Unique3ChildGen) == 0x000450, "Wrong size on ACh025Unique3ChildGen");
static_assert(offsetof(ACh025Unique3ChildGen, _spawnScale) == 0x000448, "Member 'ACh025Unique3ChildGen::_spawnScale' has a wrong offset!");

// Class InGameModule.Ch034
// 0x0000 (0x0B10 - 0x0B10)
class ACh034 final : public ACharacterBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034">();
	}
	static class ACh034* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034>();
	}
};
static_assert(alignof(ACh034) == 0x000010, "Wrong alignment on ACh034");
static_assert(sizeof(ACh034) == 0x000B10, "Wrong size on ACh034");

// Class InGameModule.Ch034Unique1Gen
// 0x0160 (0x05B0 - 0x0450)
class ACh034Unique1Gen final : public AProjectileGeneratorBattle
{
public:
	TArray<class ACh034Unique1*>                  _spawnBulletList;                                  // 0x0448(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x68];                                     // 0x0458(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _basePointForwardList;                             // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _basePointRightList;                               // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _directionRightMinList;                            // 0x04E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _directionRightMaxList;                            // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _directionForwardMinList;                          // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _directionForwardMaxList;                          // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _minRandomOffsetList;                              // 0x0520(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _maxRandomOffsetList;                              // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FCh034Unique1LevelData>    _levelDataList;                                    // 0x0540(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         _groundIgnoreDist;                                 // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _checkHeight;                                      // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _checkLow;                                         // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _wallDegThreshold;                                 // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bEndAction;                                       // 0x05A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0xF];                                      // 0x05A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndAction_RPC(bool bEndAction);
	void OnRep_EndAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034Unique1Gen">();
	}
	static class ACh034Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034Unique1Gen>();
	}
};
static_assert(alignof(ACh034Unique1Gen) == 0x000010, "Wrong alignment on ACh034Unique1Gen");
static_assert(sizeof(ACh034Unique1Gen) == 0x0005B0, "Wrong size on ACh034Unique1Gen");
static_assert(offsetof(ACh034Unique1Gen, _spawnBulletList) == 0x000448, "Member 'ACh034Unique1Gen::_spawnBulletList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _basePointForwardList) == 0x0004C0, "Member 'ACh034Unique1Gen::_basePointForwardList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _basePointRightList) == 0x0004D0, "Member 'ACh034Unique1Gen::_basePointRightList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _directionRightMinList) == 0x0004E0, "Member 'ACh034Unique1Gen::_directionRightMinList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _directionRightMaxList) == 0x0004F0, "Member 'ACh034Unique1Gen::_directionRightMaxList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _directionForwardMinList) == 0x000500, "Member 'ACh034Unique1Gen::_directionForwardMinList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _directionForwardMaxList) == 0x000510, "Member 'ACh034Unique1Gen::_directionForwardMaxList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _minRandomOffsetList) == 0x000520, "Member 'ACh034Unique1Gen::_minRandomOffsetList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _maxRandomOffsetList) == 0x000530, "Member 'ACh034Unique1Gen::_maxRandomOffsetList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _levelDataList) == 0x000540, "Member 'ACh034Unique1Gen::_levelDataList' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _groundIgnoreDist) == 0x000590, "Member 'ACh034Unique1Gen::_groundIgnoreDist' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _checkHeight) == 0x000594, "Member 'ACh034Unique1Gen::_checkHeight' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _checkLow) == 0x000598, "Member 'ACh034Unique1Gen::_checkLow' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _wallDegThreshold) == 0x00059C, "Member 'ACh034Unique1Gen::_wallDegThreshold' has a wrong offset!");
static_assert(offsetof(ACh034Unique1Gen, _bEndAction) == 0x0005A0, "Member 'ACh034Unique1Gen::_bEndAction' has a wrong offset!");

// Class InGameModule.Ch034Unique2Child
// 0x0000 (0x1EC0 - 0x1EC0)
class ACh034Unique2Child final : public ACh017Unique2Child
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034Unique2Child">();
	}
	static class ACh034Unique2Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034Unique2Child>();
	}
};
static_assert(alignof(ACh034Unique2Child) == 0x000010, "Wrong alignment on ACh034Unique2Child");
static_assert(sizeof(ACh034Unique2Child) == 0x001EC0, "Wrong size on ACh034Unique2Child");

// Class InGameModule.Ch034Unique3
// 0x0000 (0x1DE0 - 0x1DE0)
class ACh034Unique3 final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034Unique3">();
	}
	static class ACh034Unique3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034Unique3>();
	}
};
static_assert(alignof(ACh034Unique3) == 0x000010, "Wrong alignment on ACh034Unique3");
static_assert(sizeof(ACh034Unique3) == 0x001DE0, "Wrong size on ACh034Unique3");

// Class InGameModule.Ch034Unique3Gen
// 0x0000 (0x0600 - 0x0600)
class ACh034Unique3Gen final : public AFanShapedGen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch034Unique3Gen">();
	}
	static class ACh034Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh034Unique3Gen>();
	}
};
static_assert(alignof(ACh034Unique3Gen) == 0x000010, "Wrong alignment on ACh034Unique3Gen");
static_assert(sizeof(ACh034Unique3Gen) == 0x000600, "Wrong size on ACh034Unique3Gen");

// Class InGameModule.Ch037_ActionAttack_Special
// 0x0008 (0x0368 - 0x0360)
class UCh037_ActionAttack_Special final : public UActionAttack_Special_Coop
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch037_ActionAttack_Special">();
	}
	static class UCh037_ActionAttack_Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCh037_ActionAttack_Special>();
	}
};
static_assert(alignof(UCh037_ActionAttack_Special) == 0x000008, "Wrong alignment on UCh037_ActionAttack_Special");
static_assert(sizeof(UCh037_ActionAttack_Special) == 0x000368, "Wrong size on UCh037_ActionAttack_Special");
static_assert(offsetof(UCh037_ActionAttack_Special, _playerState) == 0x000360, "Member 'UCh037_ActionAttack_Special::_playerState' has a wrong offset!");

// Class InGameModule.Ch037Unique1Gen
// 0x0000 (0x0470 - 0x0470)
class ACh037Unique1Gen final : public ASpreadBaseGen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch037Unique1Gen">();
	}
	static class ACh037Unique1Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh037Unique1Gen>();
	}
};
static_assert(alignof(ACh037Unique1Gen) == 0x000010, "Wrong alignment on ACh037Unique1Gen");
static_assert(sizeof(ACh037Unique1Gen) == 0x000470, "Wrong size on ACh037Unique1Gen");

// Class InGameModule.Ch037Unique3Shot
// 0x0000 (0x1FD0 - 0x1FD0)
class ACh037Unique3Shot final : public ACustomBullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch037Unique3Shot">();
	}
	static class ACh037Unique3Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh037Unique3Shot>();
	}
};
static_assert(alignof(ACh037Unique3Shot) == 0x000010, "Wrong alignment on ACh037Unique3Shot");
static_assert(sizeof(ACh037Unique3Shot) == 0x001FD0, "Wrong size on ACh037Unique3Shot");

// Class InGameModule.Ch038_ActionAttack_Special
// 0x0008 (0x0368 - 0x0360)
class UCh038_ActionAttack_Special final : public UActionAttack_Special_Coop
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ActionMainRelease();
	void BP_ActionRemoteRelease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch038_ActionAttack_Special">();
	}
	static class UCh038_ActionAttack_Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCh038_ActionAttack_Special>();
	}
};
static_assert(alignof(UCh038_ActionAttack_Special) == 0x000008, "Wrong alignment on UCh038_ActionAttack_Special");
static_assert(sizeof(UCh038_ActionAttack_Special) == 0x000368, "Wrong size on UCh038_ActionAttack_Special");

// Class InGameModule.Ch038Unique3Child
// 0x0010 (0x1FE0 - 0x1FD0)
class ACh038Unique3Child final : public ACustomBullet
{
public:
	class UCustomParticleSystemComponent*         _smokeParticle;                                    // 0x1FD0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD8[0x8];                                     // 0x1FD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch038Unique3Child">();
	}
	static class ACh038Unique3Child* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh038Unique3Child>();
	}
};
static_assert(alignof(ACh038Unique3Child) == 0x000010, "Wrong alignment on ACh038Unique3Child");
static_assert(sizeof(ACh038Unique3Child) == 0x001FE0, "Wrong size on ACh038Unique3Child");
static_assert(offsetof(ACh038Unique3Child, _smokeParticle) == 0x001FD0, "Member 'ACh038Unique3Child::_smokeParticle' has a wrong offset!");

// Class InGameModule.Ch043Unique3HomingGen
// 0x0000 (0x0450 - 0x0450)
class ACh043Unique3HomingGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch043Unique3HomingGen">();
	}
	static class ACh043Unique3HomingGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh043Unique3HomingGen>();
	}
};
static_assert(alignof(ACh043Unique3HomingGen) == 0x000010, "Wrong alignment on ACh043Unique3HomingGen");
static_assert(sizeof(ACh043Unique3HomingGen) == 0x000450, "Wrong size on ACh043Unique3HomingGen");

// Class InGameModule.Ch046Unique1BulletBase
// 0x0010 (0x1DF0 - 0x1DE0)
class ACh046Unique1BulletBase final : public ABullet
{
public:
	TArray<class UOutlineStaticMeshComponent*>    _bulletMeshList;                                   // 0x1DD8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DE8[0x8];                                     // 0x1DE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch046Unique1BulletBase">();
	}
	static class ACh046Unique1BulletBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh046Unique1BulletBase>();
	}
};
static_assert(alignof(ACh046Unique1BulletBase) == 0x000010, "Wrong alignment on ACh046Unique1BulletBase");
static_assert(sizeof(ACh046Unique1BulletBase) == 0x001DF0, "Wrong size on ACh046Unique1BulletBase");
static_assert(offsetof(ACh046Unique1BulletBase, _bulletMeshList) == 0x001DD8, "Member 'ACh046Unique1BulletBase::_bulletMeshList' has a wrong offset!");

// Class InGameModule.Ch046Unique2Gen
// 0x0070 (0x04C0 - 0x0450)
class ACh046Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	class ACh046Unique2BulletBase*                _bullet;                                           // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _meshComponent;                                    // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterAttackComponent*              _attackComponent;                                  // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _spawnPointOffset;                                 // 0x0460(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMagazineManagementComponent*           _magazineManager;                                  // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           _sendReplicateTimer;                               // 0x0478(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x40];                                     // 0x0480(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveDamageT(class UPrimitiveComponent* HitComponent, float DamageValue, EHitMarkType HitMarkType, const struct FHitResult& Hit, bool IsMeleeAttack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch046Unique2Gen">();
	}
	static class ACh046Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh046Unique2Gen>();
	}
};
static_assert(alignof(ACh046Unique2Gen) == 0x000010, "Wrong alignment on ACh046Unique2Gen");
static_assert(sizeof(ACh046Unique2Gen) == 0x0004C0, "Wrong size on ACh046Unique2Gen");
static_assert(offsetof(ACh046Unique2Gen, _bullet) == 0x000448, "Member 'ACh046Unique2Gen::_bullet' has a wrong offset!");
static_assert(offsetof(ACh046Unique2Gen, _meshComponent) == 0x000450, "Member 'ACh046Unique2Gen::_meshComponent' has a wrong offset!");
static_assert(offsetof(ACh046Unique2Gen, _attackComponent) == 0x000458, "Member 'ACh046Unique2Gen::_attackComponent' has a wrong offset!");
static_assert(offsetof(ACh046Unique2Gen, _spawnPointOffset) == 0x000460, "Member 'ACh046Unique2Gen::_spawnPointOffset' has a wrong offset!");
static_assert(offsetof(ACh046Unique2Gen, _magazineManager) == 0x000470, "Member 'ACh046Unique2Gen::_magazineManager' has a wrong offset!");
static_assert(offsetof(ACh046Unique2Gen, _sendReplicateTimer) == 0x000478, "Member 'ACh046Unique2Gen::_sendReplicateTimer' has a wrong offset!");

// Class InGameModule.Ch046Unique3Gen
// 0x0010 (0x0460 - 0x0450)
class ACh046Unique3Gen final : public AProjectileGeneratorBattle
{
public:
	class ABullet*                                _bullet;                                           // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnhancedSkeletalMeshComponent*         _characterMesh;                                    // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch046Unique3Gen">();
	}
	static class ACh046Unique3Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh046Unique3Gen>();
	}
};
static_assert(alignof(ACh046Unique3Gen) == 0x000010, "Wrong alignment on ACh046Unique3Gen");
static_assert(sizeof(ACh046Unique3Gen) == 0x000460, "Wrong size on ACh046Unique3Gen");
static_assert(offsetof(ACh046Unique3Gen, _bullet) == 0x000448, "Member 'ACh046Unique3Gen::_bullet' has a wrong offset!");
static_assert(offsetof(ACh046Unique3Gen, _characterMesh) == 0x000450, "Member 'ACh046Unique3Gen::_characterMesh' has a wrong offset!");

// Class InGameModule.WrappedCh101SpecialGen
// 0x0000 (0x0450 - 0x0450)
class AWrappedCh101SpecialGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrappedCh101SpecialGen">();
	}
	static class AWrappedCh101SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWrappedCh101SpecialGen>();
	}
};
static_assert(alignof(AWrappedCh101SpecialGen) == 0x000010, "Wrong alignment on AWrappedCh101SpecialGen");
static_assert(sizeof(AWrappedCh101SpecialGen) == 0x000450, "Wrong size on AWrappedCh101SpecialGen");

// Class InGameModule.Ch102SpecialGen
// 0x0020 (0x0470 - 0x0450)
class ACh102SpecialGen final : public AProjectileGeneratorBattle
{
public:
	float                                         _checkStartPosHight;                               // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkHight;                                       // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x4];                                      // 0x0450(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCh102SpecialGenRep                    _createCh102SpecialRep;                            // 0x0454(0x0014)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateCh102Special_RPC(const struct FCh102SpecialGenRep& Gen);
	void OnRep_CreateCh102Special();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch102SpecialGen">();
	}
	static class ACh102SpecialGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh102SpecialGen>();
	}
};
static_assert(alignof(ACh102SpecialGen) == 0x000010, "Wrong alignment on ACh102SpecialGen");
static_assert(sizeof(ACh102SpecialGen) == 0x000470, "Wrong size on ACh102SpecialGen");
static_assert(offsetof(ACh102SpecialGen, _checkStartPosHight) == 0x000448, "Member 'ACh102SpecialGen::_checkStartPosHight' has a wrong offset!");
static_assert(offsetof(ACh102SpecialGen, _checkHight) == 0x00044C, "Member 'ACh102SpecialGen::_checkHight' has a wrong offset!");
static_assert(offsetof(ACh102SpecialGen, _createCh102SpecialRep) == 0x000454, "Member 'ACh102SpecialGen::_createCh102SpecialRep' has a wrong offset!");

// Class InGameModule.Ch102Unique2
// 0x0080 (0x2050 - 0x1FD0)
class ACh102Unique2 final : public ACustomBullet
{
public:
	float                                         _targetReflectAngle;                               // 0x1FD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD4[0x7C];                                    // 0x1FD4(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReflection(const struct FVector& Normal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch102Unique2">();
	}
	static class ACh102Unique2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh102Unique2>();
	}
};
static_assert(alignof(ACh102Unique2) == 0x000010, "Wrong alignment on ACh102Unique2");
static_assert(sizeof(ACh102Unique2) == 0x002050, "Wrong size on ACh102Unique2");
static_assert(offsetof(ACh102Unique2, _targetReflectAngle) == 0x001FD0, "Member 'ACh102Unique2::_targetReflectAngle' has a wrong offset!");

// Class InGameModule.Ch109Special
// 0x02F0 (0x22C0 - 0x1FD0)
class ACh109Special final : public ACustomBullet
{
public:
	class UParticleSystem*                        _noteEffect;                                       // 0x1FD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _putNormalDist;                                    // 0x1FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDC[0x4];                                     // 0x1FDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _putSound;                                         // 0x1FE0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FCh109SpecialSoundInfo>         _attackSoundList;                                  // 0x2000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCh109SpecialSoundInfo>         _baseSoundList;                                    // 0x2010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         _soundPlayradius;                                  // 0x2020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _soundPlayMoveDist;                                // 0x2024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           _rotateCurve;                                      // 0x2028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomBulletPhysicsLikeComponent*      _pPhysicsLikeComp;                                 // 0x2030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _pBGColRadio;                                      // 0x2038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _pBGColBullet;                                     // 0x2040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _pParticle;                                        // 0x2048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2050[0x10];                                    // 0x2050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _attackRandomIdList;                               // 0x2060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 _baseRandomIdList;                                 // 0x2070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2080[0x200];                                   // 0x2080(0x0200)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _playStartPositionList;                            // 0x2280(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _playEndPositionList;                              // 0x2290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22A0[0x20];                                    // 0x22A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch109Special">();
	}
	static class ACh109Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh109Special>();
	}
};
static_assert(alignof(ACh109Special) == 0x000010, "Wrong alignment on ACh109Special");
static_assert(sizeof(ACh109Special) == 0x0022C0, "Wrong size on ACh109Special");
static_assert(offsetof(ACh109Special, _noteEffect) == 0x001FD0, "Member 'ACh109Special::_noteEffect' has a wrong offset!");
static_assert(offsetof(ACh109Special, _putNormalDist) == 0x001FD8, "Member 'ACh109Special::_putNormalDist' has a wrong offset!");
static_assert(offsetof(ACh109Special, _putSound) == 0x001FE0, "Member 'ACh109Special::_putSound' has a wrong offset!");
static_assert(offsetof(ACh109Special, _attackSoundList) == 0x002000, "Member 'ACh109Special::_attackSoundList' has a wrong offset!");
static_assert(offsetof(ACh109Special, _baseSoundList) == 0x002010, "Member 'ACh109Special::_baseSoundList' has a wrong offset!");
static_assert(offsetof(ACh109Special, _soundPlayradius) == 0x002020, "Member 'ACh109Special::_soundPlayradius' has a wrong offset!");
static_assert(offsetof(ACh109Special, _soundPlayMoveDist) == 0x002024, "Member 'ACh109Special::_soundPlayMoveDist' has a wrong offset!");
static_assert(offsetof(ACh109Special, _rotateCurve) == 0x002028, "Member 'ACh109Special::_rotateCurve' has a wrong offset!");
static_assert(offsetof(ACh109Special, _pPhysicsLikeComp) == 0x002030, "Member 'ACh109Special::_pPhysicsLikeComp' has a wrong offset!");
static_assert(offsetof(ACh109Special, _pBGColRadio) == 0x002038, "Member 'ACh109Special::_pBGColRadio' has a wrong offset!");
static_assert(offsetof(ACh109Special, _pBGColBullet) == 0x002040, "Member 'ACh109Special::_pBGColBullet' has a wrong offset!");
static_assert(offsetof(ACh109Special, _pParticle) == 0x002048, "Member 'ACh109Special::_pParticle' has a wrong offset!");
static_assert(offsetof(ACh109Special, _attackRandomIdList) == 0x002060, "Member 'ACh109Special::_attackRandomIdList' has a wrong offset!");
static_assert(offsetof(ACh109Special, _baseRandomIdList) == 0x002070, "Member 'ACh109Special::_baseRandomIdList' has a wrong offset!");
static_assert(offsetof(ACh109Special, _playStartPositionList) == 0x002280, "Member 'ACh109Special::_playStartPositionList' has a wrong offset!");
static_assert(offsetof(ACh109Special, _playEndPositionList) == 0x002290, "Member 'ACh109Special::_playEndPositionList' has a wrong offset!");

// Class InGameModule.Ch109Unique2Gen
// 0x0000 (0x0450 - 0x0450)
class ACh109Unique2Gen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ch109Unique2Gen">();
	}
	static class ACh109Unique2Gen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACh109Unique2Gen>();
	}
};
static_assert(alignof(ACh109Unique2Gen) == 0x000010, "Wrong alignment on ACh109Unique2Gen");
static_assert(sizeof(ACh109Unique2Gen) == 0x000450, "Wrong size on ACh109Unique2Gen");

// Class InGameModule.CharacterAbilityPopupWidget
// 0x0010 (0x0378 - 0x0368)
class UCharacterAbilityPopupWidget final : public UPlayerInfoBaseWidget
{
public:
	class UCharacterAbilityWidget*                _characterAbility;                                 // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _returnButton;                                     // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDecideReturnButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAbilityPopupWidget">();
	}
	static class UCharacterAbilityPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAbilityPopupWidget>();
	}
};
static_assert(alignof(UCharacterAbilityPopupWidget) == 0x000008, "Wrong alignment on UCharacterAbilityPopupWidget");
static_assert(sizeof(UCharacterAbilityPopupWidget) == 0x000378, "Wrong size on UCharacterAbilityPopupWidget");
static_assert(offsetof(UCharacterAbilityPopupWidget, _characterAbility) == 0x000368, "Member 'UCharacterAbilityPopupWidget::_characterAbility' has a wrong offset!");
static_assert(offsetof(UCharacterAbilityPopupWidget, _returnButton) == 0x000370, "Member 'UCharacterAbilityPopupWidget::_returnButton' has a wrong offset!");

// Class InGameModule.CharacterActionControlComponent
// 0x00E8 (0x01A0 - 0x00B8)
class UCharacterActionControlComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRegistActionClassData>         _baseActionClassDataList_Common;                   // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRegistActionClassData>         _baseActionClassDataList_Chara;                    // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRegistAttackClassData>         _attackActionClassDataList;                        // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRegistDamageClassData>         _damageActionClassDataList;                        // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UActionAttackBase*                      _aimingAttackActionFunc;                           // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _serverAimingMode;                                 // 0x0168(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _currentActionButtonTarget;                        // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACharacterBattle*>               _characterListForSpectialAction;                   // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ACharacterBattle*>               _characterListForRecoverAlly;                      // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRegisterAttackActionToSlot_ToClient(const struct FNetworkRegisterAttackActionData& ServerData, EAttackId AttackId, EMagazineRegisterType MagazineRegisterType);
	void OnRegisterAttackActionToSlotArray_ToClient(const TArray<struct FNetworkRegisterAttackActionData>& ServerDataList);
	void RegisterAttackActionToAttackSlot_ToServer(EAttackId AttackId, TSubclassOf<class UActionAttackBase> AttackActionClass, int32 Level, EMagazineRegisterType MagazineRegisterType);
	void RegisterAttackActionToAttackSlotArray_ToServer(const TArray<struct FNetworkRegisterAttackActionData>& ServerDataList);
	void SendActionPing_ToClient(uint8 ActionIndex, int32 Ping);
	void SendActionPing_ToServer(uint8 ActionIndex, int32 Ping);
	void SetAction_ToClient(uint8 ActionIndex, int32 ActionArgment, EActionKind RequestActionKind, uint32 NetServerPriorityActionSerialNo);
	void SetAction_ToServer(uint8 ActionIndex, int32 ActionArgment, EActionKind RequestActionKind, uint32 NetServerPriorityActionSerialNo);
	void SetAimingMode_ToServer(bool bAimingMode);
	void SetAttackAction_ToClient(EAttackId AttackId, const struct FVector_NetQuantize100& TargetLocation, class AActor* TargetActor, int32 UniqueLevel, ECommandId CommandID, bool bBeginGround);
	void SetAttackAction_ToServer(EAttackId AttackId, const struct FVector_NetQuantize100& TargetLocation, class AActor* TargetActor, int32 UniqueLevel, ECommandId CommandID, bool bBeginGround, uint32 NetServerPriorityActionSerialNo);
	void TerminateAttackLayer_ToClient();
	void TerminateAttackLayer_ToServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterActionControlComponent">();
	}
	static class UCharacterActionControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterActionControlComponent>();
	}
};
static_assert(alignof(UCharacterActionControlComponent) == 0x000008, "Wrong alignment on UCharacterActionControlComponent");
static_assert(sizeof(UCharacterActionControlComponent) == 0x0001A0, "Wrong size on UCharacterActionControlComponent");
static_assert(offsetof(UCharacterActionControlComponent, _baseActionClassDataList_Common) == 0x0000D0, "Member 'UCharacterActionControlComponent::_baseActionClassDataList_Common' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _baseActionClassDataList_Chara) == 0x0000E0, "Member 'UCharacterActionControlComponent::_baseActionClassDataList_Chara' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _attackActionClassDataList) == 0x0000F0, "Member 'UCharacterActionControlComponent::_attackActionClassDataList' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _damageActionClassDataList) == 0x000100, "Member 'UCharacterActionControlComponent::_damageActionClassDataList' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _aimingAttackActionFunc) == 0x000160, "Member 'UCharacterActionControlComponent::_aimingAttackActionFunc' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _serverAimingMode) == 0x000168, "Member 'UCharacterActionControlComponent::_serverAimingMode' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _currentActionButtonTarget) == 0x000170, "Member 'UCharacterActionControlComponent::_currentActionButtonTarget' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _characterListForSpectialAction) == 0x000178, "Member 'UCharacterActionControlComponent::_characterListForSpectialAction' has a wrong offset!");
static_assert(offsetof(UCharacterActionControlComponent, _characterListForRecoverAlly) == 0x000188, "Member 'UCharacterActionControlComponent::_characterListForRecoverAlly' has a wrong offset!");

// Class InGameModule.CharacterActionGuideWidget
// 0x0048 (0x0300 - 0x02B8)
class UCharacterActionGuideWidget final : public UWidgetAttachToActor
{
public:
	class UHorizontalBox*                         _specialActionHorizontalBox;                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _specialActionText;                                // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         _finisherHorizontalBox;                            // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _finisherText;                                     // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URetainerBox*                           _specialActionRetainerBox;                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URetainerBox*                           _finisherRetainerBox;                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _loadFinisherText;                                 // 0x02E8(0x0018)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterActionGuideWidget">();
	}
	static class UCharacterActionGuideWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterActionGuideWidget>();
	}
};
static_assert(alignof(UCharacterActionGuideWidget) == 0x000008, "Wrong alignment on UCharacterActionGuideWidget");
static_assert(sizeof(UCharacterActionGuideWidget) == 0x000300, "Wrong size on UCharacterActionGuideWidget");
static_assert(offsetof(UCharacterActionGuideWidget, _specialActionHorizontalBox) == 0x0002B8, "Member 'UCharacterActionGuideWidget::_specialActionHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCharacterActionGuideWidget, _specialActionText) == 0x0002C0, "Member 'UCharacterActionGuideWidget::_specialActionText' has a wrong offset!");
static_assert(offsetof(UCharacterActionGuideWidget, _finisherHorizontalBox) == 0x0002C8, "Member 'UCharacterActionGuideWidget::_finisherHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCharacterActionGuideWidget, _finisherText) == 0x0002D0, "Member 'UCharacterActionGuideWidget::_finisherText' has a wrong offset!");
static_assert(offsetof(UCharacterActionGuideWidget, _specialActionRetainerBox) == 0x0002D8, "Member 'UCharacterActionGuideWidget::_specialActionRetainerBox' has a wrong offset!");
static_assert(offsetof(UCharacterActionGuideWidget, _finisherRetainerBox) == 0x0002E0, "Member 'UCharacterActionGuideWidget::_finisherRetainerBox' has a wrong offset!");
static_assert(offsetof(UCharacterActionGuideWidget, _loadFinisherText) == 0x0002E8, "Member 'UCharacterActionGuideWidget::_loadFinisherText' has a wrong offset!");

// Class InGameModule.AddPartsStaticMesh
// 0x0008 (0x0050 - 0x0048)
class UAddPartsStaticMesh final : public UAddParts
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddPartsStaticMesh">();
	}
	static class UAddPartsStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddPartsStaticMesh>();
	}
};
static_assert(alignof(UAddPartsStaticMesh) == 0x000008, "Wrong alignment on UAddPartsStaticMesh");
static_assert(sizeof(UAddPartsStaticMesh) == 0x000050, "Wrong size on UAddPartsStaticMesh");

// Class InGameModule.AddPartsParticle
// 0x0048 (0x0090 - 0x0048)
class alignas(0x10) UAddPartsParticle final : public UAddParts
{
public:
	class UParticleSystem*                        _particleSystem;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddPartsParticle">();
	}
	static class UAddPartsParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddPartsParticle>();
	}
};
static_assert(alignof(UAddPartsParticle) == 0x000010, "Wrong alignment on UAddPartsParticle");
static_assert(sizeof(UAddPartsParticle) == 0x000090, "Wrong size on UAddPartsParticle");
static_assert(offsetof(UAddPartsParticle, _particleSystem) == 0x000048, "Member 'UAddPartsParticle::_particleSystem' has a wrong offset!");

// Class InGameModule.CharacterAttackCollisionController
// 0x0050 (0x0108 - 0x00B8)
class UCharacterAttackCollisionController final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitGroupRemoveReservedInfo>    _removeGroupReservedTbl;                           // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UCharacterAttackReplicateComponent*     _characterAttackReplicator;                        // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _damageAttenuationCurve;                           // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttackHit_RPC(const struct FProjectileHitRep& Rep);
	void AttackHit_RPC_Client(const struct FBulletHitRep& Rep);
	void OnHitBackground(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnHitCharacter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAttackCollisionController">();
	}
	static class UCharacterAttackCollisionController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAttackCollisionController>();
	}
};
static_assert(alignof(UCharacterAttackCollisionController) == 0x000008, "Wrong alignment on UCharacterAttackCollisionController");
static_assert(sizeof(UCharacterAttackCollisionController) == 0x000108, "Wrong size on UCharacterAttackCollisionController");
static_assert(offsetof(UCharacterAttackCollisionController, _removeGroupReservedTbl) == 0x0000E0, "Member 'UCharacterAttackCollisionController::_removeGroupReservedTbl' has a wrong offset!");
static_assert(offsetof(UCharacterAttackCollisionController, _characterAttackReplicator) == 0x0000F0, "Member 'UCharacterAttackCollisionController::_characterAttackReplicator' has a wrong offset!");
static_assert(offsetof(UCharacterAttackCollisionController, _damageAttenuationCurve) == 0x0000F8, "Member 'UCharacterAttackCollisionController::_damageAttenuationCurve' has a wrong offset!");

// Class InGameModule.CharacterAttackReplicateComponent
// 0x0038 (0x00E8 - 0x00B0)
class UCharacterAttackReplicateComponent final : public UActorComponent
{
public:
	struct FCharacterAttackHitRep                 _rep;                                              // 0x00B0(0x0038)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void CharacterAttackHit_RPC(const struct FCharacterAttackHitRep& Rep);
	void OnRep_CharacterAttackHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAttackReplicateComponent">();
	}
	static class UCharacterAttackReplicateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAttackReplicateComponent>();
	}
};
static_assert(alignof(UCharacterAttackReplicateComponent) == 0x000008, "Wrong alignment on UCharacterAttackReplicateComponent");
static_assert(sizeof(UCharacterAttackReplicateComponent) == 0x0000E8, "Wrong size on UCharacterAttackReplicateComponent");
static_assert(offsetof(UCharacterAttackReplicateComponent, _rep) == 0x0000B0, "Member 'UCharacterAttackReplicateComponent::_rep' has a wrong offset!");

// Class InGameModule.CharacterBattleEffectComponent
// 0x00A0 (0x0158 - 0x00B8)
class UCharacterBattleEffectComponent final : public UCharacterBattleComponentBase
{
public:
	TWeakObjectPtr<class UParticleSystemComponent> _waterSplashEffect;                                // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UParticleSystemComponent> _waterRipplesEffect;                               // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UParticleSystemComponent> _underWaterEffect;                                 // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UParticleSystemComponent*> _usingSupplyEffect;                                // 0x00D8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _waterSplashEffectAsset;                           // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _waterRipplesEffectAsset;                          // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _underWaterEffectAsset;                            // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _useSupplyEffectAsset;                             // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             _usingSupplyDataTable;                             // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBattleEffectComponent">();
	}
	static class UCharacterBattleEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBattleEffectComponent>();
	}
};
static_assert(alignof(UCharacterBattleEffectComponent) == 0x000008, "Wrong alignment on UCharacterBattleEffectComponent");
static_assert(sizeof(UCharacterBattleEffectComponent) == 0x000158, "Wrong size on UCharacterBattleEffectComponent");
static_assert(offsetof(UCharacterBattleEffectComponent, _waterSplashEffect) == 0x0000B8, "Member 'UCharacterBattleEffectComponent::_waterSplashEffect' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _waterRipplesEffect) == 0x0000C8, "Member 'UCharacterBattleEffectComponent::_waterRipplesEffect' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _underWaterEffect) == 0x0000D0, "Member 'UCharacterBattleEffectComponent::_underWaterEffect' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _usingSupplyEffect) == 0x0000D8, "Member 'UCharacterBattleEffectComponent::_usingSupplyEffect' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _waterSplashEffectAsset) == 0x000128, "Member 'UCharacterBattleEffectComponent::_waterSplashEffectAsset' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _waterRipplesEffectAsset) == 0x000130, "Member 'UCharacterBattleEffectComponent::_waterRipplesEffectAsset' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _underWaterEffectAsset) == 0x000138, "Member 'UCharacterBattleEffectComponent::_underWaterEffectAsset' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _useSupplyEffectAsset) == 0x000140, "Member 'UCharacterBattleEffectComponent::_useSupplyEffectAsset' has a wrong offset!");
static_assert(offsetof(UCharacterBattleEffectComponent, _usingSupplyDataTable) == 0x000148, "Member 'UCharacterBattleEffectComponent::_usingSupplyDataTable' has a wrong offset!");

// Class InGameModule.CharacterBuffControlCompnent
// 0x0018 (0x00D0 - 0x00B8)
class UCharacterBuffControlCompnent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyTeamBuffs_ToClient(const struct FNetTeamRollBuff& Data);
	void RequestApplyTeamBuffs_ToServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBuffControlCompnent">();
	}
	static class UCharacterBuffControlCompnent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBuffControlCompnent>();
	}
};
static_assert(alignof(UCharacterBuffControlCompnent) == 0x000008, "Wrong alignment on UCharacterBuffControlCompnent");
static_assert(sizeof(UCharacterBuffControlCompnent) == 0x0000D0, "Wrong size on UCharacterBuffControlCompnent");

// Class InGameModule.CharacterCommandComponent
// 0x0178 (0x0230 - 0x00B8)
class UCharacterCommandComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x178];                                     // 0x00B8(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ClearCommand(ECommandId CommandID);
	void BP_SetChargeEnabled(ECommandId CommandID, bool Flag);
	void BP_SetChargeTime(ECommandId CommandID, float Time);
	void BP_SetCommandValidity(ECommandId CommandID, bool Flag);

	const struct FVector BP_GetMoveDirection() const;
	const struct FVector BP_GetMoveDirectionForWall() const;
	float BP_GetMoveRate() const;
	bool BP_IsSatisfiedCommand(ECommandId CommandID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCommandComponent">();
	}
	static class UCharacterCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCommandComponent>();
	}
};
static_assert(alignof(UCharacterCommandComponent) == 0x000008, "Wrong alignment on UCharacterCommandComponent");
static_assert(sizeof(UCharacterCommandComponent) == 0x000230, "Wrong size on UCharacterCommandComponent");

// Class InGameModule.CharacterConditionAbility
// 0x0008 (0x0108 - 0x0100)
class UCharacterConditionAbility : public UCharacterConditionBase
{
public:
	EMdAbilityType                                _abilityType;                                      // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float BP_GetEfficacyValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterConditionAbility">();
	}
	static class UCharacterConditionAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterConditionAbility>();
	}
};
static_assert(alignof(UCharacterConditionAbility) == 0x000008, "Wrong alignment on UCharacterConditionAbility");
static_assert(sizeof(UCharacterConditionAbility) == 0x000108, "Wrong size on UCharacterConditionAbility");
static_assert(offsetof(UCharacterConditionAbility, _abilityType) == 0x000100, "Member 'UCharacterConditionAbility::_abilityType' has a wrong offset!");

// Class InGameModule.CharacterDamageComponent
// 0x0100 (0x01B8 - 0x00B8)
class UCharacterDamageComponent : public UCharacterBattleComponentBase
{
public:
	struct FNetDamageBootInfo                     _serverDamageBootInfo;                             // 0x00B8(0x0050)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FNetDamageBootInfo>             _serverDamageBootInfoList;                         // 0x0108(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageInfo                            _currentDamageInfo;                                // 0x0120(0x0080)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x18];                                     // 0x01A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_AddSlipDamage(float DamageValue, ECharacterId DamageParamCharaId, const class FName ParamName, EDamageCauserType DamageCauserType);
	struct FVector BP_GetDamageDirection();
	void BP_SetDamageInvincible(bool bEnableEffect);
	void BP_SetRecoverInvincible();
	void OnRep_Replicated_serverDamageBootInfo();
	void ReceiveDamage_RPC_OnServer(const struct FTakeDamageArgument& DamageArgument);
	void SendDamageToClient_RPC_OnClient(const struct FNetDamageBootInfo& DamageBootInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDamageComponent">();
	}
	static class UCharacterDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDamageComponent>();
	}
};
static_assert(alignof(UCharacterDamageComponent) == 0x000008, "Wrong alignment on UCharacterDamageComponent");
static_assert(sizeof(UCharacterDamageComponent) == 0x0001B8, "Wrong size on UCharacterDamageComponent");
static_assert(offsetof(UCharacterDamageComponent, _serverDamageBootInfo) == 0x0000B8, "Member 'UCharacterDamageComponent::_serverDamageBootInfo' has a wrong offset!");
static_assert(offsetof(UCharacterDamageComponent, _serverDamageBootInfoList) == 0x000108, "Member 'UCharacterDamageComponent::_serverDamageBootInfoList' has a wrong offset!");
static_assert(offsetof(UCharacterDamageComponent, _currentDamageInfo) == 0x000120, "Member 'UCharacterDamageComponent::_currentDamageInfo' has a wrong offset!");

// Class InGameModule.CharacterGiantControlComponent
// 0x01D8 (0x0290 - 0x00B8)
class alignas(0x10) UCharacterGiantControlComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x120];                                     // 0x00B8(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterGiantAnimationData           _defaultData;                                      // 0x01D8(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FCharacterGiantAnimationData           _giantData;                                        // 0x0230(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_RequestBecomeGiant(float DestinationScale, float Span);
	void BP_RequestReturnNormal(float Span);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterGiantControlComponent">();
	}
	static class UCharacterGiantControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterGiantControlComponent>();
	}
};
static_assert(alignof(UCharacterGiantControlComponent) == 0x000010, "Wrong alignment on UCharacterGiantControlComponent");
static_assert(sizeof(UCharacterGiantControlComponent) == 0x000290, "Wrong size on UCharacterGiantControlComponent");
static_assert(offsetof(UCharacterGiantControlComponent, _defaultData) == 0x0001D8, "Member 'UCharacterGiantControlComponent::_defaultData' has a wrong offset!");
static_assert(offsetof(UCharacterGiantControlComponent, _giantData) == 0x000230, "Member 'UCharacterGiantControlComponent::_giantData' has a wrong offset!");

// Class InGameModule.CharacterInfoPresenter
// 0x0008 (0x0250 - 0x0248)
class ACharacterInfoPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInfoPresenter">();
	}
	static class ACharacterInfoPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterInfoPresenter>();
	}
};
static_assert(alignof(ACharacterInfoPresenter) == 0x000008, "Wrong alignment on ACharacterInfoPresenter");
static_assert(sizeof(ACharacterInfoPresenter) == 0x000250, "Wrong size on ACharacterInfoPresenter");

// Class InGameModule.AnimInstanceAttack
// 0x0020 (0x02E0 - 0x02C0)
class UAnimInstanceAttack final : public UAnimInstance
{
public:
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_EventOnHit(const struct FVector& HitLocation);

	float BP_GetAdditiveDistance() const;
	struct FVector BP_GetAdditiveDistanceForVector() const;
	struct FRotator BP_GetAdditiveRotator() const;
	float BP_GetBlendingAlpha() const;
	struct FVector BP_GetTargetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceAttack">();
	}
	static class UAnimInstanceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceAttack>();
	}
};
static_assert(alignof(UAnimInstanceAttack) == 0x000010, "Wrong alignment on UAnimInstanceAttack");
static_assert(sizeof(UAnimInstanceAttack) == 0x0002E0, "Wrong size on UAnimInstanceAttack");

// Class InGameModule.CharacterMaterialControlComponent
// 0x0060 (0x01D0 - 0x0170)
class UCharacterMaterialControlComponent final : public UMaterialControlComponent
{
public:
	class UDataTable*                             _dataTable;                                        // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x50];                                     // 0x0178(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     _respawnedMaterial;                                // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_ClearPreset(const class FName PresetName, class UDataTable* DataTable);
	void BP_ClearPresetCondition(const class FName PresetName);
	void BP_LoopEnd(class FName Key);
	void BP_LoopStart(class FName Key, class FName ParamName, float StartValue, float TargetValue, float Span, class FName CacheName, EMaterialGroupFlag GroupFlag);
	void BP_SetPreset(const class FName PresetName, class UDataTable* DataTable);
	void BP_SetPresetCondition(const class FName PresetName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMaterialControlComponent">();
	}
	static class UCharacterMaterialControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMaterialControlComponent>();
	}
};
static_assert(alignof(UCharacterMaterialControlComponent) == 0x000008, "Wrong alignment on UCharacterMaterialControlComponent");
static_assert(sizeof(UCharacterMaterialControlComponent) == 0x0001D0, "Wrong size on UCharacterMaterialControlComponent");
static_assert(offsetof(UCharacterMaterialControlComponent, _dataTable) == 0x000170, "Member 'UCharacterMaterialControlComponent::_dataTable' has a wrong offset!");
static_assert(offsetof(UCharacterMaterialControlComponent, _respawnedMaterial) == 0x0001C8, "Member 'UCharacterMaterialControlComponent::_respawnedMaterial' has a wrong offset!");

// Class InGameModule.CharacterRespawnControlCompnent
// 0x0038 (0x00F0 - 0x00B8)
class UCharacterRespawnControlCompnent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomParticleSystemComponent*> _particles;                                        // 0x00E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BP_DestroyEffects(class UParticleSystem* EmitterTemplate);
	void BP_PlayEffects(class UParticleSystem* EmitterTemplate);
	void SetRespawnLocation_ToNetMulticast(const struct FVector_NetQuantize& RespawnLocation);

	struct FVector BP_GetRespawnLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterRespawnControlCompnent">();
	}
	static class UCharacterRespawnControlCompnent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterRespawnControlCompnent>();
	}
};
static_assert(alignof(UCharacterRespawnControlCompnent) == 0x000008, "Wrong alignment on UCharacterRespawnControlCompnent");
static_assert(sizeof(UCharacterRespawnControlCompnent) == 0x0000F0, "Wrong size on UCharacterRespawnControlCompnent");
static_assert(offsetof(UCharacterRespawnControlCompnent, _particles) == 0x0000E0, "Member 'UCharacterRespawnControlCompnent::_particles' has a wrong offset!");

// Class InGameModule.CharacterStatusWidget
// 0x0188 (0x0570 - 0x03E8)
class UCharacterStatusWidget final : public UAppWidget
{
public:
	class UTextBlock*                             _characterNameText;                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _characterRomanAlphabetText;                       // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _descriptionText;                                  // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _healthAndGuardPointText;                          // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _healthPointText;                                  // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _maxHealthPointText;                               // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _guardPointText;                                   // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           _guardPointProgressBar;                            // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           _healthProgressBar;                                // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpecialActionWidget*                   _specialAction1;                                   // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpecialActionWidget*                   _specialAction2;                                   // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URoleWidget*                            _roleWidget;                                       // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _characterImage;                                   // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _battleScoreDamage;                                // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _battleScoreDamageText;                            // 0x0458(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _battleScoreLifeTime;                              // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _battleScoreLifeTimeText;                          // 0x0478(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _battleScoreLevelUp;                               // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _battleScoreLevelUpText;                           // 0x0498(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _battleScoreGetItem;                               // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _battleScoreGetItemText;                           // 0x04B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _supportScoreItemSupport;                          // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _supportScoreItemSupportText;                      // 0x04D8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _supportScoreRescue;                               // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _supportScoreRescueText;                           // 0x04F8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _supportScoreRecovery;                             // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _supportScoreRecoveryText;                         // 0x0518(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterScoreWidget*                  _supportScorePlusUltra;                            // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _supportScorePlusUltraText;                        // 0x0538(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _characterMaterial;                                // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecvPlayerDataActivityStatus(const struct FPlayerDataActivityStatus& PlayerDataActivityStatus);
	void RequestPlayerDataActivityStatus();
	void ShowCharacterModel(ECharacterId CharacterId, int32 CostumeCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatusWidget">();
	}
	static class UCharacterStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatusWidget>();
	}
};
static_assert(alignof(UCharacterStatusWidget) == 0x000008, "Wrong alignment on UCharacterStatusWidget");
static_assert(sizeof(UCharacterStatusWidget) == 0x000570, "Wrong size on UCharacterStatusWidget");
static_assert(offsetof(UCharacterStatusWidget, _characterNameText) == 0x0003E8, "Member 'UCharacterStatusWidget::_characterNameText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _characterRomanAlphabetText) == 0x0003F0, "Member 'UCharacterStatusWidget::_characterRomanAlphabetText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _descriptionText) == 0x0003F8, "Member 'UCharacterStatusWidget::_descriptionText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _healthAndGuardPointText) == 0x000400, "Member 'UCharacterStatusWidget::_healthAndGuardPointText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _healthPointText) == 0x000408, "Member 'UCharacterStatusWidget::_healthPointText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _maxHealthPointText) == 0x000410, "Member 'UCharacterStatusWidget::_maxHealthPointText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _guardPointText) == 0x000418, "Member 'UCharacterStatusWidget::_guardPointText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _guardPointProgressBar) == 0x000420, "Member 'UCharacterStatusWidget::_guardPointProgressBar' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _healthProgressBar) == 0x000428, "Member 'UCharacterStatusWidget::_healthProgressBar' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _specialAction1) == 0x000430, "Member 'UCharacterStatusWidget::_specialAction1' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _specialAction2) == 0x000438, "Member 'UCharacterStatusWidget::_specialAction2' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _roleWidget) == 0x000440, "Member 'UCharacterStatusWidget::_roleWidget' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _characterImage) == 0x000448, "Member 'UCharacterStatusWidget::_characterImage' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreDamage) == 0x000450, "Member 'UCharacterStatusWidget::_battleScoreDamage' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreDamageText) == 0x000458, "Member 'UCharacterStatusWidget::_battleScoreDamageText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreLifeTime) == 0x000470, "Member 'UCharacterStatusWidget::_battleScoreLifeTime' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreLifeTimeText) == 0x000478, "Member 'UCharacterStatusWidget::_battleScoreLifeTimeText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreLevelUp) == 0x000490, "Member 'UCharacterStatusWidget::_battleScoreLevelUp' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreLevelUpText) == 0x000498, "Member 'UCharacterStatusWidget::_battleScoreLevelUpText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreGetItem) == 0x0004B0, "Member 'UCharacterStatusWidget::_battleScoreGetItem' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _battleScoreGetItemText) == 0x0004B8, "Member 'UCharacterStatusWidget::_battleScoreGetItemText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScoreItemSupport) == 0x0004D0, "Member 'UCharacterStatusWidget::_supportScoreItemSupport' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScoreItemSupportText) == 0x0004D8, "Member 'UCharacterStatusWidget::_supportScoreItemSupportText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScoreRescue) == 0x0004F0, "Member 'UCharacterStatusWidget::_supportScoreRescue' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScoreRescueText) == 0x0004F8, "Member 'UCharacterStatusWidget::_supportScoreRescueText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScoreRecovery) == 0x000510, "Member 'UCharacterStatusWidget::_supportScoreRecovery' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScoreRecoveryText) == 0x000518, "Member 'UCharacterStatusWidget::_supportScoreRecoveryText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScorePlusUltra) == 0x000530, "Member 'UCharacterStatusWidget::_supportScorePlusUltra' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _supportScorePlusUltraText) == 0x000538, "Member 'UCharacterStatusWidget::_supportScorePlusUltraText' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, _characterMaterial) == 0x000560, "Member 'UCharacterStatusWidget::_characterMaterial' has a wrong offset!");

// Class InGameModule.CharacterWidget
// 0x0020 (0x0408 - 0x03E8)
class UCharacterWidget final : public UAppWidget
{
public:
	class UCharacterStatusWidget*                 _characterStatus;                                  // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterAbilityWidget*                _characterAbility;                                 // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _returnButton;                                     // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetGeneralWindow*                   _generalWindow;                                    // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnClosedWindow();
	void OnDecideReturnButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnSwitchTabEvent(int32 NewSelectTab);
	void UpdateCharacter(ECharacterId CharacterId, int32 VariationNo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterWidget">();
	}
	static class UCharacterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterWidget>();
	}
};
static_assert(alignof(UCharacterWidget) == 0x000008, "Wrong alignment on UCharacterWidget");
static_assert(sizeof(UCharacterWidget) == 0x000408, "Wrong size on UCharacterWidget");
static_assert(offsetof(UCharacterWidget, _characterStatus) == 0x0003E8, "Member 'UCharacterWidget::_characterStatus' has a wrong offset!");
static_assert(offsetof(UCharacterWidget, _characterAbility) == 0x0003F0, "Member 'UCharacterWidget::_characterAbility' has a wrong offset!");
static_assert(offsetof(UCharacterWidget, _returnButton) == 0x0003F8, "Member 'UCharacterWidget::_returnButton' has a wrong offset!");
static_assert(offsetof(UCharacterWidget, _generalWindow) == 0x000400, "Member 'UCharacterWidget::_generalWindow' has a wrong offset!");

// Class InGameModule.CommandWheelBase
// 0x0040 (0x0390 - 0x0350)
class UCommandWheelBase : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerBattle*                _playerController;                                 // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerStateBattle*                     _playerState;                                      // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHudCommandControlComponent*            _hudCommandControlComponent;                       // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWheelCommonParts*                      _wheel;                                            // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           _cannotUseImage;                                   // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _currentPageNum;                                   // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CalculateMaxPageNum(int32 ElementNum);
	void ClearAllActualIcons();
	void ClearCurrentIndex();
	void CloseWheel();
	void DecideCommand();
	void ForceCloseWheel();
	void GamePadDecide();
	int32 GetSerializedIndexFromWheelIdxAndPageNum(int32 Index_0, int32 Page);
	void OnChangedIndex();
	void OnPageProceeded();
	void OnPageTurnedBack();
	void OnRefreshed();
	void ShowWheel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandWheelBase">();
	}
	static class UCommandWheelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandWheelBase>();
	}
};
static_assert(alignof(UCommandWheelBase) == 0x000008, "Wrong alignment on UCommandWheelBase");
static_assert(sizeof(UCommandWheelBase) == 0x000390, "Wrong size on UCommandWheelBase");
static_assert(offsetof(UCommandWheelBase, _playerController) == 0x000360, "Member 'UCommandWheelBase::_playerController' has a wrong offset!");
static_assert(offsetof(UCommandWheelBase, _playerState) == 0x000368, "Member 'UCommandWheelBase::_playerState' has a wrong offset!");
static_assert(offsetof(UCommandWheelBase, _hudCommandControlComponent) == 0x000370, "Member 'UCommandWheelBase::_hudCommandControlComponent' has a wrong offset!");
static_assert(offsetof(UCommandWheelBase, _wheel) == 0x000378, "Member 'UCommandWheelBase::_wheel' has a wrong offset!");
static_assert(offsetof(UCommandWheelBase, _cannotUseImage) == 0x000380, "Member 'UCommandWheelBase::_cannotUseImage' has a wrong offset!");
static_assert(offsetof(UCommandWheelBase, _currentPageNum) == 0x000388, "Member 'UCommandWheelBase::_currentPageNum' has a wrong offset!");

// Class InGameModule.CommandWheelWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class ICommandWheelWidgetInterface final : public IInterface
{
public:
	void OnDecideWheelCommand();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandWheelWidgetInterface">();
	}
	static class ICommandWheelWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICommandWheelWidgetInterface>();
	}
};
static_assert(alignof(ICommandWheelWidgetInterface) == 0x000008, "Wrong alignment on ICommandWheelWidgetInterface");
static_assert(sizeof(ICommandWheelWidgetInterface) == 0x000028, "Wrong size on ICommandWheelWidgetInterface");

// Class InGameModule.CommunicationPinActor
// 0x0090 (0x02B0 - 0x0220)
class ACommunicationPinActor final : public AActor
{
public:
	class UPinWidgetComponent*                    _pinWidgetComponent;                               // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            _pinWidget;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHerovsGameState*                       _gameState;                                        // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               _pinParticle;                                      // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _dangerEffectColor;                                // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _normalEffectColor;                                // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPinInfo                               _pinInfo;                                          // 0x0270(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConditionObserver*                     _pinReplicationObserver;                           // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitPinInfo(const struct FPinInfo& PinInfo);
	void OnRep_PinInfo();
	void PlaySignalPinCharacterVoice();
	void SetUpPin();
	void Vanish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunicationPinActor">();
	}
	static class ACommunicationPinActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommunicationPinActor>();
	}
};
static_assert(alignof(ACommunicationPinActor) == 0x000008, "Wrong alignment on ACommunicationPinActor");
static_assert(sizeof(ACommunicationPinActor) == 0x0002B0, "Wrong size on ACommunicationPinActor");
static_assert(offsetof(ACommunicationPinActor, _pinWidgetComponent) == 0x000220, "Member 'ACommunicationPinActor::_pinWidgetComponent' has a wrong offset!");
static_assert(offsetof(ACommunicationPinActor, _pinWidget) == 0x000228, "Member 'ACommunicationPinActor::_pinWidget' has a wrong offset!");
static_assert(offsetof(ACommunicationPinActor, _gameState) == 0x000238, "Member 'ACommunicationPinActor::_gameState' has a wrong offset!");
static_assert(offsetof(ACommunicationPinActor, _pinParticle) == 0x000240, "Member 'ACommunicationPinActor::_pinParticle' has a wrong offset!");
static_assert(offsetof(ACommunicationPinActor, _dangerEffectColor) == 0x000248, "Member 'ACommunicationPinActor::_dangerEffectColor' has a wrong offset!");
static_assert(offsetof(ACommunicationPinActor, _normalEffectColor) == 0x000258, "Member 'ACommunicationPinActor::_normalEffectColor' has a wrong offset!");
static_assert(offsetof(ACommunicationPinActor, _pinInfo) == 0x000270, "Member 'ACommunicationPinActor::_pinInfo' has a wrong offset!");
static_assert(offsetof(ACommunicationPinActor, _pinReplicationObserver) == 0x0002A8, "Member 'ACommunicationPinActor::_pinReplicationObserver' has a wrong offset!");

// Class InGameModule.CompressCatchGen
// 0x0030 (0x0480 - 0x0450)
class ACompressCatchGen final : public AProjectileGeneratorBattle
{
public:
	class ABullet*                                _bullet;                                           // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x30];                                     // 0x0450(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompressCatchGen">();
	}
	static class ACompressCatchGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACompressCatchGen>();
	}
};
static_assert(alignof(ACompressCatchGen) == 0x000010, "Wrong alignment on ACompressCatchGen");
static_assert(sizeof(ACompressCatchGen) == 0x000480, "Wrong size on ACompressCatchGen");
static_assert(offsetof(ACompressCatchGen, _bullet) == 0x000448, "Member 'ACompressCatchGen::_bullet' has a wrong offset!");

// Class InGameModule.CreateTeamComponent
// 0x0000 (0x00B0 - 0x00B0)
class UCreateTeamComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateTeamComponent">();
	}
	static class UCreateTeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateTeamComponent>();
	}
};
static_assert(alignof(UCreateTeamComponent) == 0x000008, "Wrong alignment on UCreateTeamComponent");
static_assert(sizeof(UCreateTeamComponent) == 0x0000B0, "Wrong size on UCreateTeamComponent");

// Class InGameModule.CrossHairsWidget
// 0x0058 (0x03A8 - 0x0350)
class UCrossHairsWidget final : public UWidgetBase
{
public:
	class UImage*                                 _crosshair;                                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ECrossHairsColor, struct FSlateColor>    _colors;                                           // 0x0358(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossHairsWidget">();
	}
	static class UCrossHairsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossHairsWidget>();
	}
};
static_assert(alignof(UCrossHairsWidget) == 0x000008, "Wrong alignment on UCrossHairsWidget");
static_assert(sizeof(UCrossHairsWidget) == 0x0003A8, "Wrong size on UCrossHairsWidget");
static_assert(offsetof(UCrossHairsWidget, _crosshair) == 0x000350, "Member 'UCrossHairsWidget::_crosshair' has a wrong offset!");
static_assert(offsetof(UCrossHairsWidget, _colors) == 0x000358, "Member 'UCrossHairsWidget::_colors' has a wrong offset!");

// Class InGameModule.CustomMatchComponent
// 0x0028 (0x00D8 - 0x00B0)
class UCustomMatchComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceQuit_Client();
	void RequestOpenCustomMatchRoom();
	void SendResultData_Client(const struct FCustomMatchResultData& ResultData);

	void NoticeForceQuit_Client() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomMatchComponent">();
	}
	static class UCustomMatchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomMatchComponent>();
	}
};
static_assert(alignof(UCustomMatchComponent) == 0x000008, "Wrong alignment on UCustomMatchComponent");
static_assert(sizeof(UCustomMatchComponent) == 0x0000D8, "Wrong size on UCustomMatchComponent");

// Class InGameModule.WipeWidget
// 0x0000 (0x0350 - 0x0350)
class UWipeWidget final : public UWidgetBase
{
public:
	void BP_EventWipeHiddenDisplayPoint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WipeWidget">();
	}
	static class UWipeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWipeWidget>();
	}
};
static_assert(alignof(UWipeWidget) == 0x000008, "Wrong alignment on UWipeWidget");
static_assert(sizeof(UWipeWidget) == 0x000350, "Wrong size on UWipeWidget");

// Class InGameModule.DamageIndicator
// 0x0158 (0x0320 - 0x01C8)
class UDamageIndicator final : public UWidgetDrawPrimitive
{
public:
	class APlayerControllerBattle*                _playerController;                                 // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDamageIndicatorInfo>           _indicators;                                       // 0x01D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              _indicatorSize;                                    // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _damageIndicator;                                  // 0x01F0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	float                                         _timerRate;                                        // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            _redIndicatorColor;                                // 0x02C8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _blueIndicatorColor;                               // 0x02F0(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageIndicator">();
	}
	static class UDamageIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageIndicator>();
	}
};
static_assert(alignof(UDamageIndicator) == 0x000010, "Wrong alignment on UDamageIndicator");
static_assert(sizeof(UDamageIndicator) == 0x000320, "Wrong size on UDamageIndicator");
static_assert(offsetof(UDamageIndicator, _playerController) == 0x0001C8, "Member 'UDamageIndicator::_playerController' has a wrong offset!");
static_assert(offsetof(UDamageIndicator, _indicators) == 0x0001D0, "Member 'UDamageIndicator::_indicators' has a wrong offset!");
static_assert(offsetof(UDamageIndicator, _indicatorSize) == 0x0001E0, "Member 'UDamageIndicator::_indicatorSize' has a wrong offset!");
static_assert(offsetof(UDamageIndicator, _damageIndicator) == 0x0001F0, "Member 'UDamageIndicator::_damageIndicator' has a wrong offset!");
static_assert(offsetof(UDamageIndicator, _timerRate) == 0x0002C0, "Member 'UDamageIndicator::_timerRate' has a wrong offset!");
static_assert(offsetof(UDamageIndicator, _redIndicatorColor) == 0x0002C8, "Member 'UDamageIndicator::_redIndicatorColor' has a wrong offset!");
static_assert(offsetof(UDamageIndicator, _blueIndicatorColor) == 0x0002F0, "Member 'UDamageIndicator::_blueIndicatorColor' has a wrong offset!");

// Class InGameModule.DebugPlayerStatusText
// 0x00B0 (0x0278 - 0x01C8)
class UDebugPlayerStatusText final : public UWidgetDrawPrimitive
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateFontInfo                         _playerStatusFont;                                 // 0x01D0(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _healthFontColor;                                  // 0x0228(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _guardFontColor;                                   // 0x0250(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugPlayerStatusText">();
	}
	static class UDebugPlayerStatusText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugPlayerStatusText>();
	}
};
static_assert(alignof(UDebugPlayerStatusText) == 0x000008, "Wrong alignment on UDebugPlayerStatusText");
static_assert(sizeof(UDebugPlayerStatusText) == 0x000278, "Wrong size on UDebugPlayerStatusText");
static_assert(offsetof(UDebugPlayerStatusText, _playerState) == 0x0001C8, "Member 'UDebugPlayerStatusText::_playerState' has a wrong offset!");
static_assert(offsetof(UDebugPlayerStatusText, _playerStatusFont) == 0x0001D0, "Member 'UDebugPlayerStatusText::_playerStatusFont' has a wrong offset!");
static_assert(offsetof(UDebugPlayerStatusText, _healthFontColor) == 0x000228, "Member 'UDebugPlayerStatusText::_healthFontColor' has a wrong offset!");
static_assert(offsetof(UDebugPlayerStatusText, _guardFontColor) == 0x000250, "Member 'UDebugPlayerStatusText::_guardFontColor' has a wrong offset!");

// Class InGameModule.DialogueTextBlock
// 0x00C0 (0x0410 - 0x0350)
class UDialogueTextBlock final : public UWidgetBase
{
public:
	class URichTextBlock*                         _name;                                             // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         _message;                                          // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _face;                                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _faceMaster;                                       // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _faceMaterial;                                     // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _allyMessageFaceEdgeColor;                         // 0x0378(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _myMessageFaceEdgeColor;                           // 0x0388(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _messageLifeTime;                                  // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         _defaultFont;                                      // 0x03A0(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x18];                                     // 0x03F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueTextBlock">();
	}
	static class UDialogueTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueTextBlock>();
	}
};
static_assert(alignof(UDialogueTextBlock) == 0x000008, "Wrong alignment on UDialogueTextBlock");
static_assert(sizeof(UDialogueTextBlock) == 0x000410, "Wrong size on UDialogueTextBlock");
static_assert(offsetof(UDialogueTextBlock, _name) == 0x000350, "Member 'UDialogueTextBlock::_name' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _message) == 0x000358, "Member 'UDialogueTextBlock::_message' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _face) == 0x000360, "Member 'UDialogueTextBlock::_face' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _faceMaster) == 0x000368, "Member 'UDialogueTextBlock::_faceMaster' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _faceMaterial) == 0x000370, "Member 'UDialogueTextBlock::_faceMaterial' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _allyMessageFaceEdgeColor) == 0x000378, "Member 'UDialogueTextBlock::_allyMessageFaceEdgeColor' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _myMessageFaceEdgeColor) == 0x000388, "Member 'UDialogueTextBlock::_myMessageFaceEdgeColor' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _messageLifeTime) == 0x000398, "Member 'UDialogueTextBlock::_messageLifeTime' has a wrong offset!");
static_assert(offsetof(UDialogueTextBlock, _defaultFont) == 0x0003A0, "Member 'UDialogueTextBlock::_defaultFont' has a wrong offset!");

// Class InGameModule.DogTag
// 0x0008 (0x0390 - 0x0388)
class ADogTag final : public AItemBase
{
public:
	ECharacterId                                  _characterId;                                      // 0x0388(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DogTag">();
	}
	static class ADogTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADogTag>();
	}
};
static_assert(alignof(ADogTag) == 0x000008, "Wrong alignment on ADogTag");
static_assert(sizeof(ADogTag) == 0x000390, "Wrong size on ADogTag");
static_assert(offsetof(ADogTag, _characterId) == 0x000388, "Member 'ADogTag::_characterId' has a wrong offset!");

// Class InGameModule.DuplicateControlComponent
// 0x0170 (0x0220 - 0x00B0)
class UDuplicateControlComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDuplicationData                       _duplicationDataStock;                             // 0x00D0(0x0130)(Net, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         _duplicateMaxNum;                                  // 0x0200(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStateBattle*>             _duplicatePlayerStateList;                         // 0x0208(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_DuplicateIntoForImitation(class ACharacterBattle* TargetCharacter, const struct FVector& Location, EAttackId AttackId, float LifeTime);
	void DuplicateInto_RPC_ToServer(const class ACharacterBattle* TargetCharacter, const struct FVector& SpawnLocation);
	void DuplicateIntoForImitation_RPC_ToServer(const class ACharacterBattle* TargetCharacter, const struct FVector& SpawnLocation, EAttackId AttackId, float LifeTime);
	void DuplicateIntoStockCharacter_RPC_ToServer(const struct FVector& SpawnLocation);
	void OnDeadCharacter(const class ACharacterBattle* Victim, const class ACharacterBattle* Aggriever);
	void OnRep_DuplicationData();
	void RemoveDuplicationDataData_RPC_ToServer();
	void StockDuplicationData_RPC_ToServer(const class ACharacterBattle* TargetCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DuplicateControlComponent">();
	}
	static class UDuplicateControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDuplicateControlComponent>();
	}
};
static_assert(alignof(UDuplicateControlComponent) == 0x000010, "Wrong alignment on UDuplicateControlComponent");
static_assert(sizeof(UDuplicateControlComponent) == 0x000220, "Wrong size on UDuplicateControlComponent");
static_assert(offsetof(UDuplicateControlComponent, _duplicationDataStock) == 0x0000D0, "Member 'UDuplicateControlComponent::_duplicationDataStock' has a wrong offset!");
static_assert(offsetof(UDuplicateControlComponent, _duplicateMaxNum) == 0x000200, "Member 'UDuplicateControlComponent::_duplicateMaxNum' has a wrong offset!");
static_assert(offsetof(UDuplicateControlComponent, _duplicatePlayerStateList) == 0x000208, "Member 'UDuplicateControlComponent::_duplicatePlayerStateList' has a wrong offset!");

// Class InGameModule.EmoteWheel
// 0x0088 (0x0418 - 0x0390)
class UEmoteWheel final : public UCommandWheelBase
{
public:
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimaryAssetItemIcon*                  _primaryAssetIcon;                                 // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPaperSprite*>                   _emoteIcons;                                       // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x68];                                     // 0x03B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateButtonGuide();
	void UpdateEmoteList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteWheel">();
	}
	static class UEmoteWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteWheel>();
	}
};
static_assert(alignof(UEmoteWheel) == 0x000008, "Wrong alignment on UEmoteWheel");
static_assert(sizeof(UEmoteWheel) == 0x000418, "Wrong size on UEmoteWheel");
static_assert(offsetof(UEmoteWheel, _playerDatabaseWork) == 0x000390, "Member 'UEmoteWheel::_playerDatabaseWork' has a wrong offset!");
static_assert(offsetof(UEmoteWheel, _primaryAssetIcon) == 0x000398, "Member 'UEmoteWheel::_primaryAssetIcon' has a wrong offset!");
static_assert(offsetof(UEmoteWheel, _emoteIcons) == 0x0003A0, "Member 'UEmoteWheel::_emoteIcons' has a wrong offset!");

// Class InGameModule.FieldInteractPopUpWidget
// 0x00D8 (0x0390 - 0x02B8)
class UFieldInteractPopUpWidget final : public UWidgetAttachToActor
{
public:
	class UHUDDispatchComponent*                  _hudDispatchComponent;                             // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _switcher;                                         // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _baseGrid;                                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _supplyIcon;                                       // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _description;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      _gridMaterialMaster;                               // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _gridMaterial;                                     // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _abilityPopUpImage;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _abilityPopUpMID;                                  // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _whichQuirk;                                       // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _abilityDesc;                                      // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _abilityTypeIcon;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityLevelCounter*                   _levelCounter;                                     // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                _nameBG;                                           // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               _buttonGuideOverlay;                               // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _name;                                             // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _buttonGuideText;                                  // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _supplyNameCanvasPanel;                            // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _buttonGuideMask;                                  // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _supplyNameMask;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _normalSupplyMask;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _abilitySupplyMask;                                // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _fullInventoryTextNormalSupply;                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _fullInventoryTextAbilitySupply;                   // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _allyInteractText;                                 // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _blockUserText;                                    // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldInteractPopUpWidget">();
	}
	static class UFieldInteractPopUpWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldInteractPopUpWidget>();
	}
};
static_assert(alignof(UFieldInteractPopUpWidget) == 0x000008, "Wrong alignment on UFieldInteractPopUpWidget");
static_assert(sizeof(UFieldInteractPopUpWidget) == 0x000390, "Wrong size on UFieldInteractPopUpWidget");
static_assert(offsetof(UFieldInteractPopUpWidget, _hudDispatchComponent) == 0x0002B8, "Member 'UFieldInteractPopUpWidget::_hudDispatchComponent' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _hudResource) == 0x0002C0, "Member 'UFieldInteractPopUpWidget::_hudResource' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _switcher) == 0x0002C8, "Member 'UFieldInteractPopUpWidget::_switcher' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _baseGrid) == 0x0002D0, "Member 'UFieldInteractPopUpWidget::_baseGrid' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _supplyIcon) == 0x0002D8, "Member 'UFieldInteractPopUpWidget::_supplyIcon' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _description) == 0x0002E0, "Member 'UFieldInteractPopUpWidget::_description' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _gridMaterialMaster) == 0x0002E8, "Member 'UFieldInteractPopUpWidget::_gridMaterialMaster' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _gridMaterial) == 0x0002F0, "Member 'UFieldInteractPopUpWidget::_gridMaterial' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _abilityPopUpImage) == 0x0002F8, "Member 'UFieldInteractPopUpWidget::_abilityPopUpImage' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _abilityPopUpMID) == 0x000300, "Member 'UFieldInteractPopUpWidget::_abilityPopUpMID' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _whichQuirk) == 0x000308, "Member 'UFieldInteractPopUpWidget::_whichQuirk' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _abilityDesc) == 0x000310, "Member 'UFieldInteractPopUpWidget::_abilityDesc' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _abilityTypeIcon) == 0x000318, "Member 'UFieldInteractPopUpWidget::_abilityTypeIcon' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _levelCounter) == 0x000320, "Member 'UFieldInteractPopUpWidget::_levelCounter' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _nameBG) == 0x000328, "Member 'UFieldInteractPopUpWidget::_nameBG' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _buttonGuideOverlay) == 0x000330, "Member 'UFieldInteractPopUpWidget::_buttonGuideOverlay' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _name) == 0x000338, "Member 'UFieldInteractPopUpWidget::_name' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _buttonGuideText) == 0x000340, "Member 'UFieldInteractPopUpWidget::_buttonGuideText' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _supplyNameCanvasPanel) == 0x000348, "Member 'UFieldInteractPopUpWidget::_supplyNameCanvasPanel' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _buttonGuideMask) == 0x000350, "Member 'UFieldInteractPopUpWidget::_buttonGuideMask' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _supplyNameMask) == 0x000358, "Member 'UFieldInteractPopUpWidget::_supplyNameMask' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _normalSupplyMask) == 0x000360, "Member 'UFieldInteractPopUpWidget::_normalSupplyMask' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _abilitySupplyMask) == 0x000368, "Member 'UFieldInteractPopUpWidget::_abilitySupplyMask' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _fullInventoryTextNormalSupply) == 0x000370, "Member 'UFieldInteractPopUpWidget::_fullInventoryTextNormalSupply' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _fullInventoryTextAbilitySupply) == 0x000378, "Member 'UFieldInteractPopUpWidget::_fullInventoryTextAbilitySupply' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _allyInteractText) == 0x000380, "Member 'UFieldInteractPopUpWidget::_allyInteractText' has a wrong offset!");
static_assert(offsetof(UFieldInteractPopUpWidget, _blockUserText) == 0x000388, "Member 'UFieldInteractPopUpWidget::_blockUserText' has a wrong offset!");

// Class InGameModule.FogGrabGen
// 0x0070 (0x04C0 - 0x0450)
class AFogGrabGen final : public AProjectileGeneratorBattle
{
public:
	class UCharacterCommandComponent*             _characterCommandComponent;                        // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x58];                                     // 0x0450(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AFogGrab*                               _fogGrabShot;                                      // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FogGrabGen">();
	}
	static class AFogGrabGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFogGrabGen>();
	}
};
static_assert(alignof(AFogGrabGen) == 0x000010, "Wrong alignment on AFogGrabGen");
static_assert(sizeof(AFogGrabGen) == 0x0004C0, "Wrong size on AFogGrabGen");
static_assert(offsetof(AFogGrabGen, _characterCommandComponent) == 0x000448, "Member 'AFogGrabGen::_characterCommandComponent' has a wrong offset!");
static_assert(offsetof(AFogGrabGen, _fogGrabShot) == 0x0004A8, "Member 'AFogGrabGen::_fogGrabShot' has a wrong offset!");

// Class InGameModule.FogShot_Before
// 0x0000 (0x1DE0 - 0x1DE0)
class AFogShot_Before final : public ABullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FogShot_Before">();
	}
	static class AFogShot_Before* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFogShot_Before>();
	}
};
static_assert(alignof(AFogShot_Before) == 0x000010, "Wrong alignment on AFogShot_Before");
static_assert(sizeof(AFogShot_Before) == 0x001DE0, "Wrong size on AFogShot_Before");

// Class InGameModule.FreeAnimationWidget
// 0x0128 (0x02F0 - 0x01C8)
class UFreeAnimationWidget final : public UWidgetDrawPrimitive
{
public:
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _animationBrush;                                   // 0x01D0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	class APlayerControllerBattle*                _playerController;                                 // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x24];                                     // 0x02B0(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _speed;                                            // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x4];                                      // 0x02D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _bezierControlPoint1Offset;                        // 0x02DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _bezierControlPoint2Offset;                        // 0x02E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _easeExp;                                          // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeAnimationWidget">();
	}
	static class UFreeAnimationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFreeAnimationWidget>();
	}
};
static_assert(alignof(UFreeAnimationWidget) == 0x000010, "Wrong alignment on UFreeAnimationWidget");
static_assert(sizeof(UFreeAnimationWidget) == 0x0002F0, "Wrong size on UFreeAnimationWidget");
static_assert(offsetof(UFreeAnimationWidget, _animationBrush) == 0x0001D0, "Member 'UFreeAnimationWidget::_animationBrush' has a wrong offset!");
static_assert(offsetof(UFreeAnimationWidget, _playerController) == 0x0002A0, "Member 'UFreeAnimationWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UFreeAnimationWidget, _localPlayerHudManager) == 0x0002A8, "Member 'UFreeAnimationWidget::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UFreeAnimationWidget, _speed) == 0x0002D4, "Member 'UFreeAnimationWidget::_speed' has a wrong offset!");
static_assert(offsetof(UFreeAnimationWidget, _bezierControlPoint1Offset) == 0x0002DC, "Member 'UFreeAnimationWidget::_bezierControlPoint1Offset' has a wrong offset!");
static_assert(offsetof(UFreeAnimationWidget, _bezierControlPoint2Offset) == 0x0002E4, "Member 'UFreeAnimationWidget::_bezierControlPoint2Offset' has a wrong offset!");
static_assert(offsetof(UFreeAnimationWidget, _easeExp) == 0x0002EC, "Member 'UFreeAnimationWidget::_easeExp' has a wrong offset!");

// Class InGameModule.GameModeLobby
// 0x01E8 (0x0538 - 0x0350)
class AGameModeLobby final : public AGameModeInGame
{
public:
	class UHerovsGameInstance*                    _gameInstance;                                     // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x48];                                     // 0x0358(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UStageBarrierManagerComponent*          _stageBarrierManagerComponent;                     // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyManagerVisualLobbyComponent*     _supplyManagerComponent;                           // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x30];                                     // 0x03B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _toBattleCountdownDilation;                        // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x54];                                     // 0x03E4(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bEnableSystemVoice;                               // 0x0438(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECharacterId>                          _newCharacterBeforSeason;                          // 0x0440(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<ECharacterId>                          _newCharacterAfterSeason;                          // 0x0450(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         _newCharacterVoiceMax;                             // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _fixedTimeInterval;                                // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _systemVoiceInterval;                              // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _rareCostumeVoiceMax;                              // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _rampageVoiceMax;                                  // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0xC4];                                     // 0x0474(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CountRampage(const EAttackId ID);
	void DelaySpawnAICharacterBattle(const struct FBotInfoToSpawn& botSpawnInfo);
	void FillWithBots();
	void GameStart();
	void OnCompleteConsumeRentalPoint(int32 RequestId);
	void OnCompleteStartBattle(int32 RequestId);
	void OnIdleTimeOver();
	void OnTimeOver_StartCountdownToBattle();
	void RequestConsumeRentalPoint();
	void StartBattle(const bool bForceStart);
	void UpdateCountdownToBattle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeLobby">();
	}
	static class AGameModeLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeLobby>();
	}
};
static_assert(alignof(AGameModeLobby) == 0x000008, "Wrong alignment on AGameModeLobby");
static_assert(sizeof(AGameModeLobby) == 0x000538, "Wrong size on AGameModeLobby");
static_assert(offsetof(AGameModeLobby, _gameInstance) == 0x000350, "Member 'AGameModeLobby::_gameInstance' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _stageBarrierManagerComponent) == 0x0003A0, "Member 'AGameModeLobby::_stageBarrierManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _supplyManagerComponent) == 0x0003A8, "Member 'AGameModeLobby::_supplyManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _toBattleCountdownDilation) == 0x0003E0, "Member 'AGameModeLobby::_toBattleCountdownDilation' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _bEnableSystemVoice) == 0x000438, "Member 'AGameModeLobby::_bEnableSystemVoice' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _newCharacterBeforSeason) == 0x000440, "Member 'AGameModeLobby::_newCharacterBeforSeason' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _newCharacterAfterSeason) == 0x000450, "Member 'AGameModeLobby::_newCharacterAfterSeason' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _newCharacterVoiceMax) == 0x000460, "Member 'AGameModeLobby::_newCharacterVoiceMax' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _fixedTimeInterval) == 0x000464, "Member 'AGameModeLobby::_fixedTimeInterval' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _systemVoiceInterval) == 0x000468, "Member 'AGameModeLobby::_systemVoiceInterval' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _rareCostumeVoiceMax) == 0x00046C, "Member 'AGameModeLobby::_rareCostumeVoiceMax' has a wrong offset!");
static_assert(offsetof(AGameModeLobby, _rampageVoiceMax) == 0x000470, "Member 'AGameModeLobby::_rampageVoiceMax' has a wrong offset!");

// Class InGameModule.GameModeSquadBattle
// 0x0000 (0x04D8 - 0x04D8)
class AGameModeSquadBattle final : public AGameModeBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeSquadBattle">();
	}
	static class AGameModeSquadBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeSquadBattle>();
	}
};
static_assert(alignof(AGameModeSquadBattle) == 0x000008, "Wrong alignment on AGameModeSquadBattle");
static_assert(sizeof(AGameModeSquadBattle) == 0x0004D8, "Wrong size on AGameModeSquadBattle");

// Class InGameModule.GameModeTakeCharacterImage
// 0x0020 (0x0370 - 0x0350)
class AGameModeTakeCharacterImage final : public AGameModeInGame
{
public:
	class UPrimaryAssetCharacter*                 _primaryAsset;                                     // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimaryAssetTakeCharacterImage*        _primaryCharacterImage;                            // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _charaData;                                        // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_PlayFaceAnimation(int32 Index_0);
	void DisableCallSign(bool bDisable);
	void DisableEffect(bool bDisable);
	TArray<class UTexture*> GetTexture(int32 TextureType);
	void OnCostumeColorWhite();
	void PlayCustomAnimation(ETakeCharacterImageTypeCustom Type);
	void PlayEmote(int32 Index_0);
	void PlayGasha();
	void PlayPause();
	void PlayPlusUltra();
	void PlayUniqueActionUnique(int32 Index_0);
	void SetCostumeColorWhite();
	class ACharacterBattle* SpawnCharacter(int32 PlayerId, int32 CostumeId, int32 CostumeColor, ECharacterId CharaID, const struct FTransform& Transform, int32 Variation);
	void StopCloth();
	void UpdateResource(class UTexture* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeTakeCharacterImage">();
	}
	static class AGameModeTakeCharacterImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeTakeCharacterImage>();
	}
};
static_assert(alignof(AGameModeTakeCharacterImage) == 0x000008, "Wrong alignment on AGameModeTakeCharacterImage");
static_assert(sizeof(AGameModeTakeCharacterImage) == 0x000370, "Wrong size on AGameModeTakeCharacterImage");
static_assert(offsetof(AGameModeTakeCharacterImage, _primaryAsset) == 0x000350, "Member 'AGameModeTakeCharacterImage::_primaryAsset' has a wrong offset!");
static_assert(offsetof(AGameModeTakeCharacterImage, _primaryCharacterImage) == 0x000358, "Member 'AGameModeTakeCharacterImage::_primaryCharacterImage' has a wrong offset!");
static_assert(offsetof(AGameModeTakeCharacterImage, _charaData) == 0x000360, "Member 'AGameModeTakeCharacterImage::_charaData' has a wrong offset!");

// Class InGameModule.GameModeTutorial
// 0x0008 (0x04E0 - 0x04D8)
class AGameModeTutorial final : public AGameModeBattle
{
public:
	bool                                          _isSequenceFinish;                                 // 0x04D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPTutorialBattleChecker2();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeTutorial">();
	}
	static class AGameModeTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeTutorial>();
	}
};
static_assert(alignof(AGameModeTutorial) == 0x000008, "Wrong alignment on AGameModeTutorial");
static_assert(sizeof(AGameModeTutorial) == 0x0004E0, "Wrong size on AGameModeTutorial");
static_assert(offsetof(AGameModeTutorial, _isSequenceFinish) == 0x0004D8, "Member 'AGameModeTutorial::_isSequenceFinish' has a wrong offset!");

// Class InGameModule.GameSessionBattle
// 0x0000 (0x0238 - 0x0238)
class AGameSessionBattle final : public AHerovsGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSessionBattle">();
	}
	static class AGameSessionBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameSessionBattle>();
	}
};
static_assert(alignof(AGameSessionBattle) == 0x000008, "Wrong alignment on AGameSessionBattle");
static_assert(sizeof(AGameSessionBattle) == 0x000238, "Wrong size on AGameSessionBattle");

// Class InGameModule.GameStateBattle_CanOnlyMove
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_CanOnlyMove final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_CanOnlyMove">();
	}
	static class UGameStateBattle_CanOnlyMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_CanOnlyMove>();
	}
};
static_assert(alignof(UGameStateBattle_CanOnlyMove) == 0x000008, "Wrong alignment on UGameStateBattle_CanOnlyMove");
static_assert(sizeof(UGameStateBattle_CanOnlyMove) == 0x000038, "Wrong size on UGameStateBattle_CanOnlyMove");

// Class InGameModule.GameStateBattle_DisplayAllPlayerStartPoint
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_DisplayAllPlayerStartPoint final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_DisplayAllPlayerStartPoint">();
	}
	static class UGameStateBattle_DisplayAllPlayerStartPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_DisplayAllPlayerStartPoint>();
	}
};
static_assert(alignof(UGameStateBattle_DisplayAllPlayerStartPoint) == 0x000008, "Wrong alignment on UGameStateBattle_DisplayAllPlayerStartPoint");
static_assert(sizeof(UGameStateBattle_DisplayAllPlayerStartPoint) == 0x000038, "Wrong size on UGameStateBattle_DisplayAllPlayerStartPoint");

// Class InGameModule.GameStateBattle_ExitingFromBattle
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_ExitingFromBattle final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_ExitingFromBattle">();
	}
	static class UGameStateBattle_ExitingFromBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_ExitingFromBattle>();
	}
};
static_assert(alignof(UGameStateBattle_ExitingFromBattle) == 0x000008, "Wrong alignment on UGameStateBattle_ExitingFromBattle");
static_assert(sizeof(UGameStateBattle_ExitingFromBattle) == 0x000038, "Wrong size on UGameStateBattle_ExitingFromBattle");

// Class InGameModule.GameStateBattle_Init
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_Init final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_Init">();
	}
	static class UGameStateBattle_Init* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_Init>();
	}
};
static_assert(alignof(UGameStateBattle_Init) == 0x000008, "Wrong alignment on UGameStateBattle_Init");
static_assert(sizeof(UGameStateBattle_Init) == 0x000038, "Wrong size on UGameStateBattle_Init");

// Class InGameModule.GameStateBattle_OnCongratulateWinner
// 0x0008 (0x0040 - 0x0038)
class UGameStateBattle_OnCongratulateWinner final : public UGameStateBattleFiniteStateBase
{
public:
	TSubclassOf<class UActorComponent>            _winnerOverheadWidgetComponent;                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_OnCongratulateWinner">();
	}
	static class UGameStateBattle_OnCongratulateWinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_OnCongratulateWinner>();
	}
};
static_assert(alignof(UGameStateBattle_OnCongratulateWinner) == 0x000008, "Wrong alignment on UGameStateBattle_OnCongratulateWinner");
static_assert(sizeof(UGameStateBattle_OnCongratulateWinner) == 0x000040, "Wrong size on UGameStateBattle_OnCongratulateWinner");
static_assert(offsetof(UGameStateBattle_OnCongratulateWinner, _winnerOverheadWidgetComponent) == 0x000038, "Member 'UGameStateBattle_OnCongratulateWinner::_winnerOverheadWidgetComponent' has a wrong offset!");

// Class InGameModule.GameStateBattle_WaitBriefingOpen
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_WaitBriefingOpen final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_WaitBriefingOpen">();
	}
	static class UGameStateBattle_WaitBriefingOpen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_WaitBriefingOpen>();
	}
};
static_assert(alignof(UGameStateBattle_WaitBriefingOpen) == 0x000008, "Wrong alignment on UGameStateBattle_WaitBriefingOpen");
static_assert(sizeof(UGameStateBattle_WaitBriefingOpen) == 0x000038, "Wrong size on UGameStateBattle_WaitBriefingOpen");

// Class InGameModule.GameStateBattle_ZoomCameraScene
// 0x0000 (0x0038 - 0x0038)
class UGameStateBattle_ZoomCameraScene final : public UGameStateBattleFiniteStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBattle_ZoomCameraScene">();
	}
	static class UGameStateBattle_ZoomCameraScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateBattle_ZoomCameraScene>();
	}
};
static_assert(alignof(UGameStateBattle_ZoomCameraScene) == 0x000008, "Wrong alignment on UGameStateBattle_ZoomCameraScene");
static_assert(sizeof(UGameStateBattle_ZoomCameraScene) == 0x000038, "Wrong size on UGameStateBattle_ZoomCameraScene");

// Class InGameModule.GameStateLobby
// 0x0080 (0x03D0 - 0x0350)
class AGameStateLobby final : public AHerovsGameState
{
public:
	class UGameTeamInfoComponent*                 _gameTeamInfoComponent;                            // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ELobbySequence                                _lobbySequence;                                    // 0x0370(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotManager*                            _botManagerComponent;                              // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFiniteStateMachine*                    _fsm;                                              // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bMatchingCompleted;                               // 0x0388(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bReadyToBattle;                                   // 0x0389(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38A[0xE];                                      // 0x038A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _timeToStartBattle;                                // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39C[0x14];                                     // 0x039C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _showCountdownToBattle;                            // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CountDownEvent__DelegateSignature(int32 Count);
	void DisplayMatchingInfo(int32 PlayerNum, float Time, bool bBot);
	void GameSequenceEvent__DelegateSignature();
	void MulticastLoadSupplyAbility(const TArray<struct FCharacterAbilityInfo>& CharacterIdList);
	void OnAddedPlayerLobby();
	void OnRemovedPlayerLobby();
	void OnRep_CountDown();
	void OnRep_LobbySequence();
	void OnRep_MatchingCompleted();
	void OnRep_ReadyToBattle();
	void PreGameStart();
	void ReadyToBattle();

	ELobbySequence GetLobbySequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateLobby">();
	}
	static class AGameStateLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateLobby>();
	}
};
static_assert(alignof(AGameStateLobby) == 0x000008, "Wrong alignment on AGameStateLobby");
static_assert(sizeof(AGameStateLobby) == 0x0003D0, "Wrong size on AGameStateLobby");
static_assert(offsetof(AGameStateLobby, _gameTeamInfoComponent) == 0x000350, "Member 'AGameStateLobby::_gameTeamInfoComponent' has a wrong offset!");
static_assert(offsetof(AGameStateLobby, _lobbySequence) == 0x000370, "Member 'AGameStateLobby::_lobbySequence' has a wrong offset!");
static_assert(offsetof(AGameStateLobby, _botManagerComponent) == 0x000378, "Member 'AGameStateLobby::_botManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameStateLobby, _fsm) == 0x000380, "Member 'AGameStateLobby::_fsm' has a wrong offset!");
static_assert(offsetof(AGameStateLobby, _bMatchingCompleted) == 0x000388, "Member 'AGameStateLobby::_bMatchingCompleted' has a wrong offset!");
static_assert(offsetof(AGameStateLobby, _bReadyToBattle) == 0x000389, "Member 'AGameStateLobby::_bReadyToBattle' has a wrong offset!");
static_assert(offsetof(AGameStateLobby, _timeToStartBattle) == 0x000398, "Member 'AGameStateLobby::_timeToStartBattle' has a wrong offset!");
static_assert(offsetof(AGameStateLobby, _showCountdownToBattle) == 0x0003B0, "Member 'AGameStateLobby::_showCountdownToBattle' has a wrong offset!");

// Class InGameModule.GameStateLobby_Recruiting
// 0x0000 (0x0030 - 0x0030)
class UGameStateLobby_Recruiting final : public UFiniteState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateLobby_Recruiting">();
	}
	static class UGameStateLobby_Recruiting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateLobby_Recruiting>();
	}
};
static_assert(alignof(UGameStateLobby_Recruiting) == 0x000008, "Wrong alignment on UGameStateLobby_Recruiting");
static_assert(sizeof(UGameStateLobby_Recruiting) == 0x000030, "Wrong size on UGameStateLobby_Recruiting");

// Class InGameModule.GameStateSoloBattle
// 0x0000 (0x0610 - 0x0610)
class AGameStateSoloBattle final : public AGameStateBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateSoloBattle">();
	}
	static class AGameStateSoloBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateSoloBattle>();
	}
};
static_assert(alignof(AGameStateSoloBattle) == 0x000008, "Wrong alignment on AGameStateSoloBattle");
static_assert(sizeof(AGameStateSoloBattle) == 0x000610, "Wrong size on AGameStateSoloBattle");

// Class InGameModule.GameStateTakeCharacterImage
// 0x0000 (0x0610 - 0x0610)
class AGameStateTakeCharacterImage final : public AGameStateBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateTakeCharacterImage">();
	}
	static class AGameStateTakeCharacterImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateTakeCharacterImage>();
	}
};
static_assert(alignof(AGameStateTakeCharacterImage) == 0x000008, "Wrong alignment on AGameStateTakeCharacterImage");
static_assert(sizeof(AGameStateTakeCharacterImage) == 0x000610, "Wrong size on AGameStateTakeCharacterImage");

// Class InGameModule.GameStateTutorial
// 0x0008 (0x0618 - 0x0610)
class AGameStateTutorial final : public AGameStateBattle
{
public:
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateTutorial">();
	}
	static class AGameStateTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateTutorial>();
	}
};
static_assert(alignof(AGameStateTutorial) == 0x000008, "Wrong alignment on AGameStateTutorial");
static_assert(sizeof(AGameStateTutorial) == 0x000618, "Wrong size on AGameStateTutorial");

// Class InGameModule.GenericCounter
// 0x0180 (0x04D0 - 0x0350)
class UGenericCounter final : public UWidgetBase
{
public:
	bool                                          _bShowImage;                                       // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _digitScale;                                       // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            _digitTintColor;                                   // 0x0358(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _captionTintColor;                                 // 0x0380(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FText                                   _caption;                                          // 0x03A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _imageBrush;                                       // 0x03C0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	float                                         _captionVerticalOffset;                            // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         _digitBox;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _digit10;                                          // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _digit01;                                          // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpacer*                                _digitSpacer;                                      // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _captionTextBlock;                                 // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _image;                                            // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCaptionColor(const struct FSlateColor& InColor);
	void SetCounterColor(const struct FSlateColor& InColor);
	void SetCounterNum(int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericCounter">();
	}
	static class UGenericCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericCounter>();
	}
};
static_assert(alignof(UGenericCounter) == 0x000010, "Wrong alignment on UGenericCounter");
static_assert(sizeof(UGenericCounter) == 0x0004D0, "Wrong size on UGenericCounter");
static_assert(offsetof(UGenericCounter, _bShowImage) == 0x000350, "Member 'UGenericCounter::_bShowImage' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _digitScale) == 0x000354, "Member 'UGenericCounter::_digitScale' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _digitTintColor) == 0x000358, "Member 'UGenericCounter::_digitTintColor' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _captionTintColor) == 0x000380, "Member 'UGenericCounter::_captionTintColor' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _caption) == 0x0003A8, "Member 'UGenericCounter::_caption' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _imageBrush) == 0x0003C0, "Member 'UGenericCounter::_imageBrush' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _captionVerticalOffset) == 0x000490, "Member 'UGenericCounter::_captionVerticalOffset' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _digitBox) == 0x000498, "Member 'UGenericCounter::_digitBox' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _digit10) == 0x0004A0, "Member 'UGenericCounter::_digit10' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _digit01) == 0x0004A8, "Member 'UGenericCounter::_digit01' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _digitSpacer) == 0x0004B0, "Member 'UGenericCounter::_digitSpacer' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _captionTextBlock) == 0x0004B8, "Member 'UGenericCounter::_captionTextBlock' has a wrong offset!");
static_assert(offsetof(UGenericCounter, _image) == 0x0004C0, "Member 'UGenericCounter::_image' has a wrong offset!");

// Class InGameModule.GimmickDataAsset
// 0x0028 (0x0090 - 0x0068)
class UGimmickDataAsset final : public UGimmickBaseDataAsset
{
public:
	TSoftClassPtr<class UClass>                   _spawnBlueprint;                                   // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickDataAsset">();
	}
	static class UGimmickDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGimmickDataAsset>();
	}
};
static_assert(alignof(UGimmickDataAsset) == 0x000008, "Wrong alignment on UGimmickDataAsset");
static_assert(sizeof(UGimmickDataAsset) == 0x000090, "Wrong size on UGimmickDataAsset");
static_assert(offsetof(UGimmickDataAsset, _spawnBlueprint) == 0x000068, "Member 'UGimmickDataAsset::_spawnBlueprint' has a wrong offset!");

// Class InGameModule.GimmickManagerComponentBase
// 0x0000 (0x00B0 - 0x00B0)
class UGimmickManagerComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickManagerComponentBase">();
	}
	static class UGimmickManagerComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGimmickManagerComponentBase>();
	}
};
static_assert(alignof(UGimmickManagerComponentBase) == 0x000008, "Wrong alignment on UGimmickManagerComponentBase");
static_assert(sizeof(UGimmickManagerComponentBase) == 0x0000B0, "Wrong size on UGimmickManagerComponentBase");

// Class InGameModule.GimmickManagerComponent
// 0x00B8 (0x0168 - 0x00B0)
class UGimmickManagerComponent final : public UGimmickManagerComponentBase
{
public:
	class UDataTable*                             _gimmickSpawnPointDataTable;                       // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGimmickSpawnMaxInfo>           _gimmickSpawnMaxInfo;                              // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0xA0];                                      // 0x00C8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickManagerComponent">();
	}
	static class UGimmickManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGimmickManagerComponent>();
	}
};
static_assert(alignof(UGimmickManagerComponent) == 0x000008, "Wrong alignment on UGimmickManagerComponent");
static_assert(sizeof(UGimmickManagerComponent) == 0x000168, "Wrong size on UGimmickManagerComponent");
static_assert(offsetof(UGimmickManagerComponent, _gimmickSpawnPointDataTable) == 0x0000B0, "Member 'UGimmickManagerComponent::_gimmickSpawnPointDataTable' has a wrong offset!");
static_assert(offsetof(UGimmickManagerComponent, _gimmickSpawnMaxInfo) == 0x0000B8, "Member 'UGimmickManagerComponent::_gimmickSpawnMaxInfo' has a wrong offset!");

// Class InGameModule.GotoResultAppWidget
// 0x0008 (0x03F0 - 0x03E8)
class UGotoResultAppWidget final : public UAppWidget
{
public:
	class UWidgetGeneralWindow*                   _popupWindow;                                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnCloseLevelEvent();
	void OnPopupButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType, bool LeftButton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GotoResultAppWidget">();
	}
	static class UGotoResultAppWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGotoResultAppWidget>();
	}
};
static_assert(alignof(UGotoResultAppWidget) == 0x000008, "Wrong alignment on UGotoResultAppWidget");
static_assert(sizeof(UGotoResultAppWidget) == 0x0003F0, "Wrong size on UGotoResultAppWidget");
static_assert(offsetof(UGotoResultAppWidget, _popupWindow) == 0x0003E8, "Member 'UGotoResultAppWidget::_popupWindow' has a wrong offset!");

// Class InGameModule.GraduallyAlphaControl
// 0x0000 (0x0028 - 0x0028)
class UGraduallyAlphaControl final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraduallyAlphaControl">();
	}
	static class UGraduallyAlphaControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraduallyAlphaControl>();
	}
};
static_assert(alignof(UGraduallyAlphaControl) == 0x000008, "Wrong alignment on UGraduallyAlphaControl");
static_assert(sizeof(UGraduallyAlphaControl) == 0x000028, "Wrong size on UGraduallyAlphaControl");

// Class InGameModule.GroundElementAccessor
// 0x0000 (0x0028 - 0x0028)
class UGroundElementAccessor final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundElementAccessor">();
	}
	static class UGroundElementAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundElementAccessor>();
	}
};
static_assert(alignof(UGroundElementAccessor) == 0x000008, "Wrong alignment on UGroundElementAccessor");
static_assert(sizeof(UGroundElementAccessor) == 0x000028, "Wrong size on UGroundElementAccessor");

// Class InGameModule.GroundPositionEffectComponent
// 0x00D0 (0x02D0 - 0x0200)
class UGroundPositionEffectComponent final : public UHeroBaseComponent
{
public:
	bool                                          _bWallHitCreate;                                   // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bBeginPlayCreate;                                 // 0x01F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHitBackGroundCreate;                             // 0x01FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _buseBackGroundNormal;                             // 0x01FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHitCharacterCreate;                              // 0x01FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _wallDegThreshold;                                 // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    _decalObject;                                      // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _mi;                                               // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             _decalMaterialTbl;                                 // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _decalGroundDist;                                  // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnableXYZ                             _decalEnableRot;                                   // 0x0224(0x0003)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_227[0x1];                                      // 0x0227(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _groundEffect;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _airEffect;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _effectGroundDist;                                 // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _effectDelaySeconds;                               // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0240(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _effectPSC;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACustomBullet*                          _ownerCustomBullte;                                // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBattle*                       _ownerBtl;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x38];                                     // 0x0298(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelaySpawn();
	void OnHitBackground(const struct FHitResult& HitResult);
	void OnHitCharacter(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundPositionEffectComponent">();
	}
	static class UGroundPositionEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundPositionEffectComponent>();
	}
};
static_assert(alignof(UGroundPositionEffectComponent) == 0x000010, "Wrong alignment on UGroundPositionEffectComponent");
static_assert(sizeof(UGroundPositionEffectComponent) == 0x0002D0, "Wrong size on UGroundPositionEffectComponent");
static_assert(offsetof(UGroundPositionEffectComponent, _bWallHitCreate) == 0x0001F8, "Member 'UGroundPositionEffectComponent::_bWallHitCreate' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _bBeginPlayCreate) == 0x0001F9, "Member 'UGroundPositionEffectComponent::_bBeginPlayCreate' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _bHitBackGroundCreate) == 0x0001FA, "Member 'UGroundPositionEffectComponent::_bHitBackGroundCreate' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _buseBackGroundNormal) == 0x0001FB, "Member 'UGroundPositionEffectComponent::_buseBackGroundNormal' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _bHitCharacterCreate) == 0x0001FC, "Member 'UGroundPositionEffectComponent::_bHitCharacterCreate' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _wallDegThreshold) == 0x000200, "Member 'UGroundPositionEffectComponent::_wallDegThreshold' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _decalObject) == 0x000208, "Member 'UGroundPositionEffectComponent::_decalObject' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _mi) == 0x000210, "Member 'UGroundPositionEffectComponent::_mi' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _decalMaterialTbl) == 0x000218, "Member 'UGroundPositionEffectComponent::_decalMaterialTbl' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _decalGroundDist) == 0x000220, "Member 'UGroundPositionEffectComponent::_decalGroundDist' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _decalEnableRot) == 0x000224, "Member 'UGroundPositionEffectComponent::_decalEnableRot' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _groundEffect) == 0x000228, "Member 'UGroundPositionEffectComponent::_groundEffect' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _airEffect) == 0x000230, "Member 'UGroundPositionEffectComponent::_airEffect' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _effectGroundDist) == 0x000238, "Member 'UGroundPositionEffectComponent::_effectGroundDist' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _effectDelaySeconds) == 0x00023C, "Member 'UGroundPositionEffectComponent::_effectDelaySeconds' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _graduallyAlpha) == 0x000240, "Member 'UGroundPositionEffectComponent::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _effectPSC) == 0x000280, "Member 'UGroundPositionEffectComponent::_effectPSC' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _ownerCustomBullte) == 0x000288, "Member 'UGroundPositionEffectComponent::_ownerCustomBullte' has a wrong offset!");
static_assert(offsetof(UGroundPositionEffectComponent, _ownerBtl) == 0x000290, "Member 'UGroundPositionEffectComponent::_ownerBtl' has a wrong offset!");

// Class InGameModule.GroundShavingComponent
// 0x0120 (0x0320 - 0x0200)
class UGroundShavingComponent final : public UHeroBaseComponent
{
public:
	EViewType                                     _viewType;                                         // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _groundImpactTbl;                                  // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             _groundDecalMaterialTbl;                           // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGroundShavingEffect                   _groundEffect;                                     // 0x0210(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGroundShavingDecal                    _decal;                                            // 0x0218(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         _groundParticleLimitAngle;                         // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _time;                                             // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _lockRotateXY;                                     // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _shavingGraduallyAlpha;                            // 0x0238(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGraduallyAlpha                        _decalGraduallyAlpha;                              // 0x0278(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 _shavingSeCueName;                                 // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _shavingSeComponent;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBattle*                       _ownerCharacter;                                   // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABullet*                                _ownerBullet;                                      // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _groundPSC;                                        // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x38];                                     // 0x02E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundShavingComponent">();
	}
	static class UGroundShavingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundShavingComponent>();
	}
};
static_assert(alignof(UGroundShavingComponent) == 0x000010, "Wrong alignment on UGroundShavingComponent");
static_assert(sizeof(UGroundShavingComponent) == 0x000320, "Wrong size on UGroundShavingComponent");
static_assert(offsetof(UGroundShavingComponent, _viewType) == 0x0001F8, "Member 'UGroundShavingComponent::_viewType' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _groundImpactTbl) == 0x000200, "Member 'UGroundShavingComponent::_groundImpactTbl' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _groundDecalMaterialTbl) == 0x000208, "Member 'UGroundShavingComponent::_groundDecalMaterialTbl' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _groundEffect) == 0x000210, "Member 'UGroundShavingComponent::_groundEffect' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _decal) == 0x000218, "Member 'UGroundShavingComponent::_decal' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _groundParticleLimitAngle) == 0x000228, "Member 'UGroundShavingComponent::_groundParticleLimitAngle' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _time) == 0x00022C, "Member 'UGroundShavingComponent::_time' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _lockRotateXY) == 0x000230, "Member 'UGroundShavingComponent::_lockRotateXY' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _shavingGraduallyAlpha) == 0x000238, "Member 'UGroundShavingComponent::_shavingGraduallyAlpha' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _decalGraduallyAlpha) == 0x000278, "Member 'UGroundShavingComponent::_decalGraduallyAlpha' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _shavingSeCueName) == 0x0002B8, "Member 'UGroundShavingComponent::_shavingSeCueName' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _shavingSeComponent) == 0x0002C8, "Member 'UGroundShavingComponent::_shavingSeComponent' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _ownerCharacter) == 0x0002D0, "Member 'UGroundShavingComponent::_ownerCharacter' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _ownerBullet) == 0x0002D8, "Member 'UGroundShavingComponent::_ownerBullet' has a wrong offset!");
static_assert(offsetof(UGroundShavingComponent, _groundPSC) == 0x0002E0, "Member 'UGroundShavingComponent::_groundPSC' has a wrong offset!");

// Class InGameModule.GuideSecondActionToSignal
// 0x0010 (0x0360 - 0x0350)
class UGuideSecondActionToSignal final : public UWidgetBase
{
public:
	class URichTextBlock*                         _command;                                          // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _commandText;                                      // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuideSecondActionToSignal">();
	}
	static class UGuideSecondActionToSignal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuideSecondActionToSignal>();
	}
};
static_assert(alignof(UGuideSecondActionToSignal) == 0x000008, "Wrong alignment on UGuideSecondActionToSignal");
static_assert(sizeof(UGuideSecondActionToSignal) == 0x000360, "Wrong size on UGuideSecondActionToSignal");
static_assert(offsetof(UGuideSecondActionToSignal, _command) == 0x000350, "Member 'UGuideSecondActionToSignal::_command' has a wrong offset!");
static_assert(offsetof(UGuideSecondActionToSignal, _commandText) == 0x000358, "Member 'UGuideSecondActionToSignal::_commandText' has a wrong offset!");

// Class InGameModule.HairSplineComponent
// 0x0160 (0x06B0 - 0x0550)
class UHairSplineComponent final : public USplineComponent
{
public:
	TArray<struct FNode>                          _nodes;                                            // 0x0548(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_558[0x158];                                    // 0x0558(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HairSplineComponent">();
	}
	static class UHairSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHairSplineComponent>();
	}
};
static_assert(alignof(UHairSplineComponent) == 0x000010, "Wrong alignment on UHairSplineComponent");
static_assert(sizeof(UHairSplineComponent) == 0x0006B0, "Wrong size on UHairSplineComponent");
static_assert(offsetof(UHairSplineComponent, _nodes) == 0x000548, "Member 'UHairSplineComponent::_nodes' has a wrong offset!");

// Class InGameModule.HeroBoxComponent
// 0x0200 (0x0680 - 0x0480)
class UHeroBoxComponent final : public UBoxComponent
{
public:
	struct FHeroShapeImpl                         _impl;                                             // 0x0480(0x0200)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroBoxComponent">();
	}
	static class UHeroBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroBoxComponent>();
	}
};
static_assert(alignof(UHeroBoxComponent) == 0x000010, "Wrong alignment on UHeroBoxComponent");
static_assert(sizeof(UHeroBoxComponent) == 0x000680, "Wrong size on UHeroBoxComponent");
static_assert(offsetof(UHeroBoxComponent, _impl) == 0x000480, "Member 'UHeroBoxComponent::_impl' has a wrong offset!");

// Class InGameModule.HeroCapsuleComponent
// 0x0210 (0x0680 - 0x0470)
class UHeroCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroShapeImpl                         _impl;                                             // 0x0480(0x0200)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroCapsuleComponent">();
	}
	static class UHeroCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroCapsuleComponent>();
	}
};
static_assert(alignof(UHeroCapsuleComponent) == 0x000010, "Wrong alignment on UHeroCapsuleComponent");
static_assert(sizeof(UHeroCapsuleComponent) == 0x000680, "Wrong size on UHeroCapsuleComponent");
static_assert(offsetof(UHeroCapsuleComponent, _impl) == 0x000480, "Member 'UHeroCapsuleComponent::_impl' has a wrong offset!");

// Class InGameModule.HeroPhysicalMaterial
// 0x0008 (0x0088 - 0x0080)
class UHeroPhysicalMaterial final : public UPhysicalMaterial
{
public:
	bool                                          _bNoClimb;                                         // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bNoSpawnEffect;                                   // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroPhysicalMaterial">();
	}
	static class UHeroPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroPhysicalMaterial>();
	}
};
static_assert(alignof(UHeroPhysicalMaterial) == 0x000008, "Wrong alignment on UHeroPhysicalMaterial");
static_assert(sizeof(UHeroPhysicalMaterial) == 0x000088, "Wrong size on UHeroPhysicalMaterial");
static_assert(offsetof(UHeroPhysicalMaterial, _bNoClimb) == 0x000080, "Member 'UHeroPhysicalMaterial::_bNoClimb' has a wrong offset!");
static_assert(offsetof(UHeroPhysicalMaterial, _bNoSpawnEffect) == 0x000081, "Member 'UHeroPhysicalMaterial::_bNoSpawnEffect' has a wrong offset!");

// Class InGameModule.HeroShapeInterface
// 0x0000 (0x0028 - 0x0028)
class IHeroShapeInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroShapeInterface">();
	}
	static class IHeroShapeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHeroShapeInterface>();
	}
};
static_assert(alignof(IHeroShapeInterface) == 0x000008, "Wrong alignment on IHeroShapeInterface");
static_assert(sizeof(IHeroShapeInterface) == 0x000028, "Wrong size on IHeroShapeInterface");

// Class InGameModule.HeroSphereComponent
// 0x0210 (0x0680 - 0x0470)
class UHeroSphereComponent final : public USphereComponent
{
public:
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroShapeImpl                         _impl;                                             // 0x0480(0x0200)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroSphereComponent">();
	}
	static class UHeroSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroSphereComponent>();
	}
};
static_assert(alignof(UHeroSphereComponent) == 0x000010, "Wrong alignment on UHeroSphereComponent");
static_assert(sizeof(UHeroSphereComponent) == 0x000680, "Wrong size on UHeroSphereComponent");
static_assert(offsetof(UHeroSphereComponent, _impl) == 0x000480, "Member 'UHeroSphereComponent::_impl' has a wrong offset!");

// Class InGameModule.HerovsReplicationGraph
// 0x0120 (0x05D0 - 0x04B0)
class UHerovsReplicationGraph final : public UReplicationGraph
{
public:
	TArray<class UClass*>                         SpatializedClasses;                                // 0x04A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         NonSpatializedChildClasses;                        // 0x04B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         AlwaysRelevantClasses;                             // 0x04C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0xE8];                                     // 0x04E8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HerovsReplicationGraph">();
	}
	static class UHerovsReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHerovsReplicationGraph>();
	}
};
static_assert(alignof(UHerovsReplicationGraph) == 0x000010, "Wrong alignment on UHerovsReplicationGraph");
static_assert(sizeof(UHerovsReplicationGraph) == 0x0005D0, "Wrong size on UHerovsReplicationGraph");
static_assert(offsetof(UHerovsReplicationGraph, SpatializedClasses) == 0x0004A8, "Member 'UHerovsReplicationGraph::SpatializedClasses' has a wrong offset!");
static_assert(offsetof(UHerovsReplicationGraph, NonSpatializedChildClasses) == 0x0004B8, "Member 'UHerovsReplicationGraph::NonSpatializedChildClasses' has a wrong offset!");
static_assert(offsetof(UHerovsReplicationGraph, AlwaysRelevantClasses) == 0x0004C8, "Member 'UHerovsReplicationGraph::AlwaysRelevantClasses' has a wrong offset!");
static_assert(offsetof(UHerovsReplicationGraph, GridNode) == 0x0004D8, "Member 'UHerovsReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UHerovsReplicationGraph, AlwaysRelevantNode) == 0x0004E0, "Member 'UHerovsReplicationGraph::AlwaysRelevantNode' has a wrong offset!");

// Class InGameModule.HerovsReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0240 (0x0290 - 0x0050)
class UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_50[0x220];                                     // 0x0050(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastPawn;                                          // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAlwaysRelevantActorInfo>       PastRelevantActors;                                // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HerovsReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000290, "Wrong size on UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection, LastPawn) == 0x000270, "Member 'UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection::LastPawn' has a wrong offset!");
static_assert(offsetof(UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection, PastRelevantActors) == 0x000278, "Member 'UHerovsReplicationGraphNode_AlwaysRelevant_ForConnection::PastRelevantActors' has a wrong offset!");

// Class InGameModule.HerovsReplicationGraphNode_PlayerStateFrequencyLimiter
// 0x0028 (0x0078 - 0x0050)
class UHerovsReplicationGraphNode_PlayerStateFrequencyLimiter final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HerovsReplicationGraphNode_PlayerStateFrequencyLimiter">();
	}
	static class UHerovsReplicationGraphNode_PlayerStateFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHerovsReplicationGraphNode_PlayerStateFrequencyLimiter>();
	}
};
static_assert(alignof(UHerovsReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000008, "Wrong alignment on UHerovsReplicationGraphNode_PlayerStateFrequencyLimiter");
static_assert(sizeof(UHerovsReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000078, "Wrong size on UHerovsReplicationGraphNode_PlayerStateFrequencyLimiter");

// Class InGameModule.HitEffectComponent
// 0x00C0 (0x0178 - 0x00B8)
class UHitEffectComponent final : public UCharacterBattleComponentBase
{
public:
	TMap<EHitMarkType, struct FHitEffectInfo>     _effectInfoList;                                   // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EHitMarkCorrectionType, struct FHitEffectCorrectionInfo> _correctionInfoList;                               // 0x0108(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x20];                                     // 0x0158(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitEffectComponent">();
	}
	static class UHitEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitEffectComponent>();
	}
};
static_assert(alignof(UHitEffectComponent) == 0x000008, "Wrong alignment on UHitEffectComponent");
static_assert(sizeof(UHitEffectComponent) == 0x000178, "Wrong size on UHitEffectComponent");
static_assert(offsetof(UHitEffectComponent, _effectInfoList) == 0x0000B8, "Member 'UHitEffectComponent::_effectInfoList' has a wrong offset!");
static_assert(offsetof(UHitEffectComponent, _correctionInfoList) == 0x000108, "Member 'UHitEffectComponent::_correctionInfoList' has a wrong offset!");

// Class InGameModule.HitEffectDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class UHitEffectDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<EHitMarkType, struct FHitEffectInfo>     _hitEffectInfoList;                                // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EHitMarkCorrectionType, struct FHitEffectCorrectionInfo> _hitEffectCorrectionList;                          // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void SortByAlphabetName();
	void SortByEnum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitEffectDataAsset">();
	}
	static class UHitEffectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitEffectDataAsset>();
	}
};
static_assert(alignof(UHitEffectDataAsset) == 0x000008, "Wrong alignment on UHitEffectDataAsset");
static_assert(sizeof(UHitEffectDataAsset) == 0x0000D0, "Wrong size on UHitEffectDataAsset");
static_assert(offsetof(UHitEffectDataAsset, _hitEffectInfoList) == 0x000030, "Member 'UHitEffectDataAsset::_hitEffectInfoList' has a wrong offset!");
static_assert(offsetof(UHitEffectDataAsset, _hitEffectCorrectionList) == 0x000080, "Member 'UHitEffectDataAsset::_hitEffectCorrectionList' has a wrong offset!");

// Class InGameModule.HUDAbilityInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDAbilityInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDAbilityInterface">();
	}
	static class IHUDAbilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDAbilityInterface>();
	}
};
static_assert(alignof(IHUDAbilityInterface) == 0x000008, "Wrong alignment on IHUDAbilityInterface");
static_assert(sizeof(IHUDAbilityInterface) == 0x000028, "Wrong size on IHUDAbilityInterface");

// Class InGameModule.HUDAbilityPresenter
// 0x0030 (0x0278 - 0x0248)
class AHUDAbilityPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _playerState;                                      // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SwitchShortcutInfoVisibility(bool bVisible) const;
	void UpdateUIOnSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDAbilityPresenter">();
	}
	static class AHUDAbilityPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDAbilityPresenter>();
	}
};
static_assert(alignof(AHUDAbilityPresenter) == 0x000008, "Wrong alignment on AHUDAbilityPresenter");
static_assert(sizeof(AHUDAbilityPresenter) == 0x000278, "Wrong size on AHUDAbilityPresenter");
static_assert(offsetof(AHUDAbilityPresenter, _gameOption) == 0x000250, "Member 'AHUDAbilityPresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AHUDAbilityPresenter, _supplyHolderComponent) == 0x000258, "Member 'AHUDAbilityPresenter::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(AHUDAbilityPresenter, _playerController) == 0x000260, "Member 'AHUDAbilityPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDAbilityPresenter, _playerState) == 0x000270, "Member 'AHUDAbilityPresenter::_playerState' has a wrong offset!");

// Class InGameModule.HUDBaseInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDBaseInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDBaseInterface">();
	}
	static class IHUDBaseInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDBaseInterface>();
	}
};
static_assert(alignof(IHUDBaseInterface) == 0x000008, "Wrong alignment on IHUDBaseInterface");
static_assert(sizeof(IHUDBaseInterface) == 0x000028, "Wrong size on IHUDBaseInterface");

// Class InGameModule.HUDBasePresenter
// 0x0030 (0x0278 - 0x0248)
class AHUDBasePresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x18];                                     // 0x0248(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerBattle*                _playerController;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _localPlayer;                                      // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _winnerPlayer;                                     // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsBlockMember(const class FString& PlayerId) const;
	void ShowGuardBreak(class ACharacterBattle* GuardBrokenCharacter, bool bMyMurderer, bool bGuardBreakAndKO) const;
	void ShowKnockDown(class ACharacterBattle* DownCharacter, bool bMyMurderer, bool bGuardBreakAndKO) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDBasePresenter">();
	}
	static class AHUDBasePresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDBasePresenter>();
	}
};
static_assert(alignof(AHUDBasePresenter) == 0x000008, "Wrong alignment on AHUDBasePresenter");
static_assert(sizeof(AHUDBasePresenter) == 0x000278, "Wrong size on AHUDBasePresenter");
static_assert(offsetof(AHUDBasePresenter, _playerController) == 0x000260, "Member 'AHUDBasePresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDBasePresenter, _localPlayer) == 0x000268, "Member 'AHUDBasePresenter::_localPlayer' has a wrong offset!");
static_assert(offsetof(AHUDBasePresenter, _winnerPlayer) == 0x000270, "Member 'AHUDBasePresenter::_winnerPlayer' has a wrong offset!");

// Class InGameModule.HUDCircularProgressBarInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDCircularProgressBarInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDCircularProgressBarInterface">();
	}
	static class IHUDCircularProgressBarInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDCircularProgressBarInterface>();
	}
};
static_assert(alignof(IHUDCircularProgressBarInterface) == 0x000008, "Wrong alignment on IHUDCircularProgressBarInterface");
static_assert(sizeof(IHUDCircularProgressBarInterface) == 0x000028, "Wrong size on IHUDCircularProgressBarInterface");

// Class InGameModule.HUDCircularProgressBarPresenter
// 0x0040 (0x0288 - 0x0248)
class AHUDCircularProgressBarPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerCircularProgressBarWidget*       _playerCircularProgressBar;                        // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCircularProgressBarWidget*             _circularProgressBar;                              // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _playerState;                                      // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerControllerBattle*                _playerController;                                 // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USimulatedPlayerHudManager*             _simulatedPlayerHudManager;                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHudResource*                           _hudResource;                                      // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDCircularProgressBarPresenter">();
	}
	static class AHUDCircularProgressBarPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDCircularProgressBarPresenter>();
	}
};
static_assert(alignof(AHUDCircularProgressBarPresenter) == 0x000008, "Wrong alignment on AHUDCircularProgressBarPresenter");
static_assert(sizeof(AHUDCircularProgressBarPresenter) == 0x000288, "Wrong size on AHUDCircularProgressBarPresenter");
static_assert(offsetof(AHUDCircularProgressBarPresenter, _playerCircularProgressBar) == 0x000250, "Member 'AHUDCircularProgressBarPresenter::_playerCircularProgressBar' has a wrong offset!");
static_assert(offsetof(AHUDCircularProgressBarPresenter, _circularProgressBar) == 0x000258, "Member 'AHUDCircularProgressBarPresenter::_circularProgressBar' has a wrong offset!");
static_assert(offsetof(AHUDCircularProgressBarPresenter, _playerState) == 0x000268, "Member 'AHUDCircularProgressBarPresenter::_playerState' has a wrong offset!");
static_assert(offsetof(AHUDCircularProgressBarPresenter, _playerController) == 0x000270, "Member 'AHUDCircularProgressBarPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDCircularProgressBarPresenter, _simulatedPlayerHudManager) == 0x000278, "Member 'AHUDCircularProgressBarPresenter::_simulatedPlayerHudManager' has a wrong offset!");
static_assert(offsetof(AHUDCircularProgressBarPresenter, _hudResource) == 0x000280, "Member 'AHUDCircularProgressBarPresenter::_hudResource' has a wrong offset!");

// Class InGameModule.HudCommandControlComponent
// 0x04E0 (0x0590 - 0x00B0)
class UHudCommandControlComponent final : public UActorComponent
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        _primaryCommandInputComponent;                     // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        _optionMenuButtonInputComponent;                   // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        _winDemoInputComponent;                            // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        _lvUpButtonInputComponent;                         // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInputComponent*>                _hudCommandInputComponents;                        // 0x00E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AHUDBasePresenter*                      _hudBasePresenter;                                 // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConditionObserver*                     _observer;                                         // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x88];                                     // 0x0108(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _onStartButtonPressedInMenu;                       // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x4];                                      // 0x01A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _menuOpenTime;                                     // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x4];                                      // 0x01A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _levelUpShortCutTime;                              // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x58];                                     // 0x01B0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _textChatOpenTime;                                 // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x28];                                     // 0x020C(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _longPressThreshold;                               // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x30];                                     // 0x0238(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _onSymbolWheelReady;                               // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onEmoteWheelReady;                                // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onLvShortCutWheelReady;                           // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onSupplyWheelReady;                               // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onSignalWheelReady;                               // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onDebugEmoteWheelReady;                           // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onSelectSupplyDispatched;                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onManualSignalDispatched;                         // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onLvShortCutDispatched;                           // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onEmoteCommandDispatched;                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onSymbolCommandDispatched;                        // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _onRemoveWheel;                                    // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x150];                                    // 0x0328(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractTargetComponent*               _currentInteractTarget;                            // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACommunicationPinActor*                 _commPinActor;                                     // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACommunicationPinActor*                 _oldPin;                                           // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACommunicationPinActor*>         _mySupplyPin;                                      // 0x0490(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x28];                                     // 0x04A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACommunicationPinActor>     _bpPinActor;                                       // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACommunicationPinActor*>         _existingPins;                                     // 0x04D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _secondClickTimeLimit;                             // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHUDCrossHairsPresenter*                _crossHairsPresenter;                              // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x4];                                      // 0x04F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pinResponseRange;                                 // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACommunicationPinActor*                 _currentAimingPin;                                 // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACommunicationPinActor*                 _previousAimingPin;                                // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x4];                                      // 0x0508(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pinLifeTime;                                      // 0x050C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x18];                                     // 0x0510(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACommunicationPinActor*>         _respondedPinList;                                 // 0x0528(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         _senderPlayerId;                                   // 0x0538(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _senderSquadId;                                    // 0x0539(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _sendCount;                                        // 0x053A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53B[0x1];                                      // 0x053B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sendCountResetTime;                               // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _maxSendCount;                                     // 0x0540(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _maxSupplyPinsNum;                                 // 0x0541(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_542[0x2E];                                     // 0x0542(0x002E)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                _emoteDebugUMGClass;                               // 0x0570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyHolderComponent*                 _supplyHolder;                                     // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapWidget*                             _expandedMapInstance;                              // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_EliminateCommandHudRemnants();
	void BP_PushPrimaryInputComponent();
	void BP_ReturnInputSystemFromUIToGame();
	void CommitPin(EMarkerType MarkerType, const struct FHitResult& HitResult, const bool IsAlert, const bool bPlaceFromMap);
	void DestroyPin_OnServer();
	void DispatchDestructionToUI(class ACommunicationPinActor* DestroyedActor);
	void FinishHolding();
	void FlipPrimaryInputComponent();
	TSoftObjectPtr<class UDataTable> GetAnimTable(ECharacterId Whose);
	void HudWheelCommandEvent__DelegateSignature();
	void OnInteractionUpdated(class UInteractTargetComponent* TargetComponent);
	void OnStartButtonPressedInMenu__DelegateSignature();
	void PinLifeEvent__DelegateSignature(class ACommunicationPinActor* SpawnedPinActor);
	void PopWinDemoButtonInputComponent();
	void PushLvUpButtonInputComponent();
	void PushOptionMenuButtonInputComponent();
	void PushPrimaryInputComponent();
	void PushWinDemoInputComponent();
	void RegisterPin(class ACommunicationPinActor* Pin);
	void RemovePinFromList(uint8 PinGuid);
	void RespawnedPushPrimaryInputComponent();
	void RespondToAllySignal();
	void RespondToSignalTwo();
	void SendAbilityRequest_ToServer(const class APlayerStateBattle* Sender, const EMdAbilityType AbilityType, const EAttackId AttackId);
	void SendMarkerCancelMessage(const class ACommunicationPinActor* PinActor);
	void SendSupplyRequest_ToServer(const class APlayerStateBattle* Sender, const class FName& SupplyId);
	void SendTextMessage(const class FString& InKeyForTable, bool SendToMyself);
	void ServerCancelPin(class ACommunicationPinActor* PinActor);
	void ServerOutputDoubleClickTime(float Time);
	void ServerPlacePinEvent(const struct FPinInfo& PinInfo);
	void ServerSendTextMessage(const class FString& InKeyForTable);
	void SetFirstUseSupply(class FName NewShortcut);
	void SignalWheelReady();
	void SupplyWheelReady();

	int32 GetCurrentSupplyNumber(const class FName& SupplyId) const;
	bool GetHitResult(struct FHitResult* HitResult) const;
	void PlayEmote(int32 EmoteCode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudCommandControlComponent">();
	}
	static class UHudCommandControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudCommandControlComponent>();
	}
};
static_assert(alignof(UHudCommandControlComponent) == 0x000008, "Wrong alignment on UHudCommandControlComponent");
static_assert(sizeof(UHudCommandControlComponent) == 0x000590, "Wrong size on UHudCommandControlComponent");
static_assert(offsetof(UHudCommandControlComponent, _playerState) == 0x0000B0, "Member 'UHudCommandControlComponent::_playerState' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _playerController) == 0x0000B8, "Member 'UHudCommandControlComponent::_playerController' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _primaryCommandInputComponent) == 0x0000C0, "Member 'UHudCommandControlComponent::_primaryCommandInputComponent' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _optionMenuButtonInputComponent) == 0x0000C8, "Member 'UHudCommandControlComponent::_optionMenuButtonInputComponent' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _winDemoInputComponent) == 0x0000D0, "Member 'UHudCommandControlComponent::_winDemoInputComponent' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _lvUpButtonInputComponent) == 0x0000D8, "Member 'UHudCommandControlComponent::_lvUpButtonInputComponent' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _hudCommandInputComponents) == 0x0000E0, "Member 'UHudCommandControlComponent::_hudCommandInputComponents' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _hudBasePresenter) == 0x0000F0, "Member 'UHudCommandControlComponent::_hudBasePresenter' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _observer) == 0x000100, "Member 'UHudCommandControlComponent::_observer' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onStartButtonPressedInMenu) == 0x000190, "Member 'UHudCommandControlComponent::_onStartButtonPressedInMenu' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _menuOpenTime) == 0x0001A4, "Member 'UHudCommandControlComponent::_menuOpenTime' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _levelUpShortCutTime) == 0x0001AC, "Member 'UHudCommandControlComponent::_levelUpShortCutTime' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _textChatOpenTime) == 0x000208, "Member 'UHudCommandControlComponent::_textChatOpenTime' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _longPressThreshold) == 0x000234, "Member 'UHudCommandControlComponent::_longPressThreshold' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onSymbolWheelReady) == 0x000268, "Member 'UHudCommandControlComponent::_onSymbolWheelReady' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onEmoteWheelReady) == 0x000278, "Member 'UHudCommandControlComponent::_onEmoteWheelReady' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onLvShortCutWheelReady) == 0x000288, "Member 'UHudCommandControlComponent::_onLvShortCutWheelReady' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onSupplyWheelReady) == 0x000298, "Member 'UHudCommandControlComponent::_onSupplyWheelReady' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onSignalWheelReady) == 0x0002A8, "Member 'UHudCommandControlComponent::_onSignalWheelReady' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onDebugEmoteWheelReady) == 0x0002B8, "Member 'UHudCommandControlComponent::_onDebugEmoteWheelReady' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onSelectSupplyDispatched) == 0x0002C8, "Member 'UHudCommandControlComponent::_onSelectSupplyDispatched' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onManualSignalDispatched) == 0x0002D8, "Member 'UHudCommandControlComponent::_onManualSignalDispatched' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onLvShortCutDispatched) == 0x0002E8, "Member 'UHudCommandControlComponent::_onLvShortCutDispatched' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onEmoteCommandDispatched) == 0x0002F8, "Member 'UHudCommandControlComponent::_onEmoteCommandDispatched' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onSymbolCommandDispatched) == 0x000308, "Member 'UHudCommandControlComponent::_onSymbolCommandDispatched' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _onRemoveWheel) == 0x000318, "Member 'UHudCommandControlComponent::_onRemoveWheel' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _currentInteractTarget) == 0x000478, "Member 'UHudCommandControlComponent::_currentInteractTarget' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _commPinActor) == 0x000480, "Member 'UHudCommandControlComponent::_commPinActor' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _oldPin) == 0x000488, "Member 'UHudCommandControlComponent::_oldPin' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _mySupplyPin) == 0x000490, "Member 'UHudCommandControlComponent::_mySupplyPin' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _bpPinActor) == 0x0004C8, "Member 'UHudCommandControlComponent::_bpPinActor' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _existingPins) == 0x0004D0, "Member 'UHudCommandControlComponent::_existingPins' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _secondClickTimeLimit) == 0x0004E0, "Member 'UHudCommandControlComponent::_secondClickTimeLimit' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _crossHairsPresenter) == 0x0004E8, "Member 'UHudCommandControlComponent::_crossHairsPresenter' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _pinResponseRange) == 0x0004F4, "Member 'UHudCommandControlComponent::_pinResponseRange' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _currentAimingPin) == 0x0004F8, "Member 'UHudCommandControlComponent::_currentAimingPin' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _previousAimingPin) == 0x000500, "Member 'UHudCommandControlComponent::_previousAimingPin' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _pinLifeTime) == 0x00050C, "Member 'UHudCommandControlComponent::_pinLifeTime' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _respondedPinList) == 0x000528, "Member 'UHudCommandControlComponent::_respondedPinList' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _senderPlayerId) == 0x000538, "Member 'UHudCommandControlComponent::_senderPlayerId' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _senderSquadId) == 0x000539, "Member 'UHudCommandControlComponent::_senderSquadId' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _sendCount) == 0x00053A, "Member 'UHudCommandControlComponent::_sendCount' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _sendCountResetTime) == 0x00053C, "Member 'UHudCommandControlComponent::_sendCountResetTime' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _maxSendCount) == 0x000540, "Member 'UHudCommandControlComponent::_maxSendCount' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _maxSupplyPinsNum) == 0x000541, "Member 'UHudCommandControlComponent::_maxSupplyPinsNum' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _emoteDebugUMGClass) == 0x000570, "Member 'UHudCommandControlComponent::_emoteDebugUMGClass' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _supplyHolder) == 0x000578, "Member 'UHudCommandControlComponent::_supplyHolder' has a wrong offset!");
static_assert(offsetof(UHudCommandControlComponent, _expandedMapInstance) == 0x000580, "Member 'UHudCommandControlComponent::_expandedMapInstance' has a wrong offset!");

// Class InGameModule.HUDCrossHairsInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDCrossHairsInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDCrossHairsInterface">();
	}
	static class IHUDCrossHairsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDCrossHairsInterface>();
	}
};
static_assert(alignof(IHUDCrossHairsInterface) == 0x000008, "Wrong alignment on IHUDCrossHairsInterface");
static_assert(sizeof(IHUDCrossHairsInterface) == 0x000028, "Wrong size on IHUDCrossHairsInterface");

// Class InGameModule.HUDCrossHairsPresenter
// 0x0028 (0x0270 - 0x0248)
class AHUDCrossHairsPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerCrossHairsWidget*                _playerCrossHairs;                                 // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrossHairsWidget*                      _crossHairs;                                       // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameOption*                            _gameOption;                                       // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwitchCrossHairsVisibility(bool bVisibility) const;
	void UpdateUIOnSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDCrossHairsPresenter">();
	}
	static class AHUDCrossHairsPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDCrossHairsPresenter>();
	}
};
static_assert(alignof(AHUDCrossHairsPresenter) == 0x000008, "Wrong alignment on AHUDCrossHairsPresenter");
static_assert(sizeof(AHUDCrossHairsPresenter) == 0x000270, "Wrong size on AHUDCrossHairsPresenter");
static_assert(offsetof(AHUDCrossHairsPresenter, _playerCrossHairs) == 0x000250, "Member 'AHUDCrossHairsPresenter::_playerCrossHairs' has a wrong offset!");
static_assert(offsetof(AHUDCrossHairsPresenter, _crossHairs) == 0x000258, "Member 'AHUDCrossHairsPresenter::_crossHairs' has a wrong offset!");
static_assert(offsetof(AHUDCrossHairsPresenter, _gameOption) == 0x000260, "Member 'AHUDCrossHairsPresenter::_gameOption' has a wrong offset!");

// Class InGameModule.HUDDialogueInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDDialogueInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDDialogueInterface">();
	}
	static class IHUDDialogueInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDDialogueInterface>();
	}
};
static_assert(alignof(IHUDDialogueInterface) == 0x000008, "Wrong alignment on IHUDDialogueInterface");
static_assert(sizeof(IHUDDialogueInterface) == 0x000028, "Wrong size on IHUDDialogueInterface");

// Class InGameModule.HUDDialoguePresenter
// 0x0008 (0x0250 - 0x0248)
class AHUDDialoguePresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDDialoguePresenter">();
	}
	static class AHUDDialoguePresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDDialoguePresenter>();
	}
};
static_assert(alignof(AHUDDialoguePresenter) == 0x000008, "Wrong alignment on AHUDDialoguePresenter");
static_assert(sizeof(AHUDDialoguePresenter) == 0x000250, "Wrong size on AHUDDialoguePresenter");

// Class InGameModule.HUDDispatchComponent
// 0x0238 (0x02E8 - 0x00B0)
class UHUDDispatchComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x238];                                     // 0x00B0(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginSquadMemberCircularProgressRate_ToClient(ECircularProgressType Type, class APlayerStateBattle* PLAYER, float OpenSpan);
	void OnEndSquadMemberCircularProgressRate_ToClient(class APlayerStateBattle* PLAYER);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDDispatchComponent">();
	}
	static class UHUDDispatchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDDispatchComponent>();
	}
};
static_assert(alignof(UHUDDispatchComponent) == 0x000008, "Wrong alignment on UHUDDispatchComponent");
static_assert(sizeof(UHUDDispatchComponent) == 0x0002E8, "Wrong size on UHUDDispatchComponent");

// Class InGameModule.HUDGameButtonGuideInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDGameButtonGuideInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDGameButtonGuideInterface">();
	}
	static class IHUDGameButtonGuideInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDGameButtonGuideInterface>();
	}
};
static_assert(alignof(IHUDGameButtonGuideInterface) == 0x000008, "Wrong alignment on IHUDGameButtonGuideInterface");
static_assert(sizeof(IHUDGameButtonGuideInterface) == 0x000028, "Wrong size on IHUDGameButtonGuideInterface");

// Class InGameModule.HUDGameButtonGuidePresenter
// 0x0038 (0x0280 - 0x0248)
class AHUDGameButtonGuidePresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                _rootWidget;                                       // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPlatformRichTextBlock*>         _platformButtons;                                  // 0x0270(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void HideButtonGuides();
	void ShowButtonGuides();
	void UpdateUIOnSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDGameButtonGuidePresenter">();
	}
	static class AHUDGameButtonGuidePresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDGameButtonGuidePresenter>();
	}
};
static_assert(alignof(AHUDGameButtonGuidePresenter) == 0x000008, "Wrong alignment on AHUDGameButtonGuidePresenter");
static_assert(sizeof(AHUDGameButtonGuidePresenter) == 0x000280, "Wrong size on AHUDGameButtonGuidePresenter");
static_assert(offsetof(AHUDGameButtonGuidePresenter, _gameOption) == 0x000250, "Member 'AHUDGameButtonGuidePresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AHUDGameButtonGuidePresenter, _rootWidget) == 0x000258, "Member 'AHUDGameButtonGuidePresenter::_rootWidget' has a wrong offset!");
static_assert(offsetof(AHUDGameButtonGuidePresenter, _playerController) == 0x000260, "Member 'AHUDGameButtonGuidePresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDGameButtonGuidePresenter, _platformButtons) == 0x000270, "Member 'AHUDGameButtonGuidePresenter::_platformButtons' has a wrong offset!");

// Class InGameModule.HUDInGameMiscInfoInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDInGameMiscInfoInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDInGameMiscInfoInterface">();
	}
	static class IHUDInGameMiscInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDInGameMiscInfoInterface>();
	}
};
static_assert(alignof(IHUDInGameMiscInfoInterface) == 0x000008, "Wrong alignment on IHUDInGameMiscInfoInterface");
static_assert(sizeof(IHUDInGameMiscInfoInterface) == 0x000028, "Wrong size on IHUDInGameMiscInfoInterface");

// Class InGameModule.HUDInGameMiscInfoPresenter
// 0x0040 (0x0288 - 0x0248)
class AHUDInGameMiscInfoPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _viewTargetState;                                  // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _localPlayerState;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPoisonMistManagerComponent*            _poisonMistManager;                                // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameOption*                            _gameOption;                                       // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangedViewTarget(class APlayerStateBattle* PlayerState);
	void UpdateDamagePoint();
	void UpdateUIOnSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDInGameMiscInfoPresenter">();
	}
	static class AHUDInGameMiscInfoPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDInGameMiscInfoPresenter>();
	}
};
static_assert(alignof(AHUDInGameMiscInfoPresenter) == 0x000008, "Wrong alignment on AHUDInGameMiscInfoPresenter");
static_assert(sizeof(AHUDInGameMiscInfoPresenter) == 0x000288, "Wrong size on AHUDInGameMiscInfoPresenter");
static_assert(offsetof(AHUDInGameMiscInfoPresenter, _viewTargetState) == 0x000258, "Member 'AHUDInGameMiscInfoPresenter::_viewTargetState' has a wrong offset!");
static_assert(offsetof(AHUDInGameMiscInfoPresenter, _localPlayerState) == 0x000260, "Member 'AHUDInGameMiscInfoPresenter::_localPlayerState' has a wrong offset!");
static_assert(offsetof(AHUDInGameMiscInfoPresenter, _playerController) == 0x000268, "Member 'AHUDInGameMiscInfoPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDInGameMiscInfoPresenter, _poisonMistManager) == 0x000270, "Member 'AHUDInGameMiscInfoPresenter::_poisonMistManager' has a wrong offset!");
static_assert(offsetof(AHUDInGameMiscInfoPresenter, _gameOption) == 0x000278, "Member 'AHUDInGameMiscInfoPresenter::_gameOption' has a wrong offset!");

// Class InGameModule.HUDKillLogInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDKillLogInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDKillLogInterface">();
	}
	static class IHUDKillLogInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDKillLogInterface>();
	}
};
static_assert(alignof(IHUDKillLogInterface) == 0x000008, "Wrong alignment on IHUDKillLogInterface");
static_assert(sizeof(IHUDKillLogInterface) == 0x000028, "Wrong size on IHUDKillLogInterface");

// Class InGameModule.HUDKillLogPresenter
// 0x0030 (0x0278 - 0x0248)
class AHUDKillLogPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateUIOnSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDKillLogPresenter">();
	}
	static class AHUDKillLogPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDKillLogPresenter>();
	}
};
static_assert(alignof(AHUDKillLogPresenter) == 0x000008, "Wrong alignment on AHUDKillLogPresenter");
static_assert(sizeof(AHUDKillLogPresenter) == 0x000278, "Wrong size on AHUDKillLogPresenter");
static_assert(offsetof(AHUDKillLogPresenter, _gameOption) == 0x000250, "Member 'AHUDKillLogPresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AHUDKillLogPresenter, _playerController) == 0x000258, "Member 'AHUDKillLogPresenter::_playerController' has a wrong offset!");

// Class InGameModule.HUDLeadersLastCountDownInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDLeadersLastCountDownInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLeadersLastCountDownInterface">();
	}
	static class IHUDLeadersLastCountDownInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDLeadersLastCountDownInterface>();
	}
};
static_assert(alignof(IHUDLeadersLastCountDownInterface) == 0x000008, "Wrong alignment on IHUDLeadersLastCountDownInterface");
static_assert(sizeof(IHUDLeadersLastCountDownInterface) == 0x000028, "Wrong size on IHUDLeadersLastCountDownInterface");

// Class InGameModule.HUDLeadersLastCountDownPresenter
// 0x0028 (0x0270 - 0x0248)
class AHUDLeadersLastCountDownPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateLeadersBattle*              _localPlayerState;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameStateLeadersBattle*                _gameStateLeaders;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLeadersLastCountDownPresenter">();
	}
	static class AHUDLeadersLastCountDownPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDLeadersLastCountDownPresenter>();
	}
};
static_assert(alignof(AHUDLeadersLastCountDownPresenter) == 0x000008, "Wrong alignment on AHUDLeadersLastCountDownPresenter");
static_assert(sizeof(AHUDLeadersLastCountDownPresenter) == 0x000270, "Wrong size on AHUDLeadersLastCountDownPresenter");
static_assert(offsetof(AHUDLeadersLastCountDownPresenter, _localPlayerState) == 0x000250, "Member 'AHUDLeadersLastCountDownPresenter::_localPlayerState' has a wrong offset!");
static_assert(offsetof(AHUDLeadersLastCountDownPresenter, _playerController) == 0x000258, "Member 'AHUDLeadersLastCountDownPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDLeadersLastCountDownPresenter, _gameStateLeaders) == 0x000260, "Member 'AHUDLeadersLastCountDownPresenter::_gameStateLeaders' has a wrong offset!");

// Class InGameModule.HUDLeadersRankInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDLeadersRankInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLeadersRankInterface">();
	}
	static class IHUDLeadersRankInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDLeadersRankInterface>();
	}
};
static_assert(alignof(IHUDLeadersRankInterface) == 0x000008, "Wrong alignment on IHUDLeadersRankInterface");
static_assert(sizeof(IHUDLeadersRankInterface) == 0x000028, "Wrong size on IHUDLeadersRankInterface");

// Class InGameModule.HUDLeadersRankPresenter
// 0x0080 (0x02C8 - 0x0248)
class AHUDLeadersRankPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateLeadersBattle*              _localPlayerState;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameStateLeadersBattle*                _gameStateLeaders;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x60];                                     // 0x0268(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLeadersRankPresenter">();
	}
	static class AHUDLeadersRankPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDLeadersRankPresenter>();
	}
};
static_assert(alignof(AHUDLeadersRankPresenter) == 0x000008, "Wrong alignment on AHUDLeadersRankPresenter");
static_assert(sizeof(AHUDLeadersRankPresenter) == 0x0002C8, "Wrong size on AHUDLeadersRankPresenter");
static_assert(offsetof(AHUDLeadersRankPresenter, _localPlayerState) == 0x000250, "Member 'AHUDLeadersRankPresenter::_localPlayerState' has a wrong offset!");
static_assert(offsetof(AHUDLeadersRankPresenter, _playerController) == 0x000258, "Member 'AHUDLeadersRankPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDLeadersRankPresenter, _gameStateLeaders) == 0x000260, "Member 'AHUDLeadersRankPresenter::_gameStateLeaders' has a wrong offset!");

// Class InGameModule.HUDLeadersTimerInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDLeadersTimerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLeadersTimerInterface">();
	}
	static class IHUDLeadersTimerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDLeadersTimerInterface>();
	}
};
static_assert(alignof(IHUDLeadersTimerInterface) == 0x000008, "Wrong alignment on IHUDLeadersTimerInterface");
static_assert(sizeof(IHUDLeadersTimerInterface) == 0x000028, "Wrong size on IHUDLeadersTimerInterface");

// Class InGameModule.HUDLeadersTimerPresenter
// 0x0028 (0x0270 - 0x0248)
class AHUDLeadersTimerPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateLeadersBattle*              _localPlayerState;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameStateLeadersBattle*                _gameStateLeaders;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLeadersTimerPresenter">();
	}
	static class AHUDLeadersTimerPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDLeadersTimerPresenter>();
	}
};
static_assert(alignof(AHUDLeadersTimerPresenter) == 0x000008, "Wrong alignment on AHUDLeadersTimerPresenter");
static_assert(sizeof(AHUDLeadersTimerPresenter) == 0x000270, "Wrong size on AHUDLeadersTimerPresenter");
static_assert(offsetof(AHUDLeadersTimerPresenter, _localPlayerState) == 0x000250, "Member 'AHUDLeadersTimerPresenter::_localPlayerState' has a wrong offset!");
static_assert(offsetof(AHUDLeadersTimerPresenter, _playerController) == 0x000258, "Member 'AHUDLeadersTimerPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDLeadersTimerPresenter, _gameStateLeaders) == 0x000260, "Member 'AHUDLeadersTimerPresenter::_gameStateLeaders' has a wrong offset!");

// Class InGameModule.HUDLevelUpShortCutInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDLevelUpShortCutInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLevelUpShortCutInterface">();
	}
	static class IHUDLevelUpShortCutInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDLevelUpShortCutInterface>();
	}
};
static_assert(alignof(IHUDLevelUpShortCutInterface) == 0x000008, "Wrong alignment on IHUDLevelUpShortCutInterface");
static_assert(sizeof(IHUDLevelUpShortCutInterface) == 0x000028, "Wrong size on IHUDLevelUpShortCutInterface");

// Class InGameModule.HUDLevelUpShortCutPresenter
// 0x0038 (0x0280 - 0x0248)
class AHUDLevelUpShortCutPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x18];                                     // 0x0248(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _commandHudComponent;                              // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LvUpWidgetShowBegin();
	void LvUpWidgetShowEnd();

	void SwitchLvUpShortCutVisibility(bool bVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDLevelUpShortCutPresenter">();
	}
	static class AHUDLevelUpShortCutPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDLevelUpShortCutPresenter>();
	}
};
static_assert(alignof(AHUDLevelUpShortCutPresenter) == 0x000008, "Wrong alignment on AHUDLevelUpShortCutPresenter");
static_assert(sizeof(AHUDLevelUpShortCutPresenter) == 0x000280, "Wrong size on AHUDLevelUpShortCutPresenter");
static_assert(offsetof(AHUDLevelUpShortCutPresenter, _supplyHolderComponent) == 0x000260, "Member 'AHUDLevelUpShortCutPresenter::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(AHUDLevelUpShortCutPresenter, _commandHudComponent) == 0x000268, "Member 'AHUDLevelUpShortCutPresenter::_commandHudComponent' has a wrong offset!");

// Class InGameModule.HUDMagazineInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDMagazineInterface final : public IInterface
{
public:
	void ViewDoWorkOnLevelUp(EAttackId SlotAttackId);
	void ViewUpdateMagazineState(EAttackId SlotAttackId, int32 NewAmmoNum, float NewReloadRate);
	void ViewUpdateSkillState(EAttackId SlotAttackId, ECharacterId SkillCharacterId, EAttackId SkillAttackId, int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDMagazineInterface">();
	}
	static class IHUDMagazineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDMagazineInterface>();
	}
};
static_assert(alignof(IHUDMagazineInterface) == 0x000008, "Wrong alignment on IHUDMagazineInterface");
static_assert(sizeof(IHUDMagazineInterface) == 0x000028, "Wrong size on IHUDMagazineInterface");

// Class InGameModule.HUDMagazinePresenter
// 0x01A0 (0x03E8 - 0x0248)
class AHUDMagazinePresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _viewTargetPlayerState;                            // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillManagementComponent*              _skillManagementComponent;                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMagazineManagementComponent*           _magazineManagementComponent;                      // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x50];                                     // 0x0288(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttackId, class UUserWidget*>           _skillWidgets;                                     // 0x02D8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTransformInfo*                         _transformInfo;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0xB0];                                     // 0x0338(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeSkill(const class USkillChangeParam* SkillChangeParam);
	void DoWorkOnLevelUp(EAttackId SlotAttackId);
	void OnSkillLevelUp(EAttackId AttackId);
	void SendMagazineInfoToWidget(EAttackId SlotAttackId);
	void SetSpecialActionParam(const struct FMagazineViewInfo& Param);
	void SwitchCharacterSpecialActionAvailability(const struct FRequestUIData& Data);
	void TrainingCharacterChanged(class APlayerStateBattle* PlayerStateBattle);

	void UpdateTransformUIVisibility() const;
	void UpdateUIOnSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDMagazinePresenter">();
	}
	static class AHUDMagazinePresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDMagazinePresenter>();
	}
};
static_assert(alignof(AHUDMagazinePresenter) == 0x000008, "Wrong alignment on AHUDMagazinePresenter");
static_assert(sizeof(AHUDMagazinePresenter) == 0x0003E8, "Wrong size on AHUDMagazinePresenter");
static_assert(offsetof(AHUDMagazinePresenter, _gameOption) == 0x000258, "Member 'AHUDMagazinePresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _playerController) == 0x000260, "Member 'AHUDMagazinePresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _viewTargetPlayerState) == 0x000268, "Member 'AHUDMagazinePresenter::_viewTargetPlayerState' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _localPlayerHudManager) == 0x000270, "Member 'AHUDMagazinePresenter::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _skillManagementComponent) == 0x000278, "Member 'AHUDMagazinePresenter::_skillManagementComponent' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _magazineManagementComponent) == 0x000280, "Member 'AHUDMagazinePresenter::_magazineManagementComponent' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _skillWidgets) == 0x0002D8, "Member 'AHUDMagazinePresenter::_skillWidgets' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _playerDatabaseWork) == 0x000328, "Member 'AHUDMagazinePresenter::_playerDatabaseWork' has a wrong offset!");
static_assert(offsetof(AHUDMagazinePresenter, _transformInfo) == 0x000330, "Member 'AHUDMagazinePresenter::_transformInfo' has a wrong offset!");

// Class InGameModule.HUDPlayerTagInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDPlayerTagInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDPlayerTagInterface">();
	}
	static class IHUDPlayerTagInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDPlayerTagInterface>();
	}
};
static_assert(alignof(IHUDPlayerTagInterface) == 0x000008, "Wrong alignment on IHUDPlayerTagInterface");
static_assert(sizeof(IHUDPlayerTagInterface) == 0x000028, "Wrong size on IHUDPlayerTagInterface");

// Class InGameModule.HUDPlayerTagPresenter
// 0x0050 (0x0298 - 0x0248)
class AHUDPlayerTagPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _viewTargetState;                                  // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _localPlayerState;                                 // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameOption*                            _gameOption;                                       // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           _damageUICurve;                                    // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangedViewTarget(class APlayerStateBattle* PlayerState);
	void SendDamageInfo(const struct FAttackHitData& HitData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDPlayerTagPresenter">();
	}
	static class AHUDPlayerTagPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDPlayerTagPresenter>();
	}
};
static_assert(alignof(AHUDPlayerTagPresenter) == 0x000008, "Wrong alignment on AHUDPlayerTagPresenter");
static_assert(sizeof(AHUDPlayerTagPresenter) == 0x000298, "Wrong size on AHUDPlayerTagPresenter");
static_assert(offsetof(AHUDPlayerTagPresenter, _viewTargetState) == 0x000250, "Member 'AHUDPlayerTagPresenter::_viewTargetState' has a wrong offset!");
static_assert(offsetof(AHUDPlayerTagPresenter, _localPlayerState) == 0x000258, "Member 'AHUDPlayerTagPresenter::_localPlayerState' has a wrong offset!");
static_assert(offsetof(AHUDPlayerTagPresenter, _playerController) == 0x000260, "Member 'AHUDPlayerTagPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDPlayerTagPresenter, _gameOption) == 0x000268, "Member 'AHUDPlayerTagPresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AHUDPlayerTagPresenter, _damageUICurve) == 0x000280, "Member 'AHUDPlayerTagPresenter::_damageUICurve' has a wrong offset!");

// Class InGameModule.HUDPlusUltraInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDPlusUltraInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDPlusUltraInterface">();
	}
	static class IHUDPlusUltraInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDPlusUltraInterface>();
	}
};
static_assert(alignof(IHUDPlusUltraInterface) == 0x000008, "Wrong alignment on IHUDPlusUltraInterface");
static_assert(sizeof(IHUDPlusUltraInterface) == 0x000028, "Wrong size on IHUDPlusUltraInterface");

// Class InGameModule.HUDPlusUltraPresenter
// 0x0030 (0x0278 - 0x0248)
class AHUDPlusUltraPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x18];                                     // 0x0248(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          _readySound;                                       // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeViewTarget(const class APlayerState* ViewTarget);

	void SwitchPlusUltraVisibility(bool bVisible) const;
	void UpdateUIOnSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDPlusUltraPresenter">();
	}
	static class AHUDPlusUltraPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDPlusUltraPresenter>();
	}
};
static_assert(alignof(AHUDPlusUltraPresenter) == 0x000008, "Wrong alignment on AHUDPlusUltraPresenter");
static_assert(sizeof(AHUDPlusUltraPresenter) == 0x000278, "Wrong size on AHUDPlusUltraPresenter");
static_assert(offsetof(AHUDPlusUltraPresenter, _gameOption) == 0x000260, "Member 'AHUDPlusUltraPresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AHUDPlusUltraPresenter, _readySound) == 0x000268, "Member 'AHUDPlusUltraPresenter::_readySound' has a wrong offset!");

// Class InGameModule.HUDStatusInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDStatusInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStatusInterface">();
	}
	static class IHUDStatusInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDStatusInterface>();
	}
};
static_assert(alignof(IHUDStatusInterface) == 0x000008, "Wrong alignment on IHUDStatusInterface");
static_assert(sizeof(IHUDStatusInterface) == 0x000028, "Wrong size on IHUDStatusInterface");

// Class InGameModule.HUDStatusPresenter
// 0x00C0 (0x0308 - 0x0248)
class AHUDStatusPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHerovsGameState*                       _gameState;                                        // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _viewTargetPlayerState;                            // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USupplyHolderComponent*>         _supplyHolderComponentList;                        // 0x0270(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UHUDDispatchComponent*>          _hudDispatchComponentList;                         // 0x0280(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class APlayerStateBattle*>             _squadMembers;                                     // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<uint8, class UStatusBoxBase*>            _statusBoxMap;                                     // 0x02A0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHudResource*                           _hudResource;                                      // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginSquadMemberAction(const ECircularProgressType Type, const class APlayerStateBattle* PLAYER, const float OpenSpan);
	void BeginUsingSupply(const class USupplyHolder* Holder, const class FName& UsedSupply);
	void ComparisonUpdateTargetStatus(class APlayerStateBattle* Winner, bool Success);
	void EndSquadMemberAction(const class APlayerStateBattle* PLAYER);
	void EndUsingSupply(const class APlayerStateBattle* UsedPlayer);
	void OnAddedPlayer(class AHerovsPlayerState* AddedPlayer);
	void OnPlayerChanged(class APlayerStateBattle* PlayerState);
	void PlayAbilityRequestSenderNotification(int16 SenderPlayerId, const EMdAbilityType AbilityType, const EAttackId AttackId);
	void PlaySupplyRequestSenderNotification(int16 SenderPlayerId, const class FName& SupplyId);

	void SwitchAllyPlayerStatusVisibility(bool bVisibility) const;
	void SwitchLocalPlayerStatusVisibility(bool bVisibility) const;
	void UpdateUIOnSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStatusPresenter">();
	}
	static class AHUDStatusPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUDStatusPresenter>();
	}
};
static_assert(alignof(AHUDStatusPresenter) == 0x000008, "Wrong alignment on AHUDStatusPresenter");
static_assert(sizeof(AHUDStatusPresenter) == 0x000308, "Wrong size on AHUDStatusPresenter");
static_assert(offsetof(AHUDStatusPresenter, _gameOption) == 0x000250, "Member 'AHUDStatusPresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _gameState) == 0x000258, "Member 'AHUDStatusPresenter::_gameState' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _playerController) == 0x000260, "Member 'AHUDStatusPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _viewTargetPlayerState) == 0x000268, "Member 'AHUDStatusPresenter::_viewTargetPlayerState' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _supplyHolderComponentList) == 0x000270, "Member 'AHUDStatusPresenter::_supplyHolderComponentList' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _hudDispatchComponentList) == 0x000280, "Member 'AHUDStatusPresenter::_hudDispatchComponentList' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _squadMembers) == 0x000290, "Member 'AHUDStatusPresenter::_squadMembers' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _statusBoxMap) == 0x0002A0, "Member 'AHUDStatusPresenter::_statusBoxMap' has a wrong offset!");
static_assert(offsetof(AHUDStatusPresenter, _hudResource) == 0x000300, "Member 'AHUDStatusPresenter::_hudResource' has a wrong offset!");

// Class InGameModule.CollisionMonitoring
// 0x0000 (0x0028 - 0x0028)
class ICollisionMonitoring final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionMonitoring">();
	}
	static class ICollisionMonitoring* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICollisionMonitoring>();
	}
};
static_assert(alignof(ICollisionMonitoring) == 0x000008, "Wrong alignment on ICollisionMonitoring");
static_assert(sizeof(ICollisionMonitoring) == 0x000028, "Wrong size on ICollisionMonitoring");

// Class InGameModule.InBattleAnnounceInterface
// 0x0000 (0x0028 - 0x0028)
class IInBattleAnnounceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InBattleAnnounceInterface">();
	}
	static class IInBattleAnnounceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInBattleAnnounceInterface>();
	}
};
static_assert(alignof(IInBattleAnnounceInterface) == 0x000008, "Wrong alignment on IInBattleAnnounceInterface");
static_assert(sizeof(IInBattleAnnounceInterface) == 0x000028, "Wrong size on IInBattleAnnounceInterface");

// Class InGameModule.InBattleAnnouncePresenter
// 0x0090 (0x0360 - 0x02D0)
class AInBattleAnnouncePresenter final : public AMultiWidgetCreator
{
public:
	uint8                                         Pad_2D0[0x58];                                     // 0x02D0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UAutoChatComponent*                     _autoChatComponent;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPoisonMistManagerComponent*            _poisonMistManager;                                // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _playerState;                                      // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameOption*                            _gameOption;                                       // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InBattleAnnouncePresenter">();
	}
	static class AInBattleAnnouncePresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInBattleAnnouncePresenter>();
	}
};
static_assert(alignof(AInBattleAnnouncePresenter) == 0x000008, "Wrong alignment on AInBattleAnnouncePresenter");
static_assert(sizeof(AInBattleAnnouncePresenter) == 0x000360, "Wrong size on AInBattleAnnouncePresenter");
static_assert(offsetof(AInBattleAnnouncePresenter, _autoChatComponent) == 0x000328, "Member 'AInBattleAnnouncePresenter::_autoChatComponent' has a wrong offset!");
static_assert(offsetof(AInBattleAnnouncePresenter, _poisonMistManager) == 0x000330, "Member 'AInBattleAnnouncePresenter::_poisonMistManager' has a wrong offset!");
static_assert(offsetof(AInBattleAnnouncePresenter, _playerState) == 0x000348, "Member 'AInBattleAnnouncePresenter::_playerState' has a wrong offset!");
static_assert(offsetof(AInBattleAnnouncePresenter, _gameOption) == 0x000350, "Member 'AInBattleAnnouncePresenter::_gameOption' has a wrong offset!");

// Class InGameModule.InBattlePlayerNotificationInterface
// 0x0000 (0x0028 - 0x0028)
class IInBattlePlayerNotificationInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InBattlePlayerNotificationInterface">();
	}
	static class IInBattlePlayerNotificationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInBattlePlayerNotificationInterface>();
	}
};
static_assert(alignof(IInBattlePlayerNotificationInterface) == 0x000008, "Wrong alignment on IInBattlePlayerNotificationInterface");
static_assert(sizeof(IInBattlePlayerNotificationInterface) == 0x000028, "Wrong size on IInBattlePlayerNotificationInterface");

// Class InGameModule.InBattlePlayerNotificationPresenter
// 0x0028 (0x02F8 - 0x02D0)
class AInBattlePlayerNotificationPresenter final : public AMultiWidgetCreator
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHerovsGameState*                       _gameState;                                        // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _localPlayerState;                                 // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LeadersKOSetUp(ELeadersBattleTeamType Team, int32 Score, int32 PrevScore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InBattlePlayerNotificationPresenter">();
	}
	static class AInBattlePlayerNotificationPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInBattlePlayerNotificationPresenter>();
	}
};
static_assert(alignof(AInBattlePlayerNotificationPresenter) == 0x000008, "Wrong alignment on AInBattlePlayerNotificationPresenter");
static_assert(sizeof(AInBattlePlayerNotificationPresenter) == 0x0002F8, "Wrong size on AInBattlePlayerNotificationPresenter");
static_assert(offsetof(AInBattlePlayerNotificationPresenter, _gameState) == 0x0002D8, "Member 'AInBattlePlayerNotificationPresenter::_gameState' has a wrong offset!");
static_assert(offsetof(AInBattlePlayerNotificationPresenter, _localPlayerState) == 0x0002E0, "Member 'AInBattlePlayerNotificationPresenter::_localPlayerState' has a wrong offset!");
static_assert(offsetof(AInBattlePlayerNotificationPresenter, _playerController) == 0x0002E8, "Member 'AInBattlePlayerNotificationPresenter::_playerController' has a wrong offset!");

// Class InGameModule.InGameAbilityWidget
// 0x0038 (0x0388 - 0x0350)
class UInGameAbilityWidget final : public UWidgetBase
{
public:
	class UAbilityIconWidget*                     _abilityIcon;                                      // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityWidget*                         _ability;                                          // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityLevelListWidget*                _abilityLevelList;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillDerivedWidget*                    _skillDerived;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _abilityIndex;                                     // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_374[0x14];                                     // 0x0374(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EAttackId BP_GetAttackId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAbilityWidget">();
	}
	static class UInGameAbilityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAbilityWidget>();
	}
};
static_assert(alignof(UInGameAbilityWidget) == 0x000008, "Wrong alignment on UInGameAbilityWidget");
static_assert(sizeof(UInGameAbilityWidget) == 0x000388, "Wrong size on UInGameAbilityWidget");
static_assert(offsetof(UInGameAbilityWidget, _abilityIcon) == 0x000350, "Member 'UInGameAbilityWidget::_abilityIcon' has a wrong offset!");
static_assert(offsetof(UInGameAbilityWidget, _ability) == 0x000358, "Member 'UInGameAbilityWidget::_ability' has a wrong offset!");
static_assert(offsetof(UInGameAbilityWidget, _abilityLevelList) == 0x000360, "Member 'UInGameAbilityWidget::_abilityLevelList' has a wrong offset!");
static_assert(offsetof(UInGameAbilityWidget, _skillDerived) == 0x000368, "Member 'UInGameAbilityWidget::_skillDerived' has a wrong offset!");
static_assert(offsetof(UInGameAbilityWidget, _abilityIndex) == 0x000370, "Member 'UInGameAbilityWidget::_abilityIndex' has a wrong offset!");

// Class InGameModule.InGameButtonGuide
// 0x0030 (0x0380 - 0x0350)
class UInGameButtonGuide final : public UWidgetBase
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _commandHudComponent;                              // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _holdGauge;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _bag;                                              // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _bugBox;                                           // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _optionBox;                                        // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseSystemMenu();
	void ForceSetNewVisibilityFlag(bool NewVisibility);
	void SetGaugePercent();
	void SetSholderImage(int32 MaxSholderHolder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameButtonGuide">();
	}
	static class UInGameButtonGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameButtonGuide>();
	}
};
static_assert(alignof(UInGameButtonGuide) == 0x000008, "Wrong alignment on UInGameButtonGuide");
static_assert(sizeof(UInGameButtonGuide) == 0x000380, "Wrong size on UInGameButtonGuide");
static_assert(offsetof(UInGameButtonGuide, _playerState) == 0x000350, "Member 'UInGameButtonGuide::_playerState' has a wrong offset!");
static_assert(offsetof(UInGameButtonGuide, _commandHudComponent) == 0x000358, "Member 'UInGameButtonGuide::_commandHudComponent' has a wrong offset!");
static_assert(offsetof(UInGameButtonGuide, _holdGauge) == 0x000360, "Member 'UInGameButtonGuide::_holdGauge' has a wrong offset!");
static_assert(offsetof(UInGameButtonGuide, _bag) == 0x000368, "Member 'UInGameButtonGuide::_bag' has a wrong offset!");
static_assert(offsetof(UInGameButtonGuide, _bugBox) == 0x000370, "Member 'UInGameButtonGuide::_bugBox' has a wrong offset!");
static_assert(offsetof(UInGameButtonGuide, _optionBox) == 0x000378, "Member 'UInGameButtonGuide::_optionBox' has a wrong offset!");

// Class InGameModule.InGameCharacterWidget
// 0x0008 (0x0370 - 0x0368)
class UInGameCharacterWidget final : public UPlayerInfoBaseWidget
{
public:
	class UCharacterWidget*                       _characterWidget;                                  // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameCharacterWidget">();
	}
	static class UInGameCharacterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameCharacterWidget>();
	}
};
static_assert(alignof(UInGameCharacterWidget) == 0x000008, "Wrong alignment on UInGameCharacterWidget");
static_assert(sizeof(UInGameCharacterWidget) == 0x000370, "Wrong size on UInGameCharacterWidget");
static_assert(offsetof(UInGameCharacterWidget, _characterWidget) == 0x000368, "Member 'UInGameCharacterWidget::_characterWidget' has a wrong offset!");

// Class InGameModule.InGameCheat
// 0x0000 (0x0088 - 0x0088)
class UInGameCheat final : public UCheat
{
public:
	void ChangeCharacter(ECharacterId CharaID);
	void DEF_DMG();
	void FFOFF();
	void FFON();
	void GP_HEAL();
	void HP_HEAL();
	void NO_DMG();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameCheat">();
	}
	static class UInGameCheat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameCheat>();
	}
};
static_assert(alignof(UInGameCheat) == 0x000008, "Wrong alignment on UInGameCheat");
static_assert(sizeof(UInGameCheat) == 0x000088, "Wrong size on UInGameCheat");

// Class InGameModule.InGameCheatManager
// 0x0040 (0x00C8 - 0x0088)
class UInGameCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DiffMagazineParam(const class FString& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameCheatManager">();
	}
	static class UInGameCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameCheatManager>();
	}
};
static_assert(alignof(UInGameCheatManager) == 0x000008, "Wrong alignment on UInGameCheatManager");
static_assert(sizeof(UInGameCheatManager) == 0x0000C8, "Wrong size on UInGameCheatManager");

// Class InGameModule.InGameDecalComponent
// 0x0060 (0x02A0 - 0x0240)
class UInGameDecalComponent final : public UDecalComponent
{
public:
	EViewType                                     _viewType;                                         // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0240(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class ACharacterBattle*                       _ownerCharacter;                                   // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* SetMID(class UMaterialInstanceDynamic* Mid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameDecalComponent">();
	}
	static class UInGameDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameDecalComponent>();
	}
};
static_assert(alignof(UInGameDecalComponent) == 0x000010, "Wrong alignment on UInGameDecalComponent");
static_assert(sizeof(UInGameDecalComponent) == 0x0002A0, "Wrong size on UInGameDecalComponent");
static_assert(offsetof(UInGameDecalComponent, _viewType) == 0x000238, "Member 'UInGameDecalComponent::_viewType' has a wrong offset!");
static_assert(offsetof(UInGameDecalComponent, _graduallyAlpha) == 0x000240, "Member 'UInGameDecalComponent::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(UInGameDecalComponent, _ownerCharacter) == 0x000280, "Member 'UInGameDecalComponent::_ownerCharacter' has a wrong offset!");
static_assert(offsetof(UInGameDecalComponent, _mid) == 0x000288, "Member 'UInGameDecalComponent::_mid' has a wrong offset!");

// Class InGameModule.InGameEffectSubsystemBlueprint
// 0x0000 (0x0028 - 0x0028)
class UInGameEffectSubsystemBlueprint final : public UBlueprintFunctionLibrary
{
public:
	static class UBattleCustomParticleSystemComponent* SpawnEmitterAtLocation(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Locate, const struct FRotator& Rot, const struct FVector& Scale, bool bAutoDestroy);
	static class UBattleCustomParticleSystemComponent* SpawnEmitterAttached(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy);
	static class UBattleCustomParticleSystemComponent* SpawnEmitterAttachedLocateOnly(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameEffectSubsystemBlueprint">();
	}
	static class UInGameEffectSubsystemBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameEffectSubsystemBlueprint>();
	}
};
static_assert(alignof(UInGameEffectSubsystemBlueprint) == 0x000008, "Wrong alignment on UInGameEffectSubsystemBlueprint");
static_assert(sizeof(UInGameEffectSubsystemBlueprint) == 0x000028, "Wrong size on UInGameEffectSubsystemBlueprint");

// Class InGameModule.InGameEffectWorldPool
// 0x0010 (0x0040 - 0x0030)
class UInGameEffectWorldPool final : public UGameInstanceSubsystem
{
public:
	TArray<class UParticleSystemComponent*>       _emptyParticleTbl;                                 // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameEffectWorldPool">();
	}
	static class UInGameEffectWorldPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameEffectWorldPool>();
	}
};
static_assert(alignof(UInGameEffectWorldPool) == 0x000008, "Wrong alignment on UInGameEffectWorldPool");
static_assert(sizeof(UInGameEffectWorldPool) == 0x000040, "Wrong size on UInGameEffectWorldPool");
static_assert(offsetof(UInGameEffectWorldPool, _emptyParticleTbl) == 0x000030, "Member 'UInGameEffectWorldPool::_emptyParticleTbl' has a wrong offset!");

// Class InGameModule.InGameInventoryWidget
// 0x0170 (0x0558 - 0x03E8)
class UInGameInventoryWidget final : public UAppWidget
{
public:
	struct FLinearColor                           _activeFrameColor;                                 // 0x03E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _deactivateFrameColor;                             // 0x03F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _activeFrameSize;                                  // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deactivateFrameSize;                              // 0x040C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlatformWidgetButton*                  _buttonGuidDropShoulder;                           // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformWidgetButton*                  _buttonGuidSwapShoulder;                           // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformWidgetButton*                  _buttonGuidCloseShoulder;                          // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformWidgetButton*                  _buttonGuidDecisionShoulder;                       // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                _shoulderButtonGuideBackGround;                    // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _buttonGuideCanvas;                                // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x58];                                     // 0x0450(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryItemShoulderWidget*           _supplyShoulderWidget;                             // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryAbilityWidget*                _abilityWidget;                                    // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventorySkillWidget*                  _skillWidget;                                      // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventorySupplyDropArea*               _supplyDropAreaWidget;                             // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemWidget*                            _selectedSupplyWidget;                             // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppWidget*                             _currentDragWidget;                                // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x30];                                     // 0x04E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerDatabaseWork*                    _pdw;                                              // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _commandHudComponent;                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHUDDispatchComponent*                  _hudDispatchComponent;                             // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppWidgetWork*                         _appWidgetWork;                                    // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	void Close();
	void CloseOnMapEnlarged();
	void OnChangeControlledPadEvent();
	void OnEndUsingSupplyEvent(const class USupplyHolder* SupplyHolder);
	class UWidget* OnFocusNavigationEventByAbility(EUINavigation InNavigation);
	class UWidget* OnFocusNavigationEventByShoulder(EUINavigation InNavigation);
	class UWidget* OnFocusNavigationEventBySkill(EUINavigation InNavigation);
	void OnInputEnterEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnInputFlipOpenOrCloseWindowEvent();
	void OnRepPlayerStateEvent(class APlayerStateBattle* PlayerState);
	void OnStartUsingSupplyEvent(const class USupplyHolder* SupplyHolder);
	void OnUpdateSupplyEvent(const TArray<class USupplyHolder*>& List);
	void Open();
	void Update(const TArray<class USupplyHolder*>& List);

	class UItemWidget* GetCanFocusFarShoulderWidget(class UWidget* CheckWidget, bool bNearWidth) const;
	class UItemWidget* GetCanFocusNearAbilityWidget(class UWidget* ShoulderWidget, EUINavigation NavigationType) const;
	class UItemWidget* GetCanFocusNearShoulderWidget(class UWidget* CheckWidget) const;
	class UItemWidget* GetCanFocusNearSkillWidget(class UWidget* ShoulderWidget, EUINavigation NavigationType) const;
	class UWidget* GetFocusByRightRowShoulderWidget(int32 HeightRow) const;
	class UItemWidget* GetNavigationCanFocusNearShoulderWidget(class UWidget* CheckWidget, EUINavigation NavigationType) const;
	EInventorySelectStatus GetSelectStatusType() const;
	class UWidget* SetFocusByRightRowBottomWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameInventoryWidget">();
	}
	static class UInGameInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameInventoryWidget>();
	}
};
static_assert(alignof(UInGameInventoryWidget) == 0x000008, "Wrong alignment on UInGameInventoryWidget");
static_assert(sizeof(UInGameInventoryWidget) == 0x000558, "Wrong size on UInGameInventoryWidget");
static_assert(offsetof(UInGameInventoryWidget, _activeFrameColor) == 0x0003E8, "Member 'UInGameInventoryWidget::_activeFrameColor' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _deactivateFrameColor) == 0x0003F8, "Member 'UInGameInventoryWidget::_deactivateFrameColor' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _activeFrameSize) == 0x000408, "Member 'UInGameInventoryWidget::_activeFrameSize' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _deactivateFrameSize) == 0x00040C, "Member 'UInGameInventoryWidget::_deactivateFrameSize' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _buttonGuidDropShoulder) == 0x000420, "Member 'UInGameInventoryWidget::_buttonGuidDropShoulder' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _buttonGuidSwapShoulder) == 0x000428, "Member 'UInGameInventoryWidget::_buttonGuidSwapShoulder' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _buttonGuidCloseShoulder) == 0x000430, "Member 'UInGameInventoryWidget::_buttonGuidCloseShoulder' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _buttonGuidDecisionShoulder) == 0x000438, "Member 'UInGameInventoryWidget::_buttonGuidDecisionShoulder' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _shoulderButtonGuideBackGround) == 0x000440, "Member 'UInGameInventoryWidget::_shoulderButtonGuideBackGround' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _buttonGuideCanvas) == 0x000448, "Member 'UInGameInventoryWidget::_buttonGuideCanvas' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _supplyShoulderWidget) == 0x0004A8, "Member 'UInGameInventoryWidget::_supplyShoulderWidget' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _abilityWidget) == 0x0004B0, "Member 'UInGameInventoryWidget::_abilityWidget' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _skillWidget) == 0x0004B8, "Member 'UInGameInventoryWidget::_skillWidget' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _supplyDropAreaWidget) == 0x0004C0, "Member 'UInGameInventoryWidget::_supplyDropAreaWidget' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _selectedSupplyWidget) == 0x0004D0, "Member 'UInGameInventoryWidget::_selectedSupplyWidget' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _currentDragWidget) == 0x0004D8, "Member 'UInGameInventoryWidget::_currentDragWidget' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _pdw) == 0x000510, "Member 'UInGameInventoryWidget::_pdw' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _playerController) == 0x000518, "Member 'UInGameInventoryWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _playerState) == 0x000520, "Member 'UInGameInventoryWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _supplyHolderComponent) == 0x000528, "Member 'UInGameInventoryWidget::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _commandHudComponent) == 0x000530, "Member 'UInGameInventoryWidget::_commandHudComponent' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _hudDispatchComponent) == 0x000538, "Member 'UInGameInventoryWidget::_hudDispatchComponent' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _localPlayerHudManager) == 0x000540, "Member 'UInGameInventoryWidget::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UInGameInventoryWidget, _appWidgetWork) == 0x000548, "Member 'UInGameInventoryWidget::_appWidgetWork' has a wrong offset!");

// Class InGameModule.InGameMiscInfo
// 0x00A0 (0x0408 - 0x0368)
class UInGameMiscInfo final : public UPlayerInfoBaseWidget
{
public:
	class UKillLogManagerComponent*               _killLogManager;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             _spectateNum;                                      // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _spectator;                                        // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_ShowUpSpectator;                               // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_LikeCountup;                                   // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _likeNum;                                          // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _like;                                             // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _koNum;                                            // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _ko;                                               // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _assistNum;                                        // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _assist;                                           // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _damageNum;                                        // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _leaderKoNum;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _koLeader;                                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _otherKoNum;                                       // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _otherKo;                                          // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInvalidationBox*                       _miscInfo;                                         // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRecvCheerEvent(int32 CheerCount, int32 LocalCheerCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameMiscInfo">();
	}
	static class UInGameMiscInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameMiscInfo>();
	}
};
static_assert(alignof(UInGameMiscInfo) == 0x000008, "Wrong alignment on UInGameMiscInfo");
static_assert(sizeof(UInGameMiscInfo) == 0x000408, "Wrong size on UInGameMiscInfo");
static_assert(offsetof(UInGameMiscInfo, _killLogManager) == 0x000368, "Member 'UInGameMiscInfo::_killLogManager' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _spectateNum) == 0x000388, "Member 'UInGameMiscInfo::_spectateNum' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _spectator) == 0x000390, "Member 'UInGameMiscInfo::_spectator' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, Ani_ShowUpSpectator) == 0x000398, "Member 'UInGameMiscInfo::Ani_ShowUpSpectator' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, Ani_LikeCountup) == 0x0003A0, "Member 'UInGameMiscInfo::Ani_LikeCountup' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _likeNum) == 0x0003A8, "Member 'UInGameMiscInfo::_likeNum' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _like) == 0x0003B0, "Member 'UInGameMiscInfo::_like' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _koNum) == 0x0003B8, "Member 'UInGameMiscInfo::_koNum' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _ko) == 0x0003C0, "Member 'UInGameMiscInfo::_ko' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _assistNum) == 0x0003C8, "Member 'UInGameMiscInfo::_assistNum' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _assist) == 0x0003D0, "Member 'UInGameMiscInfo::_assist' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _damageNum) == 0x0003D8, "Member 'UInGameMiscInfo::_damageNum' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _leaderKoNum) == 0x0003E0, "Member 'UInGameMiscInfo::_leaderKoNum' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _koLeader) == 0x0003E8, "Member 'UInGameMiscInfo::_koLeader' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _otherKoNum) == 0x0003F0, "Member 'UInGameMiscInfo::_otherKoNum' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _otherKo) == 0x0003F8, "Member 'UInGameMiscInfo::_otherKo' has a wrong offset!");
static_assert(offsetof(UInGameMiscInfo, _miscInfo) == 0x000400, "Member 'UInGameMiscInfo::_miscInfo' has a wrong offset!");

// Class InGameModule.ParticleSystemSurfacePack
// 0x0000 (0x0200 - 0x0200)
class UParticleSystemSurfacePack final : public USceneComponent
{
public:
	class UDataTable*                             _particleSet;                                      // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemSurfacePack">();
	}
	static class UParticleSystemSurfacePack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemSurfacePack>();
	}
};
static_assert(alignof(UParticleSystemSurfacePack) == 0x000010, "Wrong alignment on UParticleSystemSurfacePack");
static_assert(sizeof(UParticleSystemSurfacePack) == 0x000200, "Wrong size on UParticleSystemSurfacePack");
static_assert(offsetof(UParticleSystemSurfacePack, _particleSet) == 0x0001F8, "Member 'UParticleSystemSurfacePack::_particleSet' has a wrong offset!");

// Class InGameModule.InGameStatics
// 0x0000 (0x0028 - 0x0028)
class UInGameStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckWorldStatics(class UObject* WorldContextObject, const struct FVector& StartLocation, const struct FVector& EndLocation, float SphereRadius, TArray<struct FHitResult>* ResultHits, const TArray<class AActor*>& IgnoreList, EDrawDebugTrace DrawDebugType);
	static float GetGroundHeight(class UObject* WorldContextObject, const struct FVector& StartLocation, float CheckDistance, bool bCheckNormal, class AActor** HitActor, const TArray<class AActor*>& IgnoreList, class UCapsuleComponent* Capsule);
	static float GetGroundHeightFromParam(class UObject* WorldContextObject, class AActor** HitActor, const struct FGroundCheckParam& Param);
	static ESurfaceType GetHitSurfaceType(const struct FHitResult& ResultHit);
	static float GetPlaneDegree(const struct FVector& Normal);
	static ESurfaceType GetSurfaceType(class UObject* WorldContextObject, const struct FVector& StartLocation, const struct FVector& EndLocation, float SphereRadius, struct FHitResult* ResultHit, const TArray<class AActor*>& IgnoreList);
	static class FString MakeCharacterJsonPath(ECharacterId CharacterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameStatics">();
	}
	static class UInGameStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameStatics>();
	}
};
static_assert(alignof(UInGameStatics) == 0x000008, "Wrong alignment on UInGameStatics");
static_assert(sizeof(UInGameStatics) == 0x000028, "Wrong size on UInGameStatics");

// Class InGameModule.InGameSystemMenu
// 0x0000 (0x03E8 - 0x03E8)
class UInGameSystemMenu final : public UAppWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameSystemMenu">();
	}
	static class UInGameSystemMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameSystemMenu>();
	}
};
static_assert(alignof(UInGameSystemMenu) == 0x000008, "Wrong alignment on UInGameSystemMenu");
static_assert(sizeof(UInGameSystemMenu) == 0x0003E8, "Wrong size on UInGameSystemMenu");

// Class InGameModule.InteractTargetComponent
// 0x0080 (0x0130 - 0x00B0)
class UInteractTargetComponent final : public UActorComponent
{
public:
	class USphereComponent*                       _hitShape;                                         // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInteractType                                 _type;                                             // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x67];                                      // 0x00B9(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterInteractComponent*            _negotiator;                                       // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACommunicationPinActor*                 _markerActor;                                      // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractTargetComponent">();
	}
	static class UInteractTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractTargetComponent>();
	}
};
static_assert(alignof(UInteractTargetComponent) == 0x000008, "Wrong alignment on UInteractTargetComponent");
static_assert(sizeof(UInteractTargetComponent) == 0x000130, "Wrong size on UInteractTargetComponent");
static_assert(offsetof(UInteractTargetComponent, _hitShape) == 0x0000B0, "Member 'UInteractTargetComponent::_hitShape' has a wrong offset!");
static_assert(offsetof(UInteractTargetComponent, _type) == 0x0000B8, "Member 'UInteractTargetComponent::_type' has a wrong offset!");
static_assert(offsetof(UInteractTargetComponent, _negotiator) == 0x000120, "Member 'UInteractTargetComponent::_negotiator' has a wrong offset!");
static_assert(offsetof(UInteractTargetComponent, _markerActor) == 0x000128, "Member 'UInteractTargetComponent::_markerActor' has a wrong offset!");

// Class InGameModule.InterractTarget
// 0x0000 (0x0028 - 0x0028)
class IInterractTarget final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterractTarget">();
	}
	static class IInterractTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterractTarget>();
	}
};
static_assert(alignof(IInterractTarget) == 0x000008, "Wrong alignment on IInterractTarget");
static_assert(sizeof(IInterractTarget) == 0x000028, "Wrong size on IInterractTarget");

// Class InGameModule.InventoryAbilityEffectWidget
// 0x0018 (0x0368 - 0x0350)
class UInventoryAbilityEffectWidget final : public UWidgetBase
{
public:
	class UHorizontalBox*                         _upHorizontalBox;                                  // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         _downHorizontalBox;                                // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        _swapButtonGuideSwitcher;                          // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAbilityEffectWidget">();
	}
	static class UInventoryAbilityEffectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAbilityEffectWidget>();
	}
};
static_assert(alignof(UInventoryAbilityEffectWidget) == 0x000008, "Wrong alignment on UInventoryAbilityEffectWidget");
static_assert(sizeof(UInventoryAbilityEffectWidget) == 0x000368, "Wrong size on UInventoryAbilityEffectWidget");
static_assert(offsetof(UInventoryAbilityEffectWidget, _upHorizontalBox) == 0x000350, "Member 'UInventoryAbilityEffectWidget::_upHorizontalBox' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityEffectWidget, _downHorizontalBox) == 0x000358, "Member 'UInventoryAbilityEffectWidget::_downHorizontalBox' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityEffectWidget, _swapButtonGuideSwitcher) == 0x000360, "Member 'UInventoryAbilityEffectWidget::_swapButtonGuideSwitcher' has a wrong offset!");

// Class InGameModule.InventoryEquipmentBaseWidget
// 0x00E0 (0x04C8 - 0x03E8)
class UInventoryEquipmentBaseWidget : public UAppWidget
{
public:
	uint8                                         Pad_3E8[0x28];                                     // 0x03E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetButton*                          _buttonGuidDecisionShoulder;                       // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x58];                                     // 0x0418(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetButton*                          _buttonGuidClose;                                  // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetButton*                          _buttonGuidSwap;                                   // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetButton*                          _buttonGuidDrop;                                   // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                _buttonGuideBackGround;                            // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USupply*                                _currentSelectShoulderSupply;                      // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USupplyHolder*                          _currentSelectSupplyHolder;                        // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _frameMaterialInstanceDynamic;                     // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItemWidget*>                    _supplyWidgetList;                                 // 0x04B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UInGameInventoryWidget*                 _ownerInventoryWidget;                             // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryEquipmentBaseWidget">();
	}
	static class UInventoryEquipmentBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryEquipmentBaseWidget>();
	}
};
static_assert(alignof(UInventoryEquipmentBaseWidget) == 0x000008, "Wrong alignment on UInventoryEquipmentBaseWidget");
static_assert(sizeof(UInventoryEquipmentBaseWidget) == 0x0004C8, "Wrong size on UInventoryEquipmentBaseWidget");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _buttonGuidDecisionShoulder) == 0x000410, "Member 'UInventoryEquipmentBaseWidget::_buttonGuidDecisionShoulder' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _buttonGuidClose) == 0x000470, "Member 'UInventoryEquipmentBaseWidget::_buttonGuidClose' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _buttonGuidSwap) == 0x000478, "Member 'UInventoryEquipmentBaseWidget::_buttonGuidSwap' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _buttonGuidDrop) == 0x000480, "Member 'UInventoryEquipmentBaseWidget::_buttonGuidDrop' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _buttonGuideBackGround) == 0x000488, "Member 'UInventoryEquipmentBaseWidget::_buttonGuideBackGround' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _currentSelectShoulderSupply) == 0x000490, "Member 'UInventoryEquipmentBaseWidget::_currentSelectShoulderSupply' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _currentSelectSupplyHolder) == 0x000498, "Member 'UInventoryEquipmentBaseWidget::_currentSelectSupplyHolder' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _frameMaterialInstanceDynamic) == 0x0004A0, "Member 'UInventoryEquipmentBaseWidget::_frameMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _supplyWidgetList) == 0x0004B0, "Member 'UInventoryEquipmentBaseWidget::_supplyWidgetList' has a wrong offset!");
static_assert(offsetof(UInventoryEquipmentBaseWidget, _ownerInventoryWidget) == 0x0004C0, "Member 'UInventoryEquipmentBaseWidget::_ownerInventoryWidget' has a wrong offset!");

// Class InGameModule.InventoryAbilityWidget
// 0x00B8 (0x0580 - 0x04C8)
class UInventoryAbilityWidget final : public UInventoryEquipmentBaseWidget
{
public:
	class UUniformGridPanel*                      _supplyUniformGridPanel;                           // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supply_1;                                         // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supply_2;                                         // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _backGround;                                       // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryAbilityEffectWidget*          _effectWidget;                                     // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryAbilityEffectWidget*          _effectWidget_1;                                   // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _displayNameTextBlock;                             // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _displayNameTextBlock_1;                           // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _requestSwitcher;                                  // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryRequestIconWidget*            _inventoryRequest_0;                               // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryRequestIconWidget*            _inventoryRequest_1;                               // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInventoryRequestIconWidget*>    _inventoryRequestIconList;                         // 0x0530(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _pdw;                                              // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _focusIn;                                          // 0x0548(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _focusOut;                                         // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _selectItemWidget;                                 // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInventoryAbilityEffectWidget*>  _abilityEffectList;                                // 0x0560(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     _abilityEffectDisplayNameList;                     // 0x0570(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnBeginUseAbilityEvent(class UAbilityHolder* Ability);
	void OnEndUseAbilityEvent(class UAbilityHolder* Ability);
	void OnFocusEvent(class UAppWidget* Widget);
	void OnRemoveFocusEvent(class UAppWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAbilityWidget">();
	}
	static class UInventoryAbilityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAbilityWidget>();
	}
};
static_assert(alignof(UInventoryAbilityWidget) == 0x000008, "Wrong alignment on UInventoryAbilityWidget");
static_assert(sizeof(UInventoryAbilityWidget) == 0x000580, "Wrong size on UInventoryAbilityWidget");
static_assert(offsetof(UInventoryAbilityWidget, _supplyUniformGridPanel) == 0x0004C8, "Member 'UInventoryAbilityWidget::_supplyUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _supply_1) == 0x0004D0, "Member 'UInventoryAbilityWidget::_supply_1' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _supply_2) == 0x0004D8, "Member 'UInventoryAbilityWidget::_supply_2' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _backGround) == 0x0004E0, "Member 'UInventoryAbilityWidget::_backGround' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _effectWidget) == 0x0004E8, "Member 'UInventoryAbilityWidget::_effectWidget' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _effectWidget_1) == 0x0004F0, "Member 'UInventoryAbilityWidget::_effectWidget_1' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _playerController) == 0x0004F8, "Member 'UInventoryAbilityWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _playerState) == 0x000500, "Member 'UInventoryAbilityWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _displayNameTextBlock) == 0x000508, "Member 'UInventoryAbilityWidget::_displayNameTextBlock' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _displayNameTextBlock_1) == 0x000510, "Member 'UInventoryAbilityWidget::_displayNameTextBlock_1' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _requestSwitcher) == 0x000518, "Member 'UInventoryAbilityWidget::_requestSwitcher' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _inventoryRequest_0) == 0x000520, "Member 'UInventoryAbilityWidget::_inventoryRequest_0' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _inventoryRequest_1) == 0x000528, "Member 'UInventoryAbilityWidget::_inventoryRequest_1' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _inventoryRequestIconList) == 0x000530, "Member 'UInventoryAbilityWidget::_inventoryRequestIconList' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _pdw) == 0x000540, "Member 'UInventoryAbilityWidget::_pdw' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _focusIn) == 0x000548, "Member 'UInventoryAbilityWidget::_focusIn' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _focusOut) == 0x000550, "Member 'UInventoryAbilityWidget::_focusOut' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _selectItemWidget) == 0x000558, "Member 'UInventoryAbilityWidget::_selectItemWidget' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _abilityEffectList) == 0x000560, "Member 'UInventoryAbilityWidget::_abilityEffectList' has a wrong offset!");
static_assert(offsetof(UInventoryAbilityWidget, _abilityEffectDisplayNameList) == 0x000570, "Member 'UInventoryAbilityWidget::_abilityEffectDisplayNameList' has a wrong offset!");

// Class InGameModule.InventoryAllyShoulderWidget
// 0x0008 (0x03F0 - 0x03E8)
class UInventoryAllyShoulderWidget final : public UAppWidget
{
public:
	class UWidgetSwitcher*                        _shoulderSwitcher;                                 // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAllyShoulderWidget">();
	}
	static class UInventoryAllyShoulderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAllyShoulderWidget>();
	}
};
static_assert(alignof(UInventoryAllyShoulderWidget) == 0x000008, "Wrong alignment on UInventoryAllyShoulderWidget");
static_assert(sizeof(UInventoryAllyShoulderWidget) == 0x0003F0, "Wrong size on UInventoryAllyShoulderWidget");
static_assert(offsetof(UInventoryAllyShoulderWidget, _shoulderSwitcher) == 0x0003E8, "Member 'UInventoryAllyShoulderWidget::_shoulderSwitcher' has a wrong offset!");

// Class InGameModule.InventoryAllySkillListWidget
// 0x0080 (0x0468 - 0x03E8)
class UInventoryAllySkillListWidget final : public UAppWidget
{
public:
	TArray<class APlayerStateBattle*>             _squadMemberPlayerStateBattleList;                 // 0x03E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class APlayerStateBattle*                     _statusBoxPlayerState;                             // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerStateBattle*                     _ownerPlayerState;                                 // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInventoryAllySkillWidgetInfo          _playerSkillInfo;                                  // 0x0408(0x0010)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInventoryAllySkillInfo>        _allySkillInfo;                                    // 0x0418(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _playerCanvasPanel;                                // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryAllySkillWidget*              _playerSkillUnique1;                               // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryAllySkillWidget*              _playerSkillUnique2;                               // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryAllySkillWidget*              _playerSkillUnique3;                               // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryAllyShoulderWidget*           _shoulderIcon;                                     // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHudCommandControlComponent*            _commandHudComponent;                              // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRepOwnerPlayerStateEvent(class APlayerStateBattle* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAllySkillListWidget">();
	}
	static class UInventoryAllySkillListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAllySkillListWidget>();
	}
};
static_assert(alignof(UInventoryAllySkillListWidget) == 0x000008, "Wrong alignment on UInventoryAllySkillListWidget");
static_assert(sizeof(UInventoryAllySkillListWidget) == 0x000468, "Wrong size on UInventoryAllySkillListWidget");
static_assert(offsetof(UInventoryAllySkillListWidget, _squadMemberPlayerStateBattleList) == 0x0003E8, "Member 'UInventoryAllySkillListWidget::_squadMemberPlayerStateBattleList' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _statusBoxPlayerState) == 0x0003F8, "Member 'UInventoryAllySkillListWidget::_statusBoxPlayerState' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _ownerPlayerState) == 0x000400, "Member 'UInventoryAllySkillListWidget::_ownerPlayerState' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _playerSkillInfo) == 0x000408, "Member 'UInventoryAllySkillListWidget::_playerSkillInfo' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _allySkillInfo) == 0x000418, "Member 'UInventoryAllySkillListWidget::_allySkillInfo' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _playerCanvasPanel) == 0x000428, "Member 'UInventoryAllySkillListWidget::_playerCanvasPanel' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _playerSkillUnique1) == 0x000430, "Member 'UInventoryAllySkillListWidget::_playerSkillUnique1' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _playerSkillUnique2) == 0x000438, "Member 'UInventoryAllySkillListWidget::_playerSkillUnique2' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _playerSkillUnique3) == 0x000440, "Member 'UInventoryAllySkillListWidget::_playerSkillUnique3' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _shoulderIcon) == 0x000448, "Member 'UInventoryAllySkillListWidget::_shoulderIcon' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _commandHudComponent) == 0x000450, "Member 'UInventoryAllySkillListWidget::_commandHudComponent' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillListWidget, _localPlayerHudManager) == 0x000458, "Member 'UInventoryAllySkillListWidget::_localPlayerHudManager' has a wrong offset!");

// Class InGameModule.InventoryAllySkillWidget
// 0x00C0 (0x04A8 - 0x03E8)
class UInventoryAllySkillWidget final : public UAppWidget
{
public:
	class UImage*                                 _baseIcon;                                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _abilityTypeIcon;                                  // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _attackID;                                         // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityLevelCounter*                   _abilityLevelCounter;                              // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAttackId, class UMaterialInstance*>     _baseMaterialList;                                 // 0x0408(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EAttackId, class UMaterialInstanceDynamic*> _baseDynamicMaterialList;                          // 0x0458(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAllySkillWidget">();
	}
	static class UInventoryAllySkillWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAllySkillWidget>();
	}
};
static_assert(alignof(UInventoryAllySkillWidget) == 0x000008, "Wrong alignment on UInventoryAllySkillWidget");
static_assert(sizeof(UInventoryAllySkillWidget) == 0x0004A8, "Wrong size on UInventoryAllySkillWidget");
static_assert(offsetof(UInventoryAllySkillWidget, _baseIcon) == 0x0003E8, "Member 'UInventoryAllySkillWidget::_baseIcon' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillWidget, _abilityTypeIcon) == 0x0003F0, "Member 'UInventoryAllySkillWidget::_abilityTypeIcon' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillWidget, _attackID) == 0x0003F8, "Member 'UInventoryAllySkillWidget::_attackID' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillWidget, _abilityLevelCounter) == 0x000400, "Member 'UInventoryAllySkillWidget::_abilityLevelCounter' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillWidget, _baseMaterialList) == 0x000408, "Member 'UInventoryAllySkillWidget::_baseMaterialList' has a wrong offset!");
static_assert(offsetof(UInventoryAllySkillWidget, _baseDynamicMaterialList) == 0x000458, "Member 'UInventoryAllySkillWidget::_baseDynamicMaterialList' has a wrong offset!");

// Class InGameModule.ShoulderSupplyEntryData
// 0x0078 (0x00A0 - 0x0028)
class UShoulderSupplyEntryData final : public UObject
{
public:
	ESupplyType                                   _supplyType;                                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperSprite*                           _supplyIcon;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPaperSprite*                           _abilityTypeIcon;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMdAbilityType                                _typeAsAbility;                                    // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _displayName;                                      // 0x0048(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   _displayDescription;                               // 0x0060(0x0018)(NativeAccessSpecifierPublic)
	int32                                         _sortPriority;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _originIndex;                                      // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _stackCount;                                       // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxStack;                                         // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _abilityLevel;                                     // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _shoulderLevelIndex;                               // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bUsing;                                           // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyHolder*                          _supplyHolder;                                     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShoulderSupplyEntryData">();
	}
	static class UShoulderSupplyEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShoulderSupplyEntryData>();
	}
};
static_assert(alignof(UShoulderSupplyEntryData) == 0x000008, "Wrong alignment on UShoulderSupplyEntryData");
static_assert(sizeof(UShoulderSupplyEntryData) == 0x0000A0, "Wrong size on UShoulderSupplyEntryData");
static_assert(offsetof(UShoulderSupplyEntryData, _supplyType) == 0x000028, "Member 'UShoulderSupplyEntryData::_supplyType' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _supplyIcon) == 0x000030, "Member 'UShoulderSupplyEntryData::_supplyIcon' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _abilityTypeIcon) == 0x000038, "Member 'UShoulderSupplyEntryData::_abilityTypeIcon' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _attackID) == 0x000040, "Member 'UShoulderSupplyEntryData::_attackID' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _typeAsAbility) == 0x000041, "Member 'UShoulderSupplyEntryData::_typeAsAbility' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _displayName) == 0x000048, "Member 'UShoulderSupplyEntryData::_displayName' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _displayDescription) == 0x000060, "Member 'UShoulderSupplyEntryData::_displayDescription' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _sortPriority) == 0x000078, "Member 'UShoulderSupplyEntryData::_sortPriority' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _originIndex) == 0x00007C, "Member 'UShoulderSupplyEntryData::_originIndex' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _stackCount) == 0x000080, "Member 'UShoulderSupplyEntryData::_stackCount' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _maxStack) == 0x000084, "Member 'UShoulderSupplyEntryData::_maxStack' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _abilityLevel) == 0x000088, "Member 'UShoulderSupplyEntryData::_abilityLevel' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _shoulderLevelIndex) == 0x00008C, "Member 'UShoulderSupplyEntryData::_shoulderLevelIndex' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _bUsing) == 0x000090, "Member 'UShoulderSupplyEntryData::_bUsing' has a wrong offset!");
static_assert(offsetof(UShoulderSupplyEntryData, _supplyHolder) == 0x000098, "Member 'UShoulderSupplyEntryData::_supplyHolder' has a wrong offset!");

// Class InGameModule.ShoulderSupplyEntryList
// 0x0010 (0x0038 - 0x0028)
class UShoulderSupplyEntryList final : public UObject
{
public:
	TArray<class UShoulderSupplyEntryData*>       _supplyEntryShoulderData;                          // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShoulderSupplyEntryList">();
	}
	static class UShoulderSupplyEntryList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShoulderSupplyEntryList>();
	}
};
static_assert(alignof(UShoulderSupplyEntryList) == 0x000008, "Wrong alignment on UShoulderSupplyEntryList");
static_assert(sizeof(UShoulderSupplyEntryList) == 0x000038, "Wrong size on UShoulderSupplyEntryList");
static_assert(offsetof(UShoulderSupplyEntryList, _supplyEntryShoulderData) == 0x000028, "Member 'UShoulderSupplyEntryList::_supplyEntryShoulderData' has a wrong offset!");

// Class InGameModule.InventoryItemShoulderWidget
// 0x01F0 (0x05D8 - 0x03E8)
class UInventoryItemShoulderWidget final : public UAppWidget
{
public:
	class UInGameInventoryWidget*                 _ownerInventoryWidget;                             // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      _gridPanel;                                        // 0x03F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        _mainWindowWidgetSwitcher;                         // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      _currentLevelGridPanel;                            // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           _autoLevelUpToggle;                                // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _backGround_0;                                     // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _backGround_1;                                     // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _backGround_2;                                     // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _backGround_3;                                     // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         _backGroundList;                                   // 0x0430(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWidgetButton*                          _buttonGuidDecisionShoulder;                       // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x58];                                     // 0x0448(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetButton*                          _buttonGuidSwap;                                   // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetButton*                          _buttonGuidClose;                                  // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetButton*                          _buttonGuidDrop;                                   // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                _buttonGuideBackGround;                            // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusIn_0;                                        // 0x04C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusOut_0;                                       // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusIn_1;                                        // 0x04D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusOut_1;                                       // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusIn_2;                                        // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusOut_2;                                       // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusIn_3;                                        // 0x04F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusOut_3;                                       // 0x04F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidgetAnimation*>               _focusInList;                                      // 0x0500(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidgetAnimation*>               _focusOutList;                                     // 0x0510(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 _elementWidthNum;                                  // 0x0520(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 _elementHeightNum;                                 // 0x0530(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           _descriptionPanel;                                 // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _supplyNameTextBlock;                              // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _supplyDescriptionTextBlock;                       // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _abilityDescriptionTextBlock;                      // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _abilityTypeImage;                                 // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        _descriptionWidgetSwitcher;                        // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UShoulderSupplyEntryList*>       _supplyEntryDataList;                              // 0x0570(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UShoulderSupplyEntryList*>       _sortedSupplyEntryDataList;                        // 0x0580(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x10];                                     // 0x0590(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerDatabaseWork*                    _pdw;                                              // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerControllerBattle*                _playerController;                                 // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerStateBattle*                     _playerState;                                      // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x20];                                     // 0x05B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndUsingSupplyEvent(const class USupplyHolder* SupplyHolder);
	void OnFocusEvent(class UAppWidget* Widget);
	void OnInputFlipOpenWindowEvent();
	void OnShoulderBagUpdateEvent();
	void OnStartUsingSupplyEvent(const class USupplyHolder* SupplyHolder);

	void OnInputDropItemEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryItemShoulderWidget">();
	}
	static class UInventoryItemShoulderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryItemShoulderWidget>();
	}
};
static_assert(alignof(UInventoryItemShoulderWidget) == 0x000008, "Wrong alignment on UInventoryItemShoulderWidget");
static_assert(sizeof(UInventoryItemShoulderWidget) == 0x0005D8, "Wrong size on UInventoryItemShoulderWidget");
static_assert(offsetof(UInventoryItemShoulderWidget, _ownerInventoryWidget) == 0x0003E8, "Member 'UInventoryItemShoulderWidget::_ownerInventoryWidget' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _gridPanel) == 0x0003F0, "Member 'UInventoryItemShoulderWidget::_gridPanel' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _mainWindowWidgetSwitcher) == 0x0003F8, "Member 'UInventoryItemShoulderWidget::_mainWindowWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _currentLevelGridPanel) == 0x000400, "Member 'UInventoryItemShoulderWidget::_currentLevelGridPanel' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _autoLevelUpToggle) == 0x000408, "Member 'UInventoryItemShoulderWidget::_autoLevelUpToggle' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _backGround_0) == 0x000410, "Member 'UInventoryItemShoulderWidget::_backGround_0' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _backGround_1) == 0x000418, "Member 'UInventoryItemShoulderWidget::_backGround_1' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _backGround_2) == 0x000420, "Member 'UInventoryItemShoulderWidget::_backGround_2' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _backGround_3) == 0x000428, "Member 'UInventoryItemShoulderWidget::_backGround_3' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _backGroundList) == 0x000430, "Member 'UInventoryItemShoulderWidget::_backGroundList' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _buttonGuidDecisionShoulder) == 0x000440, "Member 'UInventoryItemShoulderWidget::_buttonGuidDecisionShoulder' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _buttonGuidSwap) == 0x0004A0, "Member 'UInventoryItemShoulderWidget::_buttonGuidSwap' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _buttonGuidClose) == 0x0004A8, "Member 'UInventoryItemShoulderWidget::_buttonGuidClose' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _buttonGuidDrop) == 0x0004B0, "Member 'UInventoryItemShoulderWidget::_buttonGuidDrop' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _buttonGuideBackGround) == 0x0004B8, "Member 'UInventoryItemShoulderWidget::_buttonGuideBackGround' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusIn_0) == 0x0004C0, "Member 'UInventoryItemShoulderWidget::_focusIn_0' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusOut_0) == 0x0004C8, "Member 'UInventoryItemShoulderWidget::_focusOut_0' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusIn_1) == 0x0004D0, "Member 'UInventoryItemShoulderWidget::_focusIn_1' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusOut_1) == 0x0004D8, "Member 'UInventoryItemShoulderWidget::_focusOut_1' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusIn_2) == 0x0004E0, "Member 'UInventoryItemShoulderWidget::_focusIn_2' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusOut_2) == 0x0004E8, "Member 'UInventoryItemShoulderWidget::_focusOut_2' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusIn_3) == 0x0004F0, "Member 'UInventoryItemShoulderWidget::_focusIn_3' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusOut_3) == 0x0004F8, "Member 'UInventoryItemShoulderWidget::_focusOut_3' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusInList) == 0x000500, "Member 'UInventoryItemShoulderWidget::_focusInList' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _focusOutList) == 0x000510, "Member 'UInventoryItemShoulderWidget::_focusOutList' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _elementWidthNum) == 0x000520, "Member 'UInventoryItemShoulderWidget::_elementWidthNum' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _elementHeightNum) == 0x000530, "Member 'UInventoryItemShoulderWidget::_elementHeightNum' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _descriptionPanel) == 0x000540, "Member 'UInventoryItemShoulderWidget::_descriptionPanel' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _supplyNameTextBlock) == 0x000548, "Member 'UInventoryItemShoulderWidget::_supplyNameTextBlock' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _supplyDescriptionTextBlock) == 0x000550, "Member 'UInventoryItemShoulderWidget::_supplyDescriptionTextBlock' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _abilityDescriptionTextBlock) == 0x000558, "Member 'UInventoryItemShoulderWidget::_abilityDescriptionTextBlock' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _abilityTypeImage) == 0x000560, "Member 'UInventoryItemShoulderWidget::_abilityTypeImage' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _descriptionWidgetSwitcher) == 0x000568, "Member 'UInventoryItemShoulderWidget::_descriptionWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _supplyEntryDataList) == 0x000570, "Member 'UInventoryItemShoulderWidget::_supplyEntryDataList' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _sortedSupplyEntryDataList) == 0x000580, "Member 'UInventoryItemShoulderWidget::_sortedSupplyEntryDataList' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _pdw) == 0x0005A0, "Member 'UInventoryItemShoulderWidget::_pdw' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _playerController) == 0x0005A8, "Member 'UInventoryItemShoulderWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UInventoryItemShoulderWidget, _playerState) == 0x0005B0, "Member 'UInventoryItemShoulderWidget::_playerState' has a wrong offset!");

// Class InGameModule.InventorySkillWidget
// 0x0100 (0x05C8 - 0x04C8)
class UInventorySkillWidget final : public UInventoryEquipmentBaseWidget
{
public:
	class UPlayerDatabaseWork*                    _pdw;                                              // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUniformGridPanel*                      _supplyUniformGridPanel;                           // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supply_1;                                         // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supply_2;                                         // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supply_3;                                         // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _skillBackGround;                                  // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _backGround;                                       // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _unique1TextBlock;                                 // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _unique2TextBlock;                                 // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _unique3TextBlock;                                 // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryAbilityEffectWidget*          _effectWidget_0;                                   // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryAbilityEffectWidget*          _effectWidget_1;                                   // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryAbilityEffectWidget*          _effectWidget_2;                                   // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInventoryAbilityEffectWidget*>  _abilityEffectList;                                // 0x0540(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _requestSwitcher;                                  // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryRequestIconWidget*            _inventoryRequest_0;                               // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryRequestIconWidget*            _inventoryRequest_1;                               // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryRequestIconWidget*            _inventoryRequest_2;                               // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInventoryRequestIconWidget*>    _inventoryRequestIconList;                         // 0x0570(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniIn;                                            // 0x0580(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniIdle;                                          // 0x0588(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniOut;                                           // 0x0590(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _focusIn;                                          // 0x0598(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _focusOut;                                         // 0x05A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _selectItemWidget;                                 // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     _uniqueSkillTextBlockList;                         // 0x05B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x8];                                      // 0x05C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationFinished_Implementation(const class UWidgetAnimation* InAnimation);
	void OnFocusEvent(class UAppWidget* Widget);
	void OnRemoveFocusEvent(class UAppWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySkillWidget">();
	}
	static class UInventorySkillWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventorySkillWidget>();
	}
};
static_assert(alignof(UInventorySkillWidget) == 0x000008, "Wrong alignment on UInventorySkillWidget");
static_assert(sizeof(UInventorySkillWidget) == 0x0005C8, "Wrong size on UInventorySkillWidget");
static_assert(offsetof(UInventorySkillWidget, _pdw) == 0x0004C8, "Member 'UInventorySkillWidget::_pdw' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _supplyUniformGridPanel) == 0x0004D0, "Member 'UInventorySkillWidget::_supplyUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _supply_1) == 0x0004D8, "Member 'UInventorySkillWidget::_supply_1' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _supply_2) == 0x0004E0, "Member 'UInventorySkillWidget::_supply_2' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _supply_3) == 0x0004E8, "Member 'UInventorySkillWidget::_supply_3' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _skillBackGround) == 0x0004F0, "Member 'UInventorySkillWidget::_skillBackGround' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _backGround) == 0x0004F8, "Member 'UInventorySkillWidget::_backGround' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _playerController) == 0x000500, "Member 'UInventorySkillWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _playerState) == 0x000508, "Member 'UInventorySkillWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _unique1TextBlock) == 0x000510, "Member 'UInventorySkillWidget::_unique1TextBlock' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _unique2TextBlock) == 0x000518, "Member 'UInventorySkillWidget::_unique2TextBlock' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _unique3TextBlock) == 0x000520, "Member 'UInventorySkillWidget::_unique3TextBlock' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _effectWidget_0) == 0x000528, "Member 'UInventorySkillWidget::_effectWidget_0' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _effectWidget_1) == 0x000530, "Member 'UInventorySkillWidget::_effectWidget_1' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _effectWidget_2) == 0x000538, "Member 'UInventorySkillWidget::_effectWidget_2' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _abilityEffectList) == 0x000540, "Member 'UInventorySkillWidget::_abilityEffectList' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _requestSwitcher) == 0x000550, "Member 'UInventorySkillWidget::_requestSwitcher' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _inventoryRequest_0) == 0x000558, "Member 'UInventorySkillWidget::_inventoryRequest_0' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _inventoryRequest_1) == 0x000560, "Member 'UInventorySkillWidget::_inventoryRequest_1' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _inventoryRequest_2) == 0x000568, "Member 'UInventorySkillWidget::_inventoryRequest_2' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _inventoryRequestIconList) == 0x000570, "Member 'UInventorySkillWidget::_inventoryRequestIconList' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _aniIn) == 0x000580, "Member 'UInventorySkillWidget::_aniIn' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _aniIdle) == 0x000588, "Member 'UInventorySkillWidget::_aniIdle' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _aniOut) == 0x000590, "Member 'UInventorySkillWidget::_aniOut' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _focusIn) == 0x000598, "Member 'UInventorySkillWidget::_focusIn' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _focusOut) == 0x0005A0, "Member 'UInventorySkillWidget::_focusOut' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _selectItemWidget) == 0x0005A8, "Member 'UInventorySkillWidget::_selectItemWidget' has a wrong offset!");
static_assert(offsetof(UInventorySkillWidget, _uniqueSkillTextBlockList) == 0x0005B0, "Member 'UInventorySkillWidget::_uniqueSkillTextBlockList' has a wrong offset!");

// Class InGameModule.InventorySupplyDropArea
// 0x0030 (0x04B8 - 0x0488)
class UInventorySupplyDropArea final : public UWidgetButton
{
public:
	uint8                                         Pad_488[0x18];                                     // 0x0488(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       _focusIn;                                          // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _focusOut;                                         // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_1;                                           // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayDustBoxAnimation();
	void StopDustBoxAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySupplyDropArea">();
	}
	static class UInventorySupplyDropArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventorySupplyDropArea>();
	}
};
static_assert(alignof(UInventorySupplyDropArea) == 0x000008, "Wrong alignment on UInventorySupplyDropArea");
static_assert(sizeof(UInventorySupplyDropArea) == 0x0004B8, "Wrong size on UInventorySupplyDropArea");
static_assert(offsetof(UInventorySupplyDropArea, _focusIn) == 0x0004A0, "Member 'UInventorySupplyDropArea::_focusIn' has a wrong offset!");
static_assert(offsetof(UInventorySupplyDropArea, _focusOut) == 0x0004A8, "Member 'UInventorySupplyDropArea::_focusOut' has a wrong offset!");
static_assert(offsetof(UInventorySupplyDropArea, Frame_1) == 0x0004B0, "Member 'UInventorySupplyDropArea::Frame_1' has a wrong offset!");

// Class InGameModule.ItemWidget
// 0x03E8 (0x0870 - 0x0488)
class UItemWidget final : public UWidgetButton
{
public:
	uint8                                         Pad_488[0xB0];                                     // 0x0488(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttackId, class UMaterialInstance*>     _baseMaterialList;                                 // 0x0538(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EAttackId, class UMaterialInstance*>     _captureSkillMaterialList;                         // 0x0588(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EAttackId, class UMaterialInstance*>     _characterFaceMaterialList;                        // 0x05D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EAttackId, class UMaterialInstanceDynamic*> _baseDynamicMaterialList;                          // 0x0628(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EAttackId, class UMaterialInstanceDynamic*> _captureSkillDynamicMaterialList;                  // 0x0678(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EAttackId, class UMaterialInstanceDynamic*> _characterFaceDynamicMaterialList;                 // 0x06C8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EAttackId, class UTexture2D*>            _dotImageList;                                     // 0x0718(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UOverlay*                               _overlay;                                          // 0x0768(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _backGround;                                       // 0x0770(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _itemIcon;                                         // 0x0778(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _skillCardBase;                                    // 0x0780(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _skillDotImage;                                    // 0x0788(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _skillFaceImage;                                   // 0x0790(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _attackID;                                         // 0x0798(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityLevelCounter*                   _levelCounter;                                     // 0x07A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _reserveSelect;                                    // 0x07A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _abilityTypeIcon;                                  // 0x07B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _roleTypeImage;                                    // 0x07B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _stackNumber;                                      // 0x07C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _stackMaxNumber;                                   // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         _stackNumberHorizontalBox;                         // 0x07D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _abilityTime;                                      // 0x07D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetLocalizeLayout*                  _abilityTimeText;                                  // 0x07E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _topConceal;                                       // 0x07E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _useProgressTimer;                                 // 0x07F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _useProgressMaterialInstance;                      // 0x07F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _sortPriority;                                     // 0x0800(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_804[0x24];                                     // 0x0804(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperSprite*                           _currentPaperSprite;                               // 0x0828(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_830[0x12];                                     // 0x0830(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	EInventoryWidgetType                          _inventoryWidgetType;                              // 0x0842(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_843[0x1];                                      // 0x0843(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _supplyIndex;                                      // 0x0844(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInGameInventoryWidget*                 _inventoryWidget;                                  // 0x0848(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _ani_LvUp;                                         // 0x0850(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       _ani_LvUpShortcut;                                 // 0x0858(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USupplyHolder*                          _supplyHolder;                                     // 0x0860(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ChangeAbilityIcon(class UPaperSprite* InPaperSprite, uint8 AbilityType, EAttackId AttackId, float Level, bool IsSkillIcon);
	void BP_ChangeSupplyIcon(class UPaperSprite* InPaperSprite, const int32 StackCount, const int32 MaxStack);
	void OnDecideEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDropEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnFocusEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnPressEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnRemovedFocusEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void SetDragVisual(bool bDragVisual);

	bool CanFocusWidget() const;
	EMdAbilityType GetAbilityType() const;
	EAttackId GetCurrentAttackId() const;
	int32 GetCurrentLevel() const;
	class UPaperSprite* GetCurrentPaperSprite() const;
	int32 GetCurrentSupplyStackCont() const;
	int32 GetMaxSupplyStackCount() const;
	float GetProgressSeconds() const;
	EInventorySelectStatus GetSelectType() const;
	EInventoryWidgetType GetSelectWidgetType() const;
	bool IsAbilityIcon() const;
	bool IsAvatarCharacter() const;
	bool IsFaceIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWidget">();
	}
	static class UItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWidget>();
	}
};
static_assert(alignof(UItemWidget) == 0x000008, "Wrong alignment on UItemWidget");
static_assert(sizeof(UItemWidget) == 0x000870, "Wrong size on UItemWidget");
static_assert(offsetof(UItemWidget, _baseMaterialList) == 0x000538, "Member 'UItemWidget::_baseMaterialList' has a wrong offset!");
static_assert(offsetof(UItemWidget, _captureSkillMaterialList) == 0x000588, "Member 'UItemWidget::_captureSkillMaterialList' has a wrong offset!");
static_assert(offsetof(UItemWidget, _characterFaceMaterialList) == 0x0005D8, "Member 'UItemWidget::_characterFaceMaterialList' has a wrong offset!");
static_assert(offsetof(UItemWidget, _baseDynamicMaterialList) == 0x000628, "Member 'UItemWidget::_baseDynamicMaterialList' has a wrong offset!");
static_assert(offsetof(UItemWidget, _captureSkillDynamicMaterialList) == 0x000678, "Member 'UItemWidget::_captureSkillDynamicMaterialList' has a wrong offset!");
static_assert(offsetof(UItemWidget, _characterFaceDynamicMaterialList) == 0x0006C8, "Member 'UItemWidget::_characterFaceDynamicMaterialList' has a wrong offset!");
static_assert(offsetof(UItemWidget, _dotImageList) == 0x000718, "Member 'UItemWidget::_dotImageList' has a wrong offset!");
static_assert(offsetof(UItemWidget, _overlay) == 0x000768, "Member 'UItemWidget::_overlay' has a wrong offset!");
static_assert(offsetof(UItemWidget, _backGround) == 0x000770, "Member 'UItemWidget::_backGround' has a wrong offset!");
static_assert(offsetof(UItemWidget, _itemIcon) == 0x000778, "Member 'UItemWidget::_itemIcon' has a wrong offset!");
static_assert(offsetof(UItemWidget, _skillCardBase) == 0x000780, "Member 'UItemWidget::_skillCardBase' has a wrong offset!");
static_assert(offsetof(UItemWidget, _skillDotImage) == 0x000788, "Member 'UItemWidget::_skillDotImage' has a wrong offset!");
static_assert(offsetof(UItemWidget, _skillFaceImage) == 0x000790, "Member 'UItemWidget::_skillFaceImage' has a wrong offset!");
static_assert(offsetof(UItemWidget, _attackID) == 0x000798, "Member 'UItemWidget::_attackID' has a wrong offset!");
static_assert(offsetof(UItemWidget, _levelCounter) == 0x0007A0, "Member 'UItemWidget::_levelCounter' has a wrong offset!");
static_assert(offsetof(UItemWidget, _reserveSelect) == 0x0007A8, "Member 'UItemWidget::_reserveSelect' has a wrong offset!");
static_assert(offsetof(UItemWidget, _abilityTypeIcon) == 0x0007B0, "Member 'UItemWidget::_abilityTypeIcon' has a wrong offset!");
static_assert(offsetof(UItemWidget, _roleTypeImage) == 0x0007B8, "Member 'UItemWidget::_roleTypeImage' has a wrong offset!");
static_assert(offsetof(UItemWidget, _stackNumber) == 0x0007C0, "Member 'UItemWidget::_stackNumber' has a wrong offset!");
static_assert(offsetof(UItemWidget, _stackMaxNumber) == 0x0007C8, "Member 'UItemWidget::_stackMaxNumber' has a wrong offset!");
static_assert(offsetof(UItemWidget, _stackNumberHorizontalBox) == 0x0007D0, "Member 'UItemWidget::_stackNumberHorizontalBox' has a wrong offset!");
static_assert(offsetof(UItemWidget, _abilityTime) == 0x0007D8, "Member 'UItemWidget::_abilityTime' has a wrong offset!");
static_assert(offsetof(UItemWidget, _abilityTimeText) == 0x0007E0, "Member 'UItemWidget::_abilityTimeText' has a wrong offset!");
static_assert(offsetof(UItemWidget, _topConceal) == 0x0007E8, "Member 'UItemWidget::_topConceal' has a wrong offset!");
static_assert(offsetof(UItemWidget, _useProgressTimer) == 0x0007F0, "Member 'UItemWidget::_useProgressTimer' has a wrong offset!");
static_assert(offsetof(UItemWidget, _useProgressMaterialInstance) == 0x0007F8, "Member 'UItemWidget::_useProgressMaterialInstance' has a wrong offset!");
static_assert(offsetof(UItemWidget, _sortPriority) == 0x000800, "Member 'UItemWidget::_sortPriority' has a wrong offset!");
static_assert(offsetof(UItemWidget, _currentPaperSprite) == 0x000828, "Member 'UItemWidget::_currentPaperSprite' has a wrong offset!");
static_assert(offsetof(UItemWidget, _inventoryWidgetType) == 0x000842, "Member 'UItemWidget::_inventoryWidgetType' has a wrong offset!");
static_assert(offsetof(UItemWidget, _supplyIndex) == 0x000844, "Member 'UItemWidget::_supplyIndex' has a wrong offset!");
static_assert(offsetof(UItemWidget, _inventoryWidget) == 0x000848, "Member 'UItemWidget::_inventoryWidget' has a wrong offset!");
static_assert(offsetof(UItemWidget, _ani_LvUp) == 0x000850, "Member 'UItemWidget::_ani_LvUp' has a wrong offset!");
static_assert(offsetof(UItemWidget, _ani_LvUpShortcut) == 0x000858, "Member 'UItemWidget::_ani_LvUpShortcut' has a wrong offset!");
static_assert(offsetof(UItemWidget, _supplyHolder) == 0x000860, "Member 'UItemWidget::_supplyHolder' has a wrong offset!");

// Class InGameModule.KillEventParam
// 0x0088 (0x00B0 - 0x0028)
class UKillEventParam final : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillEventParam">();
	}
	static class UKillEventParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillEventParam>();
	}
};
static_assert(alignof(UKillEventParam) == 0x000008, "Wrong alignment on UKillEventParam");
static_assert(sizeof(UKillEventParam) == 0x0000B0, "Wrong size on UKillEventParam");

// Class InGameModule.KillLogChildWidget
// 0x0280 (0x05D0 - 0x0350)
class UKillLogChildWidget final : public UWidgetBase
{
public:
	class UWidgetSwitcher*                        _murdererSwitcher;                                 // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _noMurdererIcon;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpacer*                                _leftKOSpacer;                                     // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           _timerHandle;                                      // 0x0368(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killLogLifeTime;                                  // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             _murdererNameTextBlock;                            // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _deadmanNameTextBlock;                             // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _allyKillColor;                                    // 0x0388(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _allyDeathColor;                                   // 0x0398(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _enemyColor;                                       // 0x03A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _otherSquadAllyColor;                              // 0x03B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               _murdererKillCountOverlay;                         // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _murdererKillCountDigit10;                         // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _murdererKillCountDigit1;                          // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _deadmanKillCountDigit10;                          // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _deadmanKillCountDigit1;                           // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _crownBrush;                                       // 0x03F0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _stormBrush;                                       // 0x04C0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	class UImage*                                 _murdererFace;                                     // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _deathFace;                                        // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _charaFaceMat;                                     // 0x05A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _murdererFaceDynamic;                              // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _deadmanFaceDynamic;                               // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResourceDataAsset;                             // 0x05B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _slideInAnim;                                      // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Vanish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillLogChildWidget">();
	}
	static class UKillLogChildWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillLogChildWidget>();
	}
};
static_assert(alignof(UKillLogChildWidget) == 0x000010, "Wrong alignment on UKillLogChildWidget");
static_assert(sizeof(UKillLogChildWidget) == 0x0005D0, "Wrong size on UKillLogChildWidget");
static_assert(offsetof(UKillLogChildWidget, _murdererSwitcher) == 0x000350, "Member 'UKillLogChildWidget::_murdererSwitcher' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _noMurdererIcon) == 0x000358, "Member 'UKillLogChildWidget::_noMurdererIcon' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _leftKOSpacer) == 0x000360, "Member 'UKillLogChildWidget::_leftKOSpacer' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _timerHandle) == 0x000368, "Member 'UKillLogChildWidget::_timerHandle' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _killLogLifeTime) == 0x000370, "Member 'UKillLogChildWidget::_killLogLifeTime' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _murdererNameTextBlock) == 0x000378, "Member 'UKillLogChildWidget::_murdererNameTextBlock' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _deadmanNameTextBlock) == 0x000380, "Member 'UKillLogChildWidget::_deadmanNameTextBlock' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _allyKillColor) == 0x000388, "Member 'UKillLogChildWidget::_allyKillColor' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _allyDeathColor) == 0x000398, "Member 'UKillLogChildWidget::_allyDeathColor' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _enemyColor) == 0x0003A8, "Member 'UKillLogChildWidget::_enemyColor' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _otherSquadAllyColor) == 0x0003B8, "Member 'UKillLogChildWidget::_otherSquadAllyColor' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _murdererKillCountOverlay) == 0x0003C8, "Member 'UKillLogChildWidget::_murdererKillCountOverlay' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _murdererKillCountDigit10) == 0x0003D0, "Member 'UKillLogChildWidget::_murdererKillCountDigit10' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _murdererKillCountDigit1) == 0x0003D8, "Member 'UKillLogChildWidget::_murdererKillCountDigit1' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _deadmanKillCountDigit10) == 0x0003E0, "Member 'UKillLogChildWidget::_deadmanKillCountDigit10' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _deadmanKillCountDigit1) == 0x0003E8, "Member 'UKillLogChildWidget::_deadmanKillCountDigit1' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _crownBrush) == 0x0003F0, "Member 'UKillLogChildWidget::_crownBrush' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _stormBrush) == 0x0004C0, "Member 'UKillLogChildWidget::_stormBrush' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _murdererFace) == 0x000590, "Member 'UKillLogChildWidget::_murdererFace' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _deathFace) == 0x000598, "Member 'UKillLogChildWidget::_deathFace' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _charaFaceMat) == 0x0005A0, "Member 'UKillLogChildWidget::_charaFaceMat' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _murdererFaceDynamic) == 0x0005A8, "Member 'UKillLogChildWidget::_murdererFaceDynamic' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _deadmanFaceDynamic) == 0x0005B0, "Member 'UKillLogChildWidget::_deadmanFaceDynamic' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _hudResourceDataAsset) == 0x0005B8, "Member 'UKillLogChildWidget::_hudResourceDataAsset' has a wrong offset!");
static_assert(offsetof(UKillLogChildWidget, _slideInAnim) == 0x0005C0, "Member 'UKillLogChildWidget::_slideInAnim' has a wrong offset!");

// Class InGameModule.KillLogManagerComponent
// 0x00A0 (0x0150 - 0x00B0)
class UKillLogManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FKillLogInfo>                   _killLogInfoList;                                  // 0x00D0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<uint8, struct FKillCount>                _killCountList;                                    // 0x00E0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FTeamKillCount>                 _teamKillCounts;                                   // 0x0130(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLeadersKillCount>              _leadersKillCountInfo;                             // 0x0140(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void SetupKillLog(const struct FKillLogInfo& KillLogInfo, const TArray<struct FKillEventAssistPersona>& AssistPeople, uint8 ThisKillLogInfoIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillLogManagerComponent">();
	}
	static class UKillLogManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillLogManagerComponent>();
	}
};
static_assert(alignof(UKillLogManagerComponent) == 0x000008, "Wrong alignment on UKillLogManagerComponent");
static_assert(sizeof(UKillLogManagerComponent) == 0x000150, "Wrong size on UKillLogManagerComponent");
static_assert(offsetof(UKillLogManagerComponent, _playerDatabaseWork) == 0x0000C8, "Member 'UKillLogManagerComponent::_playerDatabaseWork' has a wrong offset!");
static_assert(offsetof(UKillLogManagerComponent, _killLogInfoList) == 0x0000D0, "Member 'UKillLogManagerComponent::_killLogInfoList' has a wrong offset!");
static_assert(offsetof(UKillLogManagerComponent, _killCountList) == 0x0000E0, "Member 'UKillLogManagerComponent::_killCountList' has a wrong offset!");
static_assert(offsetof(UKillLogManagerComponent, _teamKillCounts) == 0x000130, "Member 'UKillLogManagerComponent::_teamKillCounts' has a wrong offset!");
static_assert(offsetof(UKillLogManagerComponent, _leadersKillCountInfo) == 0x000140, "Member 'UKillLogManagerComponent::_leadersKillCountInfo' has a wrong offset!");

// Class InGameModule.KingsBattleCounter
// 0x0008 (0x0380 - 0x0378)
class UKingsBattleCounter final : public UBattleCounterBase
{
public:
	class UGenericCounter*                        _kingsCounter;                                     // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingsBattleCounter">();
	}
	static class UKingsBattleCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKingsBattleCounter>();
	}
};
static_assert(alignof(UKingsBattleCounter) == 0x000008, "Wrong alignment on UKingsBattleCounter");
static_assert(sizeof(UKingsBattleCounter) == 0x000380, "Wrong size on UKingsBattleCounter");
static_assert(offsetof(UKingsBattleCounter, _kingsCounter) == 0x000378, "Member 'UKingsBattleCounter::_kingsCounter' has a wrong offset!");

// Class InGameModule.KOMessageWidget
// 0x0018 (0x0368 - 0x0350)
class UKOMessageWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         _leadersPointBox;                                  // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _pointNum;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayKOAnim();
	void PlayKOAnim_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KOMessageWidget">();
	}
	static class UKOMessageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKOMessageWidget>();
	}
};
static_assert(alignof(UKOMessageWidget) == 0x000008, "Wrong alignment on UKOMessageWidget");
static_assert(sizeof(UKOMessageWidget) == 0x000368, "Wrong size on UKOMessageWidget");
static_assert(offsetof(UKOMessageWidget, _leadersPointBox) == 0x000358, "Member 'UKOMessageWidget::_leadersPointBox' has a wrong offset!");
static_assert(offsetof(UKOMessageWidget, _pointNum) == 0x000360, "Member 'UKOMessageWidget::_pointNum' has a wrong offset!");

// Class InGameModule.PoisonMist
// 0x0128 (0x0348 - 0x0220)
class APoisonMist : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoisonMistManagerComponent*            _poisonMistManager;                                // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APostProcessVolume*                     _poisonMistPostProcessVolume;                      // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPoisonMistTableRow>            _sizeTableRowList;                                 // 0x0238(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPoisonMistTimeTableRow>        _timeTableRowList;                                 // 0x0248(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFirstLocationData>             _firstLocationList;                                // 0x0258(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UPoisonMistDataAsset*                   _controlDataAsset;                                 // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStageCommonDataAsset*                  _stageCommonDataAsset;                             // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        _useLocationList;                                  // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x1C];                                     // 0x0288(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentPhase;                                     // 0x02A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPoisonMistStatusType                         _currentStatus;                                    // 0x02A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _startLocation;                                    // 0x02AC(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _targetLocation;                                   // 0x02B8(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    _currentLocation;                                  // 0x02C4(0x000C)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _currentScale;                                     // 0x02D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _startShrinkingSeconds;                            // 0x02D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _destScale;                                        // 0x02D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bHasDisplayingNextArea;                           // 0x02DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _materialInstanceDynamic;                          // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bStartFade;                                       // 0x02E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x4B];                                     // 0x02E9(0x004B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bBeforeShrinkNotified;                            // 0x0334(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bCompleteShrinkNotified;                          // 0x0335(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_336[0xA];                                      // 0x0336(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _staticMeshZoneWall;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_BeforeShrinkNotified();
	void OnRep_ChangePoisonMistStatus();
	void OnRep_CompleteShrinkNotified();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoisonMist">();
	}
	static class APoisonMist* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoisonMist>();
	}
};
static_assert(alignof(APoisonMist) == 0x000008, "Wrong alignment on APoisonMist");
static_assert(sizeof(APoisonMist) == 0x000348, "Wrong size on APoisonMist");
static_assert(offsetof(APoisonMist, _poisonMistManager) == 0x000228, "Member 'APoisonMist::_poisonMistManager' has a wrong offset!");
static_assert(offsetof(APoisonMist, _poisonMistPostProcessVolume) == 0x000230, "Member 'APoisonMist::_poisonMistPostProcessVolume' has a wrong offset!");
static_assert(offsetof(APoisonMist, _sizeTableRowList) == 0x000238, "Member 'APoisonMist::_sizeTableRowList' has a wrong offset!");
static_assert(offsetof(APoisonMist, _timeTableRowList) == 0x000248, "Member 'APoisonMist::_timeTableRowList' has a wrong offset!");
static_assert(offsetof(APoisonMist, _firstLocationList) == 0x000258, "Member 'APoisonMist::_firstLocationList' has a wrong offset!");
static_assert(offsetof(APoisonMist, _controlDataAsset) == 0x000268, "Member 'APoisonMist::_controlDataAsset' has a wrong offset!");
static_assert(offsetof(APoisonMist, _stageCommonDataAsset) == 0x000270, "Member 'APoisonMist::_stageCommonDataAsset' has a wrong offset!");
static_assert(offsetof(APoisonMist, _useLocationList) == 0x000278, "Member 'APoisonMist::_useLocationList' has a wrong offset!");
static_assert(offsetof(APoisonMist, _currentPhase) == 0x0002A4, "Member 'APoisonMist::_currentPhase' has a wrong offset!");
static_assert(offsetof(APoisonMist, _currentStatus) == 0x0002A8, "Member 'APoisonMist::_currentStatus' has a wrong offset!");
static_assert(offsetof(APoisonMist, _startLocation) == 0x0002AC, "Member 'APoisonMist::_startLocation' has a wrong offset!");
static_assert(offsetof(APoisonMist, _targetLocation) == 0x0002B8, "Member 'APoisonMist::_targetLocation' has a wrong offset!");
static_assert(offsetof(APoisonMist, _currentLocation) == 0x0002C4, "Member 'APoisonMist::_currentLocation' has a wrong offset!");
static_assert(offsetof(APoisonMist, _currentScale) == 0x0002D0, "Member 'APoisonMist::_currentScale' has a wrong offset!");
static_assert(offsetof(APoisonMist, _startShrinkingSeconds) == 0x0002D4, "Member 'APoisonMist::_startShrinkingSeconds' has a wrong offset!");
static_assert(offsetof(APoisonMist, _destScale) == 0x0002D8, "Member 'APoisonMist::_destScale' has a wrong offset!");
static_assert(offsetof(APoisonMist, _bHasDisplayingNextArea) == 0x0002DC, "Member 'APoisonMist::_bHasDisplayingNextArea' has a wrong offset!");
static_assert(offsetof(APoisonMist, _materialInstanceDynamic) == 0x0002E0, "Member 'APoisonMist::_materialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(APoisonMist, _bStartFade) == 0x0002E8, "Member 'APoisonMist::_bStartFade' has a wrong offset!");
static_assert(offsetof(APoisonMist, _bBeforeShrinkNotified) == 0x000334, "Member 'APoisonMist::_bBeforeShrinkNotified' has a wrong offset!");
static_assert(offsetof(APoisonMist, _bCompleteShrinkNotified) == 0x000335, "Member 'APoisonMist::_bCompleteShrinkNotified' has a wrong offset!");
static_assert(offsetof(APoisonMist, _staticMeshZoneWall) == 0x000340, "Member 'APoisonMist::_staticMeshZoneWall' has a wrong offset!");

// Class InGameModule.LeadersBattlePoisonMist
// 0x0008 (0x0350 - 0x0348)
class ALeadersBattlePoisonMist final : public APoisonMist
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersBattlePoisonMist">();
	}
	static class ALeadersBattlePoisonMist* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALeadersBattlePoisonMist>();
	}
};
static_assert(alignof(ALeadersBattlePoisonMist) == 0x000008, "Wrong alignment on ALeadersBattlePoisonMist");
static_assert(sizeof(ALeadersBattlePoisonMist) == 0x000350, "Wrong size on ALeadersBattlePoisonMist");

// Class InGameModule.LeadersBattleScoreManagerComponent
// 0x0078 (0x0128 - 0x00B0)
class ULeadersBattleScoreManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x68];                                      // 0x00B0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNetLeadersBattleScoreInfo>     _serverScoreInfo;                                  // 0x0118(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRepServerScoreInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersBattleScoreManagerComponent">();
	}
	static class ULeadersBattleScoreManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeadersBattleScoreManagerComponent>();
	}
};
static_assert(alignof(ULeadersBattleScoreManagerComponent) == 0x000008, "Wrong alignment on ULeadersBattleScoreManagerComponent");
static_assert(sizeof(ULeadersBattleScoreManagerComponent) == 0x000128, "Wrong size on ULeadersBattleScoreManagerComponent");
static_assert(offsetof(ULeadersBattleScoreManagerComponent, _serverScoreInfo) == 0x000118, "Member 'ULeadersBattleScoreManagerComponent::_serverScoreInfo' has a wrong offset!");

// Class InGameModule.LeadersLastCountDownWidget
// 0x0008 (0x0358 - 0x0350)
class ULeadersLastCountDownWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayLeadersLastCountDownAnim_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersLastCountDownWidget">();
	}
	static class ULeadersLastCountDownWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeadersLastCountDownWidget>();
	}
};
static_assert(alignof(ULeadersLastCountDownWidget) == 0x000008, "Wrong alignment on ULeadersLastCountDownWidget");
static_assert(sizeof(ULeadersLastCountDownWidget) == 0x000358, "Wrong size on ULeadersLastCountDownWidget");

// Class InGameModule.LeadersManagerComponent
// 0x0040 (0x00F0 - 0x00B0)
class ULeadersManagerComponent final : public UActorComponent
{
public:
	TArray<struct FLeadersTeamInfo>               _teamList;                                         // 0x00B0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeTeamLeader_RPC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersManagerComponent">();
	}
	static class ULeadersManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeadersManagerComponent>();
	}
};
static_assert(alignof(ULeadersManagerComponent) == 0x000008, "Wrong alignment on ULeadersManagerComponent");
static_assert(sizeof(ULeadersManagerComponent) == 0x0000F0, "Wrong size on ULeadersManagerComponent");
static_assert(offsetof(ULeadersManagerComponent, _teamList) == 0x0000B0, "Member 'ULeadersManagerComponent::_teamList' has a wrong offset!");

// Class InGameModule.LeadersRankItem
// 0x0078 (0x03C8 - 0x0350)
class ULeadersRankItem final : public UWidgetBase
{
public:
	ELeadersBattleTeamType                        _trialTeam;                                        // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _playerState;                                      // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _rankBGSwitcher;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _rankNum;                                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _youIcon;                                          // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _boxBg;                                            // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _bigBoxBg;                                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _teamName;                                         // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _pointText;                                        // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _addPointText;                                     // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x19];                                     // 0x03A8(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isFirstRank;                                      // 0x03C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C2[0x6];                                      // 0x03C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayAddPoint();
	void PlayAddPoint_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersRankItem">();
	}
	static class ULeadersRankItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeadersRankItem>();
	}
};
static_assert(alignof(ULeadersRankItem) == 0x000008, "Wrong alignment on ULeadersRankItem");
static_assert(sizeof(ULeadersRankItem) == 0x0003C8, "Wrong size on ULeadersRankItem");
static_assert(offsetof(ULeadersRankItem, _trialTeam) == 0x000350, "Member 'ULeadersRankItem::_trialTeam' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _playerState) == 0x000358, "Member 'ULeadersRankItem::_playerState' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _playerController) == 0x000360, "Member 'ULeadersRankItem::_playerController' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _rankBGSwitcher) == 0x000368, "Member 'ULeadersRankItem::_rankBGSwitcher' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _rankNum) == 0x000370, "Member 'ULeadersRankItem::_rankNum' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _youIcon) == 0x000378, "Member 'ULeadersRankItem::_youIcon' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _boxBg) == 0x000380, "Member 'ULeadersRankItem::_boxBg' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _bigBoxBg) == 0x000388, "Member 'ULeadersRankItem::_bigBoxBg' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _teamName) == 0x000390, "Member 'ULeadersRankItem::_teamName' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _pointText) == 0x000398, "Member 'ULeadersRankItem::_pointText' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _addPointText) == 0x0003A0, "Member 'ULeadersRankItem::_addPointText' has a wrong offset!");
static_assert(offsetof(ULeadersRankItem, _isFirstRank) == 0x0003C1, "Member 'ULeadersRankItem::_isFirstRank' has a wrong offset!");

// Class InGameModule.LeadersRankWidget
// 0x00F8 (0x0448 - 0x0350)
class ULeadersRankWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _moveVelocity;                                     // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _trailTeamNum;                                     // 0x035C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           _mainPanel;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                _allyTeamWidgetClass;                              // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateLeadersBattle*              _localPlayerState;                                 // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameStateLeadersBattle*                _gameStateLeaders;                                 // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ELeadersBattleTeamType, class ULeadersRankItem*> _rankWidget;                                       // 0x03A0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x58];                                     // 0x03F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersRankWidget">();
	}
	static class ULeadersRankWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeadersRankWidget>();
	}
};
static_assert(alignof(ULeadersRankWidget) == 0x000008, "Wrong alignment on ULeadersRankWidget");
static_assert(sizeof(ULeadersRankWidget) == 0x000448, "Wrong size on ULeadersRankWidget");
static_assert(offsetof(ULeadersRankWidget, _moveVelocity) == 0x000358, "Member 'ULeadersRankWidget::_moveVelocity' has a wrong offset!");
static_assert(offsetof(ULeadersRankWidget, _trailTeamNum) == 0x00035C, "Member 'ULeadersRankWidget::_trailTeamNum' has a wrong offset!");
static_assert(offsetof(ULeadersRankWidget, _mainPanel) == 0x000360, "Member 'ULeadersRankWidget::_mainPanel' has a wrong offset!");
static_assert(offsetof(ULeadersRankWidget, _allyTeamWidgetClass) == 0x000380, "Member 'ULeadersRankWidget::_allyTeamWidgetClass' has a wrong offset!");
static_assert(offsetof(ULeadersRankWidget, _localPlayerState) == 0x000388, "Member 'ULeadersRankWidget::_localPlayerState' has a wrong offset!");
static_assert(offsetof(ULeadersRankWidget, _playerController) == 0x000390, "Member 'ULeadersRankWidget::_playerController' has a wrong offset!");
static_assert(offsetof(ULeadersRankWidget, _gameStateLeaders) == 0x000398, "Member 'ULeadersRankWidget::_gameStateLeaders' has a wrong offset!");
static_assert(offsetof(ULeadersRankWidget, _rankWidget) == 0x0003A0, "Member 'ULeadersRankWidget::_rankWidget' has a wrong offset!");

// Class InGameModule.LeadersTimerItem
// 0x0010 (0x0360 - 0x0350)
class ULeadersTimerItem final : public UWidgetBase
{
public:
	class UTextBlock*                             _minutes;                                          // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _seconds;                                          // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersTimerItem">();
	}
	static class ULeadersTimerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeadersTimerItem>();
	}
};
static_assert(alignof(ULeadersTimerItem) == 0x000008, "Wrong alignment on ULeadersTimerItem");
static_assert(sizeof(ULeadersTimerItem) == 0x000360, "Wrong size on ULeadersTimerItem");
static_assert(offsetof(ULeadersTimerItem, _minutes) == 0x000350, "Member 'ULeadersTimerItem::_minutes' has a wrong offset!");
static_assert(offsetof(ULeadersTimerItem, _seconds) == 0x000358, "Member 'ULeadersTimerItem::_seconds' has a wrong offset!");

// Class InGameModule.LeadersTimerWidget
// 0x0010 (0x0360 - 0x0350)
class ULeadersTimerWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULeadersTimerItem*                      _timer;                                            // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeadersTimerWidget">();
	}
	static class ULeadersTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeadersTimerWidget>();
	}
};
static_assert(alignof(ULeadersTimerWidget) == 0x000008, "Wrong alignment on ULeadersTimerWidget");
static_assert(sizeof(ULeadersTimerWidget) == 0x000360, "Wrong size on ULeadersTimerWidget");
static_assert(offsetof(ULeadersTimerWidget, _timer) == 0x000358, "Member 'ULeadersTimerWidget::_timer' has a wrong offset!");

// Class InGameModule.LevelUpGuide
// 0x0078 (0x03C8 - 0x0350)
class ULevelUpGuide final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _noPossessionColor;                                // 0x0368(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _normalColor;                                      // 0x0378(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _iconImage;                                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _holdGauge;                                        // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _timerImage;                                       // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlatformRichTextBlock*                 _acceptGuide;                                      // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _canvasPanelBase;                                  // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _stackNumber;                                      // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x4];                                      // 0x03B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxShortCutTime;                                  // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayStartAnim();
	void PlayStartAnim_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelUpGuide">();
	}
	static class ULevelUpGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelUpGuide>();
	}
};
static_assert(alignof(ULevelUpGuide) == 0x000008, "Wrong alignment on ULevelUpGuide");
static_assert(sizeof(ULevelUpGuide) == 0x0003C8, "Wrong size on ULevelUpGuide");
static_assert(offsetof(ULevelUpGuide, _supplyHolderComponent) == 0x000360, "Member 'ULevelUpGuide::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _noPossessionColor) == 0x000368, "Member 'ULevelUpGuide::_noPossessionColor' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _normalColor) == 0x000378, "Member 'ULevelUpGuide::_normalColor' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _iconImage) == 0x000388, "Member 'ULevelUpGuide::_iconImage' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _holdGauge) == 0x000390, "Member 'ULevelUpGuide::_holdGauge' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _timerImage) == 0x000398, "Member 'ULevelUpGuide::_timerImage' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _acceptGuide) == 0x0003A0, "Member 'ULevelUpGuide::_acceptGuide' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _canvasPanelBase) == 0x0003A8, "Member 'ULevelUpGuide::_canvasPanelBase' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _stackNumber) == 0x0003B0, "Member 'ULevelUpGuide::_stackNumber' has a wrong offset!");
static_assert(offsetof(ULevelUpGuide, _maxShortCutTime) == 0x0003BC, "Member 'ULevelUpGuide::_maxShortCutTime' has a wrong offset!");

// Class InGameModule.LevelUpIcon
// 0x0008 (0x0358 - 0x0350)
class ULevelUpIcon final : public UWidgetBase
{
public:
	class UPlatformRichTextBlock*                 _levelUpGuide;                                     // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayAniidleAnim();
	void PlayAniidleAnim_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelUpIcon">();
	}
	static class ULevelUpIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelUpIcon>();
	}
};
static_assert(alignof(ULevelUpIcon) == 0x000008, "Wrong alignment on ULevelUpIcon");
static_assert(sizeof(ULevelUpIcon) == 0x000358, "Wrong size on ULevelUpIcon");
static_assert(offsetof(ULevelUpIcon, _levelUpGuide) == 0x000350, "Member 'ULevelUpIcon::_levelUpGuide' has a wrong offset!");

// Class InGameModule.LevelUpShortCutBase
// 0x0080 (0x0548 - 0x04C8)
class ULevelUpShortCutBase final : public UInventoryEquipmentBaseWidget
{
public:
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _pdw;                                              // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _shortCut;                                         // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supplyAlpha;                                      // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supplyBeta;                                       // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemWidget*                            _supplyGamma;                                      // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _unique1TextBlock;                                 // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _unique2TextBlock;                                 // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _unique3TextBlock;                                 // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelUpIcon*                           _unique1LvUpIcon;                                  // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelUpIcon*                           _unique2LvUpIcon;                                  // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelUpIcon*                           _unique3LvUpIcon;                                  // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     _uniqueSkillTextBlockList;                         // 0x0538(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelUpShortCutBase">();
	}
	static class ULevelUpShortCutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelUpShortCutBase>();
	}
};
static_assert(alignof(ULevelUpShortCutBase) == 0x000008, "Wrong alignment on ULevelUpShortCutBase");
static_assert(sizeof(ULevelUpShortCutBase) == 0x000548, "Wrong size on ULevelUpShortCutBase");
static_assert(offsetof(ULevelUpShortCutBase, _supplyHolderComponent) == 0x0004C8, "Member 'ULevelUpShortCutBase::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _pdw) == 0x0004D0, "Member 'ULevelUpShortCutBase::_pdw' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _shortCut) == 0x0004D8, "Member 'ULevelUpShortCutBase::_shortCut' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _supplyAlpha) == 0x0004E0, "Member 'ULevelUpShortCutBase::_supplyAlpha' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _supplyBeta) == 0x0004E8, "Member 'ULevelUpShortCutBase::_supplyBeta' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _supplyGamma) == 0x0004F0, "Member 'ULevelUpShortCutBase::_supplyGamma' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _unique1TextBlock) == 0x0004F8, "Member 'ULevelUpShortCutBase::_unique1TextBlock' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _unique2TextBlock) == 0x000500, "Member 'ULevelUpShortCutBase::_unique2TextBlock' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _unique3TextBlock) == 0x000508, "Member 'ULevelUpShortCutBase::_unique3TextBlock' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _unique1LvUpIcon) == 0x000510, "Member 'ULevelUpShortCutBase::_unique1LvUpIcon' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _unique2LvUpIcon) == 0x000518, "Member 'ULevelUpShortCutBase::_unique2LvUpIcon' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _unique3LvUpIcon) == 0x000520, "Member 'ULevelUpShortCutBase::_unique3LvUpIcon' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _playerController) == 0x000528, "Member 'ULevelUpShortCutBase::_playerController' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _playerState) == 0x000530, "Member 'ULevelUpShortCutBase::_playerState' has a wrong offset!");
static_assert(offsetof(ULevelUpShortCutBase, _uniqueSkillTextBlockList) == 0x000538, "Member 'ULevelUpShortCutBase::_uniqueSkillTextBlockList' has a wrong offset!");

// Class InGameModule.LocalPlayerHudManager
// 0x00E8 (0x0198 - 0x00B0)
class ULocalPlayerHudManager final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHudResource*                           _hudResource;                                      // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0xD0];                                      // 0x00C8(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerHudManager">();
	}
	static class ULocalPlayerHudManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerHudManager>();
	}
};
static_assert(alignof(ULocalPlayerHudManager) == 0x000008, "Wrong alignment on ULocalPlayerHudManager");
static_assert(sizeof(ULocalPlayerHudManager) == 0x000198, "Wrong size on ULocalPlayerHudManager");
static_assert(offsetof(ULocalPlayerHudManager, _hudResource) == 0x0000C0, "Member 'ULocalPlayerHudManager::_hudResource' has a wrong offset!");

// Class InGameModule.MagazineManagementComponent
// 0x00D8 (0x0190 - 0x00B8)
class UMagazineManagementComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0xD8];                                      // 0x00B8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 BP_Consume(EAttackId AttackId, int32 Ammo);
	void BP_Empty(EAttackId AttackId);
	struct FMagazineState BP_GetMagazineState(EAttackId AttackId);
	bool BP_IsEmpty(EAttackId AttackId);
	bool BP_IsStarting(EAttackId AttackId);
	void BP_Replenishment(EAttackId AttackId);
	void BP_Shoot(EAttackId AttackId);
	void BP_Start(EAttackId AttackId, float Rate);
	void BP_Stop(EAttackId AttackId);
	void SetAmmoNum(EAttackId SlotId, int32 Ammo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagazineManagementComponent">();
	}
	static class UMagazineManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagazineManagementComponent>();
	}
};
static_assert(alignof(UMagazineManagementComponent) == 0x000008, "Wrong alignment on UMagazineManagementComponent");
static_assert(sizeof(UMagazineManagementComponent) == 0x000190, "Wrong size on UMagazineManagementComponent");

// Class InGameModule.MapBackgroundWidget
// 0x0108 (0x02D0 - 0x01C8)
class UMapBackgroundWidget final : public UWidgetDrawPrimitive
{
public:
	TScriptInterface<class IInterface>            _poisonMistInterface;                              // 0x01C8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x01D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _backGround;                                       // 0x01E0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _backgroundMaterial;                               // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _backgroundBaseMaterial;                           // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bUseMapScaleOne;                                  // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 _briefingWorld;                                    // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapBackgroundWidget">();
	}
	static class UMapBackgroundWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapBackgroundWidget>();
	}
};
static_assert(alignof(UMapBackgroundWidget) == 0x000010, "Wrong alignment on UMapBackgroundWidget");
static_assert(sizeof(UMapBackgroundWidget) == 0x0002D0, "Wrong size on UMapBackgroundWidget");
static_assert(offsetof(UMapBackgroundWidget, _poisonMistInterface) == 0x0001C8, "Member 'UMapBackgroundWidget::_poisonMistInterface' has a wrong offset!");
static_assert(offsetof(UMapBackgroundWidget, _localPlayerHudManager) == 0x0001D8, "Member 'UMapBackgroundWidget::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UMapBackgroundWidget, _backGround) == 0x0001E0, "Member 'UMapBackgroundWidget::_backGround' has a wrong offset!");
static_assert(offsetof(UMapBackgroundWidget, _backgroundMaterial) == 0x0002B0, "Member 'UMapBackgroundWidget::_backgroundMaterial' has a wrong offset!");
static_assert(offsetof(UMapBackgroundWidget, _backgroundBaseMaterial) == 0x0002B8, "Member 'UMapBackgroundWidget::_backgroundBaseMaterial' has a wrong offset!");
static_assert(offsetof(UMapBackgroundWidget, _bUseMapScaleOne) == 0x0002C0, "Member 'UMapBackgroundWidget::_bUseMapScaleOne' has a wrong offset!");
static_assert(offsetof(UMapBackgroundWidget, _briefingWorld) == 0x0002C8, "Member 'UMapBackgroundWidget::_briefingWorld' has a wrong offset!");

// Class InGameModule.MapDrawableObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IMapDrawableObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapDrawableObjectInterface">();
	}
	static class IMapDrawableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMapDrawableObjectInterface>();
	}
};
static_assert(alignof(IMapDrawableObjectInterface) == 0x000008, "Wrong alignment on IMapDrawableObjectInterface");
static_assert(sizeof(IMapDrawableObjectInterface) == 0x000028, "Wrong size on IMapDrawableObjectInterface");

// Class InGameModule.MapIconsWidget
// 0x0DF8 (0x0FC0 - 0x01C8)
class UMapIconsWidget final : public UWidgetDrawPrimitive
{
public:
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppWidgetWork*                         _appWidgetWork;                                    // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyArtInfoDataAsset*                _artInfo;                                          // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _localPlayer;                                      // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _viewPlayer;                                       // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _commandHudControlComponent;                       // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnalogInputComponent*            _analogInputComponent;                             // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0210(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bIsInExpanded;                                    // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x17];                                     // 0x0229(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterId, struct FSlateBrush>        _characterIcons;                                   // 0x0240(0x0050)(NativeAccessSpecifierPrivate)
	TMap<ECharacterId, struct FSlateBrush>        _characterBadge;                                   // 0x0290(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EMarkerType, struct FSlateBrush>         _communicationPinIcons;                            // 0x02E0(0x0050)(NativeAccessSpecifierPrivate)
	struct FVector2D                              _allyIconSize;                                     // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _myDead;                                           // 0x0340(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _sameTeamPlayer;                                   // 0x0410(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _allyForwardDirBrush;                              // 0x04E0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _king;                                             // 0x05B0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _enemy;                                            // 0x0680(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _orb;                                              // 0x0750(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FVector2D                              _mapOrbSize;                                       // 0x0820(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _plusUltra;                                        // 0x0830(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _itemBox;                                          // 0x0900(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _itemBoxSign;                                      // 0x09D0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _cameraDirection;                                  // 0x0AA0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	class AGameStateBattle*                       _gameState;                                        // 0x0B70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0B78(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _markerSize;                                       // 0x0B80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B88[0x8];                                      // 0x0B88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _markerArrow;                                      // 0x0B90(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _normalPinTint;                                    // 0x0C60(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _dangerPinTint;                                    // 0x0C88(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateFontInfo                         _senderIdFont;                                     // 0x0CB0(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _senderIdColor;                                    // 0x0D08(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _cursorBrush;                                      // 0x0D30(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateFontInfo                         _guideFont;                                        // 0x0E00(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateColor                            _guideFontColor;                                   // 0x0E58(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   _deletePinGuideText;                               // 0x0E80(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   _responseToPinGuideText;                           // 0x0E98(0x0018)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EB0[0xD0];                                     // 0x0EB0(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _guideBrushScale;                                  // 0x0F80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlatformRichTextImageDecorator*        _guideBrushRichTextDecorator;                      // 0x0F88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F90[0x30];                                     // 0x0F90(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateButtonGuide();
	void UpdateViewPlayer(class APlayerStateBattle* ViewPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconsWidget">();
	}
	static class UMapIconsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapIconsWidget>();
	}
};
static_assert(alignof(UMapIconsWidget) == 0x000010, "Wrong alignment on UMapIconsWidget");
static_assert(sizeof(UMapIconsWidget) == 0x000FC0, "Wrong size on UMapIconsWidget");
static_assert(offsetof(UMapIconsWidget, _appWidgetWork) == 0x0001D0, "Member 'UMapIconsWidget::_appWidgetWork' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _playerDatabaseWork) == 0x0001D8, "Member 'UMapIconsWidget::_playerDatabaseWork' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _hudResource) == 0x0001E0, "Member 'UMapIconsWidget::_hudResource' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _artInfo) == 0x0001E8, "Member 'UMapIconsWidget::_artInfo' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _localPlayer) == 0x0001F0, "Member 'UMapIconsWidget::_localPlayer' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _viewPlayer) == 0x0001F8, "Member 'UMapIconsWidget::_viewPlayer' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _commandHudControlComponent) == 0x000200, "Member 'UMapIconsWidget::_commandHudControlComponent' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _analogInputComponent) == 0x000208, "Member 'UMapIconsWidget::_analogInputComponent' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _localPlayerHudManager) == 0x000210, "Member 'UMapIconsWidget::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _bIsInExpanded) == 0x000228, "Member 'UMapIconsWidget::_bIsInExpanded' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _characterIcons) == 0x000240, "Member 'UMapIconsWidget::_characterIcons' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _characterBadge) == 0x000290, "Member 'UMapIconsWidget::_characterBadge' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _communicationPinIcons) == 0x0002E0, "Member 'UMapIconsWidget::_communicationPinIcons' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _allyIconSize) == 0x000330, "Member 'UMapIconsWidget::_allyIconSize' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _myDead) == 0x000340, "Member 'UMapIconsWidget::_myDead' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _sameTeamPlayer) == 0x000410, "Member 'UMapIconsWidget::_sameTeamPlayer' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _allyForwardDirBrush) == 0x0004E0, "Member 'UMapIconsWidget::_allyForwardDirBrush' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _king) == 0x0005B0, "Member 'UMapIconsWidget::_king' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _enemy) == 0x000680, "Member 'UMapIconsWidget::_enemy' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _orb) == 0x000750, "Member 'UMapIconsWidget::_orb' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _mapOrbSize) == 0x000820, "Member 'UMapIconsWidget::_mapOrbSize' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _plusUltra) == 0x000830, "Member 'UMapIconsWidget::_plusUltra' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _itemBox) == 0x000900, "Member 'UMapIconsWidget::_itemBox' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _itemBoxSign) == 0x0009D0, "Member 'UMapIconsWidget::_itemBoxSign' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _cameraDirection) == 0x000AA0, "Member 'UMapIconsWidget::_cameraDirection' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _gameState) == 0x000B70, "Member 'UMapIconsWidget::_gameState' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _playerController) == 0x000B78, "Member 'UMapIconsWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _markerSize) == 0x000B80, "Member 'UMapIconsWidget::_markerSize' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _markerArrow) == 0x000B90, "Member 'UMapIconsWidget::_markerArrow' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _normalPinTint) == 0x000C60, "Member 'UMapIconsWidget::_normalPinTint' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _dangerPinTint) == 0x000C88, "Member 'UMapIconsWidget::_dangerPinTint' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _senderIdFont) == 0x000CB0, "Member 'UMapIconsWidget::_senderIdFont' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _senderIdColor) == 0x000D08, "Member 'UMapIconsWidget::_senderIdColor' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _cursorBrush) == 0x000D30, "Member 'UMapIconsWidget::_cursorBrush' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _guideFont) == 0x000E00, "Member 'UMapIconsWidget::_guideFont' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _guideFontColor) == 0x000E58, "Member 'UMapIconsWidget::_guideFontColor' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _deletePinGuideText) == 0x000E80, "Member 'UMapIconsWidget::_deletePinGuideText' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _responseToPinGuideText) == 0x000E98, "Member 'UMapIconsWidget::_responseToPinGuideText' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _guideBrushScale) == 0x000F80, "Member 'UMapIconsWidget::_guideBrushScale' has a wrong offset!");
static_assert(offsetof(UMapIconsWidget, _guideBrushRichTextDecorator) == 0x000F88, "Member 'UMapIconsWidget::_guideBrushRichTextDecorator' has a wrong offset!");

// Class InGameModule.MapWidget
// 0x0158 (0x04C0 - 0x0368)
class UMapWidget final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _mapSize;                                          // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameOption*                            _gameOption;                                       // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppWidgetWork*                         _appWidgetWork;                                    // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x88];                                     // 0x0390(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _rMapOverlayPosition;                              // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _rMiscInfoPosition;                                // 0x0420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _lMapOverlayPosition;                              // 0x0428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _lMiscInfoPosition;                                // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOneGameSessionWork*                    _oneGameSessionWork;                               // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnalogInputComponent*            _analogInputComponent;                             // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUDDispatchComponent*                  _hudDispatchComponent;                             // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHudCommandControlComponent*            _hudCommandControlComponent;                       // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapIconsWidget*                        _icons;                                            // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapBackgroundWidget*                   _map;                                              // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformRichTextBlock*                 _placeMarkerButtonGuide;                           // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformRichTextBlock*                 _placeDoubleClickMarkerButtonGuide;                // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                _slider;                                           // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultMapScale;                                  // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerBattle*                _playerController;                                 // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x20];                                     // 0x0498(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           _flashInputTimerHandle;                            // 0x04B8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeMinimapMarkerButtonGuide();
	void DisableMapFunction();
	void InputDataDelete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWidget">();
	}
	static class UMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWidget>();
	}
};
static_assert(alignof(UMapWidget) == 0x000008, "Wrong alignment on UMapWidget");
static_assert(sizeof(UMapWidget) == 0x0004C0, "Wrong size on UMapWidget");
static_assert(offsetof(UMapWidget, _mapSize) == 0x000378, "Member 'UMapWidget::_mapSize' has a wrong offset!");
static_assert(offsetof(UMapWidget, _gameOption) == 0x000380, "Member 'UMapWidget::_gameOption' has a wrong offset!");
static_assert(offsetof(UMapWidget, _appWidgetWork) == 0x000388, "Member 'UMapWidget::_appWidgetWork' has a wrong offset!");
static_assert(offsetof(UMapWidget, _rMapOverlayPosition) == 0x000418, "Member 'UMapWidget::_rMapOverlayPosition' has a wrong offset!");
static_assert(offsetof(UMapWidget, _rMiscInfoPosition) == 0x000420, "Member 'UMapWidget::_rMiscInfoPosition' has a wrong offset!");
static_assert(offsetof(UMapWidget, _lMapOverlayPosition) == 0x000428, "Member 'UMapWidget::_lMapOverlayPosition' has a wrong offset!");
static_assert(offsetof(UMapWidget, _lMiscInfoPosition) == 0x000430, "Member 'UMapWidget::_lMiscInfoPosition' has a wrong offset!");
static_assert(offsetof(UMapWidget, _oneGameSessionWork) == 0x000438, "Member 'UMapWidget::_oneGameSessionWork' has a wrong offset!");
static_assert(offsetof(UMapWidget, _analogInputComponent) == 0x000440, "Member 'UMapWidget::_analogInputComponent' has a wrong offset!");
static_assert(offsetof(UMapWidget, _hudDispatchComponent) == 0x000448, "Member 'UMapWidget::_hudDispatchComponent' has a wrong offset!");
static_assert(offsetof(UMapWidget, _hudCommandControlComponent) == 0x000450, "Member 'UMapWidget::_hudCommandControlComponent' has a wrong offset!");
static_assert(offsetof(UMapWidget, _icons) == 0x000458, "Member 'UMapWidget::_icons' has a wrong offset!");
static_assert(offsetof(UMapWidget, _map) == 0x000460, "Member 'UMapWidget::_map' has a wrong offset!");
static_assert(offsetof(UMapWidget, _placeMarkerButtonGuide) == 0x000468, "Member 'UMapWidget::_placeMarkerButtonGuide' has a wrong offset!");
static_assert(offsetof(UMapWidget, _placeDoubleClickMarkerButtonGuide) == 0x000470, "Member 'UMapWidget::_placeDoubleClickMarkerButtonGuide' has a wrong offset!");
static_assert(offsetof(UMapWidget, _slider) == 0x000478, "Member 'UMapWidget::_slider' has a wrong offset!");
static_assert(offsetof(UMapWidget, _defaultMapScale) == 0x000480, "Member 'UMapWidget::_defaultMapScale' has a wrong offset!");
static_assert(offsetof(UMapWidget, _playerController) == 0x000488, "Member 'UMapWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UMapWidget, _localPlayerHudManager) == 0x000490, "Member 'UMapWidget::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UMapWidget, _flashInputTimerHandle) == 0x0004B8, "Member 'UMapWidget::_flashInputTimerHandle' has a wrong offset!");

// Class InGameModule.MapWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class IMapWidgetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWidgetInterface">();
	}
	static class IMapWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMapWidgetInterface>();
	}
};
static_assert(alignof(IMapWidgetInterface) == 0x000008, "Wrong alignment on IMapWidgetInterface");
static_assert(sizeof(IMapWidgetInterface) == 0x000028, "Wrong size on IMapWidgetInterface");

// Class InGameModule.MapWidgetPresenter
// 0x0040 (0x0310 - 0x02D0)
class AMapWidgetPresenter final : public AMultiWidgetCreator
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetBase*                            _miniMapInstance;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPoisonMistManagerComponent*            _poisonMistManager;                                // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerStateBattle;                                // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _viewTargetCharacter;                              // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWidgetPresenter">();
	}
	static class AMapWidgetPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapWidgetPresenter>();
	}
};
static_assert(alignof(AMapWidgetPresenter) == 0x000008, "Wrong alignment on AMapWidgetPresenter");
static_assert(sizeof(AMapWidgetPresenter) == 0x000310, "Wrong size on AMapWidgetPresenter");
static_assert(offsetof(AMapWidgetPresenter, _gameOption) == 0x0002D8, "Member 'AMapWidgetPresenter::_gameOption' has a wrong offset!");
static_assert(offsetof(AMapWidgetPresenter, _miniMapInstance) == 0x0002E0, "Member 'AMapWidgetPresenter::_miniMapInstance' has a wrong offset!");
static_assert(offsetof(AMapWidgetPresenter, _poisonMistManager) == 0x0002E8, "Member 'AMapWidgetPresenter::_poisonMistManager' has a wrong offset!");
static_assert(offsetof(AMapWidgetPresenter, _localPlayerHudManager) == 0x0002F0, "Member 'AMapWidgetPresenter::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(AMapWidgetPresenter, _playerController) == 0x0002F8, "Member 'AMapWidgetPresenter::_playerController' has a wrong offset!");
static_assert(offsetof(AMapWidgetPresenter, _playerStateBattle) == 0x000300, "Member 'AMapWidgetPresenter::_playerStateBattle' has a wrong offset!");
static_assert(offsetof(AMapWidgetPresenter, _viewTargetCharacter) == 0x000308, "Member 'AMapWidgetPresenter::_viewTargetCharacter' has a wrong offset!");

// Class InGameModule.MarkerResponseWheel
// 0x0000 (0x0390 - 0x0390)
class UMarkerResponseWheel final : public UCommandWheelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarkerResponseWheel">();
	}
	static class UMarkerResponseWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarkerResponseWheel>();
	}
};
static_assert(alignof(UMarkerResponseWheel) == 0x000008, "Wrong alignment on UMarkerResponseWheel");
static_assert(sizeof(UMarkerResponseWheel) == 0x000390, "Wrong size on UMarkerResponseWheel");

// Class InGameModule.MarkerWheel
// 0x0000 (0x0390 - 0x0390)
class UMarkerWheel final : public UCommandWheelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarkerWheel">();
	}
	static class UMarkerWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarkerWheel>();
	}
};
static_assert(alignof(UMarkerWheel) == 0x000008, "Wrong alignment on UMarkerWheel");
static_assert(sizeof(UMarkerWheel) == 0x000390, "Wrong size on UMarkerWheel");

// Class InGameModule.MaterialCurveControl
// 0x0130 (0x01E0 - 0x00B0)
class alignas(0x10) UMaterialCurveControl final : public UActorComponent
{
public:
	class UCurveFloat*                            _beginCurve;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _beginCurveTarget;                                 // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _endCurve;                                         // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _endCurveTarget;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x108];                                     // 0x00D8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceEnd();
	bool GetBeginCurveTimeRange(float* MinT, float* MaxT);
	bool GetEndCurveTimeRange(float* MinT, float* MaxT);
	void Reset();
	void SetMaterialInstanceDynamic(class UMaterialInstanceDynamic* Mid);
	void SetWaitTime(float Wait);

	bool IsEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialCurveControl">();
	}
	static class UMaterialCurveControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialCurveControl>();
	}
};
static_assert(alignof(UMaterialCurveControl) == 0x000010, "Wrong alignment on UMaterialCurveControl");
static_assert(sizeof(UMaterialCurveControl) == 0x0001E0, "Wrong size on UMaterialCurveControl");
static_assert(offsetof(UMaterialCurveControl, _beginCurve) == 0x0000B0, "Member 'UMaterialCurveControl::_beginCurve' has a wrong offset!");
static_assert(offsetof(UMaterialCurveControl, _beginCurveTarget) == 0x0000B8, "Member 'UMaterialCurveControl::_beginCurveTarget' has a wrong offset!");
static_assert(offsetof(UMaterialCurveControl, _endCurve) == 0x0000C0, "Member 'UMaterialCurveControl::_endCurve' has a wrong offset!");
static_assert(offsetof(UMaterialCurveControl, _endCurveTarget) == 0x0000C8, "Member 'UMaterialCurveControl::_endCurveTarget' has a wrong offset!");
static_assert(offsetof(UMaterialCurveControl, _mid) == 0x0000D0, "Member 'UMaterialCurveControl::_mid' has a wrong offset!");

// Class InGameModule.MovementComponentBattle
// 0x0778 (0x08B0 - 0x0138)
class alignas(0x10) UMovementComponentBattle final : public UMovementComponentDummy
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _ownerCharacterBattle;                             // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x188];                                    // 0x0148(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _currentGroundActor;                               // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _currentGroundPrimitiveComponent;                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _currentWallActor;                                 // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _currentWallPrimitiveComponent;                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  _emergencyLandingActor;                            // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x590];                                    // 0x0300(0x0590)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGrabInfo                              _grabInfo;                                         // 0x0890(0x0020)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void BP_ApplyInertia(float Span, float HorizonRate, float VerticalRate);
	void BP_ClearAllSpeeds();
	void BP_ClearAllSpeedsAndRotations();
	void BP_ClearCenterRotation(float Rate);
	void BP_ClearSpeedAccel();
	void BP_EnableGravity(bool Flag);
	float BP_GetGravitySpeed();
	float BP_GetGravitySpeedWholeRate();
	float BP_GetInertiaSpeed();
	float BP_GetMoveSpeedVirtical();
	float BP_GetSpeed();
	void BP_InheritSpeed(bool bSpeed, bool bVertical, bool bGravity, bool bInertia, bool bSlide);
	bool BP_IsSpeedAcceleration();
	void BP_RequestTeleportation(struct FVector* TargetLocation, const struct FRotator& TargetRotation, bool bIsIgnoreObstacle);
	void BP_ResetGravityCompletely();
	void BP_ResetVerticalDirection(float TurnTime);
	void BP_SetGravityRate(float Rate);
	void BP_SetGravitySpeed(float Speed);
	void BP_SetInertiaSpan(float Span);
	void BP_SetMoveDirection(const struct FVector& Direction);
	void BP_SetRootMotionScale(float Scale);
	void BP_SetSlideAdjust(const struct FVector& Direction, float Speed);
	void BP_SetSpeed(float Initial, float Accel, float Limit);
	void BP_SetSpeedDecreaseRate(float Rate);
	void BP_SetSpeedEasy(float Initial, float Last, float Span);
	void BP_SetSpeedInertia(float Initial, float Last, float Span, const struct FVector& Direction);
	void BP_SetSpeedJump(float Height, float Span);
	void BP_SetSpeedRate(float Rate);
	void BP_SetSpeedVirtical(float Initial, float Accel, float Limit);
	void BP_SetupTurnToDirection(const struct FVector& Direction, float TurnTime, EEasingFunc EasingType, float BlendExp, int32 Steps);
	void BP_SetupVerticalDirection(const struct FVector& Direction, float TurnTime, const struct FVector& RotationAxis);
	void BP_StopTurnToDirection();
	void BP_StopVertcalDirection();
	void BP_UpdateTurnDirection(const struct FVector& Direction);
	void BP_UpdateVerticalDirection(const struct FVector& Direction, const struct FVector& RotationAxis);
	void BreakBgProp_RPC_ToServer(class ABgProp* breakActor, const struct FVector_NetQuantize100& DamageLocation);
	void RequestTeleportation_ToClient(const struct FVector_NetQuantize& TargetLocation, const struct FQuat& TargetRotation);
	void RequestTeleportation_ToServer(const struct FVector_NetQuantize& TargetLocation, const struct FQuat& TargetRotation);
	void ServerMove(const struct FServerMoveArgument& Arg);

	float BP_CalculatePenaltyTimeForLand() const;
	const struct FVector BP_GetCurrentGroundNormal() const;
	const struct FVector BP_GetCurrentWallImpactNormal() const;
	const struct FVector BP_GetCurrentWallNormal() const;
	const struct FVector BP_GetCurrentWallUp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementComponentBattle">();
	}
	static class UMovementComponentBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementComponentBattle>();
	}
};
static_assert(alignof(UMovementComponentBattle) == 0x000010, "Wrong alignment on UMovementComponentBattle");
static_assert(sizeof(UMovementComponentBattle) == 0x0008B0, "Wrong size on UMovementComponentBattle");
static_assert(offsetof(UMovementComponentBattle, _ownerCharacterBattle) == 0x000140, "Member 'UMovementComponentBattle::_ownerCharacterBattle' has a wrong offset!");
static_assert(offsetof(UMovementComponentBattle, _currentGroundActor) == 0x0002D0, "Member 'UMovementComponentBattle::_currentGroundActor' has a wrong offset!");
static_assert(offsetof(UMovementComponentBattle, _currentGroundPrimitiveComponent) == 0x0002D8, "Member 'UMovementComponentBattle::_currentGroundPrimitiveComponent' has a wrong offset!");
static_assert(offsetof(UMovementComponentBattle, _currentWallActor) == 0x0002E0, "Member 'UMovementComponentBattle::_currentWallActor' has a wrong offset!");
static_assert(offsetof(UMovementComponentBattle, _currentWallPrimitiveComponent) == 0x0002E8, "Member 'UMovementComponentBattle::_currentWallPrimitiveComponent' has a wrong offset!");
static_assert(offsetof(UMovementComponentBattle, _emergencyLandingActor) == 0x0002F8, "Member 'UMovementComponentBattle::_emergencyLandingActor' has a wrong offset!");
static_assert(offsetof(UMovementComponentBattle, _grabInfo) == 0x000890, "Member 'UMovementComponentBattle::_grabInfo' has a wrong offset!");

// Class InGameModule.MultiTraceComponent
// 0x0020 (0x0220 - 0x0200)
class UMultiTraceComponent final : public USceneComponent
{
public:
	TArray<class UPrimitiveComponent*>            _childPrimitives;                                  // 0x01F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Add(class UPrimitiveComponent* Prim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiTraceComponent">();
	}
	static class UMultiTraceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiTraceComponent>();
	}
};
static_assert(alignof(UMultiTraceComponent) == 0x000010, "Wrong alignment on UMultiTraceComponent");
static_assert(sizeof(UMultiTraceComponent) == 0x000220, "Wrong size on UMultiTraceComponent");
static_assert(offsetof(UMultiTraceComponent, _childPrimitives) == 0x0001F8, "Member 'UMultiTraceComponent::_childPrimitives' has a wrong offset!");

// Class InGameModule.NegotiationTargetComponent
// 0x0008 (0x00B8 - 0x00B0)
class UNegotiationTargetComponent final : public UActorComponent
{
public:
	class AActor*                                 _negotiationOwner;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NegotiationTargetComponent">();
	}
	static class UNegotiationTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNegotiationTargetComponent>();
	}
};
static_assert(alignof(UNegotiationTargetComponent) == 0x000008, "Wrong alignment on UNegotiationTargetComponent");
static_assert(sizeof(UNegotiationTargetComponent) == 0x0000B8, "Wrong size on UNegotiationTargetComponent");
static_assert(offsetof(UNegotiationTargetComponent, _negotiationOwner) == 0x0000B0, "Member 'UNegotiationTargetComponent::_negotiationOwner' has a wrong offset!");

// Class InGameModule.NetRelevantInterface
// 0x0000 (0x0028 - 0x0028)
class INetRelevantInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetRelevantInterface">();
	}
	static class INetRelevantInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INetRelevantInterface>();
	}
};
static_assert(alignof(INetRelevantInterface) == 0x000008, "Wrong alignment on INetRelevantInterface");
static_assert(sizeof(INetRelevantInterface) == 0x000028, "Wrong size on INetRelevantInterface");

// Class InGameModule.NotifyDecalActor
// 0x0030 (0x02B0 - 0x0280)
class ANotifyDecalActor : public AHeroDecalActor
{
public:
	class UCurveFloat*                            _decalParameterCurve;                              // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _decalParameter;                                   // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _heightScale;                                      // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomZRot;                                       // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomXYScaleMin;                                 // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _randomXYScaleMax;                                 // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotifyDecalActor">();
	}
	static class ANotifyDecalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANotifyDecalActor>();
	}
};
static_assert(alignof(ANotifyDecalActor) == 0x000008, "Wrong alignment on ANotifyDecalActor");
static_assert(sizeof(ANotifyDecalActor) == 0x0002B0, "Wrong size on ANotifyDecalActor");
static_assert(offsetof(ANotifyDecalActor, _decalParameterCurve) == 0x000280, "Member 'ANotifyDecalActor::_decalParameterCurve' has a wrong offset!");
static_assert(offsetof(ANotifyDecalActor, _decalParameter) == 0x000288, "Member 'ANotifyDecalActor::_decalParameter' has a wrong offset!");
static_assert(offsetof(ANotifyDecalActor, _heightScale) == 0x000290, "Member 'ANotifyDecalActor::_heightScale' has a wrong offset!");
static_assert(offsetof(ANotifyDecalActor, _randomZRot) == 0x000294, "Member 'ANotifyDecalActor::_randomZRot' has a wrong offset!");
static_assert(offsetof(ANotifyDecalActor, _randomXYScaleMin) == 0x000298, "Member 'ANotifyDecalActor::_randomXYScaleMin' has a wrong offset!");
static_assert(offsetof(ANotifyDecalActor, _randomXYScaleMax) == 0x00029C, "Member 'ANotifyDecalActor::_randomXYScaleMax' has a wrong offset!");

// Class InGameModule.NPCCitizen
// 0x0158 (0x0400 - 0x02A8)
class alignas(0x10) ANPCCitizen final : public ACharacterDummy
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPinnedActorComponent*                  _pinnedActorComponent;                             // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableMistReductionEvent;                         // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelayInitializer*                      _delayInitializer;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ECitizenType                                  _type;                                             // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bStartDown;                                       // 0x02F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstanceCitizen*                   _animInstance;                                     // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNPCMovementComponent*                  _movement;                                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialControlComponent*              _materialControl;                                  // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _blockCollisionSphereComponent;                    // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x90];                                     // 0x0320(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNPCCitizenStateRep                    _stateRep;                                         // 0x03B0(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractTargetComponent*               _interactTargetComponent;                          // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConditionEffectDataAsset*              _conditionDataAsset;                               // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCustomParticleSystemComponent*> _spawnedParticleList;                              // 0x03D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UAtomSoundObject*                       _soundObject;                                      // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         _voiceComponent;                                   // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Replicated_state();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCCitizen">();
	}
	static class ANPCCitizen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCCitizen>();
	}
};
static_assert(alignof(ANPCCitizen) == 0x000010, "Wrong alignment on ANPCCitizen");
static_assert(sizeof(ANPCCitizen) == 0x000400, "Wrong size on ANPCCitizen");
static_assert(offsetof(ANPCCitizen, _pinnedActorComponent) == 0x0002B8, "Member 'ANPCCitizen::_pinnedActorComponent' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, bEnableMistReductionEvent) == 0x0002D8, "Member 'ANPCCitizen::bEnableMistReductionEvent' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _delayInitializer) == 0x0002E0, "Member 'ANPCCitizen::_delayInitializer' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _type) == 0x0002F8, "Member 'ANPCCitizen::_type' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _bStartDown) == 0x0002F9, "Member 'ANPCCitizen::_bStartDown' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _animInstance) == 0x000300, "Member 'ANPCCitizen::_animInstance' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _movement) == 0x000308, "Member 'ANPCCitizen::_movement' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _materialControl) == 0x000310, "Member 'ANPCCitizen::_materialControl' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _blockCollisionSphereComponent) == 0x000318, "Member 'ANPCCitizen::_blockCollisionSphereComponent' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _stateRep) == 0x0003B0, "Member 'ANPCCitizen::_stateRep' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _interactTargetComponent) == 0x0003C8, "Member 'ANPCCitizen::_interactTargetComponent' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _conditionDataAsset) == 0x0003D0, "Member 'ANPCCitizen::_conditionDataAsset' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _spawnedParticleList) == 0x0003D8, "Member 'ANPCCitizen::_spawnedParticleList' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _soundObject) == 0x0003E8, "Member 'ANPCCitizen::_soundObject' has a wrong offset!");
static_assert(offsetof(ANPCCitizen, _voiceComponent) == 0x0003F0, "Member 'ANPCCitizen::_voiceComponent' has a wrong offset!");

// Class InGameModule.NPCCitizenSpawnPoint
// 0x0008 (0x0230 - 0x0228)
class ANPCCitizenSpawnPoint final : public AStageSpawnPointBase
{
public:
	ECitizenType                                  _citizenType;                                      // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCCitizenSpawnPoint">();
	}
	static class ANPCCitizenSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCCitizenSpawnPoint>();
	}
};
static_assert(alignof(ANPCCitizenSpawnPoint) == 0x000008, "Wrong alignment on ANPCCitizenSpawnPoint");
static_assert(sizeof(ANPCCitizenSpawnPoint) == 0x000230, "Wrong size on ANPCCitizenSpawnPoint");
static_assert(offsetof(ANPCCitizenSpawnPoint, _citizenType) == 0x000228, "Member 'ANPCCitizenSpawnPoint::_citizenType' has a wrong offset!");

// Class InGameModule.NPCManagerComponent
// 0x0198 (0x0248 - 0x00B0)
class UNPCManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _InitNpcNum;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x150];                                     // 0x00B8(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _supplySpawnRateHP;                                // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             _supplySpawnRateGP;                                // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANPCCitizen*>                    _npcs;                                             // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDestroyed(class AActor* Actor);
	void PlayRecoverKotaVice();
	void RegisterNpcCharacter(class ANPCCitizen* Npcs);
	void Unregister(class ANPCCitizen* NPC);

	int32 GetCurrentNPCsNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCManagerComponent">();
	}
	static class UNPCManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCManagerComponent>();
	}
};
static_assert(alignof(UNPCManagerComponent) == 0x000008, "Wrong alignment on UNPCManagerComponent");
static_assert(sizeof(UNPCManagerComponent) == 0x000248, "Wrong size on UNPCManagerComponent");
static_assert(offsetof(UNPCManagerComponent, _InitNpcNum) == 0x0000B4, "Member 'UNPCManagerComponent::_InitNpcNum' has a wrong offset!");
static_assert(offsetof(UNPCManagerComponent, _supplySpawnRateHP) == 0x000208, "Member 'UNPCManagerComponent::_supplySpawnRateHP' has a wrong offset!");
static_assert(offsetof(UNPCManagerComponent, _supplySpawnRateGP) == 0x000210, "Member 'UNPCManagerComponent::_supplySpawnRateGP' has a wrong offset!");
static_assert(offsetof(UNPCManagerComponent, _npcs) == 0x000228, "Member 'UNPCManagerComponent::_npcs' has a wrong offset!");

// Class InGameModule.NPCMovementComponent
// 0x0138 (0x0270 - 0x0138)
class alignas(0x10) UNPCMovementComponent final : public UMovementComponentDummy
{
public:
	uint8                                         Pad_138[0x108];                                    // 0x0138(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _underCollisionActor;                              // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x28];                                     // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCMovementComponent">();
	}
	static class UNPCMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCMovementComponent>();
	}
};
static_assert(alignof(UNPCMovementComponent) == 0x000010, "Wrong alignment on UNPCMovementComponent");
static_assert(sizeof(UNPCMovementComponent) == 0x000270, "Wrong size on UNPCMovementComponent");
static_assert(offsetof(UNPCMovementComponent, _underCollisionActor) == 0x000240, "Member 'UNPCMovementComponent::_underCollisionActor' has a wrong offset!");

// Class InGameModule.NumberOnImageDrawPrimitive
// 0x0178 (0x0340 - 0x01C8)
class UNumberOnImageDrawPrimitive final : public UWidgetDrawPrimitive
{
public:
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _baseImage;                                        // 0x01D0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _numberFont;                                       // 0x02A0(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            _numberFontColor;                                  // 0x02F8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              _textAdditionalOffset;                             // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x18];                                     // 0x0328(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseImageTintColor(const struct FSlateColor& InTintColor);
	void SetNumber(int32 InInt);
	void SetNumberFontColor(const struct FSlateColor& InFontColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NumberOnImageDrawPrimitive">();
	}
	static class UNumberOnImageDrawPrimitive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNumberOnImageDrawPrimitive>();
	}
};
static_assert(alignof(UNumberOnImageDrawPrimitive) == 0x000010, "Wrong alignment on UNumberOnImageDrawPrimitive");
static_assert(sizeof(UNumberOnImageDrawPrimitive) == 0x000340, "Wrong size on UNumberOnImageDrawPrimitive");
static_assert(offsetof(UNumberOnImageDrawPrimitive, _baseImage) == 0x0001D0, "Member 'UNumberOnImageDrawPrimitive::_baseImage' has a wrong offset!");
static_assert(offsetof(UNumberOnImageDrawPrimitive, _numberFont) == 0x0002A0, "Member 'UNumberOnImageDrawPrimitive::_numberFont' has a wrong offset!");
static_assert(offsetof(UNumberOnImageDrawPrimitive, _numberFontColor) == 0x0002F8, "Member 'UNumberOnImageDrawPrimitive::_numberFontColor' has a wrong offset!");
static_assert(offsetof(UNumberOnImageDrawPrimitive, _textAdditionalOffset) == 0x000320, "Member 'UNumberOnImageDrawPrimitive::_textAdditionalOffset' has a wrong offset!");

// Class InGameModule.OneGameSessionWork
// 0x0008 (0x0038 - 0x0030)
class UOneGameSessionWork final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OneGameSessionWork">();
	}
	static class UOneGameSessionWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOneGameSessionWork>();
	}
};
static_assert(alignof(UOneGameSessionWork) == 0x000008, "Wrong alignment on UOneGameSessionWork");
static_assert(sizeof(UOneGameSessionWork) == 0x000038, "Wrong size on UOneGameSessionWork");

// Class InGameModule.OrbSpawnPoint
// 0x0000 (0x0228 - 0x0228)
class AOrbSpawnPoint final : public AStageSpawnPointBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrbSpawnPoint">();
	}
	static class AOrbSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrbSpawnPoint>();
	}
};
static_assert(alignof(AOrbSpawnPoint) == 0x000008, "Wrong alignment on AOrbSpawnPoint");
static_assert(sizeof(AOrbSpawnPoint) == 0x000228, "Wrong size on AOrbSpawnPoint");

// Class InGameModule.PinnedActorComponent
// 0x0010 (0x00C0 - 0x00B0)
class UPinnedActorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             _onPinnedActorDeactivated;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void OnPinnedActorDeactivated(class AActor* DestroyedActor);
	void PinnedActorInterfaceEvent__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PinnedActorComponent">();
	}
	static class UPinnedActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPinnedActorComponent>();
	}
};
static_assert(alignof(UPinnedActorComponent) == 0x000008, "Wrong alignment on UPinnedActorComponent");
static_assert(sizeof(UPinnedActorComponent) == 0x0000C0, "Wrong size on UPinnedActorComponent");
static_assert(offsetof(UPinnedActorComponent, _onPinnedActorDeactivated) == 0x0000B0, "Member 'UPinnedActorComponent::_onPinnedActorDeactivated' has a wrong offset!");

// Class InGameModule.PinnedActorInterface
// 0x0000 (0x0028 - 0x0028)
class IPinnedActorInterface final : public IInterface
{
public:
	struct FPinnedActorInfo GetPinnedActorInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PinnedActorInterface">();
	}
	static class IPinnedActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPinnedActorInterface>();
	}
};
static_assert(alignof(IPinnedActorInterface) == 0x000008, "Wrong alignment on IPinnedActorInterface");
static_assert(sizeof(IPinnedActorInterface) == 0x000028, "Wrong size on IPinnedActorInterface");

// Class InGameModule.PinWidget
// 0x0080 (0x03D0 - 0x0350)
class UPinWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerBattle*                _playerController;                                 // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _commandHudComponent;                              // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _upArrow;                                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _downArrow;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _rightArrow;                                       // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _leftArrow;                                        // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _abilityBaseImage;                                 // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _characterFaceMasterMaterial;                      // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _signalKindIcon;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _symbolIconSize;                                   // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _supplyPinIconMaxSizeLongSide;                     // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkillAbilityPin*                       _abilitySignal;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuideSecondActionToSignal*             _guideSecondActionToSignal;                        // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACommunicationPinActor*                 _pinActor;                                         // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RemoveThisWidget(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PinWidget">();
	}
	static class UPinWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPinWidget>();
	}
};
static_assert(alignof(UPinWidget) == 0x000008, "Wrong alignment on UPinWidget");
static_assert(sizeof(UPinWidget) == 0x0003D0, "Wrong size on UPinWidget");
static_assert(offsetof(UPinWidget, _playerController) == 0x000358, "Member 'UPinWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UPinWidget, _commandHudComponent) == 0x000360, "Member 'UPinWidget::_commandHudComponent' has a wrong offset!");
static_assert(offsetof(UPinWidget, _upArrow) == 0x000368, "Member 'UPinWidget::_upArrow' has a wrong offset!");
static_assert(offsetof(UPinWidget, _downArrow) == 0x000370, "Member 'UPinWidget::_downArrow' has a wrong offset!");
static_assert(offsetof(UPinWidget, _rightArrow) == 0x000378, "Member 'UPinWidget::_rightArrow' has a wrong offset!");
static_assert(offsetof(UPinWidget, _leftArrow) == 0x000380, "Member 'UPinWidget::_leftArrow' has a wrong offset!");
static_assert(offsetof(UPinWidget, _abilityBaseImage) == 0x000388, "Member 'UPinWidget::_abilityBaseImage' has a wrong offset!");
static_assert(offsetof(UPinWidget, _characterFaceMasterMaterial) == 0x000390, "Member 'UPinWidget::_characterFaceMasterMaterial' has a wrong offset!");
static_assert(offsetof(UPinWidget, _signalKindIcon) == 0x000398, "Member 'UPinWidget::_signalKindIcon' has a wrong offset!");
static_assert(offsetof(UPinWidget, _symbolIconSize) == 0x0003A0, "Member 'UPinWidget::_symbolIconSize' has a wrong offset!");
static_assert(offsetof(UPinWidget, _supplyPinIconMaxSizeLongSide) == 0x0003A8, "Member 'UPinWidget::_supplyPinIconMaxSizeLongSide' has a wrong offset!");
static_assert(offsetof(UPinWidget, _abilitySignal) == 0x0003B0, "Member 'UPinWidget::_abilitySignal' has a wrong offset!");
static_assert(offsetof(UPinWidget, _guideSecondActionToSignal) == 0x0003B8, "Member 'UPinWidget::_guideSecondActionToSignal' has a wrong offset!");
static_assert(offsetof(UPinWidget, _pinActor) == 0x0003C0, "Member 'UPinWidget::_pinActor' has a wrong offset!");
static_assert(offsetof(UPinWidget, _playerDatabaseWork) == 0x0003C8, "Member 'UPinWidget::_playerDatabaseWork' has a wrong offset!");

// Class InGameModule.PinWidgetComponent
// 0x0030 (0x05E0 - 0x05B0)
class UPinWidgetComponent final : public UWidgetComponent
{
public:
	uint8                                         Pad_5B0[0x30];                                     // 0x05B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PinWidgetComponent">();
	}
	static class UPinWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPinWidgetComponent>();
	}
};
static_assert(alignof(UPinWidgetComponent) == 0x000010, "Wrong alignment on UPinWidgetComponent");
static_assert(sizeof(UPinWidgetComponent) == 0x0005E0, "Wrong size on UPinWidgetComponent");

// Class InGameModule.PinWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class IPinWidgetInterface final : public IInterface
{
public:
	void ChangePinArrowDirection(EPinArrowDirection NewArrowDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PinWidgetInterface">();
	}
	static class IPinWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPinWidgetInterface>();
	}
};
static_assert(alignof(IPinWidgetInterface) == 0x000008, "Wrong alignment on IPinWidgetInterface");
static_assert(sizeof(IPinWidgetInterface) == 0x000028, "Wrong size on IPinWidgetInterface");

// Class InGameModule.PlayerAbilityWidget
// 0x0030 (0x0398 - 0x0368)
class UPlayerAbilityWidget final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _rootCanvasPanel;                                  // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityInfoWidget*                     _primeAbility;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityInfoWidget*                     _secondAbility;                                    // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _supplyAndAbilityInfo;                             // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayerChangeEvent(const class APlayerStateBattle* PlayerState);

	void AbilityEvent() const;
	void SetAbilityHolder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAbilityWidget">();
	}
	static class UPlayerAbilityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAbilityWidget>();
	}
};
static_assert(alignof(UPlayerAbilityWidget) == 0x000008, "Wrong alignment on UPlayerAbilityWidget");
static_assert(sizeof(UPlayerAbilityWidget) == 0x000398, "Wrong size on UPlayerAbilityWidget");
static_assert(offsetof(UPlayerAbilityWidget, _supplyHolderComponent) == 0x000370, "Member 'UPlayerAbilityWidget::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(UPlayerAbilityWidget, _rootCanvasPanel) == 0x000378, "Member 'UPlayerAbilityWidget::_rootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UPlayerAbilityWidget, _primeAbility) == 0x000380, "Member 'UPlayerAbilityWidget::_primeAbility' has a wrong offset!");
static_assert(offsetof(UPlayerAbilityWidget, _secondAbility) == 0x000388, "Member 'UPlayerAbilityWidget::_secondAbility' has a wrong offset!");
static_assert(offsetof(UPlayerAbilityWidget, _supplyAndAbilityInfo) == 0x000390, "Member 'UPlayerAbilityWidget::_supplyAndAbilityInfo' has a wrong offset!");

// Class InGameModule.PlayerBuffWidget
// 0x0030 (0x0380 - 0x0350)
class UPlayerBuffWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x18];                                     // 0x0350(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBorder*                                _bgBase;                                           // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _name;                                             // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpStart(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerBuffWidget">();
	}
	static class UPlayerBuffWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerBuffWidget>();
	}
};
static_assert(alignof(UPlayerBuffWidget) == 0x000008, "Wrong alignment on UPlayerBuffWidget");
static_assert(sizeof(UPlayerBuffWidget) == 0x000380, "Wrong size on UPlayerBuffWidget");
static_assert(offsetof(UPlayerBuffWidget, _bgBase) == 0x000368, "Member 'UPlayerBuffWidget::_bgBase' has a wrong offset!");
static_assert(offsetof(UPlayerBuffWidget, _name) == 0x000370, "Member 'UPlayerBuffWidget::_name' has a wrong offset!");

// Class InGameModule.PlayerCameraManagerBattle
// 0x0010 (0x2820 - 0x2810)
class APlayerCameraManagerBattle final : public APlayerCameraManager
{
public:
	class USphereComponent*                       _checkWaterComponent;                              // 0x2810(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2818[0x8];                                     // 0x2818(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginUnderwaterEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndUnderwaterEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraManagerBattle">();
	}
	static class APlayerCameraManagerBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCameraManagerBattle>();
	}
};
static_assert(alignof(APlayerCameraManagerBattle) == 0x000010, "Wrong alignment on APlayerCameraManagerBattle");
static_assert(sizeof(APlayerCameraManagerBattle) == 0x002820, "Wrong size on APlayerCameraManagerBattle");
static_assert(offsetof(APlayerCameraManagerBattle, _checkWaterComponent) == 0x002810, "Member 'APlayerCameraManagerBattle::_checkWaterComponent' has a wrong offset!");

// Class InGameModule.PlayerCircularProgressBarWidget
// 0x0018 (0x0380 - 0x0368)
class UPlayerCircularProgressBarWidget final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           _rootCanvasPanel;                                  // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCircularProgressBarWidget*             _circularProgressBar;                              // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCircularProgressBarWidget">();
	}
	static class UPlayerCircularProgressBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCircularProgressBarWidget>();
	}
};
static_assert(alignof(UPlayerCircularProgressBarWidget) == 0x000008, "Wrong alignment on UPlayerCircularProgressBarWidget");
static_assert(sizeof(UPlayerCircularProgressBarWidget) == 0x000380, "Wrong size on UPlayerCircularProgressBarWidget");
static_assert(offsetof(UPlayerCircularProgressBarWidget, _rootCanvasPanel) == 0x000370, "Member 'UPlayerCircularProgressBarWidget::_rootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UPlayerCircularProgressBarWidget, _circularProgressBar) == 0x000378, "Member 'UPlayerCircularProgressBarWidget::_circularProgressBar' has a wrong offset!");

// Class InGameModule.PlayerControllerServerEntry
// 0x0000 (0x0610 - 0x0610)
class APlayerControllerServerEntry final : public APlayerControllerGame
{
public:
	void BP_ServerTravel(const class FString& URL);
	void ServerTravel(const class FString& URL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerServerEntry">();
	}
	static class APlayerControllerServerEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerServerEntry>();
	}
};
static_assert(alignof(APlayerControllerServerEntry) == 0x000008, "Wrong alignment on APlayerControllerServerEntry");
static_assert(sizeof(APlayerControllerServerEntry) == 0x000610, "Wrong size on APlayerControllerServerEntry");

// Class InGameModule.PlayerControllerTraining
// 0x0008 (0x09A0 - 0x0998)
class APlayerControllerTraining final : public APlayerControllerBattle
{
public:
	class AGameStateTraining*                     _gameStateTraining;                                // 0x0998(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeCharacter_OnServer(class ACharacterBattle* CurrentCharacter, const struct FTrainingBattleCharacterData& Data);
	void ChangeTrainingSetting_OnServer();
	void ChangeUniqueLevel_OnServer(class ACharacterBattle* CurrentCharacter, int32 DefUnique1Level, int32 DefUnique2Level, int32 DefUnique3Level);
	void SetAITrainingType_OnServer(class APlayerStateBattle* PlayerStateBattle, EAITrainingType Type, bool bStoreTypeOnClient);
	void SetChangedTrainingKPI_OnServer(bool IsActive, int32 CharacterCode);
	void SetTakeDamageType_OnServer(const ETakeDamageType DamageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerTraining">();
	}
	static class APlayerControllerTraining* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerTraining>();
	}
};
static_assert(alignof(APlayerControllerTraining) == 0x000008, "Wrong alignment on APlayerControllerTraining");
static_assert(sizeof(APlayerControllerTraining) == 0x0009A0, "Wrong size on APlayerControllerTraining");
static_assert(offsetof(APlayerControllerTraining, _gameStateTraining) == 0x000998, "Member 'APlayerControllerTraining::_gameStateTraining' has a wrong offset!");

// Class InGameModule.PlayerControllerVisualLobby
// 0x0000 (0x0998 - 0x0998)
class APlayerControllerVisualLobby final : public APlayerControllerBattle
{
public:
	void SendSeverTrainingCharacterData();
	void SetupTrainingCharacterData_OnServer(int32 TrainingDamageTypeIndex, bool bTrainingFriendlyFire, const struct FTrainingCharacterData& TrainingPlayerCharacterData, const struct FTrainingCharacterData& TrainingCPUCharacterData1, const struct FTrainingCharacterData& TrainingCPUCharacterData2, const struct FTrainingCharacterData& TrainingCPUCharacterData3);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerVisualLobby">();
	}
	static class APlayerControllerVisualLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerVisualLobby>();
	}
};
static_assert(alignof(APlayerControllerVisualLobby) == 0x000008, "Wrong alignment on APlayerControllerVisualLobby");
static_assert(sizeof(APlayerControllerVisualLobby) == 0x000998, "Wrong size on APlayerControllerVisualLobby");

// Class InGameModule.PlayerCounterPresenter
// 0x0008 (0x0250 - 0x0248)
class APlayerCounterPresenter final : public AWidgetCreator
{
public:
	class UGameOption*                            _gameOption;                                       // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateViewByGameOption();

	void UpdateUIOnSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCounterPresenter">();
	}
	static class APlayerCounterPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCounterPresenter>();
	}
};
static_assert(alignof(APlayerCounterPresenter) == 0x000008, "Wrong alignment on APlayerCounterPresenter");
static_assert(sizeof(APlayerCounterPresenter) == 0x000250, "Wrong size on APlayerCounterPresenter");
static_assert(offsetof(APlayerCounterPresenter, _gameOption) == 0x000248, "Member 'APlayerCounterPresenter::_gameOption' has a wrong offset!");

// Class InGameModule.PlayerCrossHairsWidget
// 0x0018 (0x0368 - 0x0350)
class UPlayerCrossHairsWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrossHairsWidget*                      _crossHairs;                                       // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           _rootCanvasPanel;                                  // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCrossHairsWidget">();
	}
	static class UPlayerCrossHairsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCrossHairsWidget>();
	}
};
static_assert(alignof(UPlayerCrossHairsWidget) == 0x000008, "Wrong alignment on UPlayerCrossHairsWidget");
static_assert(sizeof(UPlayerCrossHairsWidget) == 0x000368, "Wrong size on UPlayerCrossHairsWidget");
static_assert(offsetof(UPlayerCrossHairsWidget, _crossHairs) == 0x000358, "Member 'UPlayerCrossHairsWidget::_crossHairs' has a wrong offset!");
static_assert(offsetof(UPlayerCrossHairsWidget, _rootCanvasPanel) == 0x000360, "Member 'UPlayerCrossHairsWidget::_rootCanvasPanel' has a wrong offset!");

// Class InGameModule.PlayerDialogueWidget
// 0x0010 (0x0360 - 0x0350)
class UPlayerDialogueWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDialogueWidget*                        _dialogueWidget;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDialogueWidget">();
	}
	static class UPlayerDialogueWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDialogueWidget>();
	}
};
static_assert(alignof(UPlayerDialogueWidget) == 0x000008, "Wrong alignment on UPlayerDialogueWidget");
static_assert(sizeof(UPlayerDialogueWidget) == 0x000360, "Wrong size on UPlayerDialogueWidget");
static_assert(offsetof(UPlayerDialogueWidget, _dialogueWidget) == 0x000358, "Member 'UPlayerDialogueWidget::_dialogueWidget' has a wrong offset!");

// Class InGameModule.PlayerInGameButtonGuide
// 0x0018 (0x0368 - 0x0350)
class UPlayerInGameButtonGuide final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           _rootCanvasPanel;                                  // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameButtonGuide*                     _inGameButtonGuide;                                // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInGameButtonGuide">();
	}
	static class UPlayerInGameButtonGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInGameButtonGuide>();
	}
};
static_assert(alignof(UPlayerInGameButtonGuide) == 0x000008, "Wrong alignment on UPlayerInGameButtonGuide");
static_assert(sizeof(UPlayerInGameButtonGuide) == 0x000368, "Wrong size on UPlayerInGameButtonGuide");
static_assert(offsetof(UPlayerInGameButtonGuide, _rootCanvasPanel) == 0x000358, "Member 'UPlayerInGameButtonGuide::_rootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UPlayerInGameButtonGuide, _inGameButtonGuide) == 0x000360, "Member 'UPlayerInGameButtonGuide::_inGameButtonGuide' has a wrong offset!");

// Class InGameModule.PlayerInGameMiscInfoWidget
// 0x0020 (0x0370 - 0x0350)
class UPlayerInGameMiscInfoWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           _rootCanvasPanel;                                  // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameMiscInfo*                        _miscInfo;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPoisonMistTimerWidget*                 _poisonMistInfo;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInGameMiscInfoWidget">();
	}
	static class UPlayerInGameMiscInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInGameMiscInfoWidget>();
	}
};
static_assert(alignof(UPlayerInGameMiscInfoWidget) == 0x000008, "Wrong alignment on UPlayerInGameMiscInfoWidget");
static_assert(sizeof(UPlayerInGameMiscInfoWidget) == 0x000370, "Wrong size on UPlayerInGameMiscInfoWidget");
static_assert(offsetof(UPlayerInGameMiscInfoWidget, _rootCanvasPanel) == 0x000358, "Member 'UPlayerInGameMiscInfoWidget::_rootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UPlayerInGameMiscInfoWidget, _miscInfo) == 0x000360, "Member 'UPlayerInGameMiscInfoWidget::_miscInfo' has a wrong offset!");
static_assert(offsetof(UPlayerInGameMiscInfoWidget, _poisonMistInfo) == 0x000368, "Member 'UPlayerInGameMiscInfoWidget::_poisonMistInfo' has a wrong offset!");

// Class InGameModule.PlayerLevelUpShortCutWidget
// 0x0020 (0x0370 - 0x0350)
class UPlayerLevelUpShortCutWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           _canvasPanelBase;                                  // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelUpShortCutBase*                   _lvShortCutBaseWidget;                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelUpGuide*                          _lvUpGuide;                                        // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLevelUpShortCutWidget">();
	}
	static class UPlayerLevelUpShortCutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLevelUpShortCutWidget>();
	}
};
static_assert(alignof(UPlayerLevelUpShortCutWidget) == 0x000008, "Wrong alignment on UPlayerLevelUpShortCutWidget");
static_assert(sizeof(UPlayerLevelUpShortCutWidget) == 0x000370, "Wrong size on UPlayerLevelUpShortCutWidget");
static_assert(offsetof(UPlayerLevelUpShortCutWidget, _canvasPanelBase) == 0x000358, "Member 'UPlayerLevelUpShortCutWidget::_canvasPanelBase' has a wrong offset!");
static_assert(offsetof(UPlayerLevelUpShortCutWidget, _lvShortCutBaseWidget) == 0x000360, "Member 'UPlayerLevelUpShortCutWidget::_lvShortCutBaseWidget' has a wrong offset!");
static_assert(offsetof(UPlayerLevelUpShortCutWidget, _lvUpGuide) == 0x000368, "Member 'UPlayerLevelUpShortCutWidget::_lvUpGuide' has a wrong offset!");

// Class InGameModule.PlayerScoutBattleInfo
// 0x0010 (0x0360 - 0x0350)
class UPlayerScoutBattleInfo final : public UWidgetBase
{
public:
	class UScoutBattleActionGuideWidget*          _scoutResponse;                                    // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndScoutRequest();
	void ScoutRequest(const class APlayerStateBattle* SendPlayer, bool bBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoutBattleInfo">();
	}
	static class UPlayerScoutBattleInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoutBattleInfo>();
	}
};
static_assert(alignof(UPlayerScoutBattleInfo) == 0x000008, "Wrong alignment on UPlayerScoutBattleInfo");
static_assert(sizeof(UPlayerScoutBattleInfo) == 0x000360, "Wrong size on UPlayerScoutBattleInfo");
static_assert(offsetof(UPlayerScoutBattleInfo, _scoutResponse) == 0x000350, "Member 'UPlayerScoutBattleInfo::_scoutResponse' has a wrong offset!");

// Class InGameModule.PlayerScoutComponent
// 0x0070 (0x0120 - 0x00B0)
class UPlayerScoutComponent final : public UActorComponent
{
public:
	class APlayerStateBattle*                     _currentTarget;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReplyToScoutRequet_ToServer(class UPlayerScoutComponent* Winner, bool bPositive);
	void ScoutRequest_ToClient(class APlayerStateBattle* Winner);
	void ScoutRequest_ToServer(class APlayerStateBattle* Loser);
	void ScoutRequestComplete_NetMulticast(class UPlayerScoutComponent* Winner, bool bSuccess);
	void ScoutRequestFailed_NetMulticast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoutComponent">();
	}
	static class UPlayerScoutComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoutComponent>();
	}
};
static_assert(alignof(UPlayerScoutComponent) == 0x000008, "Wrong alignment on UPlayerScoutComponent");
static_assert(sizeof(UPlayerScoutComponent) == 0x000120, "Wrong size on UPlayerScoutComponent");
static_assert(offsetof(UPlayerScoutComponent, _currentTarget) == 0x0000B0, "Member 'UPlayerScoutComponent::_currentTarget' has a wrong offset!");

// Class InGameModule.PlayerScreenInfoWidget
// 0x00B8 (0x0420 - 0x0368)
class UPlayerScreenInfoWidget final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfKillLogPreview;                           // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOneGameSessionWork*                    _oneGameSessionWork;                               // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudCommandControlComponent*            _commandHudComponent;                              // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHUDDispatchComponent*                  _hudDispatchComponent;                             // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _rootCanvasPanel;                                  // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       _minimapWidgetPanelSlot;                           // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                _rootWidget;                                       // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFieldInteractPopUpWidget*              _popUpWidget;                                      // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterActionGuideWidget*            _specialActionGuide;                               // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterActionGuideWidget*            _finisherActionGuide;                              // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       _popUpWidgetSlot;                                  // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _dyingScreenEffect;                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _beginBlinkHealthRatio;                            // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDownWidget>                _knockDownWidgetClass;                             // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUMGEffectAttachedToActor>  _guardBreakWidgetClass;                            // 0x0400(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUMGEffectAttachedToActor*>      _damageEffectWidgetList;                           // 0x0408(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UFreeAnimationWidget*                   _freeAnimationImage;                               // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBattleSequenceChanged(EBattleSequence NewSequence);
	void OnMapClose();
	void OnMapOpen();
	void RemoveWidgetsOnDead();
	void StartGettingBloodAnimation();
	void SwitchCharacterActionGuide(const struct FRequestUIData& Data);
	void UpdateDyingEffect();
	void UpdateInteractPopUpWidget(const class UInteractTargetComponent* CurrentTarget, bool bCanInteract);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScreenInfoWidget">();
	}
	static class UPlayerScreenInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScreenInfoWidget>();
	}
};
static_assert(alignof(UPlayerScreenInfoWidget) == 0x000008, "Wrong alignment on UPlayerScreenInfoWidget");
static_assert(sizeof(UPlayerScreenInfoWidget) == 0x000420, "Wrong size on UPlayerScreenInfoWidget");
static_assert(offsetof(UPlayerScreenInfoWidget, _numberOfKillLogPreview) == 0x000370, "Member 'UPlayerScreenInfoWidget::_numberOfKillLogPreview' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _gameOption) == 0x000378, "Member 'UPlayerScreenInfoWidget::_gameOption' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _oneGameSessionWork) == 0x000380, "Member 'UPlayerScreenInfoWidget::_oneGameSessionWork' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _playerController) == 0x000388, "Member 'UPlayerScreenInfoWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _localPlayerHudManager) == 0x000390, "Member 'UPlayerScreenInfoWidget::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _commandHudComponent) == 0x000398, "Member 'UPlayerScreenInfoWidget::_commandHudComponent' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _hudDispatchComponent) == 0x0003A0, "Member 'UPlayerScreenInfoWidget::_hudDispatchComponent' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _supplyHolderComponent) == 0x0003A8, "Member 'UPlayerScreenInfoWidget::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _rootCanvasPanel) == 0x0003B0, "Member 'UPlayerScreenInfoWidget::_rootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _minimapWidgetPanelSlot) == 0x0003B8, "Member 'UPlayerScreenInfoWidget::_minimapWidgetPanelSlot' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _rootWidget) == 0x0003C0, "Member 'UPlayerScreenInfoWidget::_rootWidget' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _popUpWidget) == 0x0003C8, "Member 'UPlayerScreenInfoWidget::_popUpWidget' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _specialActionGuide) == 0x0003D0, "Member 'UPlayerScreenInfoWidget::_specialActionGuide' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _finisherActionGuide) == 0x0003D8, "Member 'UPlayerScreenInfoWidget::_finisherActionGuide' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _popUpWidgetSlot) == 0x0003E0, "Member 'UPlayerScreenInfoWidget::_popUpWidgetSlot' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _dyingScreenEffect) == 0x0003E8, "Member 'UPlayerScreenInfoWidget::_dyingScreenEffect' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _beginBlinkHealthRatio) == 0x0003F0, "Member 'UPlayerScreenInfoWidget::_beginBlinkHealthRatio' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _knockDownWidgetClass) == 0x0003F8, "Member 'UPlayerScreenInfoWidget::_knockDownWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _guardBreakWidgetClass) == 0x000400, "Member 'UPlayerScreenInfoWidget::_guardBreakWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _damageEffectWidgetList) == 0x000408, "Member 'UPlayerScreenInfoWidget::_damageEffectWidgetList' has a wrong offset!");
static_assert(offsetof(UPlayerScreenInfoWidget, _freeAnimationImage) == 0x000418, "Member 'UPlayerScreenInfoWidget::_freeAnimationImage' has a wrong offset!");

// Class InGameModule.PlayerScreenTagWidget
// 0x0010 (0x0360 - 0x0350)
class UPlayerScreenTagWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerTagWidget*                       _playerTag;                                        // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScreenTagWidget">();
	}
	static class UPlayerScreenTagWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScreenTagWidget>();
	}
};
static_assert(alignof(UPlayerScreenTagWidget) == 0x000008, "Wrong alignment on UPlayerScreenTagWidget");
static_assert(sizeof(UPlayerScreenTagWidget) == 0x000360, "Wrong size on UPlayerScreenTagWidget");
static_assert(offsetof(UPlayerScreenTagWidget, _playerTag) == 0x000358, "Member 'UPlayerScreenTagWidget::_playerTag' has a wrong offset!");

// Class InGameModule.PlayerStateBattle
// 0x0AC0 (0x0E20 - 0x0360)
class alignas(0x10) APlayerStateBattle : public AHerovsPlayerState
{
public:
	uint8                                         Pad_360[0x158];                                    // 0x0360(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepHealthData                         _healthData;                                       // 0x04B8(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x14];                                     // 0x04C8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _recoverGoalHealth;                                // 0x04DC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepDyingRecoverData                   _dyingRecoverData;                                 // 0x04E8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x188];                                    // 0x04F8(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _lastInstigatedPlayer;                             // 0x0680(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _lastInstigatedPlayerForDying;                     // 0x0690(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x4];                                      // 0x0698(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _guardPoint;                                       // 0x069C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A0[0x1D8];                                    // 0x06A0(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _plusUltraPoint;                                   // 0x0878(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bPlusUltraPermanency;                             // 0x087C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_87D[0x53];                                     // 0x087D(0x0053)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bDyingInteracted;                                 // 0x08D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D1[0x7];                                      // 0x08D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBriefingComponent*                     _briefingComponent;                                // 0x08D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E0[0x1];                                      // 0x08E0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bWinDemoComplete;                                 // 0x08E1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E2[0xA];                                      // 0x08E2(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _serverPriorityActionSerialNo;                     // 0x08EC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x18];                                     // 0x08F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ETakeDamageType                               _takeDamageType;                                   // 0x0908(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_909[0x3];                                      // 0x0909(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _totalDamage;                                      // 0x090C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_910[0x40];                                     // 0x0910(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterCondition                    _characterCondition;                               // 0x0950(0x00B0)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_A00[0x80];                                     // 0x0A00(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuffParam*                             _buffParam;                                        // 0x0A80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDeltaRateComponent*                    _deltaRateComponent;                               // 0x0A88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTransformControlComponent*             _transformControlComponent;                        // 0x0A90(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A98[0x38];                                     // 0x0A98(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UDuplicateControlComponent*             _duplicateControlComponent;                        // 0x0AD0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD8[0x30];                                     // 0x0AD8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bIsImitation;                                     // 0x0B08(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsFrailty;                                       // 0x0B09(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0A[0x2];                                      // 0x0B0A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdKey                        _parentUniqueNetIdKey;                             // 0x0B0C(0x0008)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUniqueNetIdKey                        _originalUniqueNetIdKey;                           // 0x0B14(0x0008)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1C[0x4];                                      // 0x0B1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _parentPlayer;                                     // 0x0B20(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B28[0x8];                                      // 0x0B28(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0B30(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHUDDispatchComponent*                  _hudDispatchComponent;                             // 0x0B38(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoChatComponent*                     _autoChatComponent;                                // 0x0B40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B48[0x48];                                     // 0x0B48(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class USimulatedPlayerHudManager*             _simulatedPlayerHudManager;                        // 0x0B90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B98[0xC0];                                     // 0x0B98(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRepHitEnemyInfo>               _hitEnemyInfoList;                                 // 0x0C58(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C68[0x32];                                     // 0x0C68(0x0032)(Fixing Size After Last Property [ Dumper-7 ])
	ERespawnTagState                              _respawnTagState;                                  // 0x0C9A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9B[0xA5];                                     // 0x0C9B(0x00A5)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _cheerCount;                                       // 0x0D40(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bSimultaneouslyCheer;                             // 0x0D44(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D45[0x3];                                      // 0x0D45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _lastSendPlayerState;                              // 0x0D48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D50[0x38];                                     // 0x0D50(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfSpectator;                                // 0x0D88(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8C[0x4];                                      // 0x0D8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _emblemCodes;                                      // 0x0D90(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         _myAdBackgroundId;                                 // 0x0DA0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _myAdEffectId;                                     // 0x0DA4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _myAdMessageId;                                    // 0x0DA8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _myAdMessage;                                      // 0x0DAC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DB0[0x50];                                     // 0x0DB0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _appearSquadPlayerState;                           // 0x0E00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E08[0x10];                                     // 0x0E08(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerScoutComponent*                  _playerScoutComponent;                             // 0x0E18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_ClearDyingState(bool bWithRecovery);
	void BP_ClearInvincible();
	class UBuffParam* BP_GetBuffParam();
	class ACharacterBattle* BP_GetRescueCharacter();
	bool BP_IsDead();
	bool BP_IsDying();
	bool BP_IsInvincible();
	bool BP_IsPlusUltraPermanency();
	void BP_RecoverGuardPoint(float Value, class APlayerStateBattle* Healer, bool EnableCondition);
	void BP_RecoverHealth(float Value, bool bEnableCondition, class APlayerStateBattle* Healer);
	void BP_ResetPlusUltraPoint();
	void BP_SetDyingInteracted(bool Flag);
	void BP_SetDyingInteracted_ToServer(bool Flag);
	void BP_SetInvincible(float FixTime, float MaxTime, bool EnableEffect, bool ProjectileThrough, bool SlipDamageThrough);
	void CalcExitPlayerScore_RPC(const struct FUniqueNetIdKey& ExitPlayerId);
	void ClearSimultaneouslyCheer();
	void ClientTextMessageReceived(int16 SenderPlayerId, const class FString& InKeyForTable);
	void EnableToRise(bool bIsGuard, int32 Index_0);
	void ForcePickUpTagRequest_ToServer();
	void NotifyPlayingCharacterDead_Client();
	void OnAudioFinished_AppearSquad(class UAtomComponent* AtomComponent);
	void OnRep_CheerCount();
	void OnRep_GuardPoint();
	void OnRep_HealthData();
	void OnRep_HitEnemyInfoList();
	void OnRep_NumberOfSpectator();
	void OnRep_PlusUltraPermanency();
	void OnRep_PlusUltraPoint();
	void OnRep_respawnTagState();
	void OnRep_SimultaneouslyCheer();
	void OnRep_TotalDamage();
	void ReceiveAbilityRequest_ToClient(int16 SenderPlayerId, const EMdAbilityType AbilityType, const EAttackId AttackId);
	void ReceiveSupplyRequest_ToClient(int16 SenderPlayerId, const class FName& SupplyId);
	void RecoverDying_ToClient(class ACharacterBattle* RescueCharacter);
	void ReloadTagPosition();
	void SendTotalMoveDistanceToServer_RPC(float TotalDistance);
	void ServerSealUnique(const TArray<class ACharacterBattle*>& Targets);
	void SetDyingInteracted_ToServer(bool Flag);
	void UpdateKingOrNotEffect();
	void WinDemoCompleteFlag_RPC(const bool bComplate);

	class UDeltaRateComponent* BP_GetDeltaRateComponent() const;
	class UDuplicateControlComponent* BP_GetDuplicateController() const;
	float BP_GetPlusUltraMaxTime() const;
	bool BP_IsDyingInteracted() const;
	bool BP_IsImitation() const;
	void ClientRemoveMessage(int16 PlayerIdToRemove) const;
	int32 GetCurrentEmoteId() const;
	void RequestForceQuit_RPC() const;
	void RequestForceStart_RPC() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateBattle">();
	}
	static class APlayerStateBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStateBattle>();
	}
};
static_assert(alignof(APlayerStateBattle) == 0x000010, "Wrong alignment on APlayerStateBattle");
static_assert(sizeof(APlayerStateBattle) == 0x000E20, "Wrong size on APlayerStateBattle");
static_assert(offsetof(APlayerStateBattle, _healthData) == 0x0004B8, "Member 'APlayerStateBattle::_healthData' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _recoverGoalHealth) == 0x0004DC, "Member 'APlayerStateBattle::_recoverGoalHealth' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _dyingRecoverData) == 0x0004E8, "Member 'APlayerStateBattle::_dyingRecoverData' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _lastInstigatedPlayer) == 0x000680, "Member 'APlayerStateBattle::_lastInstigatedPlayer' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _lastInstigatedPlayerForDying) == 0x000690, "Member 'APlayerStateBattle::_lastInstigatedPlayerForDying' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _guardPoint) == 0x00069C, "Member 'APlayerStateBattle::_guardPoint' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _plusUltraPoint) == 0x000878, "Member 'APlayerStateBattle::_plusUltraPoint' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _bPlusUltraPermanency) == 0x00087C, "Member 'APlayerStateBattle::_bPlusUltraPermanency' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _bDyingInteracted) == 0x0008D0, "Member 'APlayerStateBattle::_bDyingInteracted' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _briefingComponent) == 0x0008D8, "Member 'APlayerStateBattle::_briefingComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _bWinDemoComplete) == 0x0008E1, "Member 'APlayerStateBattle::_bWinDemoComplete' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _serverPriorityActionSerialNo) == 0x0008EC, "Member 'APlayerStateBattle::_serverPriorityActionSerialNo' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _takeDamageType) == 0x000908, "Member 'APlayerStateBattle::_takeDamageType' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _totalDamage) == 0x00090C, "Member 'APlayerStateBattle::_totalDamage' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _characterCondition) == 0x000950, "Member 'APlayerStateBattle::_characterCondition' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _buffParam) == 0x000A80, "Member 'APlayerStateBattle::_buffParam' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _deltaRateComponent) == 0x000A88, "Member 'APlayerStateBattle::_deltaRateComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _transformControlComponent) == 0x000A90, "Member 'APlayerStateBattle::_transformControlComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _duplicateControlComponent) == 0x000AD0, "Member 'APlayerStateBattle::_duplicateControlComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _bIsImitation) == 0x000B08, "Member 'APlayerStateBattle::_bIsImitation' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _bIsFrailty) == 0x000B09, "Member 'APlayerStateBattle::_bIsFrailty' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _parentUniqueNetIdKey) == 0x000B0C, "Member 'APlayerStateBattle::_parentUniqueNetIdKey' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _originalUniqueNetIdKey) == 0x000B14, "Member 'APlayerStateBattle::_originalUniqueNetIdKey' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _parentPlayer) == 0x000B20, "Member 'APlayerStateBattle::_parentPlayer' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _supplyHolderComponent) == 0x000B30, "Member 'APlayerStateBattle::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _hudDispatchComponent) == 0x000B38, "Member 'APlayerStateBattle::_hudDispatchComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _autoChatComponent) == 0x000B40, "Member 'APlayerStateBattle::_autoChatComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _simulatedPlayerHudManager) == 0x000B90, "Member 'APlayerStateBattle::_simulatedPlayerHudManager' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _hitEnemyInfoList) == 0x000C58, "Member 'APlayerStateBattle::_hitEnemyInfoList' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _respawnTagState) == 0x000C9A, "Member 'APlayerStateBattle::_respawnTagState' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _cheerCount) == 0x000D40, "Member 'APlayerStateBattle::_cheerCount' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _bSimultaneouslyCheer) == 0x000D44, "Member 'APlayerStateBattle::_bSimultaneouslyCheer' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _lastSendPlayerState) == 0x000D48, "Member 'APlayerStateBattle::_lastSendPlayerState' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _numberOfSpectator) == 0x000D88, "Member 'APlayerStateBattle::_numberOfSpectator' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _emblemCodes) == 0x000D90, "Member 'APlayerStateBattle::_emblemCodes' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _myAdBackgroundId) == 0x000DA0, "Member 'APlayerStateBattle::_myAdBackgroundId' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _myAdEffectId) == 0x000DA4, "Member 'APlayerStateBattle::_myAdEffectId' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _myAdMessageId) == 0x000DA8, "Member 'APlayerStateBattle::_myAdMessageId' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _myAdMessage) == 0x000DAC, "Member 'APlayerStateBattle::_myAdMessage' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _appearSquadPlayerState) == 0x000E00, "Member 'APlayerStateBattle::_appearSquadPlayerState' has a wrong offset!");
static_assert(offsetof(APlayerStateBattle, _playerScoutComponent) == 0x000E18, "Member 'APlayerStateBattle::_playerScoutComponent' has a wrong offset!");

// Class InGameModule.PlayerStateLeadersBattle
// 0x0020 (0x0E40 - 0x0E20)
class APlayerStateLeadersBattle final : public APlayerStateBattle
{
public:
	uint8                                         Pad_E20[0x20];                                     // 0x0E20(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateLeadersBattle">();
	}
	static class APlayerStateLeadersBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStateLeadersBattle>();
	}
};
static_assert(alignof(APlayerStateLeadersBattle) == 0x000010, "Wrong alignment on APlayerStateLeadersBattle");
static_assert(sizeof(APlayerStateLeadersBattle) == 0x000E40, "Wrong size on APlayerStateLeadersBattle");

// Class InGameModule.PlayerStatusInfoWidget
// 0x0218 (0x0580 - 0x0368)
class UPlayerStatusInfoWidget final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusBoxBase*                         _viewTargetStatusBox;                              // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           _squadStatusList;                                  // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                _allyPlayerStatusWidgetClass;                      // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELeadersBattleTeamType                        _trialTeam;                                        // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _allyStatusBoxBackgroundSize;                      // 0x039C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _allyStatusFaceIconScale;                          // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _allyStatusHealthGaugeSize;                        // 0x03A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _allyStatusGuardGaugeSize;                         // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _allyPlayerNameFontSize;                           // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _sameSquadAllyIcon;                                // 0x03C0(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _otherSquadAllyIcon;                               // 0x0490(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	int32                                         _memberStatusPreviewNumber;                        // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _allyBottomOffset;                                 // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _statusIngredientsAdditionalPosition;              // 0x0568(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _allyVoiceChatIconPosition;                        // 0x0570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _allyVoiceChatIconScale;                           // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _leavingPlayerShowTimer;                           // 0x057C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatusInfoWidget">();
	}
	static class UPlayerStatusInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStatusInfoWidget>();
	}
};
static_assert(alignof(UPlayerStatusInfoWidget) == 0x000010, "Wrong alignment on UPlayerStatusInfoWidget");
static_assert(sizeof(UPlayerStatusInfoWidget) == 0x000580, "Wrong size on UPlayerStatusInfoWidget");
static_assert(offsetof(UPlayerStatusInfoWidget, _gameOption) == 0x000370, "Member 'UPlayerStatusInfoWidget::_gameOption' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _playerController) == 0x000378, "Member 'UPlayerStatusInfoWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _viewTargetStatusBox) == 0x000380, "Member 'UPlayerStatusInfoWidget::_viewTargetStatusBox' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _squadStatusList) == 0x000388, "Member 'UPlayerStatusInfoWidget::_squadStatusList' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyPlayerStatusWidgetClass) == 0x000390, "Member 'UPlayerStatusInfoWidget::_allyPlayerStatusWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _trialTeam) == 0x000398, "Member 'UPlayerStatusInfoWidget::_trialTeam' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyStatusBoxBackgroundSize) == 0x00039C, "Member 'UPlayerStatusInfoWidget::_allyStatusBoxBackgroundSize' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyStatusFaceIconScale) == 0x0003A4, "Member 'UPlayerStatusInfoWidget::_allyStatusFaceIconScale' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyStatusHealthGaugeSize) == 0x0003A8, "Member 'UPlayerStatusInfoWidget::_allyStatusHealthGaugeSize' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyStatusGuardGaugeSize) == 0x0003B0, "Member 'UPlayerStatusInfoWidget::_allyStatusGuardGaugeSize' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyPlayerNameFontSize) == 0x0003B8, "Member 'UPlayerStatusInfoWidget::_allyPlayerNameFontSize' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _sameSquadAllyIcon) == 0x0003C0, "Member 'UPlayerStatusInfoWidget::_sameSquadAllyIcon' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _otherSquadAllyIcon) == 0x000490, "Member 'UPlayerStatusInfoWidget::_otherSquadAllyIcon' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _memberStatusPreviewNumber) == 0x000560, "Member 'UPlayerStatusInfoWidget::_memberStatusPreviewNumber' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyBottomOffset) == 0x000564, "Member 'UPlayerStatusInfoWidget::_allyBottomOffset' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _statusIngredientsAdditionalPosition) == 0x000568, "Member 'UPlayerStatusInfoWidget::_statusIngredientsAdditionalPosition' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyVoiceChatIconPosition) == 0x000570, "Member 'UPlayerStatusInfoWidget::_allyVoiceChatIconPosition' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _allyVoiceChatIconScale) == 0x000578, "Member 'UPlayerStatusInfoWidget::_allyVoiceChatIconScale' has a wrong offset!");
static_assert(offsetof(UPlayerStatusInfoWidget, _leavingPlayerShowTimer) == 0x00057C, "Member 'UPlayerStatusInfoWidget::_leavingPlayerShowTimer' has a wrong offset!");

// Class InGameModule.PlayerTagWidget
// 0x1158 (0x1320 - 0x01C8)
class UPlayerTagWidget final : public UWidgetDrawPrimitive
{
public:
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AHerovsGameState*                       _gameState;                                        // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _localPlayerState;                                 // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _viewTargetPlayerState;                            // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _updateTargetPlayerState;                          // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameOption*                            _gameOption;                                       // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _littleMargin;                                     // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _clampYPositionNormal;                             // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _clampYPositionOffScreen;                          // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0xC];                                      // 0x0224(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _otherSquadAllyIcon;                               // 0x0230(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _squadAllyIcon;                                    // 0x0300(0x00D0)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x1A0];                                    // 0x03D0(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         _specialActionGuideFont;                           // 0x0570(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            _specialActionGuideFontColor;                      // 0x05C8(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x18];                                     // 0x05F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _specialActionTargetCharacter;                     // 0x0608(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlatformRichTextBlock*                 _specialActionButtonGuide;                         // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ECharacterId, struct FSlateBrush>        _characterBadge;                                   // 0x0618(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EMdAbilityType, struct FSlateBrush>      _roleIcons;                                        // 0x0668(0x0050)(NativeAccessSpecifierPrivate)
	float                                         _shiftDamagePosY;                                  // 0x06B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _crown;                                            // 0x06C0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _enemyCrown;                                       // 0x0790(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              _enemyKingIconOffset;                              // 0x0860(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _plusUltraIconInactive;                            // 0x0870(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _plusUltraFontColorInactive;                       // 0x0940(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _plusUltraFontInactive;                            // 0x0968(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _plusUltraIconActive;                              // 0x09C0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _plusUltraFontColorActive;                         // 0x0A90(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _plusUltraFontActive;                              // 0x0AB8(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _healthBar;                                        // 0x0B10(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _guardPointBar;                                    // 0x0BE0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _dyingHealthBar;                                   // 0x0CB0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _healthBarBackground;                              // 0x0D80(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _guardPointBarBackground;                          // 0x0E50(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _playerNameFontColor;                              // 0x0F20(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _playerNameFont;                                   // 0x0F48(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _enemyBarScaleRatio;                               // 0x0FA0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA8[0x8];                                      // 0x0FA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _orbIcon;                                          // 0x0FB0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _orbFont;                                          // 0x1080(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            _orbNumColor;                                      // 0x10D8(0x0028)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FSlateBrush>                    _leader;                                           // 0x1100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _smallHealthDamageFont;                            // 0x1110(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _normalHealthDamageFont;                           // 0x1168(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _bigHealthDamageFont;                              // 0x11C0(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _smallGuardDamageFont;                             // 0x1218(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _normalGuardDamageFont;                            // 0x1270(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _bigGuardDamageFont;                               // 0x12C8(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerTagWidget">();
	}
	static class UPlayerTagWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerTagWidget>();
	}
};
static_assert(alignof(UPlayerTagWidget) == 0x000010, "Wrong alignment on UPlayerTagWidget");
static_assert(sizeof(UPlayerTagWidget) == 0x001320, "Wrong size on UPlayerTagWidget");
static_assert(offsetof(UPlayerTagWidget, _gameState) == 0x0001D8, "Member 'UPlayerTagWidget::_gameState' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _playerController) == 0x0001E0, "Member 'UPlayerTagWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _localPlayerState) == 0x0001E8, "Member 'UPlayerTagWidget::_localPlayerState' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _viewTargetPlayerState) == 0x0001F0, "Member 'UPlayerTagWidget::_viewTargetPlayerState' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _updateTargetPlayerState) == 0x0001F8, "Member 'UPlayerTagWidget::_updateTargetPlayerState' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _hudResource) == 0x000200, "Member 'UPlayerTagWidget::_hudResource' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _gameOption) == 0x000208, "Member 'UPlayerTagWidget::_gameOption' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _playerDatabaseWork) == 0x000210, "Member 'UPlayerTagWidget::_playerDatabaseWork' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _littleMargin) == 0x000218, "Member 'UPlayerTagWidget::_littleMargin' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _clampYPositionNormal) == 0x00021C, "Member 'UPlayerTagWidget::_clampYPositionNormal' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _clampYPositionOffScreen) == 0x000220, "Member 'UPlayerTagWidget::_clampYPositionOffScreen' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _otherSquadAllyIcon) == 0x000230, "Member 'UPlayerTagWidget::_otherSquadAllyIcon' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _squadAllyIcon) == 0x000300, "Member 'UPlayerTagWidget::_squadAllyIcon' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _specialActionGuideFont) == 0x000570, "Member 'UPlayerTagWidget::_specialActionGuideFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _specialActionGuideFontColor) == 0x0005C8, "Member 'UPlayerTagWidget::_specialActionGuideFontColor' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _specialActionTargetCharacter) == 0x000608, "Member 'UPlayerTagWidget::_specialActionTargetCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _specialActionButtonGuide) == 0x000610, "Member 'UPlayerTagWidget::_specialActionButtonGuide' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _characterBadge) == 0x000618, "Member 'UPlayerTagWidget::_characterBadge' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _roleIcons) == 0x000668, "Member 'UPlayerTagWidget::_roleIcons' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _shiftDamagePosY) == 0x0006B8, "Member 'UPlayerTagWidget::_shiftDamagePosY' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _crown) == 0x0006C0, "Member 'UPlayerTagWidget::_crown' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _enemyCrown) == 0x000790, "Member 'UPlayerTagWidget::_enemyCrown' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _enemyKingIconOffset) == 0x000860, "Member 'UPlayerTagWidget::_enemyKingIconOffset' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _plusUltraIconInactive) == 0x000870, "Member 'UPlayerTagWidget::_plusUltraIconInactive' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _plusUltraFontColorInactive) == 0x000940, "Member 'UPlayerTagWidget::_plusUltraFontColorInactive' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _plusUltraFontInactive) == 0x000968, "Member 'UPlayerTagWidget::_plusUltraFontInactive' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _plusUltraIconActive) == 0x0009C0, "Member 'UPlayerTagWidget::_plusUltraIconActive' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _plusUltraFontColorActive) == 0x000A90, "Member 'UPlayerTagWidget::_plusUltraFontColorActive' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _plusUltraFontActive) == 0x000AB8, "Member 'UPlayerTagWidget::_plusUltraFontActive' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _healthBar) == 0x000B10, "Member 'UPlayerTagWidget::_healthBar' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _guardPointBar) == 0x000BE0, "Member 'UPlayerTagWidget::_guardPointBar' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _dyingHealthBar) == 0x000CB0, "Member 'UPlayerTagWidget::_dyingHealthBar' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _healthBarBackground) == 0x000D80, "Member 'UPlayerTagWidget::_healthBarBackground' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _guardPointBarBackground) == 0x000E50, "Member 'UPlayerTagWidget::_guardPointBarBackground' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _playerNameFontColor) == 0x000F20, "Member 'UPlayerTagWidget::_playerNameFontColor' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _playerNameFont) == 0x000F48, "Member 'UPlayerTagWidget::_playerNameFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _enemyBarScaleRatio) == 0x000FA0, "Member 'UPlayerTagWidget::_enemyBarScaleRatio' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _orbIcon) == 0x000FB0, "Member 'UPlayerTagWidget::_orbIcon' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _orbFont) == 0x001080, "Member 'UPlayerTagWidget::_orbFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _orbNumColor) == 0x0010D8, "Member 'UPlayerTagWidget::_orbNumColor' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _leader) == 0x001100, "Member 'UPlayerTagWidget::_leader' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _smallHealthDamageFont) == 0x001110, "Member 'UPlayerTagWidget::_smallHealthDamageFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _normalHealthDamageFont) == 0x001168, "Member 'UPlayerTagWidget::_normalHealthDamageFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _bigHealthDamageFont) == 0x0011C0, "Member 'UPlayerTagWidget::_bigHealthDamageFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _smallGuardDamageFont) == 0x001218, "Member 'UPlayerTagWidget::_smallGuardDamageFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _normalGuardDamageFont) == 0x001270, "Member 'UPlayerTagWidget::_normalGuardDamageFont' has a wrong offset!");
static_assert(offsetof(UPlayerTagWidget, _bigGuardDamageFont) == 0x0012C8, "Member 'UPlayerTagWidget::_bigGuardDamageFont' has a wrong offset!");

// Class InGameModule.PlusUltraLevel
// 0x0010 (0x0360 - 0x0350)
class UPlusUltraLevel final : public UWidgetBase
{
public:
	class UWidgetSwitcher*                        _levelSwitcher;                                    // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _level;                                            // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayActiveAnim();
	void PlayActiveAnim_Internal();
	void PlayLevelUpAnim();
	void PlayLevelUpAnim_Internal();
	void SetPluslevelSwitcher(int32 Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlusUltraLevel">();
	}
	static class UPlusUltraLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlusUltraLevel>();
	}
};
static_assert(alignof(UPlusUltraLevel) == 0x000008, "Wrong alignment on UPlusUltraLevel");
static_assert(sizeof(UPlusUltraLevel) == 0x000360, "Wrong size on UPlusUltraLevel");
static_assert(offsetof(UPlusUltraLevel, _levelSwitcher) == 0x000350, "Member 'UPlusUltraLevel::_levelSwitcher' has a wrong offset!");
static_assert(offsetof(UPlusUltraLevel, _level) == 0x000358, "Member 'UPlusUltraLevel::_level' has a wrong offset!");

// Class InGameModule.PlusUltraWidget
// 0x0010 (0x0378 - 0x0368)
class UPlusUltraWidget final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPUInfoWidget*                          _puInfoWidget;                                     // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlusUltraWidget">();
	}
	static class UPlusUltraWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlusUltraWidget>();
	}
};
static_assert(alignof(UPlusUltraWidget) == 0x000008, "Wrong alignment on UPlusUltraWidget");
static_assert(sizeof(UPlusUltraWidget) == 0x000378, "Wrong size on UPlusUltraWidget");
static_assert(offsetof(UPlusUltraWidget, _puInfoWidget) == 0x000370, "Member 'UPlusUltraWidget::_puInfoWidget' has a wrong offset!");

// Class InGameModule.PoisonMistDataAsset
// 0x0090 (0x00C0 - 0x0030)
class UPoisonMistDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<EGameModeType, struct FStagePoisonMistDataList> _stagePoisonMistData;                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FPoisonMistFadeRow                     _fadeTable;                                        // 0x0080(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FTeamOrbPoisonMistTable                _teamOrbTable;                                     // 0x0090(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSquadKingsPoisonMistTable             _squadKingsTable;                                  // 0x00B8(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTeamKillBattlePoisonMistTable         _teamKillBattleTable;                              // 0x00BC(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	void ClearDebugFlg();
	void MakeJSonData();
	void StagePoisonMistDataSortByEnum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoisonMistDataAsset">();
	}
	static class UPoisonMistDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoisonMistDataAsset>();
	}
};
static_assert(alignof(UPoisonMistDataAsset) == 0x000008, "Wrong alignment on UPoisonMistDataAsset");
static_assert(sizeof(UPoisonMistDataAsset) == 0x0000C0, "Wrong size on UPoisonMistDataAsset");
static_assert(offsetof(UPoisonMistDataAsset, _stagePoisonMistData) == 0x000030, "Member 'UPoisonMistDataAsset::_stagePoisonMistData' has a wrong offset!");
static_assert(offsetof(UPoisonMistDataAsset, _fadeTable) == 0x000080, "Member 'UPoisonMistDataAsset::_fadeTable' has a wrong offset!");
static_assert(offsetof(UPoisonMistDataAsset, _teamOrbTable) == 0x000090, "Member 'UPoisonMistDataAsset::_teamOrbTable' has a wrong offset!");
static_assert(offsetof(UPoisonMistDataAsset, _squadKingsTable) == 0x0000B8, "Member 'UPoisonMistDataAsset::_squadKingsTable' has a wrong offset!");
static_assert(offsetof(UPoisonMistDataAsset, _teamKillBattleTable) == 0x0000BC, "Member 'UPoisonMistDataAsset::_teamKillBattleTable' has a wrong offset!");

// Class InGameModule.PoisonMistManagerComponent
// 0x0068 (0x0118 - 0x00B0)
class UPoisonMistManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x48];                                      // 0x00B0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class AHerovsGameState*                       _ownerGameState;                                   // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APoisonMist*>                    _poisonMistList;                                   // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoisonMistManagerComponent">();
	}
	static class UPoisonMistManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoisonMistManagerComponent>();
	}
};
static_assert(alignof(UPoisonMistManagerComponent) == 0x000008, "Wrong alignment on UPoisonMistManagerComponent");
static_assert(sizeof(UPoisonMistManagerComponent) == 0x000118, "Wrong size on UPoisonMistManagerComponent");
static_assert(offsetof(UPoisonMistManagerComponent, _ownerGameState) == 0x0000F8, "Member 'UPoisonMistManagerComponent::_ownerGameState' has a wrong offset!");
static_assert(offsetof(UPoisonMistManagerComponent, _poisonMistList) == 0x000100, "Member 'UPoisonMistManagerComponent::_poisonMistList' has a wrong offset!");

// Class InGameModule.PoisonMistTimerWidget
// 0x0020 (0x0370 - 0x0350)
class UPoisonMistTimerWidget final : public UWidgetBase
{
public:
	class UInvalidationBox*                       _poisonMistInfo;                                   // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _poisonMistTime;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _poisonMistMoving;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _stormTime;                                        // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MovingPoisonMist() const;
	void StoppingPoisonMist(const float PoisonMistSeconds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoisonMistTimerWidget">();
	}
	static class UPoisonMistTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoisonMistTimerWidget>();
	}
};
static_assert(alignof(UPoisonMistTimerWidget) == 0x000008, "Wrong alignment on UPoisonMistTimerWidget");
static_assert(sizeof(UPoisonMistTimerWidget) == 0x000370, "Wrong size on UPoisonMistTimerWidget");
static_assert(offsetof(UPoisonMistTimerWidget, _poisonMistInfo) == 0x000350, "Member 'UPoisonMistTimerWidget::_poisonMistInfo' has a wrong offset!");
static_assert(offsetof(UPoisonMistTimerWidget, _poisonMistTime) == 0x000358, "Member 'UPoisonMistTimerWidget::_poisonMistTime' has a wrong offset!");
static_assert(offsetof(UPoisonMistTimerWidget, _poisonMistMoving) == 0x000360, "Member 'UPoisonMistTimerWidget::_poisonMistMoving' has a wrong offset!");
static_assert(offsetof(UPoisonMistTimerWidget, _stormTime) == 0x000368, "Member 'UPoisonMistTimerWidget::_stormTime' has a wrong offset!");

// Class InGameModule.PortalRenderSurface
// 0x0030 (0x0058 - 0x0028)
class UPortalRenderSurface final : public UObject
{
public:
	class USceneCaptureComponent2D*               _SCC2D;                                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 _renderTarget2D;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _renderMaterialAsset;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PortalRenderSurface">();
	}
	static class UPortalRenderSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPortalRenderSurface>();
	}
};
static_assert(alignof(UPortalRenderSurface) == 0x000008, "Wrong alignment on UPortalRenderSurface");
static_assert(sizeof(UPortalRenderSurface) == 0x000058, "Wrong size on UPortalRenderSurface");
static_assert(offsetof(UPortalRenderSurface, _SCC2D) == 0x000028, "Member 'UPortalRenderSurface::_SCC2D' has a wrong offset!");
static_assert(offsetof(UPortalRenderSurface, _renderTarget2D) == 0x000030, "Member 'UPortalRenderSurface::_renderTarget2D' has a wrong offset!");
static_assert(offsetof(UPortalRenderSurface, _renderMaterialAsset) == 0x000038, "Member 'UPortalRenderSurface::_renderMaterialAsset' has a wrong offset!");
static_assert(offsetof(UPortalRenderSurface, _mid) == 0x000040, "Member 'UPortalRenderSurface::_mid' has a wrong offset!");

// Class InGameModule.PortalShot
// 0x0010 (0x1DF0 - 0x1DE0)
class APortalShot final : public ABullet
{
public:
	float                                         _createPortalHeightOffset;                         // 0x1DD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DDC[0x4];                                     // 0x1DDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APortalShotGen*                         _generator;                                        // 0x1DE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DE8[0x8];                                     // 0x1DE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PortalShot">();
	}
	static class APortalShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<APortalShot>();
	}
};
static_assert(alignof(APortalShot) == 0x000010, "Wrong alignment on APortalShot");
static_assert(sizeof(APortalShot) == 0x001DF0, "Wrong size on APortalShot");
static_assert(offsetof(APortalShot, _createPortalHeightOffset) == 0x001DD8, "Member 'APortalShot::_createPortalHeightOffset' has a wrong offset!");
static_assert(offsetof(APortalShot, _generator) == 0x001DE0, "Member 'APortalShot::_generator' has a wrong offset!");

// Class InGameModule.PortalShotGen
// 0x0040 (0x0490 - 0x0450)
class APortalShotGen final : public AProjectileGeneratorBattle
{
public:
	struct FPortalShotGenRep                      _createPortalRep;                                  // 0x0448(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	class APortalShot*                            _portalShot;                                       // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APortalShot*                            _portalShotEnd;                                    // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _ignoreList;                                       // 0x0468(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x18];                                     // 0x0478(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreatePortal_RPC(const struct FPortalShotGenRep& GenPortal);
	void OnRep_CreatePortal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PortalShotGen">();
	}
	static class APortalShotGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<APortalShotGen>();
	}
};
static_assert(alignof(APortalShotGen) == 0x000010, "Wrong alignment on APortalShotGen");
static_assert(sizeof(APortalShotGen) == 0x000490, "Wrong size on APortalShotGen");
static_assert(offsetof(APortalShotGen, _createPortalRep) == 0x000448, "Member 'APortalShotGen::_createPortalRep' has a wrong offset!");
static_assert(offsetof(APortalShotGen, _portalShot) == 0x000458, "Member 'APortalShotGen::_portalShot' has a wrong offset!");
static_assert(offsetof(APortalShotGen, _portalShotEnd) == 0x000460, "Member 'APortalShotGen::_portalShotEnd' has a wrong offset!");
static_assert(offsetof(APortalShotGen, _ignoreList) == 0x000468, "Member 'APortalShotGen::_ignoreList' has a wrong offset!");

// Class InGameModule.PredictionLineComponent
// 0x0130 (0x0330 - 0x0200)
class UPredictionLineComponent final : public USceneComponent
{
public:
	class UParticleSystem*                        _hitTemplate;                                      // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            _lineMesh;                                         // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   _impactPointMesh;                                  // 0x0208(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              _lineMeshMaterial;                                 // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _meshScale;                                        // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _meshLength;                                       // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstancedStaticMeshComponent*          _ismc;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _chrBattle;                                        // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _ignoreList;                                       // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _predictionHitParticle;                            // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0xD8];                                     // 0x0258(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoreActor(class AActor* Actor);
	void Begin(float LineRadius, float HitRadius, float SimulateTime, float Frequency, float OverrideGravity, bool HitParticleAlwaysDisp);
	void End();
	void SetHitParticleTemplate(class UParticleSystem* Particle);
	void SetLineMeshMateral(class UMaterial* Material);
	void SetViewType(EViewType Type);
	void Simulate(struct FPredictProjectilePathResult* ResPathData, const struct FVector& StartDir, float Speed);
	void Simulate_ToEndPos(struct FPredictProjectilePathResult* ResPathData, const struct FVector& EndPos, float ArcParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PredictionLineComponent">();
	}
	static class UPredictionLineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPredictionLineComponent>();
	}
};
static_assert(alignof(UPredictionLineComponent) == 0x000010, "Wrong alignment on UPredictionLineComponent");
static_assert(sizeof(UPredictionLineComponent) == 0x000330, "Wrong size on UPredictionLineComponent");
static_assert(offsetof(UPredictionLineComponent, _hitTemplate) == 0x0001F8, "Member 'UPredictionLineComponent::_hitTemplate' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _lineMesh) == 0x000200, "Member 'UPredictionLineComponent::_lineMesh' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _impactPointMesh) == 0x000208, "Member 'UPredictionLineComponent::_impactPointMesh' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _lineMeshMaterial) == 0x000210, "Member 'UPredictionLineComponent::_lineMeshMaterial' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _meshScale) == 0x000218, "Member 'UPredictionLineComponent::_meshScale' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _meshLength) == 0x00021C, "Member 'UPredictionLineComponent::_meshLength' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _ismc) == 0x000220, "Member 'UPredictionLineComponent::_ismc' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _chrBattle) == 0x000238, "Member 'UPredictionLineComponent::_chrBattle' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _ignoreList) == 0x000240, "Member 'UPredictionLineComponent::_ignoreList' has a wrong offset!");
static_assert(offsetof(UPredictionLineComponent, _predictionHitParticle) == 0x000250, "Member 'UPredictionLineComponent::_predictionHitParticle' has a wrong offset!");

// Class InGameModule.PrimaryAssetStageInformation
// 0x0060 (0x00C0 - 0x0060)
class UPrimaryAssetStageInformation final : public UPrimaryAssetBase
{
public:
	TMap<EStageId, struct FStageInfo>             _stageInfoList;                                    // 0x0060(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimaryAssetStageInformation">();
	}
	static class UPrimaryAssetStageInformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrimaryAssetStageInformation>();
	}
};
static_assert(alignof(UPrimaryAssetStageInformation) == 0x000008, "Wrong alignment on UPrimaryAssetStageInformation");
static_assert(sizeof(UPrimaryAssetStageInformation) == 0x0000C0, "Wrong size on UPrimaryAssetStageInformation");
static_assert(offsetof(UPrimaryAssetStageInformation, _stageInfoList) == 0x000060, "Member 'UPrimaryAssetStageInformation::_stageInfoList' has a wrong offset!");

// Class InGameModule.PrimaryAssetTakeCharacterImage
// 0x0058 (0x00B8 - 0x0060)
class UPrimaryAssetTakeCharacterImage final : public UPrimaryAssetBase
{
public:
	TMap<ECharacterId, TSoftObjectPtr<class UDataTable>> _animTable;                                        // 0x0060(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   _characterPath;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimaryAssetTakeCharacterImage">();
	}
	static class UPrimaryAssetTakeCharacterImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrimaryAssetTakeCharacterImage>();
	}
};
static_assert(alignof(UPrimaryAssetTakeCharacterImage) == 0x000008, "Wrong alignment on UPrimaryAssetTakeCharacterImage");
static_assert(sizeof(UPrimaryAssetTakeCharacterImage) == 0x0000B8, "Wrong size on UPrimaryAssetTakeCharacterImage");
static_assert(offsetof(UPrimaryAssetTakeCharacterImage, _animTable) == 0x000060, "Member 'UPrimaryAssetTakeCharacterImage::_animTable' has a wrong offset!");
static_assert(offsetof(UPrimaryAssetTakeCharacterImage, _characterPath) == 0x0000B0, "Member 'UPrimaryAssetTakeCharacterImage::_characterPath' has a wrong offset!");

// Class InGameModule.WidgetCollider
// 0x0000 (0x0260 - 0x0260)
class UWidgetCollider final : public UImage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetCollider">();
	}
	static class UWidgetCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetCollider>();
	}
};
static_assert(alignof(UWidgetCollider) == 0x000010, "Wrong alignment on UWidgetCollider");
static_assert(sizeof(UWidgetCollider) == 0x000260, "Wrong size on UWidgetCollider");

// Class InGameModule.ProfileHasWidget
// 0x0000 (0x0350 - 0x0350)
class UProfileHasWidget final : public UWidgetBase
{
public:
	void OnChangedFinishBattleScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileHasWidget">();
	}
	static class UProfileHasWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfileHasWidget>();
	}
};
static_assert(alignof(UProfileHasWidget) == 0x000008, "Wrong alignment on UProfileHasWidget");
static_assert(sizeof(UProfileHasWidget) == 0x000350, "Wrong size on UProfileHasWidget");

// Class InGameModule.ProjectileCreator
// 0x0058 (0x0278 - 0x0220)
class AProjectileCreator final : public AActor
{
public:
	bool                                          _active;                                           // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerId;                                         // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _charaId;                                          // 0x0222(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_223[0x1];                                      // 0x0223(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _variationNo;                                      // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _DBIndexID;                                        // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _level;                                            // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _delay;                                            // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _beginFastShot;                                    // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _count;                                            // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          _jsonIDX;                                          // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _characterBattle;                                  // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x28];                                     // 0x0250(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileCreator">();
	}
	static class AProjectileCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileCreator>();
	}
};
static_assert(alignof(AProjectileCreator) == 0x000008, "Wrong alignment on AProjectileCreator");
static_assert(sizeof(AProjectileCreator) == 0x000278, "Wrong size on AProjectileCreator");
static_assert(offsetof(AProjectileCreator, _active) == 0x000220, "Member 'AProjectileCreator::_active' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _playerId) == 0x000221, "Member 'AProjectileCreator::_playerId' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _charaId) == 0x000222, "Member 'AProjectileCreator::_charaId' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _variationNo) == 0x000224, "Member 'AProjectileCreator::_variationNo' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _DBIndexID) == 0x000228, "Member 'AProjectileCreator::_DBIndexID' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _level) == 0x000230, "Member 'AProjectileCreator::_level' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _delay) == 0x000234, "Member 'AProjectileCreator::_delay' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _beginFastShot) == 0x000238, "Member 'AProjectileCreator::_beginFastShot' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _count) == 0x00023C, "Member 'AProjectileCreator::_count' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _jsonIDX) == 0x000240, "Member 'AProjectileCreator::_jsonIDX' has a wrong offset!");
static_assert(offsetof(AProjectileCreator, _characterBattle) == 0x000248, "Member 'AProjectileCreator::_characterBattle' has a wrong offset!");

// Class InGameModule.ProjectileEvents
// 0x0140 (0x0170 - 0x0030)
class UProjectileEvents final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileEvents">();
	}
	static class UProjectileEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileEvents>();
	}
};
static_assert(alignof(UProjectileEvents) == 0x000008, "Wrong alignment on UProjectileEvents");
static_assert(sizeof(UProjectileEvents) == 0x000170, "Wrong size on UProjectileEvents");

// Class InGameModule.ProjectileNotify
// 0x0090 (0x00C8 - 0x0038)
class UProjectileNotify : public UAnimNotify
{
public:
	EProjectileGeneratorID                        _generatorID;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _generatorDataName;                                // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _chargeGeneratorDataName;                          // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _socketName;                                       // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachType                                   _attachType;                                       // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterId, struct FProjectileTransform> _offsetTransform;                                  // 0x0070(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         _attachTime;                                       // 0x00C0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _editCharaId;                                      // 0x00C4(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileNotify">();
	}
	static class UProjectileNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileNotify>();
	}
};
static_assert(alignof(UProjectileNotify) == 0x000008, "Wrong alignment on UProjectileNotify");
static_assert(sizeof(UProjectileNotify) == 0x0000C8, "Wrong size on UProjectileNotify");
static_assert(offsetof(UProjectileNotify, _generatorID) == 0x000038, "Member 'UProjectileNotify::_generatorID' has a wrong offset!");
static_assert(offsetof(UProjectileNotify, _generatorDataName) == 0x000040, "Member 'UProjectileNotify::_generatorDataName' has a wrong offset!");
static_assert(offsetof(UProjectileNotify, _chargeGeneratorDataName) == 0x000050, "Member 'UProjectileNotify::_chargeGeneratorDataName' has a wrong offset!");
static_assert(offsetof(UProjectileNotify, _socketName) == 0x000060, "Member 'UProjectileNotify::_socketName' has a wrong offset!");
static_assert(offsetof(UProjectileNotify, _attachType) == 0x000068, "Member 'UProjectileNotify::_attachType' has a wrong offset!");
static_assert(offsetof(UProjectileNotify, _offsetTransform) == 0x000070, "Member 'UProjectileNotify::_offsetTransform' has a wrong offset!");
static_assert(offsetof(UProjectileNotify, _attachTime) == 0x0000C0, "Member 'UProjectileNotify::_attachTime' has a wrong offset!");
static_assert(offsetof(UProjectileNotify, _editCharaId) == 0x0000C4, "Member 'UProjectileNotify::_editCharaId' has a wrong offset!");

// Class InGameModule.ProjectileObjectPool
// 0x0050 (0x0080 - 0x0030)
class UProjectileObjectPool final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileObjectPool">();
	}
	static class UProjectileObjectPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileObjectPool>();
	}
};
static_assert(alignof(UProjectileObjectPool) == 0x000008, "Wrong alignment on UProjectileObjectPool");
static_assert(sizeof(UProjectileObjectPool) == 0x000080, "Wrong size on UProjectileObjectPool");

// Class InGameModule.ProjectileReplicateBattleComponent
// 0x0200 (0x02B0 - 0x00B0)
class UProjectileReplicateBattleComponent final : public UProjectileReplicateGameComponent
{
public:
	struct FProjectileGenerateRep                 _createGenerateRep[0x2];                           // 0x00B0(0x0070)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestroyBulletRep                      _bulletDestroyRep;                                 // 0x0190(0x0068)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestroyGeneratorRep                   _destroyGeneratorRep;                              // 0x01F8(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateRep                              _stateRep;                                         // 0x0200(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGeneralDataRep                        _generalDataRep;                                   // 0x0210(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x28];                                     // 0x0230(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AProjectileGeneratorBattle*>     _genList;                                          // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x48];                                     // 0x0268(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateGenerate_RPC(const struct FProjectileGenerateRep& Rep);
	void DelaySpawnReplicateTest_RPC(const struct FDelaySpawnReplicateTestRep& Data);
	void DestroyBullet_RPC(const struct FDestroyBulletRepImpl& Data);
	void DestroyGenerator_RPC(const struct FDestroyGeneratorRep& Rep);
	void GeneralData_RPC(const struct FGeneralDataRep& Data);
	void GeneratorRestoration_RPC(const struct FRestorationGeneratorRep& Data);
	void OnRep_CreateGenerateData();
	void OnRep_DestroyBullet();
	void OnRep_DestroyGenerator();
	void OnRep_GeneralData();
	void OnRep_State();
	void State_RPC(int32 State, int32 GenID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileReplicateBattleComponent">();
	}
	static class UProjectileReplicateBattleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileReplicateBattleComponent>();
	}
};
static_assert(alignof(UProjectileReplicateBattleComponent) == 0x000010, "Wrong alignment on UProjectileReplicateBattleComponent");
static_assert(sizeof(UProjectileReplicateBattleComponent) == 0x0002B0, "Wrong size on UProjectileReplicateBattleComponent");
static_assert(offsetof(UProjectileReplicateBattleComponent, _createGenerateRep) == 0x0000B0, "Member 'UProjectileReplicateBattleComponent::_createGenerateRep' has a wrong offset!");
static_assert(offsetof(UProjectileReplicateBattleComponent, _bulletDestroyRep) == 0x000190, "Member 'UProjectileReplicateBattleComponent::_bulletDestroyRep' has a wrong offset!");
static_assert(offsetof(UProjectileReplicateBattleComponent, _destroyGeneratorRep) == 0x0001F8, "Member 'UProjectileReplicateBattleComponent::_destroyGeneratorRep' has a wrong offset!");
static_assert(offsetof(UProjectileReplicateBattleComponent, _stateRep) == 0x000200, "Member 'UProjectileReplicateBattleComponent::_stateRep' has a wrong offset!");
static_assert(offsetof(UProjectileReplicateBattleComponent, _generalDataRep) == 0x000210, "Member 'UProjectileReplicateBattleComponent::_generalDataRep' has a wrong offset!");
static_assert(offsetof(UProjectileReplicateBattleComponent, _genList) == 0x000258, "Member 'UProjectileReplicateBattleComponent::_genList' has a wrong offset!");

// Class InGameModule.PUInfoWidget
// 0x0098 (0x0400 - 0x0368)
class UPUInfoWidget final : public UPlayerInfoBaseWidget
{
public:
	class APlayerStateBattle*                     _localPlayerState;                                 // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerControllerBattle;                           // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _characterFaceMID;                                 // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             _animFinishEvent;                                  // 0x0380(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             _aniPuEndAnimEvent;                                // 0x0390(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	class UGameOption*                            _gameOption;                                       // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _chargePUNum;                                      // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _bulletNum;                                        // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _buttonCanvas;                                     // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           _coolTime;                                         // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           _bullet;                                           // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_Active;                                        // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_End;                                           // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_Charge;                                        // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_Active_Watching;                               // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _textSwitcher;                                     // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _buttonGuideSwitcher;                              // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActivePlusUltra();
	void ControllerChange();
	void EndPlusUltra();
	void FinishAnim();
	void ReadyPlusUltra();

	void UpdateButtonGuideVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PUInfoWidget">();
	}
	static class UPUInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPUInfoWidget>();
	}
};
static_assert(alignof(UPUInfoWidget) == 0x000008, "Wrong alignment on UPUInfoWidget");
static_assert(sizeof(UPUInfoWidget) == 0x000400, "Wrong size on UPUInfoWidget");
static_assert(offsetof(UPUInfoWidget, _localPlayerState) == 0x000368, "Member 'UPUInfoWidget::_localPlayerState' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _playerControllerBattle) == 0x000370, "Member 'UPUInfoWidget::_playerControllerBattle' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _characterFaceMID) == 0x000378, "Member 'UPUInfoWidget::_characterFaceMID' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _animFinishEvent) == 0x000380, "Member 'UPUInfoWidget::_animFinishEvent' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _aniPuEndAnimEvent) == 0x000390, "Member 'UPUInfoWidget::_aniPuEndAnimEvent' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _gameOption) == 0x0003A0, "Member 'UPUInfoWidget::_gameOption' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _chargePUNum) == 0x0003A8, "Member 'UPUInfoWidget::_chargePUNum' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _bulletNum) == 0x0003B0, "Member 'UPUInfoWidget::_bulletNum' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _buttonCanvas) == 0x0003B8, "Member 'UPUInfoWidget::_buttonCanvas' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _coolTime) == 0x0003C0, "Member 'UPUInfoWidget::_coolTime' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _bullet) == 0x0003C8, "Member 'UPUInfoWidget::_bullet' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, Ani_Active) == 0x0003D0, "Member 'UPUInfoWidget::Ani_Active' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, Ani_End) == 0x0003D8, "Member 'UPUInfoWidget::Ani_End' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, Ani_Charge) == 0x0003E0, "Member 'UPUInfoWidget::Ani_Charge' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, Ani_Active_Watching) == 0x0003E8, "Member 'UPUInfoWidget::Ani_Active_Watching' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _textSwitcher) == 0x0003F0, "Member 'UPUInfoWidget::_textSwitcher' has a wrong offset!");
static_assert(offsetof(UPUInfoWidget, _buttonGuideSwitcher) == 0x0003F8, "Member 'UPUInfoWidget::_buttonGuideSwitcher' has a wrong offset!");

// Class InGameModule.QuakeComponent
// 0x0030 (0x0230 - 0x0200)
class UQuakeComponent final : public USceneComponent
{
public:
	EFreezeAxis                                   _freezeAxis;                                       // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                _workComponents;                                   // 0x0200(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x20];                                     // 0x0210(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuakeComponent">();
	}
	static class UQuakeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuakeComponent>();
	}
};
static_assert(alignof(UQuakeComponent) == 0x000010, "Wrong alignment on UQuakeComponent");
static_assert(sizeof(UQuakeComponent) == 0x000230, "Wrong size on UQuakeComponent");
static_assert(offsetof(UQuakeComponent, _freezeAxis) == 0x0001F8, "Member 'UQuakeComponent::_freezeAxis' has a wrong offset!");
static_assert(offsetof(UQuakeComponent, _workComponents) == 0x000200, "Member 'UQuakeComponent::_workComponents' has a wrong offset!");

// Class InGameModule.Reflect
// 0x0010 (0x1DF0 - 0x1DE0)
class AReflect final : public ABullet
{
public:
	struct FVector                                ReflectParticleScale;                              // 0x1DD8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DE4[0xC];                                     // 0x1DE4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnHitBullet(class UPrimitiveComponent* HitComponent, class ABullet* OtherBullet, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Reflect">();
	}
	static class AReflect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReflect>();
	}
};
static_assert(alignof(AReflect) == 0x000010, "Wrong alignment on AReflect");
static_assert(sizeof(AReflect) == 0x001DF0, "Wrong size on AReflect");
static_assert(offsetof(AReflect, ReflectParticleScale) == 0x001DD8, "Member 'AReflect::ReflectParticleScale' has a wrong offset!");

// Class InGameModule.RespawnTimerWidget
// 0x0028 (0x0378 - 0x0350)
class URespawnTimerWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _timeGauge;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _timeText;                                         // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RespawnTimerWidget">();
	}
	static class URespawnTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URespawnTimerWidget>();
	}
};
static_assert(alignof(URespawnTimerWidget) == 0x000008, "Wrong alignment on URespawnTimerWidget");
static_assert(sizeof(URespawnTimerWidget) == 0x000378, "Wrong size on URespawnTimerWidget");
static_assert(offsetof(URespawnTimerWidget, _timeGauge) == 0x000360, "Member 'URespawnTimerWidget::_timeGauge' has a wrong offset!");
static_assert(offsetof(URespawnTimerWidget, _timeText) == 0x000368, "Member 'URespawnTimerWidget::_timeText' has a wrong offset!");

// Class InGameModule.RestraintEffectComponent
// 0x00F8 (0x01B0 - 0x00B8)
class alignas(0x10) URestraintEffectComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERestraintType, struct FRestraintParticleInfo> _particleInfoList;                                 // 0x0130(0x0050)(NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _pBeginParticle;                                   // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _pLoopParticle;                                    // 0x0188(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _pEndParticle;                                     // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x18];                                     // 0x0198(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_RegisterEffect(const ERestraintType InEffectType);
	void OnFinishParticle(class UParticleSystemComponent* Particle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestraintEffectComponent">();
	}
	static class URestraintEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestraintEffectComponent>();
	}
};
static_assert(alignof(URestraintEffectComponent) == 0x000010, "Wrong alignment on URestraintEffectComponent");
static_assert(sizeof(URestraintEffectComponent) == 0x0001B0, "Wrong size on URestraintEffectComponent");
static_assert(offsetof(URestraintEffectComponent, _particleInfoList) == 0x000130, "Member 'URestraintEffectComponent::_particleInfoList' has a wrong offset!");
static_assert(offsetof(URestraintEffectComponent, _pBeginParticle) == 0x000180, "Member 'URestraintEffectComponent::_pBeginParticle' has a wrong offset!");
static_assert(offsetof(URestraintEffectComponent, _pLoopParticle) == 0x000188, "Member 'URestraintEffectComponent::_pLoopParticle' has a wrong offset!");
static_assert(offsetof(URestraintEffectComponent, _pEndParticle) == 0x000190, "Member 'URestraintEffectComponent::_pEndParticle' has a wrong offset!");

// Class InGameModule.ResultInfoWidget
// 0x0028 (0x0378 - 0x0350)
class UResultInfoWidget final : public UWidgetBase
{
public:
	class UImage*                                 _win;                                              // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _lose;                                             // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _giveUp;                                           // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _draw;                                             // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameStateBattle*                       _gameState;                                        // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResultInfoWidget">();
	}
	static class UResultInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResultInfoWidget>();
	}
};
static_assert(alignof(UResultInfoWidget) == 0x000008, "Wrong alignment on UResultInfoWidget");
static_assert(sizeof(UResultInfoWidget) == 0x000378, "Wrong size on UResultInfoWidget");
static_assert(offsetof(UResultInfoWidget, _win) == 0x000350, "Member 'UResultInfoWidget::_win' has a wrong offset!");
static_assert(offsetof(UResultInfoWidget, _lose) == 0x000358, "Member 'UResultInfoWidget::_lose' has a wrong offset!");
static_assert(offsetof(UResultInfoWidget, _giveUp) == 0x000360, "Member 'UResultInfoWidget::_giveUp' has a wrong offset!");
static_assert(offsetof(UResultInfoWidget, _draw) == 0x000368, "Member 'UResultInfoWidget::_draw' has a wrong offset!");
static_assert(offsetof(UResultInfoWidget, _gameState) == 0x000370, "Member 'UResultInfoWidget::_gameState' has a wrong offset!");

// Class InGameModule.RetireAppWidget
// 0x0010 (0x03F8 - 0x03E8)
class URetireAppWidget final : public UAppWidget
{
public:
	class UWidgetGeneralWindow*                   _popupWindow;                                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnCloseLevelEvent();
	void OnPopupButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType, bool LeftButton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RetireAppWidget">();
	}
	static class URetireAppWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URetireAppWidget>();
	}
};
static_assert(alignof(URetireAppWidget) == 0x000008, "Wrong alignment on URetireAppWidget");
static_assert(sizeof(URetireAppWidget) == 0x0003F8, "Wrong size on URetireAppWidget");
static_assert(offsetof(URetireAppWidget, _popupWindow) == 0x0003E8, "Member 'URetireAppWidget::_popupWindow' has a wrong offset!");

// Class InGameModule.ReturnMainMenuAppWidget
// 0x0030 (0x0418 - 0x03E8)
class UReturnMainMenuAppWidget final : public UAppWidget
{
public:
	class UWidgetGeneralWindow*                   _popupWindow;                                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  _mainMenuLevel;                                    // 0x03F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnCloseLevelEvent();
	void OnCloseLevelEventReturnToMenu();
	void OnPopupButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType, bool LeftButton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReturnMainMenuAppWidget">();
	}
	static class UReturnMainMenuAppWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReturnMainMenuAppWidget>();
	}
};
static_assert(alignof(UReturnMainMenuAppWidget) == 0x000008, "Wrong alignment on UReturnMainMenuAppWidget");
static_assert(sizeof(UReturnMainMenuAppWidget) == 0x000418, "Wrong size on UReturnMainMenuAppWidget");
static_assert(offsetof(UReturnMainMenuAppWidget, _popupWindow) == 0x0003E8, "Member 'UReturnMainMenuAppWidget::_popupWindow' has a wrong offset!");
static_assert(offsetof(UReturnMainMenuAppWidget, _mainMenuLevel) == 0x0003F0, "Member 'UReturnMainMenuAppWidget::_mainMenuLevel' has a wrong offset!");

// Class InGameModule.RiseCement
// 0x0010 (0x2080 - 0x2070)
class ARiseCement final : public ACementBase
{
public:
	uint8                                         Pad_2070[0x10];                                    // 0x2070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiseCement">();
	}
	static class ARiseCement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARiseCement>();
	}
};
static_assert(alignof(ARiseCement) == 0x000010, "Wrong alignment on ARiseCement");
static_assert(sizeof(ARiseCement) == 0x002080, "Wrong size on ARiseCement");

// Class InGameModule.WrappedRiseCementGen
// 0x0000 (0x0450 - 0x0450)
class AWrappedRiseCementGen final : public AProjectileGeneratorBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrappedRiseCementGen">();
	}
	static class AWrappedRiseCementGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWrappedRiseCementGen>();
	}
};
static_assert(alignof(AWrappedRiseCementGen) == 0x000010, "Wrong alignment on AWrappedRiseCementGen");
static_assert(sizeof(AWrappedRiseCementGen) == 0x000450, "Wrong size on AWrappedRiseCementGen");

// Class InGameModule.RiseCementGen
// 0x0060 (0x04B0 - 0x0450)
class ARiseCementGen final : public AProjectileGeneratorBattle
{
public:
	uint8                                         Pad_448[0x63];                                     // 0x0448(0x0063)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRiseCementGenRep                      _genRep;                                           // 0x04AB(0x0003)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4AE[0x2];                                      // 0x04AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RiseCement();
	void RiseCement_RPC(const struct FRiseCementGenRep& Rep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiseCementGen">();
	}
	static class ARiseCementGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARiseCementGen>();
	}
};
static_assert(alignof(ARiseCementGen) == 0x000010, "Wrong alignment on ARiseCementGen");
static_assert(sizeof(ARiseCementGen) == 0x0004B0, "Wrong size on ARiseCementGen");
static_assert(offsetof(ARiseCementGen, _genRep) == 0x0004AB, "Member 'ARiseCementGen::_genRep' has a wrong offset!");

// Class InGameModule.ScoutBattleActionGuideWidget
// 0x0040 (0x0390 - 0x0350)
class UScoutBattleActionGuideWidget final : public UWidgetBase
{
public:
	class UPlatformRichTextBlock*                 _scoutResponseAcceptCommand;                       // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformRichTextBlock*                 _scoutResponseNotAcceptCommand;                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         _scoutResponseHorizontalBox;                       // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _scoutResponseAccept;                              // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         _scoutResponseNotAcceptHorizontalBox;              // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _scoutResponseNotAcceptText;                       // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _blockUserText;                                    // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _playerName;                                       // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayConsentAnim();
	void PlayConsentAnim_Internal();
	void PlayRefusalAnim();
	void PlayRefusalAnim_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoutBattleActionGuideWidget">();
	}
	static class UScoutBattleActionGuideWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoutBattleActionGuideWidget>();
	}
};
static_assert(alignof(UScoutBattleActionGuideWidget) == 0x000008, "Wrong alignment on UScoutBattleActionGuideWidget");
static_assert(sizeof(UScoutBattleActionGuideWidget) == 0x000390, "Wrong size on UScoutBattleActionGuideWidget");
static_assert(offsetof(UScoutBattleActionGuideWidget, _scoutResponseAcceptCommand) == 0x000350, "Member 'UScoutBattleActionGuideWidget::_scoutResponseAcceptCommand' has a wrong offset!");
static_assert(offsetof(UScoutBattleActionGuideWidget, _scoutResponseNotAcceptCommand) == 0x000358, "Member 'UScoutBattleActionGuideWidget::_scoutResponseNotAcceptCommand' has a wrong offset!");
static_assert(offsetof(UScoutBattleActionGuideWidget, _scoutResponseHorizontalBox) == 0x000360, "Member 'UScoutBattleActionGuideWidget::_scoutResponseHorizontalBox' has a wrong offset!");
static_assert(offsetof(UScoutBattleActionGuideWidget, _scoutResponseAccept) == 0x000368, "Member 'UScoutBattleActionGuideWidget::_scoutResponseAccept' has a wrong offset!");
static_assert(offsetof(UScoutBattleActionGuideWidget, _scoutResponseNotAcceptHorizontalBox) == 0x000370, "Member 'UScoutBattleActionGuideWidget::_scoutResponseNotAcceptHorizontalBox' has a wrong offset!");
static_assert(offsetof(UScoutBattleActionGuideWidget, _scoutResponseNotAcceptText) == 0x000378, "Member 'UScoutBattleActionGuideWidget::_scoutResponseNotAcceptText' has a wrong offset!");
static_assert(offsetof(UScoutBattleActionGuideWidget, _blockUserText) == 0x000380, "Member 'UScoutBattleActionGuideWidget::_blockUserText' has a wrong offset!");
static_assert(offsetof(UScoutBattleActionGuideWidget, _playerName) == 0x000388, "Member 'UScoutBattleActionGuideWidget::_playerName' has a wrong offset!");

// Class InGameModule.SequenceDemoCharacterPoint
// 0x0008 (0x0228 - 0x0220)
class ASequenceDemoCharacterPoint final : public AActor
{
public:
	class UArrowComponent*                        _debugArrowComponent;                              // 0x0220(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequenceDemoCharacterPoint">();
	}
	static class ASequenceDemoCharacterPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequenceDemoCharacterPoint>();
	}
};
static_assert(alignof(ASequenceDemoCharacterPoint) == 0x000008, "Wrong alignment on ASequenceDemoCharacterPoint");
static_assert(sizeof(ASequenceDemoCharacterPoint) == 0x000228, "Wrong size on ASequenceDemoCharacterPoint");
static_assert(offsetof(ASequenceDemoCharacterPoint, _debugArrowComponent) == 0x000220, "Member 'ASequenceDemoCharacterPoint::_debugArrowComponent' has a wrong offset!");

// Class InGameModule.ShortcutItemWidget
// 0x0068 (0x03B8 - 0x0350)
class UShortcutItemWidget final : public UWidgetBase
{
public:
	class APlayerControllerBattle*                _playerController;                                 // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _iconImage;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _itemNumber;                                       // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _timerImage;                                       // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _usingSupplyTimerMID;                              // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       Ani_LastNumberShake;                               // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_SupplyChanged;                                 // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeginUsingSupply(const class USupplyHolder* Holder);
	void OnEndUsingSupply(const class USupplyHolder* Holder);
	void UpdateShortcutUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShortcutItemWidget">();
	}
	static class UShortcutItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShortcutItemWidget>();
	}
};
static_assert(alignof(UShortcutItemWidget) == 0x000008, "Wrong alignment on UShortcutItemWidget");
static_assert(sizeof(UShortcutItemWidget) == 0x0003B8, "Wrong size on UShortcutItemWidget");
static_assert(offsetof(UShortcutItemWidget, _playerController) == 0x000350, "Member 'UShortcutItemWidget::_playerController' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, _playerState) == 0x000358, "Member 'UShortcutItemWidget::_playerState' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, _supplyHolderComponent) == 0x000360, "Member 'UShortcutItemWidget::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, _hudResource) == 0x000368, "Member 'UShortcutItemWidget::_hudResource' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, _iconImage) == 0x000370, "Member 'UShortcutItemWidget::_iconImage' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, _itemNumber) == 0x000378, "Member 'UShortcutItemWidget::_itemNumber' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, _timerImage) == 0x000390, "Member 'UShortcutItemWidget::_timerImage' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, _usingSupplyTimerMID) == 0x000398, "Member 'UShortcutItemWidget::_usingSupplyTimerMID' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, Ani_LastNumberShake) == 0x0003A8, "Member 'UShortcutItemWidget::Ani_LastNumberShake' has a wrong offset!");
static_assert(offsetof(UShortcutItemWidget, Ani_SupplyChanged) == 0x0003B0, "Member 'UShortcutItemWidget::Ani_SupplyChanged' has a wrong offset!");

// Class InGameModule.SignalPinInterface
// 0x0000 (0x0028 - 0x0028)
class ISignalPinInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignalPinInterface">();
	}
	static class ISignalPinInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISignalPinInterface>();
	}
};
static_assert(alignof(ISignalPinInterface) == 0x000008, "Wrong alignment on ISignalPinInterface");
static_assert(sizeof(ISignalPinInterface) == 0x000028, "Wrong size on ISignalPinInterface");

// Class InGameModule.SignalStartWidget
// 0x0000 (0x0350 - 0x0350)
class USignalStartWidget final : public UWidgetBase
{
public:
	void OnStartCall();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignalStartWidget">();
	}
	static class USignalStartWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USignalStartWidget>();
	}
};
static_assert(alignof(USignalStartWidget) == 0x000008, "Wrong alignment on USignalStartWidget");
static_assert(sizeof(USignalStartWidget) == 0x000350, "Wrong size on USignalStartWidget");

// Class InGameModule.SimpleCharacter
// 0x0070 (0x0290 - 0x0220)
class ASimpleCharacter final : public AActor
{
public:
	class UEnhancedSkeletalMeshComponent*         _mesh;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _beginStateName;                                   // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FSimpleCharacterState> _stateList;                                        // 0x0230(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           _currentMontage;                                   // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_ChangeNext();
	void BP_ChangeState(class FName StateName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCharacter">();
	}
	static class ASimpleCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimpleCharacter>();
	}
};
static_assert(alignof(ASimpleCharacter) == 0x000008, "Wrong alignment on ASimpleCharacter");
static_assert(sizeof(ASimpleCharacter) == 0x000290, "Wrong size on ASimpleCharacter");
static_assert(offsetof(ASimpleCharacter, _mesh) == 0x000220, "Member 'ASimpleCharacter::_mesh' has a wrong offset!");
static_assert(offsetof(ASimpleCharacter, _beginStateName) == 0x000228, "Member 'ASimpleCharacter::_beginStateName' has a wrong offset!");
static_assert(offsetof(ASimpleCharacter, _stateList) == 0x000230, "Member 'ASimpleCharacter::_stateList' has a wrong offset!");
static_assert(offsetof(ASimpleCharacter, _currentMontage) == 0x000288, "Member 'ASimpleCharacter::_currentMontage' has a wrong offset!");

// Class InGameModule.SimulatedPlayerHudManager
// 0x02F0 (0x03A0 - 0x00B0)
class alignas(0x10) USimulatedPlayerHudManager final : public UActorComponent
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSequenceWork*                      _gameSequenceWork;                                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformControlComponent*             _transformControlComponent;                        // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x2C8];                                     // 0x00D8(0x02C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginChangeGuard(bool bIsDamage);
	void BeginChangeHealth(bool bIsDamage);
	void OnChangeGuardValue(float Value);
	void OnChangeHealthValue(float Value);
	void OnEndTransformState();
	void OnGuardPointDataInitialized();
	void OnHealthDataInitialized();
	void OnStocked();
	void OnTimerResumed();
	void OnTimerStoped();
	void OnVCBeginTalk(const class FString& UniqueNetId);
	void OnVCConnected(const class FString& UniqueNetId);
	void OnVCDisconnected(const class FString& UniqueNetId);
	void OnVCEndTalk(const class FString& UniqueNetId);
	void OnVCMute(const class FString& UniqueNetId);
	void OnVCUnMute(const class FString& UniqueNetId);
	void StartTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimulatedPlayerHudManager">();
	}
	static class USimulatedPlayerHudManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimulatedPlayerHudManager>();
	}
};
static_assert(alignof(USimulatedPlayerHudManager) == 0x000010, "Wrong alignment on USimulatedPlayerHudManager");
static_assert(sizeof(USimulatedPlayerHudManager) == 0x0003A0, "Wrong size on USimulatedPlayerHudManager");
static_assert(offsetof(USimulatedPlayerHudManager, _playerState) == 0x0000B0, "Member 'USimulatedPlayerHudManager::_playerState' has a wrong offset!");
static_assert(offsetof(USimulatedPlayerHudManager, _gameSequenceWork) == 0x0000B8, "Member 'USimulatedPlayerHudManager::_gameSequenceWork' has a wrong offset!");
static_assert(offsetof(USimulatedPlayerHudManager, _transformControlComponent) == 0x0000D0, "Member 'USimulatedPlayerHudManager::_transformControlComponent' has a wrong offset!");

// Class InGameModule.SkillAbilityPin
// 0x00E0 (0x04C8 - 0x03E8)
class USkillAbilityPin final : public UAppWidget
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerBattle*                _playerController;                                 // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _baseIcon;                                         // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _abilityTypeIcon;                                  // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _abilityTypeIcon_1;                                // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _attackID;                                         // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 _skillSilhouette;                                  // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        _abilityPinSwitcher;                               // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAttackId, class UMaterialInstance*>     _baseMaterialList;                                 // 0x0428(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EAttackId, class UMaterialInstanceDynamic*> _baseDynamicMaterialList;                          // 0x0478(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillAbilityPin">();
	}
	static class USkillAbilityPin* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillAbilityPin>();
	}
};
static_assert(alignof(USkillAbilityPin) == 0x000008, "Wrong alignment on USkillAbilityPin");
static_assert(sizeof(USkillAbilityPin) == 0x0004C8, "Wrong size on USkillAbilityPin");
static_assert(offsetof(USkillAbilityPin, _playerState) == 0x0003E8, "Member 'USkillAbilityPin::_playerState' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _playerController) == 0x0003F0, "Member 'USkillAbilityPin::_playerController' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _baseIcon) == 0x0003F8, "Member 'USkillAbilityPin::_baseIcon' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _abilityTypeIcon) == 0x000400, "Member 'USkillAbilityPin::_abilityTypeIcon' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _abilityTypeIcon_1) == 0x000408, "Member 'USkillAbilityPin::_abilityTypeIcon_1' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _attackID) == 0x000410, "Member 'USkillAbilityPin::_attackID' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _skillSilhouette) == 0x000418, "Member 'USkillAbilityPin::_skillSilhouette' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _abilityPinSwitcher) == 0x000420, "Member 'USkillAbilityPin::_abilityPinSwitcher' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _baseMaterialList) == 0x000428, "Member 'USkillAbilityPin::_baseMaterialList' has a wrong offset!");
static_assert(offsetof(USkillAbilityPin, _baseDynamicMaterialList) == 0x000478, "Member 'USkillAbilityPin::_baseDynamicMaterialList' has a wrong offset!");

// Class InGameModule.SkillChangeParam
// 0x0008 (0x0030 - 0x0028)
class USkillChangeParam final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillChangeParam">();
	}
	static class USkillChangeParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillChangeParam>();
	}
};
static_assert(alignof(USkillChangeParam) == 0x000008, "Wrong alignment on USkillChangeParam");
static_assert(sizeof(USkillChangeParam) == 0x000030, "Wrong size on USkillChangeParam");

// Class InGameModule.SkillManagementComponent
// 0x00C8 (0x0180 - 0x00B8)
class USkillManagementComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0xC8];                                      // 0x00B8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ClearCopySkills();
	void BP_EndCopyMode();
	void BP_EndPlusUltra();
	void BP_SetCopyCharacter(class ACharacterBattle* Character);
	void BP_SetPlusUltra();
	void BP_StartCopyMode(float Time);
	void BP_SwitchCopyMode();
	void SetOriginalSkill_ToClient(EAttackId AttackId, const struct FSkillInfo& NewInfo);
	void SetOriginalSkill_ToServer(EAttackId AttackId, const struct FSkillInfo& NewInfo);

	bool BP_IsCopyStocked() const;
	bool BP_IsEnableCopyMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillManagementComponent">();
	}
	static class USkillManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillManagementComponent>();
	}
};
static_assert(alignof(USkillManagementComponent) == 0x000008, "Wrong alignment on USkillManagementComponent");
static_assert(sizeof(USkillManagementComponent) == 0x000180, "Wrong size on USkillManagementComponent");

// Class InGameModule.SoloBattleCounter
// 0x0008 (0x0380 - 0x0378)
class USoloBattleCounter final : public UBattleCounterBase
{
public:
	class UGenericCounter*                        _playerCounter;                                    // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoloBattleCounter">();
	}
	static class USoloBattleCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoloBattleCounter>();
	}
};
static_assert(alignof(USoloBattleCounter) == 0x000008, "Wrong alignment on USoloBattleCounter");
static_assert(sizeof(USoloBattleCounter) == 0x000380, "Wrong size on USoloBattleCounter");
static_assert(offsetof(USoloBattleCounter, _playerCounter) == 0x000378, "Member 'USoloBattleCounter::_playerCounter' has a wrong offset!");

// Class InGameModule.SoundBattleStatics
// 0x0000 (0x0028 - 0x0028)
class USoundBattleStatics final : public USoundStatics
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundBattleStatics">();
	}
	static class USoundBattleStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundBattleStatics>();
	}
};
static_assert(alignof(USoundBattleStatics) == 0x000008, "Wrong alignment on USoundBattleStatics");
static_assert(sizeof(USoundBattleStatics) == 0x000028, "Wrong size on USoundBattleStatics");

// Class InGameModule.SpawnPoint
// 0x0008 (0x0258 - 0x0250)
class ASpawnPoint final : public APlayerStart
{
public:
	ESpawnPointType                               _type;                                             // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _id;                                               // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPoint">();
	}
	static class ASpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnPoint>();
	}
};
static_assert(alignof(ASpawnPoint) == 0x000008, "Wrong alignment on ASpawnPoint");
static_assert(sizeof(ASpawnPoint) == 0x000258, "Wrong size on ASpawnPoint");
static_assert(offsetof(ASpawnPoint, _type) == 0x000250, "Member 'ASpawnPoint::_type' has a wrong offset!");
static_assert(offsetof(ASpawnPoint, _id) == 0x000254, "Member 'ASpawnPoint::_id' has a wrong offset!");

// Class InGameModule.SpectatingButtonGuideWidget
// 0x0158 (0x04C0 - 0x0368)
class USpectatingButtonGuideWidget final : public UPlayerInfoBaseWidget
{
public:
	class UWidgetButton*                          _prevPlayerButton;                                 // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _nextPlayerButton;                                 // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _cheerButton;                                      // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _statusButton;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _profileButton;                                    // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _violationReportButton;                            // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _resultButton;                                     // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetButton*                          _roomButton;                                       // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _exitButtonSwitcher;                               // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USendLikeWidget*                        _sendLike;                                         // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWidgetButton*>                  _buttonArray;                                      // 0x03B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  _characterStatusLevel;                             // 0x03C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreamingDynamic*                 _characterStatusLevelStreaming;                    // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  _violationReportLevel;                             // 0x03F8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  _botViolationReportLevel;                          // 0x0420(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreamingDynamic*                 _violationReportLevelStreaming;                    // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  _goToResultLevel;                                  // 0x0450(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  _confirmRoomLevel;                                 // 0x0478(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          _likeAtomCue;                                      // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x18];                                     // 0x04A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddedPlayer(class AHerovsPlayerState* AddedPlayer_0);
	void CloseViolationReportLevel();
	void OnDecideChangePlayerViewNextButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDecideChangePlayerViewPrevButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDecideCheerButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDecideGoToResulttButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDecideOpenProfileButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDecideOpenStatusButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDecideOpenViolationReportButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnDecideRoomButtonEvent(class UAppWidget* Widget, EWidgetInputType InputType);
	void OnLevelHidden();
	void OnRecvCheerEvent(int32 CheerCount, int32 LocalCheerCount);
	void OnSetMyAd(int32 backgroundId, int32 EffectId, int32 MessageId, int32 Message, int32 LeftId, int32 MiddId, int32 RightId);
	void RemovedPlayer(class AHerovsPlayerState* RemovePlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatingButtonGuideWidget">();
	}
	static class USpectatingButtonGuideWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatingButtonGuideWidget>();
	}
};
static_assert(alignof(USpectatingButtonGuideWidget) == 0x000008, "Wrong alignment on USpectatingButtonGuideWidget");
static_assert(sizeof(USpectatingButtonGuideWidget) == 0x0004C0, "Wrong size on USpectatingButtonGuideWidget");
static_assert(offsetof(USpectatingButtonGuideWidget, _prevPlayerButton) == 0x000368, "Member 'USpectatingButtonGuideWidget::_prevPlayerButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _nextPlayerButton) == 0x000370, "Member 'USpectatingButtonGuideWidget::_nextPlayerButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _cheerButton) == 0x000378, "Member 'USpectatingButtonGuideWidget::_cheerButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _statusButton) == 0x000380, "Member 'USpectatingButtonGuideWidget::_statusButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _profileButton) == 0x000388, "Member 'USpectatingButtonGuideWidget::_profileButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _violationReportButton) == 0x000390, "Member 'USpectatingButtonGuideWidget::_violationReportButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _resultButton) == 0x000398, "Member 'USpectatingButtonGuideWidget::_resultButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _roomButton) == 0x0003A0, "Member 'USpectatingButtonGuideWidget::_roomButton' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _exitButtonSwitcher) == 0x0003A8, "Member 'USpectatingButtonGuideWidget::_exitButtonSwitcher' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _sendLike) == 0x0003B0, "Member 'USpectatingButtonGuideWidget::_sendLike' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _buttonArray) == 0x0003B8, "Member 'USpectatingButtonGuideWidget::_buttonArray' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _characterStatusLevel) == 0x0003C8, "Member 'USpectatingButtonGuideWidget::_characterStatusLevel' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _characterStatusLevelStreaming) == 0x0003F0, "Member 'USpectatingButtonGuideWidget::_characterStatusLevelStreaming' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _violationReportLevel) == 0x0003F8, "Member 'USpectatingButtonGuideWidget::_violationReportLevel' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _botViolationReportLevel) == 0x000420, "Member 'USpectatingButtonGuideWidget::_botViolationReportLevel' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _violationReportLevelStreaming) == 0x000448, "Member 'USpectatingButtonGuideWidget::_violationReportLevelStreaming' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _goToResultLevel) == 0x000450, "Member 'USpectatingButtonGuideWidget::_goToResultLevel' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _confirmRoomLevel) == 0x000478, "Member 'USpectatingButtonGuideWidget::_confirmRoomLevel' has a wrong offset!");
static_assert(offsetof(USpectatingButtonGuideWidget, _likeAtomCue) == 0x0004A0, "Member 'USpectatingButtonGuideWidget::_likeAtomCue' has a wrong offset!");

// Class InGameModule.SpectatingChangeFadeWidget
// 0x0010 (0x0378 - 0x0368)
class USpectatingChangeFadeWidget final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ChangePlayerView();
	void BP_StartFade(bool bNext);
	void StartFade(bool bNext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatingChangeFadeWidget">();
	}
	static class USpectatingChangeFadeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatingChangeFadeWidget>();
	}
};
static_assert(alignof(USpectatingChangeFadeWidget) == 0x000008, "Wrong alignment on USpectatingChangeFadeWidget");
static_assert(sizeof(USpectatingChangeFadeWidget) == 0x000378, "Wrong size on USpectatingChangeFadeWidget");

// Class InGameModule.SpringArmBattleComponent
// 0x0030 (0x02B0 - 0x0280)
class USpringArmBattleComponent final : public USpringArmComponent
{
public:
	float                                         CameraLagSpeedZ;                                   // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxDistanceMin;                           // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxDistanceMax;                           // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitInterpSpeed;                                    // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReturnInterpTime;                               // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringArmBattleComponent">();
	}
	static class USpringArmBattleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringArmBattleComponent>();
	}
};
static_assert(alignof(USpringArmBattleComponent) == 0x000010, "Wrong alignment on USpringArmBattleComponent");
static_assert(sizeof(USpringArmBattleComponent) == 0x0002B0, "Wrong size on USpringArmBattleComponent");
static_assert(offsetof(USpringArmBattleComponent, CameraLagSpeedZ) == 0x000280, "Member 'USpringArmBattleComponent::CameraLagSpeedZ' has a wrong offset!");
static_assert(offsetof(USpringArmBattleComponent, CameraLagMaxDistanceMin) == 0x000284, "Member 'USpringArmBattleComponent::CameraLagMaxDistanceMin' has a wrong offset!");
static_assert(offsetof(USpringArmBattleComponent, CameraLagMaxDistanceMax) == 0x000288, "Member 'USpringArmBattleComponent::CameraLagMaxDistanceMax' has a wrong offset!");
static_assert(offsetof(USpringArmBattleComponent, MaxSimulationIterations) == 0x00028C, "Member 'USpringArmBattleComponent::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(USpringArmBattleComponent, HitInterpSpeed) == 0x000290, "Member 'USpringArmBattleComponent::HitInterpSpeed' has a wrong offset!");
static_assert(offsetof(USpringArmBattleComponent, HitReturnInterpTime) == 0x000294, "Member 'USpringArmBattleComponent::HitReturnInterpTime' has a wrong offset!");

// Class InGameModule.SquadBattleCounter
// 0x0018 (0x0390 - 0x0378)
class USquadBattleCounter final : public UBattleCounterBase
{
public:
	class UGenericCounter*                        _squadCounter;                                     // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGenericCounter*                        _playerCounter;                                    // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniTeamup;                                        // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadBattleCounter">();
	}
	static class USquadBattleCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadBattleCounter>();
	}
};
static_assert(alignof(USquadBattleCounter) == 0x000008, "Wrong alignment on USquadBattleCounter");
static_assert(sizeof(USquadBattleCounter) == 0x000390, "Wrong size on USquadBattleCounter");
static_assert(offsetof(USquadBattleCounter, _squadCounter) == 0x000378, "Member 'USquadBattleCounter::_squadCounter' has a wrong offset!");
static_assert(offsetof(USquadBattleCounter, _playerCounter) == 0x000380, "Member 'USquadBattleCounter::_playerCounter' has a wrong offset!");
static_assert(offsetof(USquadBattleCounter, _aniTeamup) == 0x000388, "Member 'USquadBattleCounter::_aniTeamup' has a wrong offset!");

// Class InGameModule.SquadKingsPoisonMist
// 0x0010 (0x0358 - 0x0348)
class ASquadKingsPoisonMist final : public APoisonMist
{
public:
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadKingsPoisonMist">();
	}
	static class ASquadKingsPoisonMist* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquadKingsPoisonMist>();
	}
};
static_assert(alignof(ASquadKingsPoisonMist) == 0x000008, "Wrong alignment on ASquadKingsPoisonMist");
static_assert(sizeof(ASquadKingsPoisonMist) == 0x000358, "Wrong size on ASquadKingsPoisonMist");

// Class InGameModule.StageBarrierManagerComponent
// 0x0028 (0x00D8 - 0x00B0)
class UStageBarrierManagerComponent final : public UActorComponent
{
public:
	TSubclassOf<class ABgBarrier>                 _stageBarrier;                                     // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABgBarrier*>                     _stageBarrierList;                                 // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageBarrierManagerComponent">();
	}
	static class UStageBarrierManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStageBarrierManagerComponent>();
	}
};
static_assert(alignof(UStageBarrierManagerComponent) == 0x000008, "Wrong alignment on UStageBarrierManagerComponent");
static_assert(sizeof(UStageBarrierManagerComponent) == 0x0000D8, "Wrong size on UStageBarrierManagerComponent");
static_assert(offsetof(UStageBarrierManagerComponent, _stageBarrier) == 0x0000B0, "Member 'UStageBarrierManagerComponent::_stageBarrier' has a wrong offset!");
static_assert(offsetof(UStageBarrierManagerComponent, _stageBarrierList) == 0x0000B8, "Member 'UStageBarrierManagerComponent::_stageBarrierList' has a wrong offset!");

// Class InGameModule.StageCommonDataAsset
// 0x0010 (0x0040 - 0x0030)
class UStageCommonDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<float>                                 _stageRadiusList;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageCommonDataAsset">();
	}
	static class UStageCommonDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStageCommonDataAsset>();
	}
};
static_assert(alignof(UStageCommonDataAsset) == 0x000008, "Wrong alignment on UStageCommonDataAsset");
static_assert(sizeof(UStageCommonDataAsset) == 0x000040, "Wrong size on UStageCommonDataAsset");
static_assert(offsetof(UStageCommonDataAsset, _stageRadiusList) == 0x000030, "Member 'UStageCommonDataAsset::_stageRadiusList' has a wrong offset!");

// Class InGameModule.StageDataManagerWorldSubsystem
// 0x0010 (0x0040 - 0x0030)
class UStageDataManagerWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EStageId                                      _currentStageId;                                   // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageDataManagerWorldSubsystem">();
	}
	static class UStageDataManagerWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStageDataManagerWorldSubsystem>();
	}
};
static_assert(alignof(UStageDataManagerWorldSubsystem) == 0x000008, "Wrong alignment on UStageDataManagerWorldSubsystem");
static_assert(sizeof(UStageDataManagerWorldSubsystem) == 0x000040, "Wrong size on UStageDataManagerWorldSubsystem");
static_assert(offsetof(UStageDataManagerWorldSubsystem, _currentStageId) == 0x000038, "Member 'UStageDataManagerWorldSubsystem::_currentStageId' has a wrong offset!");

// Class InGameModule.StageManager
// 0x0028 (0x0248 - 0x0220)
class AStageManager final : public AInfo
{
public:
	class USupplyBoxManagerComponent*             _smallSupplyBoxManagerComponent;                   // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USupplyBoxManagerComponent*             _largeSupplyBoxManagerComponent;                   // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USupplyBoxManagerComponent*             _goldenSupplyBoxManagerComponent;                  // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickManagerComponent*               _gimmickManagerComponent;                          // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCManagerComponent*                   _npcManagerComponent;                              // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageManager">();
	}
	static class AStageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageManager>();
	}
};
static_assert(alignof(AStageManager) == 0x000008, "Wrong alignment on AStageManager");
static_assert(sizeof(AStageManager) == 0x000248, "Wrong size on AStageManager");
static_assert(offsetof(AStageManager, _smallSupplyBoxManagerComponent) == 0x000220, "Member 'AStageManager::_smallSupplyBoxManagerComponent' has a wrong offset!");
static_assert(offsetof(AStageManager, _largeSupplyBoxManagerComponent) == 0x000228, "Member 'AStageManager::_largeSupplyBoxManagerComponent' has a wrong offset!");
static_assert(offsetof(AStageManager, _goldenSupplyBoxManagerComponent) == 0x000230, "Member 'AStageManager::_goldenSupplyBoxManagerComponent' has a wrong offset!");
static_assert(offsetof(AStageManager, _gimmickManagerComponent) == 0x000238, "Member 'AStageManager::_gimmickManagerComponent' has a wrong offset!");
static_assert(offsetof(AStageManager, _npcManagerComponent) == 0x000240, "Member 'AStageManager::_npcManagerComponent' has a wrong offset!");

// Class InGameModule.StagePostProcessManager
// 0x0050 (0x0270 - 0x0220)
class AStagePostProcessManager final : public AInfo
{
public:
	class APostProcessVolume*                     _DistortionPostProcess;                            // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APostProcessVolume*                     _ScreenRainPostProcess;                            // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APostProcessVolume*                     _UnderWaterDistortionPostProcess;                  // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APostProcessVolume*                     _WorldPostProcess;                                 // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      ScreenRainSwitchMatIns;                            // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _OutlineSwitchMatIns;                              // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _OutlineLeadersMatIns;                             // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _OutlineLeadersSwitchMatIns;                       // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeAO(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StagePostProcessManager">();
	}
	static class AStagePostProcessManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStagePostProcessManager>();
	}
};
static_assert(alignof(AStagePostProcessManager) == 0x000008, "Wrong alignment on AStagePostProcessManager");
static_assert(sizeof(AStagePostProcessManager) == 0x000270, "Wrong size on AStagePostProcessManager");
static_assert(offsetof(AStagePostProcessManager, _DistortionPostProcess) == 0x000220, "Member 'AStagePostProcessManager::_DistortionPostProcess' has a wrong offset!");
static_assert(offsetof(AStagePostProcessManager, _ScreenRainPostProcess) == 0x000228, "Member 'AStagePostProcessManager::_ScreenRainPostProcess' has a wrong offset!");
static_assert(offsetof(AStagePostProcessManager, _UnderWaterDistortionPostProcess) == 0x000230, "Member 'AStagePostProcessManager::_UnderWaterDistortionPostProcess' has a wrong offset!");
static_assert(offsetof(AStagePostProcessManager, _WorldPostProcess) == 0x000238, "Member 'AStagePostProcessManager::_WorldPostProcess' has a wrong offset!");
static_assert(offsetof(AStagePostProcessManager, ScreenRainSwitchMatIns) == 0x000240, "Member 'AStagePostProcessManager::ScreenRainSwitchMatIns' has a wrong offset!");
static_assert(offsetof(AStagePostProcessManager, _OutlineSwitchMatIns) == 0x000248, "Member 'AStagePostProcessManager::_OutlineSwitchMatIns' has a wrong offset!");
static_assert(offsetof(AStagePostProcessManager, _OutlineLeadersMatIns) == 0x000250, "Member 'AStagePostProcessManager::_OutlineLeadersMatIns' has a wrong offset!");
static_assert(offsetof(AStagePostProcessManager, _OutlineLeadersSwitchMatIns) == 0x000258, "Member 'AStagePostProcessManager::_OutlineLeadersSwitchMatIns' has a wrong offset!");

// Class InGameModule.StatusBoxBase
// 0x0248 (0x0598 - 0x0350)
class UStatusBoxBase final : public UWidgetBase
{
public:
	class APlayerStateBattle*                     _statusBoxPlayerState;                             // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USimulatedPlayerHudManager*             _statusBoxSimulatedPlayerHudManager;               // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _statusBoxCharacterBattle;                         // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _charaFaceMat;                                     // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _charaFaceMatDynamic;                              // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     _healthGaugeMaterial;                              // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _guardGaugeMaterial;                               // 0x03A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _dyingGaugeMaterial;                               // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _healthGaugeMID;                                   // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _guardGaugeMID;                                    // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _dyingHealthMID;                                   // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _dyingTint;                                        // 0x03D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _deadTint;                                         // 0x03E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _usingSupplyTimerMID;                              // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x14];                                     // 0x0400(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _leaveGameTint;                                    // 0x0414(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _statusIngredientsAdditionalPosition;              // 0x0424(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerVoiceChatStateWidget*            _voiceChatState;                                   // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _playerName;                                       // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _playerOnlineId;                                   // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNumberOnImageDrawPrimitive*            _plusNumIcon;                                      // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _roleImage;                                        // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _health;                                           // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _dyingHealth;                                      // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _guard;                                            // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _reSpawnFragmentSwitcher;                          // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _reSpawnFragmentNum;                               // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _reSpawnPanel;                                     // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _characterFace;                                    // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _crown;                                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _characterBadgePanel;                              // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterBadge*                        _characterBadge;                                   // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNumberOnImageDrawPrimitive*            _orbCounter;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugPlayerStatusText*                 _playerStatus;                                     // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _timeToComeBack;                                   // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _backGround;                                       // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         _statusIngredientsHoriBox;                         // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _guardPoint;                                       // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _hp;                                               // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _normalHpColor;                                    // 0x04E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _downHpColor;                                      // 0x04F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCircularProgressBarWidget*             _actionProgressBar;                                // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryAllySkillListWidget*          _allySkillInfo;                                    // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           _disconnect;                                       // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGSupplyRequest*                      _supplyRequestNotification;                        // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x28];                                     // 0x0520(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _indicateDecimalPointNum;                          // 0x0548(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        _leaderInfo;                                       // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _leadersTeamSwitcher;                              // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                _member;                                           // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                _leadersBorder;                                    // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _borderColor;                                      // 0x0570(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_580[0x8];                                      // 0x0580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             _minutes;                                          // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _seconds;                                          // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BoxTick(float DeltaTime);
	void HideSupplyRequestUI();
	void SetGameStart();
	void SetNewOrbNum();
	void SetNewPlusNum();
	void SetStatusBox(class APlayerStateBattle* boxPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusBoxBase">();
	}
	static class UStatusBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusBoxBase>();
	}
};
static_assert(alignof(UStatusBoxBase) == 0x000008, "Wrong alignment on UStatusBoxBase");
static_assert(sizeof(UStatusBoxBase) == 0x000598, "Wrong size on UStatusBoxBase");
static_assert(offsetof(UStatusBoxBase, _statusBoxPlayerState) == 0x000350, "Member 'UStatusBoxBase::_statusBoxPlayerState' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _statusBoxSimulatedPlayerHudManager) == 0x000358, "Member 'UStatusBoxBase::_statusBoxSimulatedPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _supplyHolderComponent) == 0x000360, "Member 'UStatusBoxBase::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _statusBoxCharacterBattle) == 0x000368, "Member 'UStatusBoxBase::_statusBoxCharacterBattle' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _hudResource) == 0x000370, "Member 'UStatusBoxBase::_hudResource' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _charaFaceMat) == 0x000378, "Member 'UStatusBoxBase::_charaFaceMat' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _charaFaceMatDynamic) == 0x000380, "Member 'UStatusBoxBase::_charaFaceMatDynamic' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _healthGaugeMaterial) == 0x0003A0, "Member 'UStatusBoxBase::_healthGaugeMaterial' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _guardGaugeMaterial) == 0x0003A8, "Member 'UStatusBoxBase::_guardGaugeMaterial' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _dyingGaugeMaterial) == 0x0003B0, "Member 'UStatusBoxBase::_dyingGaugeMaterial' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _healthGaugeMID) == 0x0003B8, "Member 'UStatusBoxBase::_healthGaugeMID' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _guardGaugeMID) == 0x0003C0, "Member 'UStatusBoxBase::_guardGaugeMID' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _dyingHealthMID) == 0x0003C8, "Member 'UStatusBoxBase::_dyingHealthMID' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _dyingTint) == 0x0003D0, "Member 'UStatusBoxBase::_dyingTint' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _deadTint) == 0x0003E8, "Member 'UStatusBoxBase::_deadTint' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _usingSupplyTimerMID) == 0x0003F8, "Member 'UStatusBoxBase::_usingSupplyTimerMID' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _leaveGameTint) == 0x000414, "Member 'UStatusBoxBase::_leaveGameTint' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _statusIngredientsAdditionalPosition) == 0x000424, "Member 'UStatusBoxBase::_statusIngredientsAdditionalPosition' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _voiceChatState) == 0x000430, "Member 'UStatusBoxBase::_voiceChatState' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _playerName) == 0x000438, "Member 'UStatusBoxBase::_playerName' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _playerOnlineId) == 0x000440, "Member 'UStatusBoxBase::_playerOnlineId' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _plusNumIcon) == 0x000448, "Member 'UStatusBoxBase::_plusNumIcon' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _roleImage) == 0x000450, "Member 'UStatusBoxBase::_roleImage' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _health) == 0x000458, "Member 'UStatusBoxBase::_health' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _dyingHealth) == 0x000460, "Member 'UStatusBoxBase::_dyingHealth' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _guard) == 0x000468, "Member 'UStatusBoxBase::_guard' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _reSpawnFragmentSwitcher) == 0x000470, "Member 'UStatusBoxBase::_reSpawnFragmentSwitcher' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _reSpawnFragmentNum) == 0x000478, "Member 'UStatusBoxBase::_reSpawnFragmentNum' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _reSpawnPanel) == 0x000480, "Member 'UStatusBoxBase::_reSpawnPanel' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _characterFace) == 0x000488, "Member 'UStatusBoxBase::_characterFace' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _crown) == 0x000490, "Member 'UStatusBoxBase::_crown' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _characterBadgePanel) == 0x000498, "Member 'UStatusBoxBase::_characterBadgePanel' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _characterBadge) == 0x0004A0, "Member 'UStatusBoxBase::_characterBadge' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _orbCounter) == 0x0004A8, "Member 'UStatusBoxBase::_orbCounter' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _playerStatus) == 0x0004B0, "Member 'UStatusBoxBase::_playerStatus' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _timeToComeBack) == 0x0004B8, "Member 'UStatusBoxBase::_timeToComeBack' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _backGround) == 0x0004C0, "Member 'UStatusBoxBase::_backGround' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _statusIngredientsHoriBox) == 0x0004C8, "Member 'UStatusBoxBase::_statusIngredientsHoriBox' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _guardPoint) == 0x0004D0, "Member 'UStatusBoxBase::_guardPoint' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _hp) == 0x0004D8, "Member 'UStatusBoxBase::_hp' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _normalHpColor) == 0x0004E0, "Member 'UStatusBoxBase::_normalHpColor' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _downHpColor) == 0x0004F0, "Member 'UStatusBoxBase::_downHpColor' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _actionProgressBar) == 0x000500, "Member 'UStatusBoxBase::_actionProgressBar' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _allySkillInfo) == 0x000508, "Member 'UStatusBoxBase::_allySkillInfo' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _disconnect) == 0x000510, "Member 'UStatusBoxBase::_disconnect' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _supplyRequestNotification) == 0x000518, "Member 'UStatusBoxBase::_supplyRequestNotification' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _indicateDecimalPointNum) == 0x000548, "Member 'UStatusBoxBase::_indicateDecimalPointNum' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _leaderInfo) == 0x000550, "Member 'UStatusBoxBase::_leaderInfo' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _leadersTeamSwitcher) == 0x000558, "Member 'UStatusBoxBase::_leadersTeamSwitcher' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _member) == 0x000560, "Member 'UStatusBoxBase::_member' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _leadersBorder) == 0x000568, "Member 'UStatusBoxBase::_leadersBorder' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _borderColor) == 0x000570, "Member 'UStatusBoxBase::_borderColor' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _minutes) == 0x000588, "Member 'UStatusBoxBase::_minutes' has a wrong offset!");
static_assert(offsetof(UStatusBoxBase, _seconds) == 0x000590, "Member 'UStatusBoxBase::_seconds' has a wrong offset!");

// Class InGameModule.SubCharacter
// 0x0010 (0x0B20 - 0x0B10)
class ASubCharacter final : public ACharacterBattle
{
public:
	class ACharacterBattle*                       _parentCharacter;                                  // 0x0B10(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _playerId;                                         // 0x0B18(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B19[0x7];                                      // 0x0B19(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubCharacter">();
	}
	static class ASubCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASubCharacter>();
	}
};
static_assert(alignof(ASubCharacter) == 0x000010, "Wrong alignment on ASubCharacter");
static_assert(sizeof(ASubCharacter) == 0x000B20, "Wrong size on ASubCharacter");
static_assert(offsetof(ASubCharacter, _parentCharacter) == 0x000B10, "Member 'ASubCharacter::_parentCharacter' has a wrong offset!");
static_assert(offsetof(ASubCharacter, _playerId) == 0x000B18, "Member 'ASubCharacter::_playerId' has a wrong offset!");

// Class InGameModule.SubCharacterDamageComponent
// 0x0000 (0x01B8 - 0x01B8)
class USubCharacterDamageComponent final : public UCharacterDamageComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubCharacterDamageComponent">();
	}
	static class USubCharacterDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubCharacterDamageComponent>();
	}
};
static_assert(alignof(USubCharacterDamageComponent) == 0x000008, "Wrong alignment on USubCharacterDamageComponent");
static_assert(sizeof(USubCharacterDamageComponent) == 0x0001B8, "Wrong size on USubCharacterDamageComponent");

// Class InGameModule.Supply
// 0x0040 (0x0068 - 0x0028)
class USupply : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Supply">();
	}
	static class USupply* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupply>();
	}
};
static_assert(alignof(USupply) == 0x000008, "Wrong alignment on USupply");
static_assert(sizeof(USupply) == 0x000068, "Wrong size on USupply");

// Class InGameModule.SupplyHealthRecover
// 0x0000 (0x0068 - 0x0068)
class USupplyHealthRecover final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyHealthRecover">();
	}
	static class USupplyHealthRecover* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyHealthRecover>();
	}
};
static_assert(alignof(USupplyHealthRecover) == 0x000008, "Wrong alignment on USupplyHealthRecover");
static_assert(sizeof(USupplyHealthRecover) == 0x000068, "Wrong size on USupplyHealthRecover");

// Class InGameModule.SupplyGuardRecover
// 0x0000 (0x0068 - 0x0068)
class USupplyGuardRecover final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyGuardRecover">();
	}
	static class USupplyGuardRecover* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyGuardRecover>();
	}
};
static_assert(alignof(USupplyGuardRecover) == 0x000008, "Wrong alignment on USupplyGuardRecover");
static_assert(sizeof(USupplyGuardRecover) == 0x000068, "Wrong size on USupplyGuardRecover");

// Class InGameModule.SupplyHealthAndGuardRecover
// 0x0000 (0x0068 - 0x0068)
class USupplyHealthAndGuardRecover final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyHealthAndGuardRecover">();
	}
	static class USupplyHealthAndGuardRecover* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyHealthAndGuardRecover>();
	}
};
static_assert(alignof(USupplyHealthAndGuardRecover) == 0x000008, "Wrong alignment on USupplyHealthAndGuardRecover");
static_assert(sizeof(USupplyHealthAndGuardRecover) == 0x000068, "Wrong size on USupplyHealthAndGuardRecover");

// Class InGameModule.SupplyLevelup
// 0x0000 (0x0068 - 0x0068)
class USupplyLevelup final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyLevelup">();
	}
	static class USupplyLevelup* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyLevelup>();
	}
};
static_assert(alignof(USupplyLevelup) == 0x000008, "Wrong alignment on USupplyLevelup");
static_assert(sizeof(USupplyLevelup) == 0x000068, "Wrong size on USupplyLevelup");

// Class InGameModule.SupplyPlusultra
// 0x0000 (0x0068 - 0x0068)
class USupplyPlusultra final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyPlusultra">();
	}
	static class USupplyPlusultra* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyPlusultra>();
	}
};
static_assert(alignof(USupplyPlusultra) == 0x000008, "Wrong alignment on USupplyPlusultra");
static_assert(sizeof(USupplyPlusultra) == 0x000068, "Wrong size on USupplyPlusultra");

// Class InGameModule.SupplyAbility
// 0x0008 (0x0070 - 0x0068)
class USupplyAbility final : public USupply
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyAbility">();
	}
	static class USupplyAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyAbility>();
	}
};
static_assert(alignof(USupplyAbility) == 0x000008, "Wrong alignment on USupplyAbility");
static_assert(sizeof(USupplyAbility) == 0x000070, "Wrong size on USupplyAbility");

// Class InGameModule.SupplyShoulder
// 0x0000 (0x0068 - 0x0068)
class USupplyShoulder final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyShoulder">();
	}
	static class USupplyShoulder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyShoulder>();
	}
};
static_assert(alignof(USupplyShoulder) == 0x000008, "Wrong alignment on USupplyShoulder");
static_assert(sizeof(USupplyShoulder) == 0x000068, "Wrong size on USupplyShoulder");

// Class InGameModule.SupplyOrb
// 0x0000 (0x0068 - 0x0068)
class USupplyOrb final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyOrb">();
	}
	static class USupplyOrb* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyOrb>();
	}
};
static_assert(alignof(USupplyOrb) == 0x000008, "Wrong alignment on USupplyOrb");
static_assert(sizeof(USupplyOrb) == 0x000068, "Wrong size on USupplyOrb");

// Class InGameModule.SupplyLevelupAllAllys
// 0x0000 (0x0068 - 0x0068)
class USupplyLevelupAllAllys final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyLevelupAllAllys">();
	}
	static class USupplyLevelupAllAllys* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyLevelupAllAllys>();
	}
};
static_assert(alignof(USupplyLevelupAllAllys) == 0x000008, "Wrong alignment on USupplyLevelupAllAllys");
static_assert(sizeof(USupplyLevelupAllAllys) == 0x000068, "Wrong size on USupplyLevelupAllAllys");

// Class InGameModule.SupplyDogTag
// 0x0008 (0x0070 - 0x0068)
class USupplyDogTag final : public USupply
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyDogTag">();
	}
	static class USupplyDogTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyDogTag>();
	}
};
static_assert(alignof(USupplyDogTag) == 0x000008, "Wrong alignment on USupplyDogTag");
static_assert(sizeof(USupplyDogTag) == 0x000070, "Wrong size on USupplyDogTag");

// Class InGameModule.SupplyRespawnFlagment
// 0x0000 (0x0068 - 0x0068)
class USupplyRespawnFlagment final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyRespawnFlagment">();
	}
	static class USupplyRespawnFlagment* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyRespawnFlagment>();
	}
};
static_assert(alignof(USupplyRespawnFlagment) == 0x000008, "Wrong alignment on USupplyRespawnFlagment");
static_assert(sizeof(USupplyRespawnFlagment) == 0x000068, "Wrong size on USupplyRespawnFlagment");

// Class InGameModule.SupplyRespawn
// 0x0000 (0x0068 - 0x0068)
class USupplyRespawn final : public USupply
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyRespawn">();
	}
	static class USupplyRespawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyRespawn>();
	}
};
static_assert(alignof(USupplyRespawn) == 0x000008, "Wrong alignment on USupplyRespawn");
static_assert(sizeof(USupplyRespawn) == 0x000068, "Wrong size on USupplyRespawn");

// Class InGameModule.SupplyBox
// 0x0170 (0x0428 - 0x02B8)
class ASupplyBox final : public ASupplyActorBase
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESupplyBoxState                               _supplyBoxState;                                   // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyBoxManagerComponent*             _supplyBoxManagerComponent;                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupplySelectType                             _supplySelectType;                                 // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _dropCountMin;                                     // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _dropCountMax;                                     // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bRandomDirection;                                 // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bDisappear;                                       // 0x02DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE[0x2];                                      // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _supplyRange;                                      // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _velocityRange;                                    // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _supplyHight;                                      // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _supplyVelocity;                                   // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _supplyVelocityZ;                                  // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _supplyAcceleration;                               // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _openedSpan;                                       // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _disappearTime;                                    // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLargeBoxInfo>                  _largeBoxInfo;                                     // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _bLeadersBattle;                                   // 0x0310(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _openParticle;                                     // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          _openSound;                                        // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          _beforSpawnSound;                                  // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          _spawnSound;                                       // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          _spawnLoopSound;                                   // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _openParticleSocketName;                           // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPaperSprite*                           _itemSignalTexture;                                // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStatusChangedDelegate;                           // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnlockBeginDelegate;                             // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnlockEndDelegate;                               // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _particle_BeforAppear;                             // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _particle_Appear;                                  // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _particle_AppearLoop;                              // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _materialParameterCurve_Opened;                    // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               _particleUnlockComponent;                          // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   _meshComponent;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UShapeComponent*>                _collisionComponents;                              // 0x03B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UInteractTargetComponent*               _interactTargetComponent;                          // 0x03C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x30];                                     // 0x03D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	ESupplyBoxSize                                _supplyBoxSize;                                    // 0x0400(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleCustomParticleSystemComponent*   _beforAppearEffectComponent;                       // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _AppearLoopEffectComponent;                        // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         _spawnLoopSoundComponent;                          // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         _beforSpawnLoopSoundComponent;                     // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnChangeCollisionEvent(bool Enable);
	void OnDestroyStaging();
	void OnDestroyTimerEvent();
	void OnRep_Replicated_supplyBoxState();
	void OnStatusChanged__DelegateSignature();
	void SetupComponents();
	void UnlockBegin(class APlayerStateBattle* PlayerState);
	void UnlockEnd(class APlayerStateBattle* PlayerState);

	bool IsDisappear() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyBox">();
	}
	static class ASupplyBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyBox>();
	}
};
static_assert(alignof(ASupplyBox) == 0x000008, "Wrong alignment on ASupplyBox");
static_assert(sizeof(ASupplyBox) == 0x000428, "Wrong size on ASupplyBox");
static_assert(offsetof(ASupplyBox, _supplyBoxState) == 0x0002C0, "Member 'ASupplyBox::_supplyBoxState' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplyBoxManagerComponent) == 0x0002C8, "Member 'ASupplyBox::_supplyBoxManagerComponent' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplySelectType) == 0x0002D0, "Member 'ASupplyBox::_supplySelectType' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _dropCountMin) == 0x0002D4, "Member 'ASupplyBox::_dropCountMin' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _dropCountMax) == 0x0002D8, "Member 'ASupplyBox::_dropCountMax' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _bRandomDirection) == 0x0002DC, "Member 'ASupplyBox::_bRandomDirection' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _bDisappear) == 0x0002DD, "Member 'ASupplyBox::_bDisappear' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplyRange) == 0x0002E0, "Member 'ASupplyBox::_supplyRange' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _velocityRange) == 0x0002E4, "Member 'ASupplyBox::_velocityRange' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplyHight) == 0x0002E8, "Member 'ASupplyBox::_supplyHight' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplyVelocity) == 0x0002EC, "Member 'ASupplyBox::_supplyVelocity' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplyVelocityZ) == 0x0002F0, "Member 'ASupplyBox::_supplyVelocityZ' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplyAcceleration) == 0x0002F4, "Member 'ASupplyBox::_supplyAcceleration' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _openedSpan) == 0x0002F8, "Member 'ASupplyBox::_openedSpan' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _disappearTime) == 0x0002FC, "Member 'ASupplyBox::_disappearTime' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _largeBoxInfo) == 0x000300, "Member 'ASupplyBox::_largeBoxInfo' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _bLeadersBattle) == 0x000310, "Member 'ASupplyBox::_bLeadersBattle' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _openParticle) == 0x000318, "Member 'ASupplyBox::_openParticle' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _openSound) == 0x000320, "Member 'ASupplyBox::_openSound' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _beforSpawnSound) == 0x000328, "Member 'ASupplyBox::_beforSpawnSound' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _spawnSound) == 0x000330, "Member 'ASupplyBox::_spawnSound' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _spawnLoopSound) == 0x000338, "Member 'ASupplyBox::_spawnLoopSound' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _openParticleSocketName) == 0x000340, "Member 'ASupplyBox::_openParticleSocketName' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _itemSignalTexture) == 0x000348, "Member 'ASupplyBox::_itemSignalTexture' has a wrong offset!");
static_assert(offsetof(ASupplyBox, OnStatusChangedDelegate) == 0x000350, "Member 'ASupplyBox::OnStatusChangedDelegate' has a wrong offset!");
static_assert(offsetof(ASupplyBox, OnUnlockBeginDelegate) == 0x000360, "Member 'ASupplyBox::OnUnlockBeginDelegate' has a wrong offset!");
static_assert(offsetof(ASupplyBox, OnUnlockEndDelegate) == 0x000370, "Member 'ASupplyBox::OnUnlockEndDelegate' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _particle_BeforAppear) == 0x000380, "Member 'ASupplyBox::_particle_BeforAppear' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _particle_Appear) == 0x000388, "Member 'ASupplyBox::_particle_Appear' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _particle_AppearLoop) == 0x000390, "Member 'ASupplyBox::_particle_AppearLoop' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _materialParameterCurve_Opened) == 0x000398, "Member 'ASupplyBox::_materialParameterCurve_Opened' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _particleUnlockComponent) == 0x0003A0, "Member 'ASupplyBox::_particleUnlockComponent' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _meshComponent) == 0x0003A8, "Member 'ASupplyBox::_meshComponent' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _collisionComponents) == 0x0003B8, "Member 'ASupplyBox::_collisionComponents' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _interactTargetComponent) == 0x0003C8, "Member 'ASupplyBox::_interactTargetComponent' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _supplyBoxSize) == 0x000400, "Member 'ASupplyBox::_supplyBoxSize' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _beforAppearEffectComponent) == 0x000408, "Member 'ASupplyBox::_beforAppearEffectComponent' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _AppearLoopEffectComponent) == 0x000410, "Member 'ASupplyBox::_AppearLoopEffectComponent' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _spawnLoopSoundComponent) == 0x000418, "Member 'ASupplyBox::_spawnLoopSoundComponent' has a wrong offset!");
static_assert(offsetof(ASupplyBox, _beforSpawnLoopSoundComponent) == 0x000420, "Member 'ASupplyBox::_beforSpawnLoopSoundComponent' has a wrong offset!");

// Class InGameModule.SupplyBoxManagerComponent
// 0x0160 (0x0210 - 0x00B0)
class USupplyBoxManagerComponent final : public UActorComponent
{
public:
	ESupplyBoxSize                                _supplyBoxSize;                                    // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _nextSpawnTimeArray;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         _initSupplyBoxNum;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _supplyBoxMax;                                     // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _spawnSupplyBoxMax;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x64];                                      // 0x00D4(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASupplyBox*>                     _supplyBoxList;                                    // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0xB0];                                     // 0x0148(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASupplyBox>                 _supplyBoxClass;                                   // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             _supplyBoxSpawnRateDataTable;                      // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             _supplyBoxSpawnPointDataTable;                     // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RemoveFromManager(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyBoxManagerComponent">();
	}
	static class USupplyBoxManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyBoxManagerComponent>();
	}
};
static_assert(alignof(USupplyBoxManagerComponent) == 0x000008, "Wrong alignment on USupplyBoxManagerComponent");
static_assert(sizeof(USupplyBoxManagerComponent) == 0x000210, "Wrong size on USupplyBoxManagerComponent");
static_assert(offsetof(USupplyBoxManagerComponent, _supplyBoxSize) == 0x0000B0, "Member 'USupplyBoxManagerComponent::_supplyBoxSize' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _nextSpawnTimeArray) == 0x0000B8, "Member 'USupplyBoxManagerComponent::_nextSpawnTimeArray' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _initSupplyBoxNum) == 0x0000C8, "Member 'USupplyBoxManagerComponent::_initSupplyBoxNum' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _supplyBoxMax) == 0x0000CC, "Member 'USupplyBoxManagerComponent::_supplyBoxMax' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _spawnSupplyBoxMax) == 0x0000D0, "Member 'USupplyBoxManagerComponent::_spawnSupplyBoxMax' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _supplyBoxList) == 0x000138, "Member 'USupplyBoxManagerComponent::_supplyBoxList' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _supplyBoxClass) == 0x0001F8, "Member 'USupplyBoxManagerComponent::_supplyBoxClass' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _supplyBoxSpawnRateDataTable) == 0x000200, "Member 'USupplyBoxManagerComponent::_supplyBoxSpawnRateDataTable' has a wrong offset!");
static_assert(offsetof(USupplyBoxManagerComponent, _supplyBoxSpawnPointDataTable) == 0x000208, "Member 'USupplyBoxManagerComponent::_supplyBoxSpawnPointDataTable' has a wrong offset!");

// Class InGameModule.SupplyBoxSpawnPoint
// 0x0008 (0x0230 - 0x0228)
class ASupplyBoxSpawnPoint final : public AStageSpawnPointBase
{
public:
	ESupplyBoxSpawnType                           _spawnType;                                        // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bAlwaysSpawn;                                     // 0x0229(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESupplyBoxSize                                _size;                                             // 0x022A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22B[0x1];                                      // 0x022B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _areaCode;                                         // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool BP_GetAlwaysSpawnFlag();
	int32 BP_GetAreaCode();
	ESupplyBoxSize BP_GetSupplyBoxSize();
	ESupplyBoxSpawnType BP_SpawnType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyBoxSpawnPoint">();
	}
	static class ASupplyBoxSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyBoxSpawnPoint>();
	}
};
static_assert(alignof(ASupplyBoxSpawnPoint) == 0x000008, "Wrong alignment on ASupplyBoxSpawnPoint");
static_assert(sizeof(ASupplyBoxSpawnPoint) == 0x000230, "Wrong size on ASupplyBoxSpawnPoint");
static_assert(offsetof(ASupplyBoxSpawnPoint, _spawnType) == 0x000228, "Member 'ASupplyBoxSpawnPoint::_spawnType' has a wrong offset!");
static_assert(offsetof(ASupplyBoxSpawnPoint, _bAlwaysSpawn) == 0x000229, "Member 'ASupplyBoxSpawnPoint::_bAlwaysSpawn' has a wrong offset!");
static_assert(offsetof(ASupplyBoxSpawnPoint, _size) == 0x00022A, "Member 'ASupplyBoxSpawnPoint::_size' has a wrong offset!");
static_assert(offsetof(ASupplyBoxSpawnPoint, _areaCode) == 0x00022C, "Member 'ASupplyBoxSpawnPoint::_areaCode' has a wrong offset!");

// Class InGameModule.SupplyGenerator
// 0x0018 (0x0238 - 0x0220)
class ASupplyGenerator final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndPlaySupplyActor(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyGenerator">();
	}
	static class ASupplyGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyGenerator>();
	}
};
static_assert(alignof(ASupplyGenerator) == 0x000008, "Wrong alignment on ASupplyGenerator");
static_assert(sizeof(ASupplyGenerator) == 0x000238, "Wrong size on ASupplyGenerator");
static_assert(offsetof(ASupplyGenerator, SceneComponent) == 0x000220, "Member 'ASupplyGenerator::SceneComponent' has a wrong offset!");

// Class InGameModule.SupplyHolder
// 0x0098 (0x00C0 - 0x0028)
class USupplyHolder : public UObject
{
public:
	TArray<class USupply*>                        _supplies;                                         // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<uint32>                                _serverSerialList;                                 // 0x0038(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          _bEnable;                                          // 0x0048(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _index;                                            // 0x004C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESupplyHolderType                             _type;                                             // 0x0050(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x6F];                                      // 0x0051(0x006F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ServerSerialList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyHolder">();
	}
	static class USupplyHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyHolder>();
	}
};
static_assert(alignof(USupplyHolder) == 0x000008, "Wrong alignment on USupplyHolder");
static_assert(sizeof(USupplyHolder) == 0x0000C0, "Wrong size on USupplyHolder");
static_assert(offsetof(USupplyHolder, _supplies) == 0x000028, "Member 'USupplyHolder::_supplies' has a wrong offset!");
static_assert(offsetof(USupplyHolder, _serverSerialList) == 0x000038, "Member 'USupplyHolder::_serverSerialList' has a wrong offset!");
static_assert(offsetof(USupplyHolder, _bEnable) == 0x000048, "Member 'USupplyHolder::_bEnable' has a wrong offset!");
static_assert(offsetof(USupplyHolder, _index) == 0x00004C, "Member 'USupplyHolder::_index' has a wrong offset!");
static_assert(offsetof(USupplyHolder, _type) == 0x000050, "Member 'USupplyHolder::_type' has a wrong offset!");

// Class InGameModule.AbilityHolder
// 0x0050 (0x0110 - 0x00C0)
class UAbilityHolder final : public USupplyHolder
{
public:
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHolder">();
	}
	static class UAbilityHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityHolder>();
	}
};
static_assert(alignof(UAbilityHolder) == 0x000008, "Wrong alignment on UAbilityHolder");
static_assert(sizeof(UAbilityHolder) == 0x000110, "Wrong size on UAbilityHolder");

// Class InGameModule.SkillHolder
// 0x0010 (0x00D0 - 0x00C0)
class USkillHolder final : public USupplyHolder
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USupplyAbility*                         _prevAbility;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillHolder">();
	}
	static class USkillHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillHolder>();
	}
};
static_assert(alignof(USkillHolder) == 0x000008, "Wrong alignment on USkillHolder");
static_assert(sizeof(USkillHolder) == 0x0000D0, "Wrong size on USkillHolder");
static_assert(offsetof(USkillHolder, _prevAbility) == 0x0000C8, "Member 'USkillHolder::_prevAbility' has a wrong offset!");

// Class InGameModule.SupplyHolderComponent
// 0x01A0 (0x0250 - 0x00B0)
class USupplyHolderComponent final : public UActorComponent
{
public:
	TArray<class USupplyHolder*>                  _inventory;                                        // 0x00B0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UAbilityHolder*>                 _abilitySlot;                                      // 0x00C0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USkillHolder*>                   _skillSlot;                                        // 0x00D0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	class USupplyShoulder*                        _shoulder;                                         // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyHolder*                          _usingHolder;                                      // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _shortCutSupplyId;                                 // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x4];                                       // 0x00F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _lastUsedSupplyId;                                 // 0x00FC(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        _allLevelupSerialNo;                               // 0x0104(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x4];                                      // 0x0108(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentShoulderSize;                              // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkillHolderInitializeData>     _netSkillInitialzeData;                            // 0x0118(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x128];                                    // 0x0128(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeShoulder_NetMulticast(int32 ShoulderSize);
	void OnChangeShoulder_ToServer(uint32 SerialID);
	void OnChangeSupplyRespawnCounts_NetMulticast(uint8 Flagments, uint8 RespawnSupplies);
	void OnDrop_ToServer(const TArray<uint32>& SerialID, uint8 LevelOverWrite);
	void OnDropForDead_ToServer(const TArray<uint32>& SerialID);
	void OnEndUsing_ToClient(const struct FNetUseSupplyResult& Result);
	void OnManipulation_ToClient(const TArray<struct FNetSupplyHolderData>& List);
	void OnManipulation_ToServer(const TArray<struct FNetSupplyHolderData>& List);
	void OnPickup_ToServer(uint32 SerialID, const class FName& SupplyId);
	void OnRep_Replicated_allLevelupSerialNo();
	void OnRep_Replicated_netSkillInitialzeData();
	void OnStopUsing_ToServer();
	void OnSupplyEndUsedTeamMember_ToClient(const class APlayerStateBattle* UsedPlayer);
	void OnSupplyUpgrade_ToClient(const struct FNetSupplyHolderData& Data, uint32 SerialNo, const class FName& UpgradeSupplyKey);
	void OnSupplyUsedTeamMember_ToClient(const class USupplyHolder* MemberHolder, const class FName& UsedSupply);
	void OnUseSupply_ToServer(const struct FNetSupplyHolderData& Data);
	void SetSkillLevel_NetMulticast(const EAttackId AttackId, int32 Level);
	void SetSkillLevel_ToServer(const EAttackId AttackId, int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyHolderComponent">();
	}
	static class USupplyHolderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyHolderComponent>();
	}
};
static_assert(alignof(USupplyHolderComponent) == 0x000008, "Wrong alignment on USupplyHolderComponent");
static_assert(sizeof(USupplyHolderComponent) == 0x000250, "Wrong size on USupplyHolderComponent");
static_assert(offsetof(USupplyHolderComponent, _inventory) == 0x0000B0, "Member 'USupplyHolderComponent::_inventory' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _abilitySlot) == 0x0000C0, "Member 'USupplyHolderComponent::_abilitySlot' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _skillSlot) == 0x0000D0, "Member 'USupplyHolderComponent::_skillSlot' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _shoulder) == 0x0000E0, "Member 'USupplyHolderComponent::_shoulder' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _usingHolder) == 0x0000E8, "Member 'USupplyHolderComponent::_usingHolder' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _shortCutSupplyId) == 0x0000F0, "Member 'USupplyHolderComponent::_shortCutSupplyId' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _lastUsedSupplyId) == 0x0000FC, "Member 'USupplyHolderComponent::_lastUsedSupplyId' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _allLevelupSerialNo) == 0x000104, "Member 'USupplyHolderComponent::_allLevelupSerialNo' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _currentShoulderSize) == 0x00010C, "Member 'USupplyHolderComponent::_currentShoulderSize' has a wrong offset!");
static_assert(offsetof(USupplyHolderComponent, _netSkillInitialzeData) == 0x000118, "Member 'USupplyHolderComponent::_netSkillInitialzeData' has a wrong offset!");

// Class InGameModule.SupplyManageDecorator
// 0x0088 (0x00B0 - 0x0028)
class USupplyManageDecorator final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSupplySpawnParam                      _additionalSupplySpawnParam;                       // 0x0030(0x0080)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyManageDecorator">();
	}
	static class USupplyManageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyManageDecorator>();
	}
};
static_assert(alignof(USupplyManageDecorator) == 0x000010, "Wrong alignment on USupplyManageDecorator");
static_assert(sizeof(USupplyManageDecorator) == 0x0000B0, "Wrong size on USupplyManageDecorator");
static_assert(offsetof(USupplyManageDecorator, _additionalSupplySpawnParam) == 0x000030, "Member 'USupplyManageDecorator::_additionalSupplySpawnParam' has a wrong offset!");

// Class InGameModule.SupplyManagerComponentBase
// 0x0028 (0x00D8 - 0x00B0)
class USupplyManagerComponentBase : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USupplyManageDecorator>     _supplyManageDecoratorSubclass;                    // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupplyManageDecorator*                 _supplyManageDecorator;                            // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AItemBase>                  _itemBaseSubClass;                                 // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyManagerComponentBase">();
	}
	static class USupplyManagerComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyManagerComponentBase>();
	}
};
static_assert(alignof(USupplyManagerComponentBase) == 0x000008, "Wrong alignment on USupplyManagerComponentBase");
static_assert(sizeof(USupplyManagerComponentBase) == 0x0000D8, "Wrong size on USupplyManagerComponentBase");
static_assert(offsetof(USupplyManagerComponentBase, _supplyManageDecoratorSubclass) == 0x0000B8, "Member 'USupplyManagerComponentBase::_supplyManageDecoratorSubclass' has a wrong offset!");
static_assert(offsetof(USupplyManagerComponentBase, _supplyManageDecorator) == 0x0000C0, "Member 'USupplyManagerComponentBase::_supplyManageDecorator' has a wrong offset!");
static_assert(offsetof(USupplyManagerComponentBase, _itemBaseSubClass) == 0x0000C8, "Member 'USupplyManagerComponentBase::_itemBaseSubClass' has a wrong offset!");

// Class InGameModule.SupplyManagerComponent
// 0x0060 (0x0138 - 0x00D8)
class USupplyManagerComponent final : public USupplyManagerComponentBase
{
public:
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class USupply*>             _supplyInstanceList;                               // 0x00E8(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyManagerComponent">();
	}
	static class USupplyManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyManagerComponent>();
	}
};
static_assert(alignof(USupplyManagerComponent) == 0x000008, "Wrong alignment on USupplyManagerComponent");
static_assert(sizeof(USupplyManagerComponent) == 0x000138, "Wrong size on USupplyManagerComponent");
static_assert(offsetof(USupplyManagerComponent, _supplyInstanceList) == 0x0000E8, "Member 'USupplyManagerComponent::_supplyInstanceList' has a wrong offset!");

// Class InGameModule.SupplyManagerVisualLobbyComponent
// 0x0010 (0x00E8 - 0x00D8)
class USupplyManagerVisualLobbyComponent final : public USupplyManagerComponentBase
{
public:
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyManagerVisualLobbyComponent">();
	}
	static class USupplyManagerVisualLobbyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyManagerVisualLobbyComponent>();
	}
};
static_assert(alignof(USupplyManagerVisualLobbyComponent) == 0x000008, "Wrong alignment on USupplyManagerVisualLobbyComponent");
static_assert(sizeof(USupplyManagerVisualLobbyComponent) == 0x0000E8, "Wrong size on USupplyManagerVisualLobbyComponent");

// Class InGameModule.SupplySpawnController
// 0x0038 (0x0258 - 0x0220)
class ASupplySpawnController final : public AActor
{
public:
	float                                         _respawnSpan;                                      // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x14];                                     // 0x0224(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASupplySpawnPoint*>              _supplySpawnPointList;                             // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AItemBase*>                      _supplyList;                                       // 0x0248(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplySpawnController">();
	}
	static class ASupplySpawnController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplySpawnController>();
	}
};
static_assert(alignof(ASupplySpawnController) == 0x000008, "Wrong alignment on ASupplySpawnController");
static_assert(sizeof(ASupplySpawnController) == 0x000258, "Wrong size on ASupplySpawnController");
static_assert(offsetof(ASupplySpawnController, _respawnSpan) == 0x000220, "Member 'ASupplySpawnController::_respawnSpan' has a wrong offset!");
static_assert(offsetof(ASupplySpawnController, _supplySpawnPointList) == 0x000238, "Member 'ASupplySpawnController::_supplySpawnPointList' has a wrong offset!");
static_assert(offsetof(ASupplySpawnController, _supplyList) == 0x000248, "Member 'ASupplySpawnController::_supplyList' has a wrong offset!");

// Class InGameModule.SupplySpawnPoint
// 0x0008 (0x0230 - 0x0228)
class ASupplySpawnPoint final : public AStageSpawnPointBase
{
public:
	ESupplyCode                                   _spawnSupplyType;                                  // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAlwaysSpawn;                                     // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _characterId;                                      // 0x022A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x022B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplySpawnPoint">();
	}
	static class ASupplySpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplySpawnPoint>();
	}
};
static_assert(alignof(ASupplySpawnPoint) == 0x000008, "Wrong alignment on ASupplySpawnPoint");
static_assert(sizeof(ASupplySpawnPoint) == 0x000230, "Wrong size on ASupplySpawnPoint");
static_assert(offsetof(ASupplySpawnPoint, _spawnSupplyType) == 0x000228, "Member 'ASupplySpawnPoint::_spawnSupplyType' has a wrong offset!");
static_assert(offsetof(ASupplySpawnPoint, _bAlwaysSpawn) == 0x000229, "Member 'ASupplySpawnPoint::_bAlwaysSpawn' has a wrong offset!");
static_assert(offsetof(ASupplySpawnPoint, _characterId) == 0x00022A, "Member 'ASupplySpawnPoint::_characterId' has a wrong offset!");
static_assert(offsetof(ASupplySpawnPoint, _attackID) == 0x00022B, "Member 'ASupplySpawnPoint::_attackID' has a wrong offset!");

// Class InGameModule.SupplyWheel
// 0x0018 (0x03A8 - 0x0390)
class USupplyWheel final : public UCommandWheelBase
{
public:
	class USupplyHolderComponent*                 _supplyHolderComponent;                            // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _supplyIdDistribution;                             // 0x0398(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void RequestSupplyFromAlly();
	void UseSupplyDirectly();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyWheel">();
	}
	static class USupplyWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyWheel>();
	}
};
static_assert(alignof(USupplyWheel) == 0x000008, "Wrong alignment on USupplyWheel");
static_assert(sizeof(USupplyWheel) == 0x0003A8, "Wrong size on USupplyWheel");
static_assert(offsetof(USupplyWheel, _supplyHolderComponent) == 0x000390, "Member 'USupplyWheel::_supplyHolderComponent' has a wrong offset!");
static_assert(offsetof(USupplyWheel, _supplyIdDistribution) == 0x000398, "Member 'USupplyWheel::_supplyIdDistribution' has a wrong offset!");

// Class InGameModule.SymbolWheel
// 0x0008 (0x0398 - 0x0390)
class USymbolWheel final : public UCommandWheelBase
{
public:
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateButtonGuide();
	void UpdateSymbolList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SymbolWheel">();
	}
	static class USymbolWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USymbolWheel>();
	}
};
static_assert(alignof(USymbolWheel) == 0x000008, "Wrong alignment on USymbolWheel");
static_assert(sizeof(USymbolWheel) == 0x000398, "Wrong size on USymbolWheel");
static_assert(offsetof(USymbolWheel, _playerDatabaseWork) == 0x000390, "Member 'USymbolWheel::_playerDatabaseWork' has a wrong offset!");

// Class InGameModule.SystemMenuAppWidget
// 0x0018 (0x0400 - 0x03E8)
class USystemMenuAppWidget final : public UAppWidget
{
public:
	class APlayerControllerBattle*                _playerControllerBattle;                           // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreamingDynamic*                 _subLevelStreamingDynamic;                         // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_CloseSystemMenu();
	bool BP_GrayOutTeamMemberMute();
	void BP_OnConstruct();
	void BP_OpenLevel(const TSoftObjectPtr<class UWorld> Level, bool bHiddenWorldRending);
	class UWidgetBase* GetFocusButton();
	void GrayOutTeamMemberMuteButton();
	void OnChangeDying();
	void OnChangeSquad(int32 SquadNum);
	void OnSetEnableRetireButton(bool bShow);
	void OnSubLevelHidden();
	void OnSubLevelShown();
	void OpenMission();
	void SetMenuButtonNavigation();
	void ShowDebugButton(bool bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemMenuAppWidget">();
	}
	static class USystemMenuAppWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemMenuAppWidget>();
	}
};
static_assert(alignof(USystemMenuAppWidget) == 0x000008, "Wrong alignment on USystemMenuAppWidget");
static_assert(sizeof(USystemMenuAppWidget) == 0x000400, "Wrong size on USystemMenuAppWidget");
static_assert(offsetof(USystemMenuAppWidget, _playerControllerBattle) == 0x0003E8, "Member 'USystemMenuAppWidget::_playerControllerBattle' has a wrong offset!");
static_assert(offsetof(USystemMenuAppWidget, _subLevelStreamingDynamic) == 0x0003F0, "Member 'USystemMenuAppWidget::_subLevelStreamingDynamic' has a wrong offset!");

// Class InGameModule.SystemMenuInterface
// 0x0000 (0x0028 - 0x0028)
class ISystemMenuInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemMenuInterface">();
	}
	static class ISystemMenuInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISystemMenuInterface>();
	}
};
static_assert(alignof(ISystemMenuInterface) == 0x000008, "Wrong alignment on ISystemMenuInterface");
static_assert(sizeof(ISystemMenuInterface) == 0x000028, "Wrong size on ISystemMenuInterface");

// Class InGameModule.SystemMenuPresenter
// 0x0008 (0x0250 - 0x0248)
class ASystemMenuPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemMenuPresenter">();
	}
	static class ASystemMenuPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASystemMenuPresenter>();
	}
};
static_assert(alignof(ASystemMenuPresenter) == 0x000008, "Wrong alignment on ASystemMenuPresenter");
static_assert(sizeof(ASystemMenuPresenter) == 0x000250, "Wrong size on ASystemMenuPresenter");

// Class InGameModule.TakeCharacterImageWidget
// 0x00C0 (0x0410 - 0x0350)
class UTakeCharacterImageWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0xC0];                                     // 0x0350(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyInfo(int32 DelayTiming, const struct FTransform& CameraTransform, float CameraLength, const struct FRotator& LightRotation, int32 ColorType);
	void LoadInfo(bool IsReset, int32 Chara1P, int32 Type, int32 Variation, bool IsSubmissionOnly, int32* OutChara2P, int32* OutDelayTiming, struct FTransform* OutCameraTransform, float* OutCameraLength, struct FRotator* OutLightRotation, int32* OutColorType, float* FovValue);
	void PasteInfo(int32* OutDelayTiming, struct FTransform* OutCameraTransform, float* OutCameraLength, struct FRotator* OutLightRotation, int32* OutColorType);
	void SaveInfo(int32 Chara1P, int32 Type, int32 Chara2P, int32 DelayTiming, bool IsSubmissionOnly, const struct FTransform& CameraTransform, float CameraLength, const struct FRotator& LightRotation, int32 ColorType, float FovValue, int32 Variation);
	void SetEnableAntialias(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TakeCharacterImageWidget">();
	}
	static class UTakeCharacterImageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTakeCharacterImageWidget>();
	}
};
static_assert(alignof(UTakeCharacterImageWidget) == 0x000008, "Wrong alignment on UTakeCharacterImageWidget");
static_assert(sizeof(UTakeCharacterImageWidget) == 0x000410, "Wrong size on UTakeCharacterImageWidget");

// Class InGameModule.TeamKillBattlePoisonMist
// 0x0010 (0x0358 - 0x0348)
class ATeamKillBattlePoisonMist final : public APoisonMist
{
public:
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamKillBattlePoisonMist">();
	}
	static class ATeamKillBattlePoisonMist* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamKillBattlePoisonMist>();
	}
};
static_assert(alignof(ATeamKillBattlePoisonMist) == 0x000008, "Wrong alignment on ATeamKillBattlePoisonMist");
static_assert(sizeof(ATeamKillBattlePoisonMist) == 0x000358, "Wrong size on ATeamKillBattlePoisonMist");

// Class InGameModule.TeamKillCounter
// 0x0010 (0x0388 - 0x0378)
class UTeamKillCounter final : public UBattleCounterBase
{
public:
	class UGenericCounter*                        _belongingTeam;                                    // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGenericCounter*                        _theOtherTeam;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamKillCounter">();
	}
	static class UTeamKillCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamKillCounter>();
	}
};
static_assert(alignof(UTeamKillCounter) == 0x000008, "Wrong alignment on UTeamKillCounter");
static_assert(sizeof(UTeamKillCounter) == 0x000388, "Wrong size on UTeamKillCounter");
static_assert(offsetof(UTeamKillCounter, _belongingTeam) == 0x000378, "Member 'UTeamKillCounter::_belongingTeam' has a wrong offset!");
static_assert(offsetof(UTeamKillCounter, _theOtherTeam) == 0x000380, "Member 'UTeamKillCounter::_theOtherTeam' has a wrong offset!");

// Class InGameModule.TeamOrbPoisonMist
// 0x0008 (0x0350 - 0x0348)
class ATeamOrbPoisonMist final : public APoisonMist
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamOrbPoisonMist">();
	}
	static class ATeamOrbPoisonMist* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamOrbPoisonMist>();
	}
};
static_assert(alignof(ATeamOrbPoisonMist) == 0x000008, "Wrong alignment on ATeamOrbPoisonMist");
static_assert(sizeof(ATeamOrbPoisonMist) == 0x000350, "Wrong size on ATeamOrbPoisonMist");

// Class InGameModule.TempUsedFadeEffectComponent
// 0x0020 (0x0220 - 0x0200)
class UTempUsedFadeEffectComponent final : public USceneComponent
{
public:
	class UParticleSystemComponent*               _psc;                                              // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x20];                                     // 0x0200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempUsedFadeEffectComponent">();
	}
	static class UTempUsedFadeEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempUsedFadeEffectComponent>();
	}
};
static_assert(alignof(UTempUsedFadeEffectComponent) == 0x000010, "Wrong alignment on UTempUsedFadeEffectComponent");
static_assert(sizeof(UTempUsedFadeEffectComponent) == 0x000220, "Wrong size on UTempUsedFadeEffectComponent");
static_assert(offsetof(UTempUsedFadeEffectComponent, _psc) == 0x0001F8, "Member 'UTempUsedFadeEffectComponent::_psc' has a wrong offset!");

// Class InGameModule.TickIntervalControlComponent
// 0x0028 (0x00D8 - 0x00B0)
class UTickIntervalControlComponent final : public UActorComponent
{
public:
	class UMovementComponent*                     _movementComp;                                     // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _ownerChr;                                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABullet*                                _ownerBullet;                                      // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           _adjustTickTimer;                                  // 0x00C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickIntervalControlComponent">();
	}
	static class UTickIntervalControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickIntervalControlComponent>();
	}
};
static_assert(alignof(UTickIntervalControlComponent) == 0x000008, "Wrong alignment on UTickIntervalControlComponent");
static_assert(sizeof(UTickIntervalControlComponent) == 0x0000D8, "Wrong size on UTickIntervalControlComponent");
static_assert(offsetof(UTickIntervalControlComponent, _movementComp) == 0x0000B0, "Member 'UTickIntervalControlComponent::_movementComp' has a wrong offset!");
static_assert(offsetof(UTickIntervalControlComponent, _ownerChr) == 0x0000B8, "Member 'UTickIntervalControlComponent::_ownerChr' has a wrong offset!");
static_assert(offsetof(UTickIntervalControlComponent, _ownerBullet) == 0x0000C0, "Member 'UTickIntervalControlComponent::_ownerBullet' has a wrong offset!");
static_assert(offsetof(UTickIntervalControlComponent, _adjustTickTimer) == 0x0000C8, "Member 'UTickIntervalControlComponent::_adjustTickTimer' has a wrong offset!");

// Class InGameModule.GameBattleEvent
// 0x0000 (0x0028 - 0x0028)
class UGameBattleEvent final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBattleEvent">();
	}
	static class UGameBattleEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBattleEvent>();
	}
};
static_assert(alignof(UGameBattleEvent) == 0x000008, "Wrong alignment on UGameBattleEvent");
static_assert(sizeof(UGameBattleEvent) == 0x000028, "Wrong size on UGameBattleEvent");

// Class InGameModule.TimerEventManagerComponent
// 0x0000 (0x00B0 - 0x00B0)
class UTimerEventManagerComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerEventManagerComponent">();
	}
	static class UTimerEventManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimerEventManagerComponent>();
	}
};
static_assert(alignof(UTimerEventManagerComponent) == 0x000008, "Wrong alignment on UTimerEventManagerComponent");
static_assert(sizeof(UTimerEventManagerComponent) == 0x0000B0, "Wrong size on UTimerEventManagerComponent");

// Class InGameModule.TrainingCharacterDetailWidget
// 0x0008 (0x0370 - 0x0368)
class UTrainingCharacterDetailWidget final : public UPlayerInfoBaseWidget
{
public:
	class UCharacterWidget*                       _characterWidget;                                  // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingCharacterDetailWidget">();
	}
	static class UTrainingCharacterDetailWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrainingCharacterDetailWidget>();
	}
};
static_assert(alignof(UTrainingCharacterDetailWidget) == 0x000008, "Wrong alignment on UTrainingCharacterDetailWidget");
static_assert(sizeof(UTrainingCharacterDetailWidget) == 0x000370, "Wrong size on UTrainingCharacterDetailWidget");
static_assert(offsetof(UTrainingCharacterDetailWidget, _characterWidget) == 0x000368, "Member 'UTrainingCharacterDetailWidget::_characterWidget' has a wrong offset!");

// Class InGameModule.TrainingMenuWidget
// 0x0008 (0x03F0 - 0x03E8)
class UTrainingMenuWidget final : public UAppWidget
{
public:
	class AGameStateTraining*                     _gameStateTraining;                                // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseLevel();
	void Decide();
	void OnClosedLevel();
	void OnGetAiAction(int32 Index_0, int32* AiActionIndex);
	void OnGetAiCharacter(int32 Index_0, ECharacterId* CharacterId, int32* DefUnique1Level, int32* DefUnique2Level, int32* DefUnique3Level, int32* SkillVariationCode, int32* AiActionIndex);
	void OnGetPlayerCharacter(ECharacterId* CharacterId, int32* DefUnique1Level, int32* DefUnique2Level, int32* DefUnique3Level, int32* SkillVariationCode);
	void OnGetSetting(int32* DamageTypeIndex, bool* bFriendlyFire);
	void OnSetAiCharacter(int32 Index_0, ECharacterId CharacterId, int32 DefUnique1Level, int32 DefUnique2Level, int32 DefUnique3Level, int32 SkillVariationCode, int32 AiActionIndex);
	void OnSetLeaderMode(bool bLeader);
	void OnSetPlayerCharacter(ECharacterId CharacterId, int32 DefUnique1Level, int32 DefUnique2Level, int32 DefUnique3Level, int32 SkillVariationCode);
	void OnSetSetting(int32 DamageTypeIndex, bool bFriendlyFire);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingMenuWidget">();
	}
	static class UTrainingMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrainingMenuWidget>();
	}
};
static_assert(alignof(UTrainingMenuWidget) == 0x000008, "Wrong alignment on UTrainingMenuWidget");
static_assert(sizeof(UTrainingMenuWidget) == 0x0003F0, "Wrong size on UTrainingMenuWidget");
static_assert(offsetof(UTrainingMenuWidget, _gameStateTraining) == 0x0003E8, "Member 'UTrainingMenuWidget::_gameStateTraining' has a wrong offset!");

// Class InGameModule.TransformControlComponent
// 0x0200 (0x02B0 - 0x00B0)
class alignas(0x10) UTransformControlComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x48];                                      // 0x00B0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bIsTransforming;                                  // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x147];                                     // 0x00F9(0x0147)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransformationData>            _transformationDataStock;                          // 0x0240(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x4];                                      // 0x0250(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransformingData                      _transformingData;                                 // 0x0254(0x0002)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_256[0x5A];                                     // 0x0256(0x005A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TransfomationData();
	void RemoveTransformaionData_RPC_ToServer(int32 Index_0);
	void ReturnToOriginalRequest_RPC_ToServer();
	void StockTransformationData_RPC_ToServer(int32 Index_0, const class ACharacterBattle* TargetCharacter);
	void TransformInto_RPC_ToServer(const class ACharacterBattle* TargetCharacter);
	void TransformIntoStockCharacter_RPC_ToServer(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformControlComponent">();
	}
	static class UTransformControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformControlComponent>();
	}
};
static_assert(alignof(UTransformControlComponent) == 0x000010, "Wrong alignment on UTransformControlComponent");
static_assert(sizeof(UTransformControlComponent) == 0x0002B0, "Wrong size on UTransformControlComponent");
static_assert(offsetof(UTransformControlComponent, _bIsTransforming) == 0x0000F8, "Member 'UTransformControlComponent::_bIsTransforming' has a wrong offset!");
static_assert(offsetof(UTransformControlComponent, _transformationDataStock) == 0x000240, "Member 'UTransformControlComponent::_transformationDataStock' has a wrong offset!");
static_assert(offsetof(UTransformControlComponent, _transformingData) == 0x000254, "Member 'UTransformControlComponent::_transformingData' has a wrong offset!");

// Class InGameModule.TransformInfo
// 0x0078 (0x03E0 - 0x0368)
class UTransformInfo final : public UPlayerInfoBaseWidget
{
public:
	class APlayerControllerBattle*                _playerControllerBattle;                           // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerHudManager*                 _localPlayerHudManager;                            // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTransformControlComponent*             _transformControlComponent;                        // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _characterFaceMID;                                 // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDatabaseWork*                    _playerDatabaseWork;                               // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x18];                                     // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _noStockImage;                                     // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _characterFace;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _sampleGauge;                                      // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           _transformGauge;                                   // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniStocked;                                       // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       _aniDustbox;                                       // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           _throwStockIconBox;                                // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginTransform();
	void OnEndTransformState();
	void OnFinishedDustboxAnimation();
	void OnFinishedStockedAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformInfo">();
	}
	static class UTransformInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformInfo>();
	}
};
static_assert(alignof(UTransformInfo) == 0x000008, "Wrong alignment on UTransformInfo");
static_assert(sizeof(UTransformInfo) == 0x0003E0, "Wrong size on UTransformInfo");
static_assert(offsetof(UTransformInfo, _playerControllerBattle) == 0x000368, "Member 'UTransformInfo::_playerControllerBattle' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _localPlayerHudManager) == 0x000370, "Member 'UTransformInfo::_localPlayerHudManager' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _transformControlComponent) == 0x000378, "Member 'UTransformInfo::_transformControlComponent' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _characterFaceMID) == 0x000380, "Member 'UTransformInfo::_characterFaceMID' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _playerDatabaseWork) == 0x000388, "Member 'UTransformInfo::_playerDatabaseWork' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _noStockImage) == 0x0003A8, "Member 'UTransformInfo::_noStockImage' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _characterFace) == 0x0003B0, "Member 'UTransformInfo::_characterFace' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _sampleGauge) == 0x0003B8, "Member 'UTransformInfo::_sampleGauge' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _transformGauge) == 0x0003C0, "Member 'UTransformInfo::_transformGauge' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _aniStocked) == 0x0003C8, "Member 'UTransformInfo::_aniStocked' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _aniDustbox) == 0x0003D0, "Member 'UTransformInfo::_aniDustbox' has a wrong offset!");
static_assert(offsetof(UTransformInfo, _throwStockIconBox) == 0x0003D8, "Member 'UTransformInfo::_throwStockIconBox' has a wrong offset!");

// Class InGameModule.TutorialWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class ITutorialWidgetInterface final : public IInterface
{
public:
	void OnCharacterHasStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialWidgetInterface">();
	}
	static class ITutorialWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialWidgetInterface>();
	}
};
static_assert(alignof(ITutorialWidgetInterface) == 0x000008, "Wrong alignment on ITutorialWidgetInterface");
static_assert(sizeof(ITutorialWidgetInterface) == 0x000028, "Wrong size on ITutorialWidgetInterface");

// Class InGameModule.TutorialWidgetPresenter
// 0x0010 (0x0258 - 0x0248)
class ATutorialWidgetPresenter final : public AWidgetCreator
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialWidgetPresenter">();
	}
	static class ATutorialWidgetPresenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialWidgetPresenter>();
	}
};
static_assert(alignof(ATutorialWidgetPresenter) == 0x000008, "Wrong alignment on ATutorialWidgetPresenter");
static_assert(sizeof(ATutorialWidgetPresenter) == 0x000258, "Wrong size on ATutorialWidgetPresenter");

// Class InGameModule.UISubsystemComponent
// 0x0040 (0x00F0 - 0x00B0)
class UUISubsystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x40];                                      // 0x00B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadedCostume(int32 RequestId);
	void OnLoadedMission(int32 RequestId);
	void OnLoadedSeasonLicense(int32 RequestId);
	void OnLoadedSpecialLicense(int32 RequestId);
	void SendClientLicenseData(const struct FUniqueNetIdKey& UniqueId, const int32 SpecialLicenseExp, const int32 SeasonLicenseExp, const bool bPremium);
	void SendClientMissionData(const struct FUniqueNetIdKey& UniqueId, const TArray<int32>& ClearMissionCodeList, const TArray<int32>& UnlockedCostumeCodeList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISubsystemComponent">();
	}
	static class UUISubsystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISubsystemComponent>();
	}
};
static_assert(alignof(UUISubsystemComponent) == 0x000008, "Wrong alignment on UUISubsystemComponent");
static_assert(sizeof(UUISubsystemComponent) == 0x0000F0, "Wrong size on UUISubsystemComponent");

// Class InGameModule.UMGBattleJoinedPlayerList
// 0x0048 (0x0430 - 0x03E8)
class UUMGBattleJoinedPlayerList final : public UAppWidget
{
public:
	class AHerovsGameState*                       _gameState;                                        // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      _playerController;                                 // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FJoinedPlayer>                  _enemyInfo;                                        // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FJoinedPlayer>                  _deadEnemyInfo;                                    // 0x0408(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UWidget*>                        _playerListWidgetElements;                         // 0x0418(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UWidgetMatrixSelection*                 _playerListMatrix;                                 // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelEvent(class UAppWidget* Widget, EWidgetInputType InputType, int32 Index_0);
	void UpdateList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBattleJoinedPlayerList">();
	}
	static class UUMGBattleJoinedPlayerList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBattleJoinedPlayerList>();
	}
};
static_assert(alignof(UUMGBattleJoinedPlayerList) == 0x000008, "Wrong alignment on UUMGBattleJoinedPlayerList");
static_assert(sizeof(UUMGBattleJoinedPlayerList) == 0x000430, "Wrong size on UUMGBattleJoinedPlayerList");
static_assert(offsetof(UUMGBattleJoinedPlayerList, _gameState) == 0x0003E8, "Member 'UUMGBattleJoinedPlayerList::_gameState' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerList, _playerController) == 0x0003F0, "Member 'UUMGBattleJoinedPlayerList::_playerController' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerList, _enemyInfo) == 0x0003F8, "Member 'UUMGBattleJoinedPlayerList::_enemyInfo' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerList, _deadEnemyInfo) == 0x000408, "Member 'UUMGBattleJoinedPlayerList::_deadEnemyInfo' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerList, _playerListWidgetElements) == 0x000418, "Member 'UUMGBattleJoinedPlayerList::_playerListWidgetElements' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerList, _playerListMatrix) == 0x000428, "Member 'UUMGBattleJoinedPlayerList::_playerListMatrix' has a wrong offset!");

// Class InGameModule.UMGBattleJoinedPlayerListViewItem
// 0x0080 (0x0508 - 0x0488)
class UUMGBattleJoinedPlayerListViewItem final : public UWidgetButton
{
public:
	struct FLinearColor                           _allyListItemBgColor;                              // 0x0488(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _enemyListItemBgColor;                             // 0x0498(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameStateBattle*                       _gameState;                                        // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillLogManagerComponent*               _killLogManager;                                   // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _bgColorChangesOnPlayerSide;                       // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _characterFace;                                    // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _onlineId;                                         // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _koStat;                                           // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _myselfMark;                                       // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJoinedPlayer                          _listItemInfo;                                     // 0x04E0(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x18];                                     // 0x04F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDecide(class UAppWidget* Widget, EWidgetInputType InputType);
	void UpdateKillCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBattleJoinedPlayerListViewItem">();
	}
	static class UUMGBattleJoinedPlayerListViewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBattleJoinedPlayerListViewItem>();
	}
};
static_assert(alignof(UUMGBattleJoinedPlayerListViewItem) == 0x000008, "Wrong alignment on UUMGBattleJoinedPlayerListViewItem");
static_assert(sizeof(UUMGBattleJoinedPlayerListViewItem) == 0x000508, "Wrong size on UUMGBattleJoinedPlayerListViewItem");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _allyListItemBgColor) == 0x000488, "Member 'UUMGBattleJoinedPlayerListViewItem::_allyListItemBgColor' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _enemyListItemBgColor) == 0x000498, "Member 'UUMGBattleJoinedPlayerListViewItem::_enemyListItemBgColor' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _gameState) == 0x0004A8, "Member 'UUMGBattleJoinedPlayerListViewItem::_gameState' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _killLogManager) == 0x0004B0, "Member 'UUMGBattleJoinedPlayerListViewItem::_killLogManager' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _bgColorChangesOnPlayerSide) == 0x0004B8, "Member 'UUMGBattleJoinedPlayerListViewItem::_bgColorChangesOnPlayerSide' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _characterFace) == 0x0004C0, "Member 'UUMGBattleJoinedPlayerListViewItem::_characterFace' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _onlineId) == 0x0004C8, "Member 'UUMGBattleJoinedPlayerListViewItem::_onlineId' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _koStat) == 0x0004D0, "Member 'UUMGBattleJoinedPlayerListViewItem::_koStat' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _myselfMark) == 0x0004D8, "Member 'UUMGBattleJoinedPlayerListViewItem::_myselfMark' has a wrong offset!");
static_assert(offsetof(UUMGBattleJoinedPlayerListViewItem, _listItemInfo) == 0x0004E0, "Member 'UUMGBattleJoinedPlayerListViewItem::_listItemInfo' has a wrong offset!");

// Class InGameModule.JoinedPlayerInfo
// 0x0000 (0x0028 - 0x0028)
class UJoinedPlayerInfo final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JoinedPlayerInfo">();
	}
	static class UJoinedPlayerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJoinedPlayerInfo>();
	}
};
static_assert(alignof(UJoinedPlayerInfo) == 0x000008, "Wrong alignment on UJoinedPlayerInfo");
static_assert(sizeof(UJoinedPlayerInfo) == 0x000028, "Wrong size on UJoinedPlayerInfo");

// Class InGameModule.UMGBattleTutorialBase
// 0x0188 (0x04D8 - 0x0350)
class UUMGBattleTutorialBase final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameStateBattle*                       _gameStateBattle;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FTaskParam>        _taskParam;                                        // 0x0368(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0xA0];                                     // 0x03B8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOption*                            _gameOption;                                       // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppWidgetWork*                         _appWidgetWork;                                    // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformWidgetButton*                  _buttonToNext;                                     // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHudCommandControlComponent*            _hudCommandControlComponent;                       // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerStateBattle*                     _playerStateBattle;                                // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBattleTutorialCutIn*                _cutIn;                                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         _sequence;                                         // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACPP_SequenceActorBase*                 _sequenceActor;                                    // 0x04A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBattleTutorialProgress*             _tutorialProgress;                                 // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _commandIndex;                                     // 0x04B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _nowTutotiralProgress;                             // 0x04B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLockInput;                                      // 0x04B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _outRowNames;                                      // 0x04C0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Battle();
	void BP_Camera();
	void BP_ChangeStateTutorialCh012();
	void BP_CreateTutorialCh012();
	void BP_CutIn();
	void BP_Down();
	void BP_FadeIn();
	void BP_FadeOut();
	void BP_Jump();
	void BP_Position();
	void BP_Select();
	void BP_SendKPI();
	void BP_Step();
	void BP_Talk();
	void BP_Tips();
	void BP_Wait();
	void BP_WinnerCheck();
	void ChangeButtonGuide();
	void ClearPlusUltra();
	EScriptCommandFinishType CommandExecution(const class FString& CommandName, const class FString& Value);
	void DebugButtonToNext_OnAddedToFocusPath();
	void DispCutIn(int32 Selection, ESlateVisibility Visibiliy);
	void ForceCloseInventory();
	void ForceOnAutoLevelUp(bool Force);
	void GetBackInputToPawn();
	class FString GetDebugTagValue();
	class UMaterialInterface* GetTaskMaterial(const class FString& Key);
	class FText GetTaskText(const class FString& Key);
	int32 GetTextSize(const class FString& MessageKey);
	bool GetWidgetVisibility(ETutorialDisplayUI UI);
	void GoToMainMenu();
	void GoToNextStep();
	bool IsPlaySequencer();
	bool IsPlayVoice();
	void OnClosedSystemMenuDelegate();
	void OnDecideDelegate();
	void OnReceivedGameOptionGamePlayChanged();
	void OnReceivedGameOptionKeyConfigChanged();
	void PlayBGM(const class FString& bgmName);
	void PlaySequencer();
	void PlaySequencerFinish();
	void PlayVoice(const class FString& CueName);
	void SetAllWidgetVisibility(bool bVisible);
	void SetCanAbilitySwaping(bool bEnable);
	void SetEnableUpdateAddPlusUltraPoint(bool Enable);
	void SetHUDVisibleItemGrayOut(bool GrayOut);
	void SetPlusUltraPermanency(bool Permanency);
	void SetPlusUltraPoint(float Value);
	void SetPoisonMistState(bool Start);
	void SwitchWidgetVisibility(bool bVisible, ETutorialDisplayUI bit);
	void TakeInputToWidget(bool bAllInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBattleTutorialBase">();
	}
	static class UUMGBattleTutorialBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBattleTutorialBase>();
	}
};
static_assert(alignof(UUMGBattleTutorialBase) == 0x000008, "Wrong alignment on UUMGBattleTutorialBase");
static_assert(sizeof(UUMGBattleTutorialBase) == 0x0004D8, "Wrong size on UUMGBattleTutorialBase");
static_assert(offsetof(UUMGBattleTutorialBase, _gameStateBattle) == 0x000360, "Member 'UUMGBattleTutorialBase::_gameStateBattle' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _taskParam) == 0x000368, "Member 'UUMGBattleTutorialBase::_taskParam' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _gameOption) == 0x000458, "Member 'UUMGBattleTutorialBase::_gameOption' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _appWidgetWork) == 0x000470, "Member 'UUMGBattleTutorialBase::_appWidgetWork' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _buttonToNext) == 0x000478, "Member 'UUMGBattleTutorialBase::_buttonToNext' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _hudCommandControlComponent) == 0x000480, "Member 'UUMGBattleTutorialBase::_hudCommandControlComponent' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _playerStateBattle) == 0x000488, "Member 'UUMGBattleTutorialBase::_playerStateBattle' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _cutIn) == 0x000490, "Member 'UUMGBattleTutorialBase::_cutIn' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _sequence) == 0x000498, "Member 'UUMGBattleTutorialBase::_sequence' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _sequenceActor) == 0x0004A0, "Member 'UUMGBattleTutorialBase::_sequenceActor' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _tutorialProgress) == 0x0004A8, "Member 'UUMGBattleTutorialBase::_tutorialProgress' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _commandIndex) == 0x0004B0, "Member 'UUMGBattleTutorialBase::_commandIndex' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _nowTutotiralProgress) == 0x0004B4, "Member 'UUMGBattleTutorialBase::_nowTutotiralProgress' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _isLockInput) == 0x0004B8, "Member 'UUMGBattleTutorialBase::_isLockInput' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialBase, _outRowNames) == 0x0004C0, "Member 'UUMGBattleTutorialBase::_outRowNames' has a wrong offset!");

// Class InGameModule.UMGBattleTutorialClearConditional
// 0x0040 (0x0390 - 0x0350)
class UUMGBattleTutorialClearConditional final : public UWidgetBase
{
public:
	class AGameStateBattle*                       _gameStateBattle;                                  // 0x0350(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameSequenceWork*                      _gameSequence;                                     // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGameModeTutorial*                      _gameModeTutorial;                                 // 0x0360(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                _panel;                                            // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAdjustTextWidget*                      _reNumberText;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetReNumberText(int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBattleTutorialClearConditional">();
	}
	static class UUMGBattleTutorialClearConditional* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBattleTutorialClearConditional>();
	}
};
static_assert(alignof(UUMGBattleTutorialClearConditional) == 0x000008, "Wrong alignment on UUMGBattleTutorialClearConditional");
static_assert(sizeof(UUMGBattleTutorialClearConditional) == 0x000390, "Wrong size on UUMGBattleTutorialClearConditional");
static_assert(offsetof(UUMGBattleTutorialClearConditional, _gameStateBattle) == 0x000350, "Member 'UUMGBattleTutorialClearConditional::_gameStateBattle' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialClearConditional, _gameSequence) == 0x000358, "Member 'UUMGBattleTutorialClearConditional::_gameSequence' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialClearConditional, _gameModeTutorial) == 0x000360, "Member 'UUMGBattleTutorialClearConditional::_gameModeTutorial' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialClearConditional, _panel) == 0x000368, "Member 'UUMGBattleTutorialClearConditional::_panel' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialClearConditional, _reNumberText) == 0x000370, "Member 'UUMGBattleTutorialClearConditional::_reNumberText' has a wrong offset!");

// Class InGameModule.UMGBattleTutorialCutIn
// 0x0000 (0x0350 - 0x0350)
class UUMGBattleTutorialCutIn final : public UWidgetBase
{
public:
	void BP_DispCutIn(int32 Selection, ESlateVisibility Visibiliy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBattleTutorialCutIn">();
	}
	static class UUMGBattleTutorialCutIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBattleTutorialCutIn>();
	}
};
static_assert(alignof(UUMGBattleTutorialCutIn) == 0x000008, "Wrong alignment on UUMGBattleTutorialCutIn");
static_assert(sizeof(UUMGBattleTutorialCutIn) == 0x000350, "Wrong size on UUMGBattleTutorialCutIn");

// Class InGameModule.UMGBattleTutorialProgress
// 0x0000 (0x0350 - 0x0350)
class UUMGBattleTutorialProgress final : public UWidgetBase
{
public:
	void BP_SetNowProgress(int32 Now);
	void BP_SetNumProgress(int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBattleTutorialProgress">();
	}
	static class UUMGBattleTutorialProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBattleTutorialProgress>();
	}
};
static_assert(alignof(UUMGBattleTutorialProgress) == 0x000008, "Wrong alignment on UUMGBattleTutorialProgress");
static_assert(sizeof(UUMGBattleTutorialProgress) == 0x000350, "Wrong size on UUMGBattleTutorialProgress");

// Class InGameModule.TutorialCustomRichTextBlock
// 0x0000 (0x0860 - 0x0860)
class UTutorialCustomRichTextBlock final : public URichTextBlock
{
public:
	int32 GetTextSize();
	void SetTextSize(int32 Size);
	void SetWrapTextAt(const float InWrapTextAt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialCustomRichTextBlock">();
	}
	static class UTutorialCustomRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialCustomRichTextBlock>();
	}
};
static_assert(alignof(UTutorialCustomRichTextBlock) == 0x000010, "Wrong alignment on UTutorialCustomRichTextBlock");
static_assert(sizeof(UTutorialCustomRichTextBlock) == 0x000860, "Wrong size on UTutorialCustomRichTextBlock");

// Class InGameModule.UMGBattleTutorialSpeechBubble
// 0x0028 (0x0378 - 0x0350)
class UUMGBattleTutorialSpeechBubble final : public UWidgetBase
{
public:
	class UTutorialCustomRichTextBlock*           _tutorialMessage;                                  // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                _verticalBox;                                      // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _textMarign;                                       // 0x0360(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _defaultBubbleSizeX;                               // 0x0370(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _defaultTextSize;                                  // 0x0374(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBattleTutorialSpeechBubble">();
	}
	static class UUMGBattleTutorialSpeechBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBattleTutorialSpeechBubble>();
	}
};
static_assert(alignof(UUMGBattleTutorialSpeechBubble) == 0x000008, "Wrong alignment on UUMGBattleTutorialSpeechBubble");
static_assert(sizeof(UUMGBattleTutorialSpeechBubble) == 0x000378, "Wrong size on UUMGBattleTutorialSpeechBubble");
static_assert(offsetof(UUMGBattleTutorialSpeechBubble, _tutorialMessage) == 0x000350, "Member 'UUMGBattleTutorialSpeechBubble::_tutorialMessage' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialSpeechBubble, _verticalBox) == 0x000358, "Member 'UUMGBattleTutorialSpeechBubble::_verticalBox' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialSpeechBubble, _textMarign) == 0x000360, "Member 'UUMGBattleTutorialSpeechBubble::_textMarign' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialSpeechBubble, _defaultBubbleSizeX) == 0x000370, "Member 'UUMGBattleTutorialSpeechBubble::_defaultBubbleSizeX' has a wrong offset!");
static_assert(offsetof(UUMGBattleTutorialSpeechBubble, _defaultTextSize) == 0x000374, "Member 'UUMGBattleTutorialSpeechBubble::_defaultTextSize' has a wrong offset!");

// Class InGameModule.UMGLobbyInfo
// 0x00F8 (0x0448 - 0x0350)
class UUMGLobbyInfo final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameStateLobby*                        _gameState;                                        // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               _countDownOverlay;                                 // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _currentCount;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _countUnit;                                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _currentTeamNum;                                   // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _gameRule;                                         // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _maxTeamNum;                                       // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               _teamCounterOverlay;                               // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _gameStartRuleSwitcher;                            // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_ReadyToBattleCountdown;                        // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_ShowUpCountdown;                               // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_VanishTeamCounter;                             // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Ani_ShowUpFirstInfo;                               // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _count;                                            // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameTeamInfoComponent*                 _teamInfo;                                         // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x78];                                     // 0x03D0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ContinueCounting(int32 Count);
	void ShowCountdown();
	void StartCountdown();
	void UpdateTeamNum();
	void VanishTeamCounter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLobbyInfo">();
	}
	static class UUMGLobbyInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLobbyInfo>();
	}
};
static_assert(alignof(UUMGLobbyInfo) == 0x000008, "Wrong alignment on UUMGLobbyInfo");
static_assert(sizeof(UUMGLobbyInfo) == 0x000448, "Wrong size on UUMGLobbyInfo");
static_assert(offsetof(UUMGLobbyInfo, _gameState) == 0x000358, "Member 'UUMGLobbyInfo::_gameState' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _countDownOverlay) == 0x000360, "Member 'UUMGLobbyInfo::_countDownOverlay' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _currentCount) == 0x000368, "Member 'UUMGLobbyInfo::_currentCount' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _countUnit) == 0x000370, "Member 'UUMGLobbyInfo::_countUnit' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _currentTeamNum) == 0x000378, "Member 'UUMGLobbyInfo::_currentTeamNum' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _gameRule) == 0x000380, "Member 'UUMGLobbyInfo::_gameRule' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _maxTeamNum) == 0x000388, "Member 'UUMGLobbyInfo::_maxTeamNum' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _teamCounterOverlay) == 0x000390, "Member 'UUMGLobbyInfo::_teamCounterOverlay' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _gameStartRuleSwitcher) == 0x000398, "Member 'UUMGLobbyInfo::_gameStartRuleSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, Ani_ReadyToBattleCountdown) == 0x0003A0, "Member 'UUMGLobbyInfo::Ani_ReadyToBattleCountdown' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, Ani_ShowUpCountdown) == 0x0003A8, "Member 'UUMGLobbyInfo::Ani_ShowUpCountdown' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, Ani_VanishTeamCounter) == 0x0003B0, "Member 'UUMGLobbyInfo::Ani_VanishTeamCounter' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, Ani_ShowUpFirstInfo) == 0x0003B8, "Member 'UUMGLobbyInfo::Ani_ShowUpFirstInfo' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _count) == 0x0003C0, "Member 'UUMGLobbyInfo::_count' has a wrong offset!");
static_assert(offsetof(UUMGLobbyInfo, _teamInfo) == 0x0003C8, "Member 'UUMGLobbyInfo::_teamInfo' has a wrong offset!");

// Class InGameModule.UMGSkillActions
// 0x00E8 (0x0450 - 0x0368)
class UUMGSkillActions final : public UPlayerInfoBaseWidget
{
public:
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           _canvasPanel;                                      // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTransformInfo*                         _transformInfo;                                    // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAFOSpecialInfo*                        _afoInfo;                                          // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x50];                                     // 0x0390(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGSkillMagazine*                      _attackUnique1;                                    // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGSkillMagazine*                      _attackUnique2;                                    // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGSkillMagazine*                      _attackUnique3;                                    // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGSkillMagazine*                      _specialActionInfo;                                // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAttackId, class UUMGSkillMagazine*>     MAGAZINES_UMG_ITERATOR;                            // 0x0400(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void UpdateMagazineState(EAttackId SlotAttackId, int32 NewAmmoNum, float NewReloadRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSkillActions">();
	}
	static class UUMGSkillActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSkillActions>();
	}
};
static_assert(alignof(UUMGSkillActions) == 0x000008, "Wrong alignment on UUMGSkillActions");
static_assert(sizeof(UUMGSkillActions) == 0x000450, "Wrong size on UUMGSkillActions");
static_assert(offsetof(UUMGSkillActions, _canvasPanel) == 0x000378, "Member 'UUMGSkillActions::_canvasPanel' has a wrong offset!");
static_assert(offsetof(UUMGSkillActions, _transformInfo) == 0x000380, "Member 'UUMGSkillActions::_transformInfo' has a wrong offset!");
static_assert(offsetof(UUMGSkillActions, _afoInfo) == 0x000388, "Member 'UUMGSkillActions::_afoInfo' has a wrong offset!");
static_assert(offsetof(UUMGSkillActions, _attackUnique1) == 0x0003E0, "Member 'UUMGSkillActions::_attackUnique1' has a wrong offset!");
static_assert(offsetof(UUMGSkillActions, _attackUnique2) == 0x0003E8, "Member 'UUMGSkillActions::_attackUnique2' has a wrong offset!");
static_assert(offsetof(UUMGSkillActions, _attackUnique3) == 0x0003F0, "Member 'UUMGSkillActions::_attackUnique3' has a wrong offset!");
static_assert(offsetof(UUMGSkillActions, _specialActionInfo) == 0x0003F8, "Member 'UUMGSkillActions::_specialActionInfo' has a wrong offset!");
static_assert(offsetof(UUMGSkillActions, MAGAZINES_UMG_ITERATOR) == 0x000400, "Member 'UUMGSkillActions::MAGAZINES_UMG_ITERATOR' has a wrong offset!");

// Class InGameModule.UMGSkillMagazine
// 0x0128 (0x0478 - 0x0350)
class UUMGSkillMagazine final : public UWidgetBase
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerBattle*                _playerControllerBattle;                           // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateBattle*                     _playerState;                                      // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameOption*                            _gameOption;                                       // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x40];                                     // 0x0378(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 _skillSilhouette;                                  // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 _frameDecoration;                                  // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityLevelCounter*                   _levelCounter;                                     // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlusUltraLevel*                        _puImage;                                          // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             _bulletNum;                                        // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             _percent;                                          // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           _coolTime;                                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           _remainingBullet;                                  // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           _bullet;                                           // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 _uniqueType;                                       // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 _inactiveUniqueType;                               // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 _erasureUniqueType;                                // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlatformRichTextBlock*                 _buttonGuide;                                      // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           _inactiveEffectPanel;                              // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           _erasureEffect;                                    // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 _inactiveEffect;                                   // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        _abilityTypeColor;                                 // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _skillReloadColor;                                 // 0x0440(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _skillReadyColor;                                  // 0x0450(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _skillAvailableColor;                              // 0x0460(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultDiff;                                      // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBulletReloaded();
	void OnBulletRunsOut();
	void OnPress(class UAppWidget* Button, EWidgetInputType InputType);
	void OnRelease(class UAppWidget* Button, EWidgetInputType InputType);
	void OnSwitchMagazineAvailability(EMagazineAvailability NewAvailability);
	void PlayLevelUpAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSkillMagazine">();
	}
	static class UUMGSkillMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSkillMagazine>();
	}
};
static_assert(alignof(UUMGSkillMagazine) == 0x000008, "Wrong alignment on UUMGSkillMagazine");
static_assert(sizeof(UUMGSkillMagazine) == 0x000478, "Wrong size on UUMGSkillMagazine");
static_assert(offsetof(UUMGSkillMagazine, _playerControllerBattle) == 0x000358, "Member 'UUMGSkillMagazine::_playerControllerBattle' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _playerState) == 0x000360, "Member 'UUMGSkillMagazine::_playerState' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _gameOption) == 0x000368, "Member 'UUMGSkillMagazine::_gameOption' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _hudResource) == 0x000370, "Member 'UUMGSkillMagazine::_hudResource' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _skillSilhouette) == 0x0003B8, "Member 'UUMGSkillMagazine::_skillSilhouette' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _frameDecoration) == 0x0003C0, "Member 'UUMGSkillMagazine::_frameDecoration' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _levelCounter) == 0x0003C8, "Member 'UUMGSkillMagazine::_levelCounter' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _puImage) == 0x0003D0, "Member 'UUMGSkillMagazine::_puImage' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _bulletNum) == 0x0003D8, "Member 'UUMGSkillMagazine::_bulletNum' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _percent) == 0x0003E0, "Member 'UUMGSkillMagazine::_percent' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _coolTime) == 0x0003E8, "Member 'UUMGSkillMagazine::_coolTime' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _remainingBullet) == 0x0003F0, "Member 'UUMGSkillMagazine::_remainingBullet' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _bullet) == 0x0003F8, "Member 'UUMGSkillMagazine::_bullet' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _uniqueType) == 0x000400, "Member 'UUMGSkillMagazine::_uniqueType' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _inactiveUniqueType) == 0x000408, "Member 'UUMGSkillMagazine::_inactiveUniqueType' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _erasureUniqueType) == 0x000410, "Member 'UUMGSkillMagazine::_erasureUniqueType' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _buttonGuide) == 0x000418, "Member 'UUMGSkillMagazine::_buttonGuide' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _inactiveEffectPanel) == 0x000420, "Member 'UUMGSkillMagazine::_inactiveEffectPanel' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _erasureEffect) == 0x000428, "Member 'UUMGSkillMagazine::_erasureEffect' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _inactiveEffect) == 0x000430, "Member 'UUMGSkillMagazine::_inactiveEffect' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _abilityTypeColor) == 0x000438, "Member 'UUMGSkillMagazine::_abilityTypeColor' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _skillReloadColor) == 0x000440, "Member 'UUMGSkillMagazine::_skillReloadColor' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _skillReadyColor) == 0x000450, "Member 'UUMGSkillMagazine::_skillReadyColor' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _skillAvailableColor) == 0x000460, "Member 'UUMGSkillMagazine::_skillAvailableColor' has a wrong offset!");
static_assert(offsetof(UUMGSkillMagazine, _defaultDiff) == 0x000470, "Member 'UUMGSkillMagazine::_defaultDiff' has a wrong offset!");

// Class InGameModule.UMGSupplyRequest
// 0x00D8 (0x0428 - 0x0350)
class UUMGSupplyRequest final : public UWidgetBase
{
public:
	class UWidgetAnimation*                       Ani_SupplyRequest;                                 // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _requestIcon;                                      // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _baseIcon;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _abilityTypeIcon;                                  // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 _attackID;                                         // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        _requestSwitcher;                                  // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudResource*                           _hudResource;                                      // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EAttackId, class UMaterialInstance*>     _baseMaterialList;                                 // 0x0388(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EAttackId, class UMaterialInstanceDynamic*> _baseDynamicMaterialList;                          // 0x03D8(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSupplyRequest">();
	}
	static class UUMGSupplyRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSupplyRequest>();
	}
};
static_assert(alignof(UUMGSupplyRequest) == 0x000008, "Wrong alignment on UUMGSupplyRequest");
static_assert(sizeof(UUMGSupplyRequest) == 0x000428, "Wrong size on UUMGSupplyRequest");
static_assert(offsetof(UUMGSupplyRequest, Ani_SupplyRequest) == 0x000350, "Member 'UUMGSupplyRequest::Ani_SupplyRequest' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _requestIcon) == 0x000358, "Member 'UUMGSupplyRequest::_requestIcon' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _baseIcon) == 0x000360, "Member 'UUMGSupplyRequest::_baseIcon' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _abilityTypeIcon) == 0x000368, "Member 'UUMGSupplyRequest::_abilityTypeIcon' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _attackID) == 0x000370, "Member 'UUMGSupplyRequest::_attackID' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _requestSwitcher) == 0x000378, "Member 'UUMGSupplyRequest::_requestSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _hudResource) == 0x000380, "Member 'UUMGSupplyRequest::_hudResource' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _baseMaterialList) == 0x000388, "Member 'UUMGSupplyRequest::_baseMaterialList' has a wrong offset!");
static_assert(offsetof(UUMGSupplyRequest, _baseDynamicMaterialList) == 0x0003D8, "Member 'UUMGSupplyRequest::_baseDynamicMaterialList' has a wrong offset!");

// Class InGameModule.UseItemEffectComponent
// 0x0090 (0x0148 - 0x00B8)
class UUseItemEffectComponent final : public UCharacterBattleComponentBase
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBattleCustomParticleSystemComponent*> _activeParticleList;                               // 0x00E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FItemParticleInfo>   _particleList;                                     // 0x00F0(0x0050)(NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _ownerPlayer;                                      // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFinishParticle(class UParticleSystemComponent* Particle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseItemEffectComponent">();
	}
	static class UUseItemEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUseItemEffectComponent>();
	}
};
static_assert(alignof(UUseItemEffectComponent) == 0x000008, "Wrong alignment on UUseItemEffectComponent");
static_assert(sizeof(UUseItemEffectComponent) == 0x000148, "Wrong size on UUseItemEffectComponent");
static_assert(offsetof(UUseItemEffectComponent, _activeParticleList) == 0x0000E0, "Member 'UUseItemEffectComponent::_activeParticleList' has a wrong offset!");
static_assert(offsetof(UUseItemEffectComponent, _particleList) == 0x0000F0, "Member 'UUseItemEffectComponent::_particleList' has a wrong offset!");
static_assert(offsetof(UUseItemEffectComponent, _ownerPlayer) == 0x000140, "Member 'UUseItemEffectComponent::_ownerPlayer' has a wrong offset!");

}

