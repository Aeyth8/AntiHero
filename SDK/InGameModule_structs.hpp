#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InGameModule

#include "Basic.hpp"

#include "GameplayCameras_structs.hpp"
#include "CommonModule_structs.hpp"
#include "GameModule_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "BykingUnrealModule_structs.hpp"
#include "MasterDataModule_structs.hpp"


namespace SDK
{

// Enum InGameModule.EAttackId
// NumValues: 0x000A
enum class EAttackId : uint8
{
	NONE                                     = 0,
	UNIQUE1                                  = 1,
	UNIQUE2                                  = 2,
	UNIQUE3                                  = 3,
	MELEE                                    = 4,
	FINISHER                                 = 5,
	SPECIAL                                  = 6,
	PICKUPITEM                               = 7,
	USEITEM                                  = 8,
	MAX                                      = 9,
};

// Enum InGameModule.ECommandId
// NumValues: 0x002F
enum class ECommandId : uint8
{
	NONE                                     = 0,
	ACTION                                   = 1,
	PUSH_JUMP                                = 2,
	PRESS_JUMP                               = 3,
	PUSH_DASH                                = 4,
	PRESS_DASH                               = 5,
	PUSH_CROUCH                              = 6,
	PRESS_CROUCH                             = 7,
	PUSH_AIMING                              = 8,
	PRESS_AIMING                             = 9,
	MELEE                                    = 10,
	UNIQUE1                                  = 11,
	UNIQUE2                                  = 12,
	UNIQUE3                                  = 13,
	SPECIAL                                  = 14,
	PUSH_MELEE                               = 15,
	PUSH_UNIQUE1                             = 16,
	PUSH_UNIQUE2                             = 17,
	PUSH_UNIQUE3                             = 18,
	PUSH_SPECIAL                             = 19,
	PRESS_MELEE                              = 20,
	PRESS_UNIQUE1                            = 21,
	PRESS_UNIQUE2                            = 22,
	PRESS_UNIQUE3                            = 23,
	PRESS_SPECIAL                            = 24,
	CHARGE_MELEE                             = 25,
	CHARGE_UNIQUE1                           = 26,
	CHARGE_UNIQUE2                           = 27,
	CHARGE_UNIQUE3                           = 28,
	HOVER                                    = 29,
	HOVER_END                                = 30,
	EMOTE                                    = 31,
	USEITEM                                  = 32,
	USERESPAWN                               = 33,
	STOPITEM                                 = 34,
	ACTION_FOR_ITEM                          = 35,
	ACTION_TRIGGER_FOR_ITEM                  = 36,
	ACTION_RELEASE_FOR_ITEM                  = 37,
	ACTION_HOLD_SPAN                         = 38,
	DOUBLE_CLICK_UNIQUE1                     = 39,
	DOUBLE_CLICK_UNIQUE2                     = 40,
	DOUBLE_CLICK_UNIQUE3                     = 41,
	DODGE                                    = 42,
	END_TRANSFORM                            = 43,
	PLUS_ULTRA                               = 44,
	NUM                                      = 45,
	ECommandId_MAX                           = 46,
};

// Enum InGameModule.EHitThrowType
// NumValues: 0x0004
enum class EHitThrowType : uint8
{
	NONE                                     = 0,
	NO_DAMAGE                                = 1,
	THROW                                    = 2,
	EHitThrowType_MAX                        = 3,
};

// Enum InGameModule.EWarpCopyType
// NumValues: 0x0004
enum class EWarpCopyType : uint8
{
	WARP                                     = 0,
	PORTALWARP                               = 1,
	NONE                                     = 2,
	EWarpCopyType_MAX                        = 3,
};

// Enum InGameModule.EDamageAttribute
// NumValues: 0x0007
enum class EDamageAttribute : uint8
{
	NONE                                     = 0,
	BURN                                     = 1,
	BURN_BLUE                                = 2,
	FREEZE                                   = 3,
	ELECTRIFY                                = 4,
	COLLAPSE                                 = 5,
	EDamageAttribute_MAX                     = 6,
};

// Enum InGameModule.ESupplyBoxSize
// NumValues: 0x0004
enum class ESupplyBoxSize : uint8
{
	Small                                    = 0,
	Large                                    = 1,
	Gold                                     = 2,
	ESupplyBoxSize_MAX                       = 3,
};

// Enum InGameModule.ESupplyDropDistance
// NumValues: 0x0005
enum class ESupplyDropDistance : uint8
{
	Short                                    = 0,
	Middle                                   = 1,
	Long                                     = 2,
	SuperLong                                = 3,
	ESupplyDropDistance_MAX                  = 4,
};

// Enum InGameModule.ESupplySelectType
// NumValues: 0x0003
enum class ESupplySelectType : uint8
{
	Random                                   = 0,
	Fixed                                    = 1,
	ESupplySelectType_MAX                    = 2,
};

// Enum InGameModule.ESupplyBoxState
// NumValues: 0x0005
enum class ESupplyBoxState : uint8
{
	BeforeSpawn                              = 0,
	Spawned                                  = 1,
	Opened                                   = 2,
	Vacant                                   = 3,
	ESupplyBoxState_MAX                      = 4,
};

// Enum InGameModule.EBattleSequence
// NumValues: 0x000F
enum class EBattleSequence : uint8
{
	Init                                     = 0,
	WaitBriefingOpen                         = 1,
	DecideStartPoint                         = 2,
	AllPlayerDecidedStartPoint               = 3,
	DisplayAllPlayerStartPoint               = 4,
	ZoomCameraScene                          = 5,
	CanOnlyMove                              = 6,
	OnBattle                                 = 7,
	FinishBattleScene                        = 8,
	PrepareCongratulateWinner                = 9,
	OnCongratulateWinner                     = 10,
	EndCongratulateWinner                    = 11,
	WaitingCosmosMessage                     = 12,
	ExitingFromBattle                        = 13,
	MAX                                      = 14,
};

// Enum InGameModule.EDamageFaceDirection
// NumValues: 0x0003
enum class EDamageFaceDirection : uint8
{
	FACE_UP                                  = 0,
	FACE_DOWN                                = 1,
	FACE_MAX                                 = 2,
};

// Enum InGameModule.EDamageDirection
// NumValues: 0x0007
enum class EDamageDirection : uint8
{
	FRONT                                    = 0,
	LEFT                                     = 1,
	BACK                                     = 2,
	RIGHT                                    = 3,
	UP                                       = 4,
	DOWN                                     = 5,
	EDamageDirection_MAX                     = 6,
};

// Enum InGameModule.ERespawnType
// NumValues: 0x0005
enum class ERespawnType : uint8
{
	DEFAULT                                  = 0,
	IMMEDIATE                                = 1,
	IMMEDIATE_WITH_BRIEFING                  = 2,
	IMMEDIATE_WITH_ALLY                      = 3,
	MAX                                      = 4,
};

// Enum InGameModule.EGraduallyAlphaType
// NumValues: 0x0006
enum class EGraduallyAlphaType : uint8
{
	None                                     = 0,
	Short                                    = 1,
	NearMiddle                               = 2,
	Middle                                   = 3,
	Long                                     = 4,
	EGraduallyAlphaType_MAX                  = 5,
};

// Enum InGameModule.EHitMarkType
// NumValues: 0x0013
enum class EHitMarkType : uint8
{
	NONE                                     = 0,
	LIGHTHIT                                 = 1,
	MEDIUMHIT                                = 2,
	HARDHIT                                  = 3,
	MULTI_LIGHTHIT                           = 4,
	MULTI_MEDIUMHIT                          = 5,
	MULTI_HARDHIT                            = 6,
	SLASH_LIGHTHIT                           = 7,
	SLASH_MEDIUMHIT                          = 8,
	SLASH_HARDHIT                            = 9,
	GUARD_LIGHT                              = 10,
	GUARD_MEDIUM                             = 11,
	GUARD_HARD                               = 12,
	MULTI_GUARD_LIGHT                        = 13,
	MULTI_GUARD_MEDIUM                       = 14,
	MULTI_GUARD_HARD                         = 15,
	GUARD_BREAK                              = 16,
	DYING                                    = 17,
	EHitMarkType_MAX                         = 18,
};

// Enum InGameModule.EObjectSize
// NumValues: 0x0005
enum class EObjectSize : uint32
{
	S                                        = 0,
	M                                        = 1,
	L                                        = 2,
	LL                                       = 3,
	Max                                      = 4,
};

// Enum InGameModule.ELobbySequence
// NumValues: 0x0003
enum class ELobbySequence : uint8
{
	Init                                     = 0,
	ReadyToBattle                            = 1,
	MAX                                      = 2,
};

// Enum InGameModule.EBlurEffectType
// NumValues: 0x0003
enum class EBlurEffectType : uint8
{
	BLUR_IMMEDIATE                           = 0,
	BLUR_GRADUALLY                           = 1,
	BLUR_MAX                                 = 2,
};

// Enum InGameModule.EPinnedActorType
// NumValues: 0x0005
enum class EPinnedActorType : uint8
{
	None                                     = 0,
	Supply                                   = 1,
	Trap                                     = 2,
	Citizen                                  = 3,
	EPinnedActorType_MAX                     = 4,
};

// Enum InGameModule.EAbilityLevel
// NumValues: 0x000B
enum class EAbilityLevel : uint8
{
	UNDEF                                    = 0,
	LEVEL_1                                  = 1,
	LEVEL_2                                  = 2,
	LEVEL_3                                  = 3,
	LEVEL_4                                  = 4,
	LEVEL_5                                  = 5,
	LEVEL_6                                  = 6,
	LEVEL_7                                  = 7,
	LEVEL_8                                  = 8,
	LEVEL_9                                  = 9,
	MAX                                      = 10,
};

// Enum InGameModule.EAbilityBonusCalculation
// NumValues: 0x0003
enum class EAbilityBonusCalculation : uint8
{
	MULTPLY                                  = 0,
	ADDITION                                 = 1,
	EAbilityBonusCalculation_MAX             = 2,
};

// Enum InGameModule.EActionCancelFlag
// NumValues: 0x000B
enum class EActionCancelFlag : uint8
{
	NONE                                     = 0,
	CF_UNIQUE1                               = 1,
	CF_UNIQUE2                               = 2,
	CF_UNIQUE3                               = 4,
	CF_MELEE                                 = 8,
	CF_SPECIAL                               = 16,
	CF_JUMP                                  = 32,
	CF_DODGE                                 = 64,
	CF_CHARGE                                = 128,
	ALL                                      = 255,
	EActionCancelFlag_MAX                    = 256,
};

// Enum InGameModule.EActionAxis
// NumValues: 0x0008
enum class EActionAxis : uint8
{
	NONE                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	IX                                       = 4,
	IY                                       = 5,
	IZ                                       = 6,
	EActionAxis_MAX                          = 7,
};

// Enum InGameModule.EActionEmoteType
// NumValues: 0x000C
enum class EActionEmoteType : uint8
{
	EMOTE_00                                 = 0,
	EMOTE_01                                 = 1,
	EMOTE_02                                 = 2,
	EMOTE_03                                 = 3,
	EMOTE_04                                 = 4,
	EMOTE_05                                 = 5,
	EMOTE_06                                 = 6,
	EMOTE_07                                 = 7,
	EMOTE_08                                 = 8,
	EMOTE_09                                 = 9,
	NONE                                     = 10,
	MAX                                      = 11,
};

// Enum InGameModule.EActionButtonType
// NumValues: 0x0008
enum class EActionButtonType : uint8
{
	NONE                                     = 0,
	SPECIAL_ACTION                           = 1,
	RECOVER_ALLY                             = 2,
	RECOVER_CITIZEN                          = 3,
	PICK_UP_ITEM                             = 4,
	OPEND_SUPPLYBOX                          = 5,
	RECOVER_ENEMY_FORSCOUT                   = 6,
	EActionButtonType_MAX                    = 7,
};

// Enum InGameModule.EBattleAction
// NumValues: 0x004F
enum class EBattleAction : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Run                                      = 2,
	RunEnd                                   = 3,
	DashBegin                                = 4,
	Dash                                     = 5,
	DashEnd                                  = 6,
	JumpBegin                                = 7,
	JumpBeginForward                         = 8,
	JumpRise                                 = 9,
	JumpTop                                  = 10,
	JumpFall                                 = 11,
	Fall                                     = 12,
	DashFall                                 = 13,
	Land                                     = 14,
	DashLand                                 = 15,
	AirJumpBegin                             = 16,
	AirJumpBeginForward                      = 17,
	HighJumpRise                             = 18,
	SuperJumpRise                            = 19,
	WallCrawl                                = 20,
	WallJump                                 = 21,
	RideOverWall                             = 22,
	RecoverAlly                              = 23,
	RecoverCitizen                           = 24,
	ScoutEnemy                               = 25,
	Crouch                                   = 26,
	CrouchEnd                                = 27,
	CrouchMove                               = 28,
	Hover                                    = 29,
	AirDash                                  = 30,
	AirDashEnd                               = 31,
	WallDash                                 = 32,
	WallWalk                                 = 33,
	ParkourJump                              = 34,
	ParkourFall                              = 35,
	ParkourLand                              = 36,
	ParkourDashJump                          = 37,
	Dodge                                    = 38,
	PlusUltra                                = 39,
	Emote                                    = 40,
	PickUpItem                               = 41,
	OpenBox                                  = 42,
	DyingIdle                                = 43,
	DyingMove                                = 44,
	DyingFall                                = 45,
	DyingLand                                = 46,
	DyingRecover                             = 47,
	Die                                      = 48,
	Grabbed                                  = 49,
	Throwned                                 = 50,
	Carryed                                  = 51,
	SleepForWholeDamage                      = 52,
	SleepForWholeAttack                      = 53,
	DamageWeak                               = 54,
	DamageNagaraWeak                         = 55,
	DamageStrong                             = 56,
	DamageBound                              = 57,
	DamageDown                               = 58,
	DamageStandUp                            = 59,
	DamageToDying                            = 60,
	DamageKnockDown                          = 61,
	DamageGrabbed                            = 62,
	DamageCaptured                           = 63,
	DamageFall                               = 64,
	DamagePulledUp                           = 65,
	DamageInvolved                           = 66,
	DamageZeroGravity                        = 67,
	DamageNoise                              = 68,
	DamageFreeze                             = 69,
	DamageShock                              = 70,
	DamageRecover                            = 71,
	DamageAirRecover                         = 72,
	DamageNagaraGuard                        = 73,
	DamageGuard                              = 74,
	DamageGuardStrong                        = 75,
	DamageDyingWeak                          = 76,
	DamageDyingDead                          = 77,
	EBattleAction_MAX                        = 78,
};

// Enum InGameModule.EWallCrawlState
// NumValues: 0x0005
enum class EWallCrawlState : uint8
{
	INITIALIZE                               = 0,
	IDLE                                     = 1,
	MOVE                                     = 2,
	VERTICAL_RESET_LANDING                   = 3,
	EWallCrawlState_MAX                      = 4,
};

// Enum InGameModule.EAICombatRangeType
// NumValues: 0x0004
enum class EAICombatRangeType : uint8
{
	CLOSE_RANGE                              = 0,
	MEDIUM_RANGE                             = 1,
	LONG_RANGE                               = 2,
	EAICombatRangeType_MAX                   = 3,
};

// Enum InGameModule.EAISkillStance
// NumValues: 0x0004
enum class EAISkillStance : uint8
{
	BOTH                                     = 0,
	GROUND                                   = 1,
	AIR                                      = 2,
	EAISkillStance_MAX                       = 3,
};

// Enum InGameModule.EAISkillType
// NumValues: 0x0005
enum class EAISkillType : uint8
{
	MELEE                                    = 0,
	UNIQUE1                                  = 1,
	UNIQUE2                                  = 2,
	UNIQUE3                                  = 3,
	EAISkillType_MAX                         = 4,
};

// Enum InGameModule.EAIMoveType
// NumValues: 0x0006
enum class EAIMoveType : uint8
{
	NONE                                     = 0,
	IDLE                                     = 1,
	JUMP                                     = 2,
	DASH                                     = 3,
	WALL                                     = 4,
	EAIMoveType_MAX                          = 5,
};

// Enum InGameModule.EAIDifficultyLevel
// NumValues: 0x0004
enum class EAIDifficultyLevel : uint8
{
	LEVEL1                                   = 0,
	LEVEL2                                   = 1,
	LEVEL3                                   = 2,
	MAX                                      = 3,
};

// Enum InGameModule.EAITrainingType
// NumValues: 0x0008
enum class EAITrainingType : uint8
{
	STOP                                     = 0,
	DOGE                                     = 1,
	BATTLE                                   = 2,
	MELEE                                    = 3,
	UNIQUE1                                  = 4,
	UNIQUE2                                  = 5,
	UNIQUE3                                  = 6,
	EAITrainingType_MAX                      = 7,
};

// Enum InGameModule.EAIMode
// NumValues: 0x0005
enum class EAIMode : uint8
{
	LOBBY                                    = 0,
	TUTORIAL                                 = 1,
	TRAINING                                 = 2,
	BATTLE                                   = 3,
	EAIMode_MAX                              = 4,
};

// Enum InGameModule.EAnMagazineShootType
// NumValues: 0x0004
enum class EAnMagazineShootType : uint8
{
	SHOOT                                    = 0,
	START                                    = 1,
	STOP                                     = 2,
	EAnMagazineShootType_MAX                 = 3,
};

// Enum InGameModule.EAvatarVoiceType
// NumValues: 0x000B
enum class EAvatarVoiceType : uint8
{
	None                                     = 0,
	AttackFight                              = 1,
	AttackShoot                              = 2,
	AttackArea                               = 3,
	AttackSecret                             = 4,
	AttackBuff                               = 5,
	AttackShootDelay                         = 6,
	AttackAreaDouble                         = 7,
	AttackFightWait                          = 8,
	AttackShootWait                          = 9,
	EAvatarVoiceType_MAX                     = 10,
};

// Enum InGameModule.ENPCCitizenState
// NumValues: 0x0008
enum class ENPCCitizenState : uint8
{
	SPAWN                                    = 0,
	RUN                                      = 1,
	TRIP_OVER                                = 2,
	RECOVER                                  = 3,
	RECOVER_END                              = 4,
	ESCAPE                                   = 5,
	ESCAPE_RUN                               = 6,
	ENPCCitizenState_MAX                     = 7,
};

// Enum InGameModule.EImportance
// NumValues: 0x0004
enum class EImportance : uint8
{
	Emergency                                = 0,
	NormalAnnounce                           = 1,
	Verbose                                  = 2,
	EImportance_MAX                          = 3,
};

// Enum InGameModule.EGroupLink
// NumValues: 0x0003
enum class EGroupLink : uint8
{
	NONE                                     = 0,
	BEGIN                                    = 1,
	EGroupLink_MAX                           = 2,
};

// Enum InGameModule.EDevActionCameraMode
// NumValues: 0x0004
enum class EDevActionCameraMode : uint8
{
	NONE                                     = 0,
	EDIT                                     = 1,
	DISABLE                                  = 2,
	EDevActionCameraMode_MAX                 = 3,
};

// Enum InGameModule.EBattleCameraType
// NumValues: 0x0009
enum class EBattleCameraType : uint8
{
	NONE                                     = 0,
	DEFAULT                                  = 1,
	DASH                                     = 2,
	DOWN                                     = 3,
	CROUCH                                   = 4,
	WALL_CRAWL                               = 5,
	AIMING                                   = 6,
	AIMING_CROUCH                            = 7,
	EBattleCameraType_MAX                    = 8,
};

// Enum InGameModule.EBattleEventEffectType
// NumValues: 0x000A
enum class EBattleEventEffectType : uint8
{
	Begin                                    = 0,
	CharaHit                                 = 1,
	CharaHitVanish                           = 2,
	WallHit                                  = 3,
	WallHitVanish                            = 4,
	Break                                    = 5,
	LifeSpan                                 = 6,
	Common                                   = 7,
	EraseVanish                              = 8,
	MAX                                      = 9,
};

// Enum InGameModule.EDestructLevel
// NumValues: 0x000B
enum class EDestructLevel : uint32
{
	LEVEL_0                                  = 0,
	LEVEL_1                                  = 1,
	LEVEL_2                                  = 2,
	LEVEL_3                                  = 3,
	LEVEL_4                                  = 4,
	LEVEL_5                                  = 5,
	LEVEL_6                                  = 6,
	LEVEL_7                                  = 7,
	LEVEL_8                                  = 8,
	LEVEL_9                                  = 9,
	MAX                                      = 10,
};

// Enum InGameModule.EBulletSPBlockType
// NumValues: 0x0006
enum class EBulletSPBlockType : uint8
{
	VANISH                                   = 0,
	BLOCK_VANISH                             = 1,
	BLOCK_AIZAWA                             = 2,
	REFLECT                                  = 3,
	COMPRESS                                 = 4,
	EBulletSPBlockType_MAX                   = 5,
};

// Enum InGameModule.EPlayTiming
// NumValues: 0x0004
enum class EPlayTiming : uint8
{
	BEGIN                                    = 0,
	VANISH                                   = 1,
	FREE                                     = 2,
	EPlayTiming_MAX                          = 3,
};

// Enum InGameModule.ECh003Unique1State
// NumValues: 0x0005
enum class ECh003Unique1State : uint8
{
	NONE                                     = 0,
	SHOT                                     = 1,
	REVERSE                                  = 2,
	HIT_REVERSE                              = 3,
	ECh003Unique1State_MAX                   = 4,
};

// Enum InGameModule.ECh003Unique1ChargeState
// NumValues: 0x0005
enum class ECh003Unique1ChargeState : uint8
{
	NONE                                     = 0,
	REVERSE                                  = 1,
	HIT_REVERSE                              = 2,
	DESTROY                                  = 3,
	ECh003Unique1ChargeState_MAX             = 4,
};

// Enum InGameModule.ECh003Unique1GenState
// NumValues: 0x0005
enum class ECh003Unique1GenState : uint8
{
	NONE                                     = 0,
	REVERSE                                  = 1,
	HIT_REVERSE                              = 2,
	DESTROY                                  = 3,
	ECh003Unique1GenState_MAX                = 4,
};

// Enum InGameModule.ECh003Unique3State
// NumValues: 0x0006
enum class ECh003Unique3State : uint8
{
	NONE                                     = 0,
	STAY                                     = 1,
	FLOAT                                    = 2,
	FALL                                     = 3,
	DESTROY                                  = 4,
	ECh003Unique3State_MAX                   = 5,
};

// Enum InGameModule.ECh012Unique2BulletType
// NumValues: 0x0003
enum class ECh012Unique2BulletType : uint8
{
	IMPACT                                   = 0,
	SMOKE                                    = 1,
	ECh012Unique2BulletType_MAX              = 2,
};

// Enum InGameModule.ECh017Unique2State
// NumValues: 0x0003
enum class ECh017Unique2State : uint8
{
	NONE                                     = 0,
	ACTIVE                                   = 1,
	ECh017Unique2State_MAX                   = 2,
};

// Enum InGameModule.ECh046Unique1BulletSize
// NumValues: 0x0004
enum class ECh046Unique1BulletSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	ECh046Unique1BulletSize_MAX              = 3,
};

// Enum InGameModule.EActType
// NumValues: 0x0004
enum class EActType : uint8
{
	DEFAULT                                  = 0,
	MOVE                                     = 1,
	ATTACK                                   = 2,
	EActType_MAX                             = 3,
};

// Enum InGameModule.EAttackPhaseEndFlag
// NumValues: 0x000A
enum class EAttackPhaseEndFlag : uint8
{
	NONE                                     = 0,
	COMMAND_COMBO                            = 1,
	TIMER                                    = 2,
	GRABED                                   = 4,
	ATTACKHIT                                = 8,
	LANDING                                  = 16,
	ANIM_END                                 = 32,
	REMOTE                                   = 240,
	ALL                                      = 255,
	EAttackPhaseEndFlag_MAX                  = 256,
};

// Enum InGameModule.EMagazineRegisterType
// NumValues: 0x0006
enum class EMagazineRegisterType : uint8
{
	INITIALIZE                               = 0,
	LEVEL_CHANGE                             = 1,
	SKILL_CHANGE                             = 2,
	SKILL_COPY                               = 3,
	PLUS_ULTRA                               = 4,
	MAX                                      = 5,
};

// Enum InGameModule.EAttackAngleRangeOutType
// NumValues: 0x0003
enum class EAttackAngleRangeOutType : uint8
{
	DEFAULT                                  = 0,
	NOTIFICATION                             = 1,
	EAttackAngleRangeOutType_MAX             = 2,
};

// Enum InGameModule.ESpecialActionLaunchType
// NumValues: 0x0004
enum class ESpecialActionLaunchType : uint8
{
	NORMAL                                   = 0,
	DYING                                    = 1,
	ANYTIME                                  = 2,
	ESpecialActionLaunchType_MAX             = 3,
};

// Enum InGameModule.EAttackDisabledFlags
// NumValues: 0x0006
enum class EAttackDisabledFlags : uint8
{
	NONE                                     = 0,
	AMMO_EMPTY                               = 1,
	SEAL                                     = 2,
	ENGINE_STOP                              = 4,
	ALL                                      = 255,
	EAttackDisabledFlags_MAX                 = 256,
};

// Enum InGameModule.EANCollisionType
// NumValues: 0x0005
enum class EANCollisionType : uint8
{
	SPHERE                                   = 0,
	CAPSULE                                  = 1,
	BOX                                      = 2,
	MESH                                     = 3,
	EANCollisionType_MAX                     = 4,
};

// Enum InGameModule.EAttackHitResult
// NumValues: 0x0005
enum class EAttackHitResult : uint8
{
	NONE                                     = 0,
	CHARACTER                                = 1,
	BACKGROUND                               = 2,
	ITEM                                     = 3,
	MAX                                      = 4,
};

// Enum InGameModule.EAttackTeamType
// NumValues: 0x0004
enum class EAttackTeamType : uint8
{
	ALL                                      = 0,
	ENEMY_ONLY                               = 1,
	ALLY_ONLY                                = 2,
	EAttackTeamType_MAX                      = 3,
};

// Enum InGameModule.EAttackLaunchTarget
// NumValues: 0x0009
enum class EAttackLaunchTarget : uint8
{
	UNDEF                                    = 0,
	DEFAULT                                  = 1,
	NEAREST_DIYNG_CHARACTER                  = 2,
	NEAREST_CHARACTER                        = 3,
	NEAREST_AIMING_CHARACTER                 = 4,
	NEAREST_DIYNG_ALLY                       = 5,
	NEAREST_ALLY                             = 6,
	NEAREST_CHARACTER_ALL                    = 7,
	MAX                                      = 8,
};

// Enum InGameModule.EAttackLaunchType
// NumValues: 0x0006
enum class EAttackLaunchType : uint8
{
	UNDEF                                    = 0,
	DEFAULT                                  = 1,
	DEFAULT_AIR                              = 2,
	CHARGE                                   = 3,
	CHARGE_AIR                               = 4,
	EAttackLaunchType_MAX                    = 5,
};

// Enum InGameModule.EAttackAnimationEventId
// NumValues: 0x000D
enum class EAttackAnimationEventId : uint8
{
	NONE                                     = 0,
	ANIM_EV_A                                = 1,
	ANIM_EV_B                                = 2,
	ANIM_EV_C                                = 3,
	ANIM_EV_D                                = 4,
	ANIM_EV_E                                = 5,
	ANIM_EV_F                                = 6,
	ANIM_EV_G                                = 7,
	ANIM_EV_H                                = 8,
	ANIM_EV_I                                = 9,
	ANIM_EV_J                                = 10,
	ANIM_EV_K                                = 11,
	MAX                                      = 12,
};

// Enum InGameModule.EAttackDedicatedEventId
// NumValues: 0x0009
enum class EAttackDedicatedEventId : uint8
{
	AD_EV_A                                  = 0,
	AD_EV_B                                  = 1,
	AD_EV_C                                  = 2,
	AD_EV_D                                  = 3,
	AD_EV_E                                  = 4,
	AD_EV_F                                  = 5,
	AD_EV_G                                  = 6,
	AD_EV_H                                  = 7,
	MAX                                      = 8,
};

// Enum InGameModule.EAttackProcessType
// NumValues: 0x0006
enum class EAttackProcessType : uint8
{
	OFF                                      = 0,
	WHOLE                                    = 1,
	NAGARA                                   = 2,
	WHOLE_EXTRA                              = 3,
	NAGARA_EXTRA                             = 4,
	EAttackProcessType_MAX                   = 5,
};

// Enum InGameModule.EAttackVisualLevel
// NumValues: 0x0007
enum class EAttackVisualLevel : uint8
{
	LOW                                      = 0,
	LOWER_MIDDLE                             = 1,
	MIDDLE                                   = 2,
	ON_MIDDLE                                = 3,
	HIGH                                     = 4,
	ANY                                      = 5,
	MAX                                      = 6,
};

// Enum InGameModule.ESimulatedProcLevel
// NumValues: 0x0004
enum class ESimulatedProcLevel : uint8
{
	SIMULATED_PROC_LV_LOW                    = 0,
	SIMULATED_PROC_LV_MID                    = 1,
	SIMULATED_PROC_LV_HIGH                   = 2,
	SIMULATED_PROC_LV_MAX                    = 3,
};

// Enum InGameModule.EBattleInputMode
// NumValues: 0x0005
enum class EBattleInputMode : uint8
{
	UNINITIALIZED                            = 0,
	ALL_OFF                                  = 1,
	MOVEONLY                                 = 2,
	BATTLE                                   = 3,
	EBattleInputMode_MAX                     = 4,
};

// Enum InGameModule.ENotificationBits
// NumValues: 0x0006
enum class ENotificationBits : uint8
{
	NB_NONE                                  = 0,
	NB_EMOTE                                 = 1,
	NB_USEITEM                               = 2,
	NB_USERESPAWN                            = 4,
	NB_STOPITEM                              = 8,
	NB_MAX                                   = 9,
};

// Enum InGameModule.ECommandType
// NumValues: 0x000D
enum class ECommandType : uint8
{
	PRESS_ONE                                = 0,
	TRIGGER_ONE                              = 1,
	TRIGGER_AND_HOLD_ONE                     = 2,
	RELEASE_ONE                              = 3,
	PRESS_TWO                                = 4,
	TRIGGER_TWO                              = 5,
	TRIGGER_AND_HOLD_TWO                     = 6,
	HOLD_DOWN                                = 7,
	HOLD_SPAN                                = 8,
	CHARGE                                   = 9,
	NOTIFICATION                             = 10,
	DOUBLE_TAP                               = 11,
	ECommandType_MAX                         = 12,
};

// Enum InGameModule.ECharacterConditionType
// NumValues: 0x0004
enum class ECharacterConditionType : uint8
{
	CCT_UNDEF                                = 0,
	CCT_DEBUFF                               = 1,
	CCT_BUFF                                 = 2,
	CCT_MAX                                  = 3,
};

// Enum InGameModule.ECharacterConditionGroup
// NumValues: 0x000B
enum class ECharacterConditionGroup : uint8
{
	CC_GROUP_NONE                            = 0,
	CC_GROUP_A                               = 1,
	CC_GROUP_B                               = 2,
	CC_GROUP_C                               = 3,
	CC_GROUP_D                               = 4,
	CC_GROUP_E                               = 5,
	CC_GROUP_F                               = 6,
	CC_GROUP_G                               = 7,
	CC_GROUP_H                               = 8,
	CC_GROUP_KING                            = 9,
	CC_GROUP_MAX                             = 10,
};

// Enum InGameModule.EGuardState
// NumValues: 0x0008
enum class EGuardState : uint8
{
	NONE                                     = 0,
	WHOLE                                    = 1,
	NAGARA                                   = 2,
	NO_REACTION                              = 3,
	WHOLE_STRONG                             = 4,
	DAMAGE_REACTIOIN                         = 5,
	BREAK                                    = 6,
	EGuardState_MAX                          = 7,
};

// Enum InGameModule.ECircularProgressType
// NumValues: 0x0005
enum class ECircularProgressType : uint8
{
	RescueAlly                               = 0,
	InteractCitizen                          = 1,
	TreasureBox                              = 2,
	None                                     = 3,
	ECircularProgressType_MAX                = 4,
};

// Enum InGameModule.ECommentaryVoiceType
// NumValues: 0x001F
enum class ECommentaryVoiceType : uint8
{
	UNDEF                                    = 0,
	JOINED_LOBBY                             = 1,
	NEWCHARACTER_LOBBY                       = 2,
	RARECOSTUME_LOBBY                        = 3,
	RAMPARGE_LOBBY                           = 4,
	FIXEDTIME_LOBBY                          = 5,
	READYTOBATTLE_LOBBY                      = 6,
	TRANSITION_BRIEFING                      = 7,
	DECIDE_BRIEFING                          = 8,
	SRARTBATTLE_BRIEFING                     = 9,
	START_BATTLE                             = 10,
	NOTICESHRINK_BATTLE                      = 11,
	COMPLETENOTICESHRINK_BATTLE              = 12,
	SUPPLYBOX_BATTLE                         = 13,
	GAMESET_BATTLE                           = 14,
	FIRSTKILLEARLY_BATTLE                    = 15,
	FIRSTKILL_BATTLE                         = 16,
	FOUNDKOTA_BATTLE                         = 17,
	SPECTAING_BATTLE                         = 18,
	LIKEFIXED_BATTLE                         = 19,
	LAST_BATTLE                              = 20,
	REMAINING_HARF_SQUAD                     = 21,
	REMAINING_TWO_SQUAD                      = 22,
	REMAINING_THREE_SQUAD                    = 23,
	REMAINING_HARF_SOLO                      = 24,
	REMAINING_SIX_SOLO                       = 25,
	KILL_LEADERS                             = 26,
	SURVIVAL_LEADERS                         = 27,
	TIMELEFT_LEADERS                         = 28,
	TIMELEFTDIALOGUE_LEADERS                 = 29,
	MAX                                      = 30,
};

// Enum InGameModule.ECrossHairsColor
// NumValues: 0x000A
enum class ECrossHairsColor : uint8
{
	WHITE                                    = 0,
	RED                                      = 1,
	ORANGE                                   = 2,
	MAGENTA                                  = 3,
	GREEN                                    = 4,
	YELLOW                                   = 5,
	CYAN                                     = 6,
	BLUE                                     = 7,
	BLACK                                    = 8,
	ECrossHairsColor_MAX                     = 9,
};

// Enum InGameModule.EDamagedPointType
// NumValues: 0x0003
enum class EDamagedPointType : uint8
{
	Health                                   = 0,
	Guard                                    = 1,
	EDamagedPointType_MAX                    = 2,
};

// Enum InGameModule.EDamageRateId
// NumValues: 0x000D
enum class EDamageRateId : uint8
{
	UNDEF                                    = 0,
	MELEE                                    = 1,
	SPECIAL                                  = 2,
	UNIQUE1                                  = 3,
	UNIQUE2                                  = 4,
	UNIQUE3                                  = 5,
	UNIQUE4                                  = 6,
	UNIQUE5                                  = 7,
	UNIQUE6                                  = 8,
	UNIQUE7                                  = 9,
	UNIQUE8                                  = 10,
	UNIQUE9                                  = 11,
	EDamageRateId_MAX                        = 12,
};

// Enum InGameModule.EDamageCauserType
// NumValues: 0x0006
enum class EDamageCauserType : uint8
{
	NONE                                     = 0,
	PLAYER_ATTACK                            = 1,
	POISON_MIST                              = 2,
	KING_DEFEATED                            = 3,
	GIVE_UP                                  = 4,
	EDamageCauserType_MAX                    = 5,
};

// Enum InGameModule.ERestraintType
// NumValues: 0x0008
enum class ERestraintType : uint8
{
	NONE                                     = 0,
	BLACK_WHIP_LEVEL1                        = 1,
	BLACK_WHIP_LEVEL2                        = 2,
	BLACK_WHIP_LEVEL3                        = 3,
	TONGUE                                   = 4,
	TONGUE_SPECIAL                           = 5,
	CAPTURE_CLOTH                            = 6,
	ERestraintType_MAX                       = 7,
};

// Enum InGameModule.EHitMarkCorrectionType
// NumValues: 0x0008
enum class EHitMarkCorrectionType : uint8
{
	NONE                                     = 0,
	S                                        = 1,
	M                                        = 2,
	L                                        = 3,
	XL                                       = 4,
	GUARD_BREAK                              = 5,
	DYING                                    = 6,
	MAX                                      = 7,
};

// Enum InGameModule.EBGHitMarkType
// NumValues: 0x0003
enum class EBGHitMarkType : uint8
{
	DEFAULT                                  = 0,
	COLLAPSE                                 = 1,
	MAX                                      = 2,
};

// Enum InGameModule.ESpecificHitCondition
// NumValues: 0x0003
enum class ESpecificHitCondition : uint8
{
	ALWAYS                                   = 0,
	GROUNDONLY                               = 1,
	ESpecificHitCondition_MAX                = 2,
};

// Enum InGameModule.EHitTargetType
// NumValues: 0x0008
enum class EHitTargetType : uint8
{
	ENEMY_ONLY                               = 0,
	ENEMY_WITHOUT_GRABBED                    = 1,
	ALLY_ONLY                                = 2,
	CHARACTER_ALL                            = 3,
	STAGE_ALL                                = 4,
	STAGE_STATIC                             = 5,
	STAGE_DYNAMIC                            = 6,
	EHitTargetType_MAX                       = 7,
};

// Enum InGameModule.EDamageDirectionType
// NumValues: 0x0008
enum class EDamageDirectionType : uint8
{
	NO_CHANGE_DIRECTION                      = 0,
	CHARACTER_DIRECTION                      = 1,
	ACTOR_DIRECTION                          = 2,
	MOVEMENT_DIRECTION                       = 3,
	ACTOR_TO_CHARACTER                       = 4,
	CHARACTER_TO_CHARACTER                   = 5,
	NEARLY_ENEMY_DIRECTION                   = 6,
	EDamageDirectionType_MAX                 = 7,
};

// Enum InGameModule.EAttackMaterial
// NumValues: 0x0003
enum class EAttackMaterial : uint8
{
	NORMAL                                   = 0,
	METAL                                    = 1,
	EAttackMaterial_MAX                      = 2,
};

// Enum InGameModule.EGuardType
// NumValues: 0x0006
enum class EGuardType : uint8
{
	WHOLE                                    = 0,
	NAGARA                                   = 1,
	THROUGH                                  = 2,
	STRONG                                   = 3,
	DAMAGEREACTION                           = 4,
	EGuardType_MAX                           = 5,
};

// Enum InGameModule.EDamageKind
// NumValues: 0x0006
enum class EDamageKind : uint8
{
	UNDEF                                    = 0,
	PROJECTILE                               = 1,
	MELEE                                    = 2,
	SLIP                                     = 3,
	POISONMIST                               = 4,
	EDamageKind_MAX                          = 5,
};

// Enum InGameModule.EDamageType
// NumValues: 0x0010
enum class EDamageType : uint8
{
	NO_ACTION                                = 0,
	WEAK                                     = 1,
	ALWAYS_WEAK                              = 2,
	STRONG                                   = 3,
	STRAIGHT                                 = 4,
	GRABBED                                  = 5,
	CAPTURED                                 = 6,
	PULLED_UP                                = 7,
	INVOLVED                                 = 8,
	ZERO_GRAVITY                             = 9,
	NOISE                                    = 10,
	STRONG_LAUNCH                            = 11,
	GRABBED_NO_ACTION                        = 12,
	STRONG_BOUND                             = 13,
	TELEPORT_WEAK                            = 14,
	MAX                                      = 15,
};

// Enum InGameModule.EDeltaRateType
// NumValues: 0x001D
enum class EDeltaRateType : uint8
{
	WHOLE_DEFAULT                            = 0,
	WHOLE_HITSLOW                            = 1,
	WHOLE_DELTARATE                          = 2,
	MOVEMENT_DELTARATE                       = 3,
	MOVEMENT_DEFAULT                         = 4,
	MOVEMENT_ACTION_BASE                     = 5,
	MOVEMENT_ACTION_ATTACK                   = 6,
	MOVEMENT_SPEEDUP_ABILITY                 = 7,
	MOVEMENT_DEBUFF_SLOW                     = 8,
	MOVEMENT_USE_ITEM                        = 9,
	MOVEMENT_DEBUFF_ORB                      = 10,
	MOVEMENT_SPEEDRATE_SKILL                 = 11,
	MOVEMENT_SPEEDRATE_AHO                   = 12,
	MOVEMENT_SPEEDRATE_CONDITION             = 13,
	MOVEMENT_GIANT                           = 14,
	MOVEMENT_TEAMROLE                        = 15,
	MOVEMENT_SPEEDRATE                       = 16,
	ANIMATION_DEFAULT                        = 17,
	ANIMATION_ACTION_BASE                    = 18,
	ANIMATION_ACTION_ATTACK                  = 19,
	ANIMATION_SPEEDUP_ABILITY                = 20,
	ANIMATION_SPEEDRATE_SKILL                = 21,
	ANIMATION_DEBUFF_SLOW                    = 22,
	ANIMATION_SPEEDRATE_CONDITION            = 23,
	ANIMATION_PLAYRATE                       = 24,
	PARTICLE_DEFAULT                         = 25,
	PARTICLE_HITSLOW                         = 26,
	PARTICLE_PLAYRATE                        = 27,
	MAX                                      = 28,
};

// Enum InGameModule.ETTutorialStep
// NumValues: 0x0008
enum class ETTutorialStep : uint8
{
	Start                                    = 0,
	TipsStart                                = 1,
	TipsClose                                = 2,
	BattleStart                              = 3,
	BattleMain                               = 4,
	BattleEnd                                = 5,
	Ending                                   = 6,
	ETTutorialStep_MAX                       = 7,
};

// Enum InGameModule.ELobbyState
// NumValues: 0x0004
enum class ELobbyState : uint8
{
	Init                                     = 0,
	Recruiting                               = 1,
	Traveling                                = 2,
	ELobbyState_MAX                          = 3,
};

// Enum InGameModule.ETeamComposition
// NumValues: 0x0005
enum class ETeamComposition : uint8
{
	None                                     = 0,
	HeroOnly                                 = 1,
	VillainOnly                              = 2,
	Mixed                                    = 3,
	ETeamComposition_MAX                     = 4,
};

// Enum InGameModule.EClassRepNodeMapping
// NumValues: 0x0006
enum class EClassRepNodeMapping : uint8
{
	NotRouted                                = 0,
	RelevantAllConnections                   = 1,
	Spatialize_Static                        = 2,
	Spatialize_Dynamic                       = 3,
	Spatialize_Dormancy                      = 4,
	EClassRepNodeMapping_MAX                 = 5,
};

// Enum InGameModule.EGameBlockType
// NumValues: 0x0007
enum class EGameBlockType : uint8
{
	REFLECT                                  = 0,
	COMPRESS                                 = 1,
	VANISH                                   = 2,
	BLOCK                                    = 3,
	STAGE_BLOCK                              = 4,
	MAX                                      = 5,
	INVALID                                  = 6,
};

// Enum InGameModule.EHudCommandBitFlags
// NumValues: 0x000F
enum class EHudCommandBitFlags : uint16
{
	BB_None                                  = 0,
	BB_Communication                         = 1,
	BB_UseSupply                             = 2,
	BB_QuickSignal                           = 4,
	BB_QuickSignal_Red                       = 8,
	BB_SelectSupply                          = 16,
	BB_ManualSignal                          = 32,
	BB_WheelCommandFlag                      = 64,
	BB_HoldingButton                         = 128,
	BB_PrimeAbility                          = 256,
	BB_SecondAbility                         = 512,
	BB_Emote                                 = 1024,
	BB_Symbol                                = 2048,
	BB_LvUpShortCut                          = 4096,
	BB_Max                                   = 8192,
};

// Enum InGameModule.EKillLogPlayerAffiliation
// NumValues: 0x0005
enum class EKillLogPlayerAffiliation : uint8
{
	None                                     = 0,
	Party                                    = 1,
	Alliance                                 = 2,
	Enemy                                    = 3,
	EKillLogPlayerAffiliation_MAX            = 4,
};

// Enum InGameModule.EInventorySelectStatus
// NumValues: 0x0004
enum class EInventorySelectStatus : uint8
{
	NONE                                     = 0,
	SELECT                                   = 1,
	USING                                    = 2,
	EInventorySelectStatus_MAX               = 3,
};

// Enum InGameModule.EInventoryWidgetType
// NumValues: 0x0005
enum class EInventoryWidgetType : uint8
{
	NONE                                     = 0,
	SHOULDER                                 = 1,
	ABILITY                                  = 2,
	UNIQUE_SKILL                             = 3,
	EInventoryWidgetType_MAX                 = 4,
};

// Enum InGameModule.EGroundElementType
// NumValues: 0x0005
enum class EGroundElementType : uint8
{
	NONE                                     = 0,
	ICE                                      = 1,
	FIRE                                     = 2,
	SPARK                                    = 3,
	EGroundElementType_MAX                   = 4,
};

// Enum InGameModule.EPlayEffectTemplate
// NumValues: 0x0010
enum class EPlayEffectTemplate : uint8
{
	Default                                  = 0,
	MELEE                                    = 1,
	UNIQUE_L1                                = 2,
	UNIQUE_L4                                = 3,
	UNIQUE_L9                                = 4,
	UNIQUE_ALL                               = 5,
	STR_L1_SELF                              = 6,
	STR_L4_SELF                              = 7,
	STR_L9_SELF                              = 8,
	STR_ALL_SELF                             = 9,
	STR_L1_FRIEND                            = 10,
	STR_L4_FRIEND                            = 11,
	STR_L9_FRIEND                            = 12,
	STR_ALL_FRIEND                           = 13,
	APPEAL_KILL                              = 14,
	EPlayEffectTemplate_MAX                  = 15,
};

// Enum InGameModule.ECollisionObjectFlags
// NumValues: 0x0007
enum class ECollisionObjectFlags : uint8
{
	COF_NONE                                 = 0,
	COF_STAGE                                = 1,
	COF_WATER                                = 2,
	COF_CHARACTER                            = 4,
	COF_ITEM                                 = 8,
	COF_ITEMBOX                              = 16,
	COF_MAX                                  = 17,
};

// Enum InGameModule.EInteractType
// NumValues: 0x0008
enum class EInteractType : uint8
{
	UNDEF                                    = 0,
	ITEM                                     = 1,
	ABILITY                                  = 2,
	ITEMBOX                                  = 3,
	CITIZEN                                  = 4,
	PLAYER                                   = 5,
	DOGTAG                                   = 6,
	EInteractType_MAX                        = 7,
};

// Enum InGameModule.EAbilityEffectLogoType
// NumValues: 0x0005
enum class EAbilityEffectLogoType : uint8
{
	NONE                                     = 0,
	LEVEL_UP                                 = 1,
	SWITCH                                   = 2,
	BOTH                                     = 3,
	EAbilityEffectLogoType_MAX               = 4,
};

// Enum InGameModule.ERequestActionUIType
// NumValues: 0x0005
enum class ERequestActionUIType : uint8
{
	NONE                                     = 0,
	INTERACT                                 = 1,
	ACTIONSPECIAL                            = 2,
	FINISHER                                 = 3,
	ERequestActionUIType_MAX                 = 4,
};

// Enum InGameModule.EMagazineAvailability
// NumValues: 0x0006
enum class EMagazineAvailability : uint8
{
	AVAILABLE                                = 0,
	UNAVAILABLE_COMMON                       = 1,
	UNAVAILABLE_RELOAD                       = 2,
	UNAVAILABLE_TRANSFORM                    = 3,
	UNAVAILABLE_SEALED                       = 4,
	EMagazineAvailability_MAX                = 5,
};

// Enum InGameModule.EMagazineUseType
// NumValues: 0x0003
enum class EMagazineUseType : uint8
{
	ONE_SHOT                                 = 0,
	PER_SEC                                  = 1,
	MAX                                      = 2,
};

// Enum InGameModule.ECitizenType
// NumValues: 0x0007
enum class ECitizenType : uint8
{
	BLUE_MAN                                 = 0,
	GREEN_MAN                                = 1,
	BLUE_WOMAN                               = 2,
	GREEN_WOMAN                              = 3,
	SPECIAL_KID                              = 4,
	NUM                                      = 5,
	ECitizenType_MAX                         = 6,
};

// Enum InGameModule.EPinArrowDirection
// NumValues: 0x0005
enum class EPinArrowDirection : uint8
{
	Down                                     = 0,
	Right                                    = 1,
	Left                                     = 2,
	Up                                       = 3,
	EPinArrowDirection_MAX                   = 4,
};

// Enum InGameModule.EStopNotify
// NumValues: 0x0004
enum class EStopNotify : uint8
{
	NONE                                     = 0,
	STOP_DEACTIVATE                          = 1,
	STOP_DELETE                              = 2,
	EStopNotify_MAX                          = 3,
};

// Enum InGameModule.EPlayerScoutState
// NumValues: 0x0007
enum class EPlayerScoutState : uint8
{
	NONE                                     = 0,
	DEFAULT                                  = 1,
	REQUEST_TO_LOSER                         = 2,
	RECEIVE_FROM_WINNER                      = 3,
	REPLIED_TO_WINNER                        = 4,
	MAKE_A_SIDEKICK                          = 5,
	EPlayerScoutState_MAX                    = 6,
};

// Enum InGameModule.ERespawnTagState
// NumValues: 0x0005
enum class ERespawnTagState : uint8
{
	ALIVE                                    = 0,
	SPAWNED                                  = 1,
	COLLECTED                                = 2,
	RETIRE                                   = 3,
	ERespawnTagState_MAX                     = 4,
};

// Enum InGameModule.ETakeDamageType
// NumValues: 0x0006
enum class ETakeDamageType : uint8
{
	DEFAULT                                  = 0,
	HP_RECOVERY                              = 1,
	GP_RECOVERY                              = 2,
	INVALID                                  = 3,
	ONE_SHOT_KILL                            = 4,
	MAX                                      = 5,
};

// Enum InGameModule.EPoisonMistStatusType
// NumValues: 0x0004
enum class EPoisonMistStatusType : uint8
{
	Wait                                     = 0,
	Shrinking                                = 1,
	Num                                      = 2,
	EPoisonMistStatusType_MAX                = 3,
};

// Enum InGameModule.EBiasType
// NumValues: 0x0008
enum class EBiasType : uint8
{
	NONE                                     = 0,
	ABSOLUTE_OUTER                           = 1,
	ABSOLUTE_MIDDLE                          = 2,
	ABSOLUTE_IN                              = 3,
	RANDOM_OUTER                             = 4,
	RANDOM_MIDDLE                            = 5,
	RANDOM_IN                                = 6,
	EBiasType_MAX                            = 7,
};

// Enum InGameModule.EFreezeAxis
// NumValues: 0x0006
enum class EFreezeAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	XY                                       = 4,
	EFreezeAxis_MAX                          = 5,
};

// Enum InGameModule.ECharacterLifeState
// NumValues: 0x0004
enum class ECharacterLifeState : uint8
{
	Alive                                    = 0,
	Dying                                    = 1,
	Dead                                     = 2,
	ECharacterLifeState_MAX                  = 3,
};

// Enum InGameModule.ESpawnPointType
// NumValues: 0x0003
enum class ESpawnPointType : uint8
{
	UNDEF                                    = 0,
	TEAM_START                               = 1,
	ESpawnPointType_MAX                      = 2,
};

// Enum InGameModule.EGimmickCode
// NumValues: 0x0006
enum class EGimmickCode : uint8
{
	Undef                                    = 0,
	Gi001                                    = 1,
	Gi002                                    = 2,
	Gi003                                    = 3,
	Gi004                                    = 4,
	Max                                      = 5,
};

// Enum InGameModule.ESupplyCode
// NumValues: 0x0018
enum class ESupplyCode : uint8
{
	Undef                                    = 0,
	Su001                                    = 1,
	Su002                                    = 2,
	Su003                                    = 3,
	Su004                                    = 4,
	Su005                                    = 5,
	Su006                                    = 6,
	Su007                                    = 7,
	Su008                                    = 8,
	Su009                                    = 9,
	Su010                                    = 10,
	Su011                                    = 11,
	Su012                                    = 12,
	Su013                                    = 13,
	Su014                                    = 14,
	Su015                                    = 15,
	Su016                                    = 16,
	Su017                                    = 17,
	Su018                                    = 18,
	Su019                                    = 19,
	Su020                                    = 20,
	Su021                                    = 21,
	Ability                                  = 22,
	Max                                      = 23,
};

// Enum InGameModule.EStageSpawnPointSRT
// NumValues: 0x0004
enum class EStageSpawnPointSRT : uint8
{
	T                                        = 0,
	RT                                       = 1,
	SRT                                      = 2,
	Max                                      = 3,
};

// Enum InGameModule.EStageSpawnPointType
// NumValues: 0x0005
enum class EStageSpawnPointType : uint8
{
	Supply                                   = 0,
	NPC                                      = 1,
	Orb                                      = 2,
	Lobby                                    = 3,
	Max                                      = 4,
};

// Enum InGameModule.ESupplyBoxSpawnType
// NumValues: 0x0003
enum class ESupplyBoxSpawnType : uint8
{
	Init                                     = 0,
	TimeElapsed                              = 1,
	Max                                      = 2,
};

// Enum InGameModule.ESupplyManipulationType
// NumValues: 0x0006
enum class ESupplyManipulationType : uint8
{
	DEFAULT                                  = 0,
	USE                                      = 1,
	COMPOSITION_SOURCE                       = 2,
	COMPOSITION_DEST                         = 3,
	DROP                                     = 4,
	ESupplyManipulationType_MAX              = 5,
};

// Enum InGameModule.ESupplyHolderType
// NumValues: 0x0006
enum class ESupplyHolderType : uint8
{
	UNDEF                                    = 0,
	INVENTORY                                = 1,
	ABILITYSLOT                              = 2,
	SKILLSLOT                                = 3,
	ORBSLOT                                  = 4,
	ESupplyHolderType_MAX                    = 5,
};

// Enum InGameModule.TakeCharacterFace
// NumValues: 0x000D
enum class ETakeCharacterFace : uint8
{
	FaceIdle                                 = 0,
	FaceAttackPre                            = 1,
	FaceAttack                               = 2,
	FaceDmgWeak                              = 3,
	FaceDmgStrong                            = 4,
	FaceDeath                                = 5,
	FaceAct001                               = 6,
	FaceAct002                               = 7,
	FaceAct003                               = 8,
	FaceAct004                               = 9,
	FaceAct005                               = 10,
	FaceAct006                               = 11,
	TakeCharacterFace_MAX                    = 12,
};

// Enum InGameModule.TakeCharacterCostume
// NumValues: 0x0016
enum class ETakeCharacterCostume : uint8
{
	DEFAULT                                  = 0,
	CASTUME1                                 = 1,
	CASTUME2                                 = 2,
	CASTUME3                                 = 3,
	CASTUME4                                 = 4,
	CASTUME5                                 = 5,
	CASTUME6                                 = 6,
	CASTUME7                                 = 7,
	CASTUME8                                 = 8,
	CASTUME9                                 = 9,
	CASTUME10                                = 10,
	CASTUME11                                = 11,
	CASTUME12                                = 12,
	CASTUME13                                = 13,
	CASTUME14                                = 14,
	CASTUME15                                = 15,
	CASTUME16                                = 16,
	CASTUME17                                = 17,
	CASTUME18                                = 18,
	CASTUME19                                = 19,
	CASTUME20                                = 20,
	TakeCharacterCostume_MAX                 = 21,
};

// Enum InGameModule.TakeCharacterImageTypeCustomDirection
// NumValues: 0x0005
enum class ETakeCharacterImageTypeCustomDirection : uint8
{
	FRONT                                    = 0,
	BACK                                     = 1,
	LEFT                                     = 2,
	RIGHT                                    = 3,
	TakeCharacterImageTypeCustomDirection_MAX = 4,
};

// Enum InGameModule.TakeCharacterImageTypeCustom
// NumValues: 0x000B
enum class ETakeCharacterImageTypeCustom : uint8
{
	Slot1                                    = 0,
	Slot2                                    = 1,
	Slot3                                    = 2,
	Slot4                                    = 3,
	Slot5                                    = 4,
	Slot6                                    = 5,
	Slot7                                    = 6,
	Slot8                                    = 7,
	Slot9                                    = 8,
	Slot10                                   = 9,
	TakeCharacterImageTypeCustom_MAX         = 10,
};

// Enum InGameModule.TakeCharacterImageType
// NumValues: 0x0021
enum class ETakeCharacterImageType : uint8
{
	UNIQUE1                                  = 0,
	UNIQUE2                                  = 1,
	UNIQUE3                                  = 2,
	GA100                                    = 3,
	PAUSE1                                   = 4,
	PAUSE2                                   = 5,
	PAUSE3                                   = 6,
	PAUSE4                                   = 7,
	PAUSE5                                   = 8,
	PLUSULTRA                                = 9,
	EMOTE0                                   = 10,
	EMOTE1                                   = 11,
	EMOTE2                                   = 12,
	EMOTE3                                   = 13,
	EMOTE4                                   = 14,
	EMOTE5                                   = 15,
	EMOTE6                                   = 16,
	EMOTE7                                   = 17,
	EMOTE8                                   = 18,
	EMOTE9                                   = 19,
	EMOTE10                                  = 20,
	EMOTE11                                  = 21,
	EMOTE12                                  = 22,
	EMOTE13                                  = 23,
	EMOTE14                                  = 24,
	EMOTE15                                  = 25,
	EMOTE16                                  = 26,
	EMOTE17                                  = 27,
	EMOTE18                                  = 28,
	EMOTE19                                  = 29,
	EMOTE20                                  = 30,
	EMOTE21                                  = 31,
	TakeCharacterImageType_MAX               = 32,
};

// Enum InGameModule.ETutorialDisplayUI
// NumValues: 0x000D
enum class ETutorialDisplayUI : uint8
{
	NO_DISPLAY                               = 0,
	CROSS_HAIRS                              = 1,
	MINIMAP                                  = 2,
	ABILITY_INFO                             = 3,
	SQUAD_STATUS_INFO                        = 4,
	SHORTCUT_INFO                            = 5,
	LOCAL_PLAYER_STATUS_INFO                 = 6,
	BUTTON_GUIDE                             = 7,
	BATTLE_COUNTER                           = 8,
	PLUS_ULTRA                               = 9,
	LvUp_ShortCut                            = 10,
	MISC_INFO                                = 11,
	MAX                                      = 12,
};

// Enum InGameModule.EScriptCommandFinishType
// NumValues: 0x0004
enum class EScriptCommandFinishType : uint8
{
	GOTONEXT                                 = 0,
	LOOP                                     = 1,
	STANDBY                                  = 2,
	MAX                                      = 3,
};

// Enum InGameModule.EWinDemoCommandFlags
// NumValues: 0x0004
enum class EWinDemoCommandFlags : uint8
{
	BB_NONE                                  = 0,
	BB_HoldingButton                         = 1,
	BB_Emote                                 = 2,
	BB_MAX                                   = 3,
};

// ScriptStruct InGameModule.TransformationData
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x10) FTransformationData final
{
public:
	bool                                          _bStocking;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _charaId;                                          // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerId;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x12D];                                      // 0x0003(0x012D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransformationData) == 0x000010, "Wrong alignment on FTransformationData");
static_assert(sizeof(FTransformationData) == 0x000130, "Wrong size on FTransformationData");
static_assert(offsetof(FTransformationData, _bStocking) == 0x000000, "Member 'FTransformationData::_bStocking' has a wrong offset!");
static_assert(offsetof(FTransformationData, _charaId) == 0x000001, "Member 'FTransformationData::_charaId' has a wrong offset!");
static_assert(offsetof(FTransformationData, _playerId) == 0x000002, "Member 'FTransformationData::_playerId' has a wrong offset!");

// ScriptStruct InGameModule.DamageParam
// 0x00A4 (0x00A4 - 0x0000)
struct FDamageParam final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _additionalSeconds;                                // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _enableRecoverSpan;                                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x6C];                                      // 0x0038(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageParam) == 0x000004, "Wrong alignment on FDamageParam");
static_assert(sizeof(FDamageParam) == 0x0000A4, "Wrong size on FDamageParam");
static_assert(offsetof(FDamageParam, _additionalSeconds) == 0x000030, "Member 'FDamageParam::_additionalSeconds' has a wrong offset!");
static_assert(offsetof(FDamageParam, _enableRecoverSpan) == 0x000034, "Member 'FDamageParam::_enableRecoverSpan' has a wrong offset!");

// ScriptStruct InGameModule.DamageLevelTable
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDamageLevelTable final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageLevelTable) == 0x000008, "Wrong alignment on FDamageLevelTable");
static_assert(sizeof(FDamageLevelTable) == 0x000018, "Wrong size on FDamageLevelTable");

// ScriptStruct InGameModule.CharacterDamageParamData
// 0x0028 (0x0028 - 0x0000)
struct FCharacterDamageParamData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageParam>                   _damageParamList;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDamageLevelTable>              _damageLevelList;                                  // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDamageParamData) == 0x000008, "Wrong alignment on FCharacterDamageParamData");
static_assert(sizeof(FCharacterDamageParamData) == 0x000028, "Wrong size on FCharacterDamageParamData");
static_assert(offsetof(FCharacterDamageParamData, _damageParamList) == 0x000008, "Member 'FCharacterDamageParamData::_damageParamList' has a wrong offset!");
static_assert(offsetof(FCharacterDamageParamData, _damageLevelList) == 0x000018, "Member 'FCharacterDamageParamData::_damageLevelList' has a wrong offset!");

// ScriptStruct InGameModule.LargeBoxInfo
// 0x0010 (0x0010 - 0x0000)
struct FLargeBoxInfo final
{
public:
	int32                                         _dropCount;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _distance;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _shiftAngle;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupplyDropDistance                           _dropDistanceType;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLargeBoxInfo) == 0x000004, "Wrong alignment on FLargeBoxInfo");
static_assert(sizeof(FLargeBoxInfo) == 0x000010, "Wrong size on FLargeBoxInfo");
static_assert(offsetof(FLargeBoxInfo, _dropCount) == 0x000000, "Member 'FLargeBoxInfo::_dropCount' has a wrong offset!");
static_assert(offsetof(FLargeBoxInfo, _distance) == 0x000004, "Member 'FLargeBoxInfo::_distance' has a wrong offset!");
static_assert(offsetof(FLargeBoxInfo, _shiftAngle) == 0x000008, "Member 'FLargeBoxInfo::_shiftAngle' has a wrong offset!");
static_assert(offsetof(FLargeBoxInfo, _dropDistanceType) == 0x00000C, "Member 'FLargeBoxInfo::_dropDistanceType' has a wrong offset!");

// ScriptStruct InGameModule.AbilityValue
// 0x000C (0x000C - 0x0000)
struct FAbilityValue final
{
public:
	float                                         _value;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _span;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _interval;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityValue) == 0x000004, "Wrong alignment on FAbilityValue");
static_assert(sizeof(FAbilityValue) == 0x00000C, "Wrong size on FAbilityValue");
static_assert(offsetof(FAbilityValue, _value) == 0x000000, "Member 'FAbilityValue::_value' has a wrong offset!");
static_assert(offsetof(FAbilityValue, _span) == 0x000004, "Member 'FAbilityValue::_span' has a wrong offset!");
static_assert(offsetof(FAbilityValue, _interval) == 0x000008, "Member 'FAbilityValue::_interval' has a wrong offset!");

// ScriptStruct InGameModule.TableRowAbilityValue
// 0x0018 (0x0020 - 0x0008)
struct FTableRowAbilityValue final : public FTableRowBase
{
public:
	EAbilityBonusCalculation                      _bonusCalc;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbilityValue>                  _data;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTableRowAbilityValue) == 0x000008, "Wrong alignment on FTableRowAbilityValue");
static_assert(sizeof(FTableRowAbilityValue) == 0x000020, "Wrong size on FTableRowAbilityValue");
static_assert(offsetof(FTableRowAbilityValue, _bonusCalc) == 0x000008, "Member 'FTableRowAbilityValue::_bonusCalc' has a wrong offset!");
static_assert(offsetof(FTableRowAbilityValue, _data) == 0x000010, "Member 'FTableRowAbilityValue::_data' has a wrong offset!");

// ScriptStruct InGameModule.Ch109SpecialGenRep
// 0x0010 (0x0010 - 0x0000)
struct FCh109SpecialGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  Locate;                                            // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh109SpecialGenRep) == 0x000004, "Wrong alignment on FCh109SpecialGenRep");
static_assert(sizeof(FCh109SpecialGenRep) == 0x000010, "Wrong size on FCh109SpecialGenRep");
static_assert(offsetof(FCh109SpecialGenRep, SerialID) == 0x000000, "Member 'FCh109SpecialGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCh109SpecialGenRep, Locate) == 0x000004, "Member 'FCh109SpecialGenRep::Locate' has a wrong offset!");

// ScriptStruct InGameModule.HeroHitCollisionInfo
// 0x0160 (0x0160 - 0x0000)
struct alignas(0x10) FHeroHitCollisionInfo final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroProjectileMovementComponent*       MovementComponent;                                 // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttackParam;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupName;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x58];                                      // 0x0090(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x28];                                      // 0x00F0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoreList;                                        // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _overrideOwner;                                    // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroHitCollisionInfo) == 0x000010, "Wrong alignment on FHeroHitCollisionInfo");
static_assert(sizeof(FHeroHitCollisionInfo) == 0x000160, "Wrong size on FHeroHitCollisionInfo");
static_assert(offsetof(FHeroHitCollisionInfo, Owner) == 0x000060, "Member 'FHeroHitCollisionInfo::Owner' has a wrong offset!");
static_assert(offsetof(FHeroHitCollisionInfo, MovementComponent) == 0x000068, "Member 'FHeroHitCollisionInfo::MovementComponent' has a wrong offset!");
static_assert(offsetof(FHeroHitCollisionInfo, AttackParam) == 0x000078, "Member 'FHeroHitCollisionInfo::AttackParam' has a wrong offset!");
static_assert(offsetof(FHeroHitCollisionInfo, SocketName) == 0x000080, "Member 'FHeroHitCollisionInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FHeroHitCollisionInfo, GroupName) == 0x000088, "Member 'FHeroHitCollisionInfo::GroupName' has a wrong offset!");
static_assert(offsetof(FHeroHitCollisionInfo, MeshComp) == 0x0000E8, "Member 'FHeroHitCollisionInfo::MeshComp' has a wrong offset!");
static_assert(offsetof(FHeroHitCollisionInfo, IgnoreList) == 0x000118, "Member 'FHeroHitCollisionInfo::IgnoreList' has a wrong offset!");
static_assert(offsetof(FHeroHitCollisionInfo, _overrideOwner) == 0x000150, "Member 'FHeroHitCollisionInfo::_overrideOwner' has a wrong offset!");

// ScriptStruct InGameModule.CustomBulletInterval
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FCustomBulletInterval final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomBulletInterval) == 0x000004, "Wrong alignment on FCustomBulletInterval");
static_assert(sizeof(FCustomBulletInterval) == 0x000010, "Wrong size on FCustomBulletInterval");

// ScriptStruct InGameModule.AvaterOverride
// 0x0028 (0x0028 - 0x0000)
struct FAvaterOverride final
{
public:
	class UMaterialInstance*                      _overrideMaterial;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _overrideMaterialIndex;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _parameterName;                                    // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _parameterColor;                                   // 0x0014(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvaterOverride) == 0x000008, "Wrong alignment on FAvaterOverride");
static_assert(sizeof(FAvaterOverride) == 0x000028, "Wrong size on FAvaterOverride");
static_assert(offsetof(FAvaterOverride, _overrideMaterial) == 0x000000, "Member 'FAvaterOverride::_overrideMaterial' has a wrong offset!");
static_assert(offsetof(FAvaterOverride, _overrideMaterialIndex) == 0x000008, "Member 'FAvaterOverride::_overrideMaterialIndex' has a wrong offset!");
static_assert(offsetof(FAvaterOverride, _parameterName) == 0x00000C, "Member 'FAvaterOverride::_parameterName' has a wrong offset!");
static_assert(offsetof(FAvaterOverride, _parameterColor) == 0x000014, "Member 'FAvaterOverride::_parameterColor' has a wrong offset!");

// ScriptStruct InGameModule.HitColInfo
// 0x0020 (0x0020 - 0x0000)
struct FHitColInfo final
{
public:
	class UPrimitiveComponent*                    PPrimitive;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitColInfo) == 0x000008, "Wrong alignment on FHitColInfo");
static_assert(sizeof(FHitColInfo) == 0x000020, "Wrong size on FHitColInfo");
static_assert(offsetof(FHitColInfo, PPrimitive) == 0x000000, "Member 'FHitColInfo::PPrimitive' has a wrong offset!");

// ScriptStruct InGameModule.AIInputCommand
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FAIInputCommand
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIInputCommand) == 0x000004, "Wrong alignment on FAIInputCommand");
static_assert(sizeof(FAIInputCommand) == 0x000018, "Wrong size on FAIInputCommand");

// ScriptStruct InGameModule.AIMoveCommand
// 0x0008 (0x0020 - 0x0018)
struct FAIMoveCommand final : public FAIInputCommand
{
public:
	EAIMoveType                                   _type;                                             // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _duration;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIMoveCommand) == 0x000004, "Wrong alignment on FAIMoveCommand");
static_assert(sizeof(FAIMoveCommand) == 0x000020, "Wrong size on FAIMoveCommand");
static_assert(offsetof(FAIMoveCommand, _type) == 0x000018, "Member 'FAIMoveCommand::_type' has a wrong offset!");
static_assert(offsetof(FAIMoveCommand, _duration) == 0x00001C, "Member 'FAIMoveCommand::_duration' has a wrong offset!");

// ScriptStruct InGameModule.CameraShakerParam
// 0x0060 (0x0060 - 0x0000)
struct FCameraShakerParam final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FROscillator                           RotOscillation;                                    // 0x000C(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVOscillator                           LocOscillation;                                    // 0x0030(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FFOscillator                           FOVOscillation;                                    // 0x0054(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraShakerParam) == 0x000004, "Wrong alignment on FCameraShakerParam");
static_assert(sizeof(FCameraShakerParam) == 0x000060, "Wrong size on FCameraShakerParam");
static_assert(offsetof(FCameraShakerParam, Duration) == 0x000000, "Member 'FCameraShakerParam::Duration' has a wrong offset!");
static_assert(offsetof(FCameraShakerParam, BlendInTime) == 0x000004, "Member 'FCameraShakerParam::BlendInTime' has a wrong offset!");
static_assert(offsetof(FCameraShakerParam, BlendOutTime) == 0x000008, "Member 'FCameraShakerParam::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FCameraShakerParam, RotOscillation) == 0x00000C, "Member 'FCameraShakerParam::RotOscillation' has a wrong offset!");
static_assert(offsetof(FCameraShakerParam, LocOscillation) == 0x000030, "Member 'FCameraShakerParam::LocOscillation' has a wrong offset!");
static_assert(offsetof(FCameraShakerParam, FOVOscillation) == 0x000054, "Member 'FCameraShakerParam::FOVOscillation' has a wrong offset!");

// ScriptStruct InGameModule.SpawnCh004Unique2Var01Data
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FSpawnCh004Unique2Var01Data final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnCh004Unique2Var01Data) == 0x000010, "Wrong alignment on FSpawnCh004Unique2Var01Data");
static_assert(sizeof(FSpawnCh004Unique2Var01Data) == 0x000050, "Wrong size on FSpawnCh004Unique2Var01Data");

// ScriptStruct InGameModule.TutorialCheckListButtonGuideData
// 0x0030 (0x0030 - 0x0000)
struct FTutorialCheckListButtonGuideData final
{
public:
	bool                                          _bFromCommand;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeyConfigurableCommand                       _command;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEditDirectly;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _directTextGamePad;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _directTextKeyboard;                               // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHoldCommand;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialCheckListButtonGuideData) == 0x000008, "Wrong alignment on FTutorialCheckListButtonGuideData");
static_assert(sizeof(FTutorialCheckListButtonGuideData) == 0x000030, "Wrong size on FTutorialCheckListButtonGuideData");
static_assert(offsetof(FTutorialCheckListButtonGuideData, _bFromCommand) == 0x000000, "Member 'FTutorialCheckListButtonGuideData::_bFromCommand' has a wrong offset!");
static_assert(offsetof(FTutorialCheckListButtonGuideData, _command) == 0x000001, "Member 'FTutorialCheckListButtonGuideData::_command' has a wrong offset!");
static_assert(offsetof(FTutorialCheckListButtonGuideData, _bEditDirectly) == 0x000002, "Member 'FTutorialCheckListButtonGuideData::_bEditDirectly' has a wrong offset!");
static_assert(offsetof(FTutorialCheckListButtonGuideData, _directTextGamePad) == 0x000008, "Member 'FTutorialCheckListButtonGuideData::_directTextGamePad' has a wrong offset!");
static_assert(offsetof(FTutorialCheckListButtonGuideData, _directTextKeyboard) == 0x000018, "Member 'FTutorialCheckListButtonGuideData::_directTextKeyboard' has a wrong offset!");
static_assert(offsetof(FTutorialCheckListButtonGuideData, _bHoldCommand) == 0x000028, "Member 'FTutorialCheckListButtonGuideData::_bHoldCommand' has a wrong offset!");

// ScriptStruct InGameModule.AttackPhaseDelayData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAttackPhaseDelayData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackPhaseDelayData) == 0x000008, "Wrong alignment on FAttackPhaseDelayData");
static_assert(sizeof(FAttackPhaseDelayData) == 0x000020, "Wrong size on FAttackPhaseDelayData");

// ScriptStruct InGameModule.PinnedActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FPinnedActorInfo final
{
public:
	EPinnedActorType                              _pinnedActorType;                                  // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        _netSupplyId;                                      // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _trapPlacerTeamId;                                 // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _pinnedActor;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPinnedActorInfo) == 0x000008, "Wrong alignment on FPinnedActorInfo");
static_assert(sizeof(FPinnedActorInfo) == 0x000010, "Wrong size on FPinnedActorInfo");
static_assert(offsetof(FPinnedActorInfo, _pinnedActorType) == 0x000000, "Member 'FPinnedActorInfo::_pinnedActorType' has a wrong offset!");
static_assert(offsetof(FPinnedActorInfo, _netSupplyId) == 0x000002, "Member 'FPinnedActorInfo::_netSupplyId' has a wrong offset!");
static_assert(offsetof(FPinnedActorInfo, _trapPlacerTeamId) == 0x000004, "Member 'FPinnedActorInfo::_trapPlacerTeamId' has a wrong offset!");
static_assert(offsetof(FPinnedActorInfo, _pinnedActor) == 0x000008, "Member 'FPinnedActorInfo::_pinnedActor' has a wrong offset!");

// ScriptStruct InGameModule.PinInfo
// 0x0030 (0x0030 - 0x0000)
struct FPinInfo final
{
public:
	struct FVector_NetQuantize                    _pinLocation;                                      // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarkerType                                   _pinId;                                            // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _bIsAlert : 1;                                     // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bPlaceFromMap : 1;                                // 0x000D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _senderPlayerId;                                   // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _senderCharacterId;                                // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _pinPlaceTime;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPinnedActorInfo                       _pinnedActorInfo;                                  // 0x0018(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         _pinGuid;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPinInfo) == 0x000008, "Wrong alignment on FPinInfo");
static_assert(sizeof(FPinInfo) == 0x000030, "Wrong size on FPinInfo");
static_assert(offsetof(FPinInfo, _pinLocation) == 0x000000, "Member 'FPinInfo::_pinLocation' has a wrong offset!");
static_assert(offsetof(FPinInfo, _pinId) == 0x00000C, "Member 'FPinInfo::_pinId' has a wrong offset!");
static_assert(offsetof(FPinInfo, _senderPlayerId) == 0x00000E, "Member 'FPinInfo::_senderPlayerId' has a wrong offset!");
static_assert(offsetof(FPinInfo, _senderCharacterId) == 0x00000F, "Member 'FPinInfo::_senderCharacterId' has a wrong offset!");
static_assert(offsetof(FPinInfo, _pinPlaceTime) == 0x000010, "Member 'FPinInfo::_pinPlaceTime' has a wrong offset!");
static_assert(offsetof(FPinInfo, _pinnedActorInfo) == 0x000018, "Member 'FPinInfo::_pinnedActorInfo' has a wrong offset!");
static_assert(offsetof(FPinInfo, _pinGuid) == 0x000028, "Member 'FPinInfo::_pinGuid' has a wrong offset!");

// ScriptStruct InGameModule.DamageInfo
// 0x0080 (0x0080 - 0x0000)
struct FDamageInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _instigatedCharacter;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 _damageCauser;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _location;                                         // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x38];                                      // 0x0034(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	EDamageDirection                              _hitDirectionFLBR;                                 // 0x006C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageDirection                              _hitDirectionFB;                                   // 0x006D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageDirection                              _hitDirectionFUD;                                  // 0x006E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageFaceDirection                          _faceDirection;                                    // 0x006F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageInfo) == 0x000008, "Wrong alignment on FDamageInfo");
static_assert(sizeof(FDamageInfo) == 0x000080, "Wrong size on FDamageInfo");
static_assert(offsetof(FDamageInfo, _instigatedCharacter) == 0x000008, "Member 'FDamageInfo::_instigatedCharacter' has a wrong offset!");
static_assert(offsetof(FDamageInfo, _damageCauser) == 0x000010, "Member 'FDamageInfo::_damageCauser' has a wrong offset!");
static_assert(offsetof(FDamageInfo, _location) == 0x000028, "Member 'FDamageInfo::_location' has a wrong offset!");
static_assert(offsetof(FDamageInfo, _hitDirectionFLBR) == 0x00006C, "Member 'FDamageInfo::_hitDirectionFLBR' has a wrong offset!");
static_assert(offsetof(FDamageInfo, _hitDirectionFB) == 0x00006D, "Member 'FDamageInfo::_hitDirectionFB' has a wrong offset!");
static_assert(offsetof(FDamageInfo, _hitDirectionFUD) == 0x00006E, "Member 'FDamageInfo::_hitDirectionFUD' has a wrong offset!");
static_assert(offsetof(FDamageInfo, _faceDirection) == 0x00006F, "Member 'FDamageInfo::_faceDirection' has a wrong offset!");

// ScriptStruct InGameModule.ReserveDeActiveParticleInfo
// 0x0004 (0x0004 - 0x0000)
struct FReserveDeActiveParticleInfo final
{
public:
	float                                         _activeTimeSeconds;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReserveDeActiveParticleInfo) == 0x000004, "Wrong alignment on FReserveDeActiveParticleInfo");
static_assert(sizeof(FReserveDeActiveParticleInfo) == 0x000004, "Wrong size on FReserveDeActiveParticleInfo");
static_assert(offsetof(FReserveDeActiveParticleInfo, _activeTimeSeconds) == 0x000000, "Member 'FReserveDeActiveParticleInfo::_activeTimeSeconds' has a wrong offset!");

// ScriptStruct InGameModule.Ch010Unique2PutParts
// 0x0018 (0x0018 - 0x0000)
struct FCh010Unique2PutParts final
{
public:
	class UCustomParticleSystemComponent*         PParticle;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh010Unique2PutParts) == 0x000008, "Wrong alignment on FCh010Unique2PutParts");
static_assert(sizeof(FCh010Unique2PutParts) == 0x000018, "Wrong size on FCh010Unique2PutParts");
static_assert(offsetof(FCh010Unique2PutParts, PParticle) == 0x000000, "Member 'FCh010Unique2PutParts::PParticle' has a wrong offset!");

// ScriptStruct InGameModule.CustomBulletChildInfo
// 0x0018 (0x0018 - 0x0000)
struct FCustomBulletChildInfo final
{
public:
	class FName                                   _generatorName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bLinkingOnHitGround;                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bLinkingOnHitCharacter;                           // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bLinkingOnLifeOver;                               // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOnInterval;                                      // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _IntervalTimer;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _minLevel;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxLevel;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomBulletChildInfo) == 0x000004, "Wrong alignment on FCustomBulletChildInfo");
static_assert(sizeof(FCustomBulletChildInfo) == 0x000018, "Wrong size on FCustomBulletChildInfo");
static_assert(offsetof(FCustomBulletChildInfo, _generatorName) == 0x000000, "Member 'FCustomBulletChildInfo::_generatorName' has a wrong offset!");
static_assert(offsetof(FCustomBulletChildInfo, _bLinkingOnHitGround) == 0x000008, "Member 'FCustomBulletChildInfo::_bLinkingOnHitGround' has a wrong offset!");
static_assert(offsetof(FCustomBulletChildInfo, _bLinkingOnHitCharacter) == 0x000009, "Member 'FCustomBulletChildInfo::_bLinkingOnHitCharacter' has a wrong offset!");
static_assert(offsetof(FCustomBulletChildInfo, _bLinkingOnLifeOver) == 0x00000A, "Member 'FCustomBulletChildInfo::_bLinkingOnLifeOver' has a wrong offset!");
static_assert(offsetof(FCustomBulletChildInfo, _bOnInterval) == 0x00000B, "Member 'FCustomBulletChildInfo::_bOnInterval' has a wrong offset!");
static_assert(offsetof(FCustomBulletChildInfo, _IntervalTimer) == 0x00000C, "Member 'FCustomBulletChildInfo::_IntervalTimer' has a wrong offset!");
static_assert(offsetof(FCustomBulletChildInfo, _minLevel) == 0x000010, "Member 'FCustomBulletChildInfo::_minLevel' has a wrong offset!");
static_assert(offsetof(FCustomBulletChildInfo, _maxLevel) == 0x000014, "Member 'FCustomBulletChildInfo::_maxLevel' has a wrong offset!");

// ScriptStruct InGameModule.BulletCameraShakeInfo
// 0x0070 (0x0070 - 0x0000)
struct FBulletCameraShakeInfo final
{
public:
	float                                         _shakeDistance;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _shakeAttenuateDistance;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _shakeScaleMax;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _shakeScaleMin;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraShakerParam                     _shakeParam;                                       // 0x0010(0x0060)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletCameraShakeInfo) == 0x000004, "Wrong alignment on FBulletCameraShakeInfo");
static_assert(sizeof(FBulletCameraShakeInfo) == 0x000070, "Wrong size on FBulletCameraShakeInfo");
static_assert(offsetof(FBulletCameraShakeInfo, _shakeDistance) == 0x000000, "Member 'FBulletCameraShakeInfo::_shakeDistance' has a wrong offset!");
static_assert(offsetof(FBulletCameraShakeInfo, _shakeAttenuateDistance) == 0x000004, "Member 'FBulletCameraShakeInfo::_shakeAttenuateDistance' has a wrong offset!");
static_assert(offsetof(FBulletCameraShakeInfo, _shakeScaleMax) == 0x000008, "Member 'FBulletCameraShakeInfo::_shakeScaleMax' has a wrong offset!");
static_assert(offsetof(FBulletCameraShakeInfo, _shakeScaleMin) == 0x00000C, "Member 'FBulletCameraShakeInfo::_shakeScaleMin' has a wrong offset!");
static_assert(offsetof(FBulletCameraShakeInfo, _shakeParam) == 0x000010, "Member 'FBulletCameraShakeInfo::_shakeParam' has a wrong offset!");

// ScriptStruct InGameModule.GraduallyAlphaPreset
// 0x0018 (0x0018 - 0x0000)
struct FGraduallyAlphaPreset final
{
public:
	EGraduallyAlphaType                           _preset;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _presetStr;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGraduallyAlphaPreset) == 0x000008, "Wrong alignment on FGraduallyAlphaPreset");
static_assert(sizeof(FGraduallyAlphaPreset) == 0x000018, "Wrong size on FGraduallyAlphaPreset");
static_assert(offsetof(FGraduallyAlphaPreset, _preset) == 0x000000, "Member 'FGraduallyAlphaPreset::_preset' has a wrong offset!");
static_assert(offsetof(FGraduallyAlphaPreset, _presetStr) == 0x000008, "Member 'FGraduallyAlphaPreset::_presetStr' has a wrong offset!");

// ScriptStruct InGameModule.GraduallyAlpha
// 0x0040 (0x0040 - 0x0000)
struct FGraduallyAlpha final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlphaPreset                  Preset;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         beginDist;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDist;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAlpha;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManager*                   _playerCameraManager;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGraduallyAlpha) == 0x000008, "Wrong alignment on FGraduallyAlpha");
static_assert(sizeof(FGraduallyAlpha) == 0x000040, "Wrong size on FGraduallyAlpha");
static_assert(offsetof(FGraduallyAlpha, bActive) == 0x000000, "Member 'FGraduallyAlpha::bActive' has a wrong offset!");
static_assert(offsetof(FGraduallyAlpha, Preset) == 0x000008, "Member 'FGraduallyAlpha::Preset' has a wrong offset!");
static_assert(offsetof(FGraduallyAlpha, beginDist) == 0x000020, "Member 'FGraduallyAlpha::beginDist' has a wrong offset!");
static_assert(offsetof(FGraduallyAlpha, EndDist) == 0x000024, "Member 'FGraduallyAlpha::EndDist' has a wrong offset!");
static_assert(offsetof(FGraduallyAlpha, EndAlpha) == 0x000028, "Member 'FGraduallyAlpha::EndAlpha' has a wrong offset!");
static_assert(offsetof(FGraduallyAlpha, ParameterName) == 0x00002C, "Member 'FGraduallyAlpha::ParameterName' has a wrong offset!");
static_assert(offsetof(FGraduallyAlpha, _playerCameraManager) == 0x000038, "Member 'FGraduallyAlpha::_playerCameraManager' has a wrong offset!");

// ScriptStruct InGameModule.PropDestructTmp
// 0x0020 (0x0020 - 0x0000)
struct FPropDestructTmp final
{
public:
	class UParticleSystem*                        _destructEffect;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _scale;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNamedEmitterMaterial>          _namedMaterialSlots;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropDestructTmp) == 0x000008, "Wrong alignment on FPropDestructTmp");
static_assert(sizeof(FPropDestructTmp) == 0x000020, "Wrong size on FPropDestructTmp");
static_assert(offsetof(FPropDestructTmp, _destructEffect) == 0x000000, "Member 'FPropDestructTmp::_destructEffect' has a wrong offset!");
static_assert(offsetof(FPropDestructTmp, _scale) == 0x000008, "Member 'FPropDestructTmp::_scale' has a wrong offset!");
static_assert(offsetof(FPropDestructTmp, _namedMaterialSlots) == 0x000010, "Member 'FPropDestructTmp::_namedMaterialSlots' has a wrong offset!");

// ScriptStruct InGameModule.SpawnCh004Unique1GroundVar01Data
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FSpawnCh004Unique1GroundVar01Data final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnCh004Unique1GroundVar01Data) == 0x000010, "Wrong alignment on FSpawnCh004Unique1GroundVar01Data");
static_assert(sizeof(FSpawnCh004Unique1GroundVar01Data) == 0x000050, "Wrong size on FSpawnCh004Unique1GroundVar01Data");

// ScriptStruct InGameModule.DurableBulletInfo
// 0x0030 (0x0030 - 0x0000)
struct FDurableBulletInfo final
{
public:
	class FName                                   _changeParticleName;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _declineHpEffect;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _declineHpRate;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomParticleSystemComponent*         _pchangeParticle;                                  // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomParticleSystemComponent*         _pchangeAfterParticle;                             // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDurableBulletInfo) == 0x000008, "Wrong alignment on FDurableBulletInfo");
static_assert(sizeof(FDurableBulletInfo) == 0x000030, "Wrong size on FDurableBulletInfo");
static_assert(offsetof(FDurableBulletInfo, _changeParticleName) == 0x000000, "Member 'FDurableBulletInfo::_changeParticleName' has a wrong offset!");
static_assert(offsetof(FDurableBulletInfo, _declineHpEffect) == 0x000008, "Member 'FDurableBulletInfo::_declineHpEffect' has a wrong offset!");
static_assert(offsetof(FDurableBulletInfo, _declineHpRate) == 0x000010, "Member 'FDurableBulletInfo::_declineHpRate' has a wrong offset!");
static_assert(offsetof(FDurableBulletInfo, _pchangeParticle) == 0x000018, "Member 'FDurableBulletInfo::_pchangeParticle' has a wrong offset!");
static_assert(offsetof(FDurableBulletInfo, _pchangeAfterParticle) == 0x000020, "Member 'FDurableBulletInfo::_pchangeAfterParticle' has a wrong offset!");

// ScriptStruct InGameModule.Ch004Unique3TransformRep
// 0x002C (0x002C - 0x0000)
struct FCh004Unique3TransformRep final
{
public:
	struct FVector_NetQuantize100                 Location;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Velocity;                                          // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Idx;                                               // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 ReflectionLossData;                                // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectionSpeedLimit;                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh004Unique3TransformRep) == 0x000004, "Wrong alignment on FCh004Unique3TransformRep");
static_assert(sizeof(FCh004Unique3TransformRep) == 0x00002C, "Wrong size on FCh004Unique3TransformRep");
static_assert(offsetof(FCh004Unique3TransformRep, Location) == 0x000000, "Member 'FCh004Unique3TransformRep::Location' has a wrong offset!");
static_assert(offsetof(FCh004Unique3TransformRep, Velocity) == 0x00000C, "Member 'FCh004Unique3TransformRep::Velocity' has a wrong offset!");
static_assert(offsetof(FCh004Unique3TransformRep, Idx) == 0x000018, "Member 'FCh004Unique3TransformRep::Idx' has a wrong offset!");
static_assert(offsetof(FCh004Unique3TransformRep, ReflectionLossData) == 0x00001C, "Member 'FCh004Unique3TransformRep::ReflectionLossData' has a wrong offset!");
static_assert(offsetof(FCh004Unique3TransformRep, ReflectionSpeedLimit) == 0x000028, "Member 'FCh004Unique3TransformRep::ReflectionSpeedLimit' has a wrong offset!");

// ScriptStruct InGameModule.BriefingPinUpInfoBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FBriefingPinUpInfoBase
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBriefingPinUpInfoBase) == 0x000004, "Wrong alignment on FBriefingPinUpInfoBase");
static_assert(sizeof(FBriefingPinUpInfoBase) == 0x000010, "Wrong size on FBriefingPinUpInfoBase");

// ScriptStruct InGameModule.BriefingPinUpInfo
// 0x0018 (0x0028 - 0x0010)
struct FBriefingPinUpInfo final : public FBriefingPinUpInfoBase
{
public:
	class UBattleBriefingPinWidget*               _pin;                                              // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBriefingPinUpInfo) == 0x000008, "Wrong alignment on FBriefingPinUpInfo");
static_assert(sizeof(FBriefingPinUpInfo) == 0x000028, "Wrong size on FBriefingPinUpInfo");
static_assert(offsetof(FBriefingPinUpInfo, _pin) == 0x000010, "Member 'FBriefingPinUpInfo::_pin' has a wrong offset!");

// ScriptStruct InGameModule.BriefingOtherPinInfo
// 0x0030 (0x0030 - 0x0000)
struct FBriefingOtherPinInfo final
{
public:
	struct FBriefingPinUpInfo                     _pin;                                              // 0x0000(0x0028)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class APlayerStateBattle*                     _playerState;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBriefingOtherPinInfo) == 0x000008, "Wrong alignment on FBriefingOtherPinInfo");
static_assert(sizeof(FBriefingOtherPinInfo) == 0x000030, "Wrong size on FBriefingOtherPinInfo");
static_assert(offsetof(FBriefingOtherPinInfo, _pin) == 0x000000, "Member 'FBriefingOtherPinInfo::_pin' has a wrong offset!");
static_assert(offsetof(FBriefingOtherPinInfo, _playerState) == 0x000028, "Member 'FBriefingOtherPinInfo::_playerState' has a wrong offset!");

// ScriptStruct InGameModule.BriefingOtherPinsInfo
// 0x0050 (0x0050 - 0x0000)
struct FBriefingOtherPinsInfo final
{
public:
	TMap<uint8, struct FBriefingOtherPinInfo>     _pinList;                                          // 0x0000(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBriefingOtherPinsInfo) == 0x000008, "Wrong alignment on FBriefingOtherPinsInfo");
static_assert(sizeof(FBriefingOtherPinsInfo) == 0x000050, "Wrong size on FBriefingOtherPinsInfo");
static_assert(offsetof(FBriefingOtherPinsInfo, _pinList) == 0x000000, "Member 'FBriefingOtherPinsInfo::_pinList' has a wrong offset!");

// ScriptStruct InGameModule.BattleEventEffectInfo
// 0x0100 (0x0100 - 0x0000)
struct FBattleEventEffectInfo final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewType                                     _viewType;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _template;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          _applyOwnerRot;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ApplyOwnerScale;                                  // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSE                              _playSE;                                           // 0x0058(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          _playHorizontal;                                   // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _castShadow;                                       // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _renderCustomDepth;                                // 0x007A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _renderCustomDepthValue;                           // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0080(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAvaterOverride                        _avaterOverride;                                   // 0x00C0(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UBattleCustomParticleSystemComponent*   _psc;                                              // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtomComponent*                         _SEComp;                                           // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleEventEffectInfo) == 0x000010, "Wrong alignment on FBattleEventEffectInfo");
static_assert(sizeof(FBattleEventEffectInfo) == 0x000100, "Wrong size on FBattleEventEffectInfo");
static_assert(offsetof(FBattleEventEffectInfo, Tag) == 0x000000, "Member 'FBattleEventEffectInfo::Tag' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _viewType) == 0x000008, "Member 'FBattleEventEffectInfo::_viewType' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _template) == 0x000010, "Member 'FBattleEventEffectInfo::_template' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, OffsetTransform) == 0x000020, "Member 'FBattleEventEffectInfo::OffsetTransform' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _applyOwnerRot) == 0x000050, "Member 'FBattleEventEffectInfo::_applyOwnerRot' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _ApplyOwnerScale) == 0x000051, "Member 'FBattleEventEffectInfo::_ApplyOwnerScale' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _playSE) == 0x000058, "Member 'FBattleEventEffectInfo::_playSE' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _playHorizontal) == 0x000078, "Member 'FBattleEventEffectInfo::_playHorizontal' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _castShadow) == 0x000079, "Member 'FBattleEventEffectInfo::_castShadow' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _renderCustomDepth) == 0x00007A, "Member 'FBattleEventEffectInfo::_renderCustomDepth' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _renderCustomDepthValue) == 0x00007C, "Member 'FBattleEventEffectInfo::_renderCustomDepthValue' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _graduallyAlpha) == 0x000080, "Member 'FBattleEventEffectInfo::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _avaterOverride) == 0x0000C0, "Member 'FBattleEventEffectInfo::_avaterOverride' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _psc) == 0x0000E8, "Member 'FBattleEventEffectInfo::_psc' has a wrong offset!");
static_assert(offsetof(FBattleEventEffectInfo, _SEComp) == 0x0000F0, "Member 'FBattleEventEffectInfo::_SEComp' has a wrong offset!");

// ScriptStruct InGameModule.Ch109SpecialSoundInfo
// 0x0028 (0x0028 - 0x0000)
struct FCh109SpecialSoundInfo final
{
public:
	struct FBulletSE                              _sound;                                            // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         _playNum;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _playinterval;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh109SpecialSoundInfo) == 0x000008, "Wrong alignment on FCh109SpecialSoundInfo");
static_assert(sizeof(FCh109SpecialSoundInfo) == 0x000028, "Wrong size on FCh109SpecialSoundInfo");
static_assert(offsetof(FCh109SpecialSoundInfo, _sound) == 0x000000, "Member 'FCh109SpecialSoundInfo::_sound' has a wrong offset!");
static_assert(offsetof(FCh109SpecialSoundInfo, _playNum) == 0x000020, "Member 'FCh109SpecialSoundInfo::_playNum' has a wrong offset!");
static_assert(offsetof(FCh109SpecialSoundInfo, _playinterval) == 0x000024, "Member 'FCh109SpecialSoundInfo::_playinterval' has a wrong offset!");

// ScriptStruct InGameModule.AttackParam
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FAttackParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackParam) == 0x000004, "Wrong alignment on FAttackParam");
static_assert(sizeof(FAttackParam) == 0x000008, "Wrong size on FAttackParam");

// ScriptStruct InGameModule.CharacterAttackParamData
// 0x0018 (0x0018 - 0x0000)
struct FCharacterAttackParamData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttackParam>                   _AttackParamList;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAttackParamData) == 0x000008, "Wrong alignment on FCharacterAttackParamData");
static_assert(sizeof(FCharacterAttackParamData) == 0x000018, "Wrong size on FCharacterAttackParamData");
static_assert(offsetof(FCharacterAttackParamData, _AttackParamList) == 0x000008, "Member 'FCharacterAttackParamData::_AttackParamList' has a wrong offset!");

// ScriptStruct InGameModule.ActionPingDelayData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FActionPingDelayData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionPingDelayData) == 0x000008, "Wrong alignment on FActionPingDelayData");
static_assert(sizeof(FActionPingDelayData) == 0x000028, "Wrong size on FActionPingDelayData");

// ScriptStruct InGameModule.PropDamageParam
// 0x0038 (0x0038 - 0x0000)
struct FPropDamageParam final
{
public:
	class USceneComponent*                        _damagedComponent;                                 // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _instance;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _damageValue;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _hitLocation;                                      // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _hitDirection;                                     // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterConditionId                         _damageElementTemp;                                // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageAttribute                              _damageElement;                                    // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdKey                        _netId;                                            // 0x002C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPropDamageParam) == 0x000008, "Wrong alignment on FPropDamageParam");
static_assert(sizeof(FPropDamageParam) == 0x000038, "Wrong size on FPropDamageParam");
static_assert(offsetof(FPropDamageParam, _damagedComponent) == 0x000000, "Member 'FPropDamageParam::_damagedComponent' has a wrong offset!");
static_assert(offsetof(FPropDamageParam, _instance) == 0x000008, "Member 'FPropDamageParam::_instance' has a wrong offset!");
static_assert(offsetof(FPropDamageParam, _damageValue) == 0x00000C, "Member 'FPropDamageParam::_damageValue' has a wrong offset!");
static_assert(offsetof(FPropDamageParam, _hitLocation) == 0x000010, "Member 'FPropDamageParam::_hitLocation' has a wrong offset!");
static_assert(offsetof(FPropDamageParam, _hitDirection) == 0x00001C, "Member 'FPropDamageParam::_hitDirection' has a wrong offset!");
static_assert(offsetof(FPropDamageParam, _damageElementTemp) == 0x000028, "Member 'FPropDamageParam::_damageElementTemp' has a wrong offset!");
static_assert(offsetof(FPropDamageParam, _damageElement) == 0x000029, "Member 'FPropDamageParam::_damageElement' has a wrong offset!");
static_assert(offsetof(FPropDamageParam, _netId) == 0x00002C, "Member 'FPropDamageParam::_netId' has a wrong offset!");

// ScriptStruct InGameModule.OrbSpawnPointTableRow
// 0x0010 (0x0018 - 0x0008)
struct FOrbSpawnPointTableRow final : public FTableRowBase
{
public:
	struct FVector                                _position;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrbSpawnPointTableRow) == 0x000008, "Wrong alignment on FOrbSpawnPointTableRow");
static_assert(sizeof(FOrbSpawnPointTableRow) == 0x000018, "Wrong size on FOrbSpawnPointTableRow");
static_assert(offsetof(FOrbSpawnPointTableRow, _position) == 0x000008, "Member 'FOrbSpawnPointTableRow::_position' has a wrong offset!");

// ScriptStruct InGameModule.PropVfxMaterial
// 0x0018 (0x0018 - 0x0000)
struct FPropVfxMaterial final
{
public:
	class FName                                   _slotName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     _material;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               _mid;                                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropVfxMaterial) == 0x000008, "Wrong alignment on FPropVfxMaterial");
static_assert(sizeof(FPropVfxMaterial) == 0x000018, "Wrong size on FPropVfxMaterial");
static_assert(offsetof(FPropVfxMaterial, _slotName) == 0x000000, "Member 'FPropVfxMaterial::_slotName' has a wrong offset!");
static_assert(offsetof(FPropVfxMaterial, _material) == 0x000008, "Member 'FPropVfxMaterial::_material' has a wrong offset!");
static_assert(offsetof(FPropVfxMaterial, _mid) == 0x000010, "Member 'FPropVfxMaterial::_mid' has a wrong offset!");

// ScriptStruct InGameModule.AttackTargetSetting
// 0x0010 (0x0010 - 0x0000)
struct FAttackTargetSetting final
{
public:
	float                                         _distance;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bIgnoreObstacle;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _orLessHealthRate;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackTeamType                               _orLessHealthTeam;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackTargetSetting) == 0x000004, "Wrong alignment on FAttackTargetSetting");
static_assert(sizeof(FAttackTargetSetting) == 0x000010, "Wrong size on FAttackTargetSetting");
static_assert(offsetof(FAttackTargetSetting, _distance) == 0x000000, "Member 'FAttackTargetSetting::_distance' has a wrong offset!");
static_assert(offsetof(FAttackTargetSetting, _bIgnoreObstacle) == 0x000004, "Member 'FAttackTargetSetting::_bIgnoreObstacle' has a wrong offset!");
static_assert(offsetof(FAttackTargetSetting, _orLessHealthRate) == 0x000008, "Member 'FAttackTargetSetting::_orLessHealthRate' has a wrong offset!");
static_assert(offsetof(FAttackTargetSetting, _orLessHealthTeam) == 0x00000C, "Member 'FAttackTargetSetting::_orLessHealthTeam' has a wrong offset!");

// ScriptStruct InGameModule.ChargeAttackEffect
// 0x0030 (0x0030 - 0x0000)
struct FChargeAttackEffect final
{
public:
	class UParticleSystem*                        _particleSystem;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _attachSocket;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _scaleTransition;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _translation;                                      // 0x0014(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotation;                                         // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttackVisualLevel                            _visualLevel;                                      // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChargeAttackEffect) == 0x000008, "Wrong alignment on FChargeAttackEffect");
static_assert(sizeof(FChargeAttackEffect) == 0x000030, "Wrong size on FChargeAttackEffect");
static_assert(offsetof(FChargeAttackEffect, _particleSystem) == 0x000000, "Member 'FChargeAttackEffect::_particleSystem' has a wrong offset!");
static_assert(offsetof(FChargeAttackEffect, _attachSocket) == 0x000008, "Member 'FChargeAttackEffect::_attachSocket' has a wrong offset!");
static_assert(offsetof(FChargeAttackEffect, _scaleTransition) == 0x000010, "Member 'FChargeAttackEffect::_scaleTransition' has a wrong offset!");
static_assert(offsetof(FChargeAttackEffect, _translation) == 0x000014, "Member 'FChargeAttackEffect::_translation' has a wrong offset!");
static_assert(offsetof(FChargeAttackEffect, _rotation) == 0x000020, "Member 'FChargeAttackEffect::_rotation' has a wrong offset!");
static_assert(offsetof(FChargeAttackEffect, _visualLevel) == 0x00002C, "Member 'FChargeAttackEffect::_visualLevel' has a wrong offset!");

// ScriptStruct InGameModule.ActionAttackProperty
// 0x0014 (0x0014 - 0x0000)
struct FActionAttackProperty final
{
public:
	float                                         _rangeAngleDegreeForNagara;                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _rangeAngleDegreeForNagaraDash;                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackProcessType                            _attackProcessType;                                // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackAngleRangeOutType                      _attacklAngleRangeOutType;                         // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _rangeAngleTurnSpan;                               // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _cantAttackTimer;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionAttackProperty) == 0x000004, "Wrong alignment on FActionAttackProperty");
static_assert(sizeof(FActionAttackProperty) == 0x000014, "Wrong size on FActionAttackProperty");
static_assert(offsetof(FActionAttackProperty, _rangeAngleDegreeForNagara) == 0x000000, "Member 'FActionAttackProperty::_rangeAngleDegreeForNagara' has a wrong offset!");
static_assert(offsetof(FActionAttackProperty, _rangeAngleDegreeForNagaraDash) == 0x000004, "Member 'FActionAttackProperty::_rangeAngleDegreeForNagaraDash' has a wrong offset!");
static_assert(offsetof(FActionAttackProperty, _attackProcessType) == 0x000008, "Member 'FActionAttackProperty::_attackProcessType' has a wrong offset!");
static_assert(offsetof(FActionAttackProperty, _attacklAngleRangeOutType) == 0x000009, "Member 'FActionAttackProperty::_attacklAngleRangeOutType' has a wrong offset!");
static_assert(offsetof(FActionAttackProperty, _rangeAngleTurnSpan) == 0x00000C, "Member 'FActionAttackProperty::_rangeAngleTurnSpan' has a wrong offset!");
static_assert(offsetof(FActionAttackProperty, _cantAttackTimer) == 0x000010, "Member 'FActionAttackProperty::_cantAttackTimer' has a wrong offset!");

// ScriptStruct InGameModule.ProgressDelayData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FProgressDelayData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProgressDelayData) == 0x000008, "Wrong alignment on FProgressDelayData");
static_assert(sizeof(FProgressDelayData) == 0x000028, "Wrong size on FProgressDelayData");

// ScriptStruct InGameModule.NegotiationDelayData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FNegotiationDelayData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNegotiationDelayData) == 0x000008, "Wrong alignment on FNegotiationDelayData");
static_assert(sizeof(FNegotiationDelayData) == 0x000020, "Wrong size on FNegotiationDelayData");

// ScriptStruct InGameModule.CommandDelayData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCommandDelayData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandDelayData) == 0x000008, "Wrong alignment on FCommandDelayData");
static_assert(sizeof(FCommandDelayData) == 0x000020, "Wrong size on FCommandDelayData");

// ScriptStruct InGameModule.AnimEndDelayData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAnimEndDelayData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimEndDelayData) == 0x000008, "Wrong alignment on FAnimEndDelayData");
static_assert(sizeof(FAnimEndDelayData) == 0x000020, "Wrong size on FAnimEndDelayData");

// ScriptStruct InGameModule.AISkillParam
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FAISkillParam final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISkillParam) == 0x000008, "Wrong alignment on FAISkillParam");
static_assert(sizeof(FAISkillParam) == 0x000058, "Wrong size on FAISkillParam");

// ScriptStruct InGameModule.AIAcceptRange
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FAIAcceptRange final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAcceptRange) == 0x000004, "Wrong alignment on FAIAcceptRange");
static_assert(sizeof(FAIAcceptRange) == 0x000018, "Wrong size on FAIAcceptRange");

// ScriptStruct InGameModule.AITimeRange
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FAITimeRange final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITimeRange) == 0x000004, "Wrong alignment on FAITimeRange");
static_assert(sizeof(FAITimeRange) == 0x000008, "Wrong size on FAITimeRange");

// ScriptStruct InGameModule.AISkillCommand
// 0x0014 (0x002C - 0x0018)
struct FAISkillCommand final : public FAIInputCommand
{
public:
	EAISkillType                                  _type;                                             // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _duration;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0xC];                                       // 0x0020(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISkillCommand) == 0x000004, "Wrong alignment on FAISkillCommand");
static_assert(sizeof(FAISkillCommand) == 0x00002C, "Wrong size on FAISkillCommand");
static_assert(offsetof(FAISkillCommand, _type) == 0x000018, "Member 'FAISkillCommand::_type' has a wrong offset!");
static_assert(offsetof(FAISkillCommand, _duration) == 0x00001C, "Member 'FAISkillCommand::_duration' has a wrong offset!");

// ScriptStruct InGameModule.PlayEffectOffset
// 0x0040 (0x0040 - 0x0000)
struct FPlayEffectOffset final
{
public:
	struct FTransform                             _transform;                                        // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   _socketName;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayEffectOffset) == 0x000010, "Wrong alignment on FPlayEffectOffset");
static_assert(sizeof(FPlayEffectOffset) == 0x000040, "Wrong size on FPlayEffectOffset");
static_assert(offsetof(FPlayEffectOffset, _transform) == 0x000000, "Member 'FPlayEffectOffset::_transform' has a wrong offset!");
static_assert(offsetof(FPlayEffectOffset, _socketName) == 0x000030, "Member 'FPlayEffectOffset::_socketName' has a wrong offset!");

// ScriptStruct InGameModule.BulletAttachmentParam
// 0x0020 (0x0020 - 0x0000)
struct FBulletAttachmentParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABullet*                                Self;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroProjectileMovementComponent*       Pmc;                                               // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletAttachmentParam) == 0x000008, "Wrong alignment on FBulletAttachmentParam");
static_assert(sizeof(FBulletAttachmentParam) == 0x000020, "Wrong size on FBulletAttachmentParam");
static_assert(offsetof(FBulletAttachmentParam, Self) == 0x000008, "Member 'FBulletAttachmentParam::Self' has a wrong offset!");
static_assert(offsetof(FBulletAttachmentParam, Pmc) == 0x000010, "Member 'FBulletAttachmentParam::Pmc' has a wrong offset!");

// ScriptStruct InGameModule.PropDestructMaterial
// 0x0010 (0x0010 - 0x0000)
struct FPropDestructMaterial final
{
public:
	class FName                                   _slotName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     _material;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropDestructMaterial) == 0x000008, "Wrong alignment on FPropDestructMaterial");
static_assert(sizeof(FPropDestructMaterial) == 0x000010, "Wrong size on FPropDestructMaterial");
static_assert(offsetof(FPropDestructMaterial, _slotName) == 0x000000, "Member 'FPropDestructMaterial::_slotName' has a wrong offset!");
static_assert(offsetof(FPropDestructMaterial, _material) == 0x000008, "Member 'FPropDestructMaterial::_material' has a wrong offset!");

// ScriptStruct InGameModule.PropDestruct
// 0x0018 (0x0018 - 0x0000)
struct FPropDestruct final
{
public:
	class UParticleSystem*                        _destructEffect;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPropDestructMaterial>          _destructMaterialList;                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropDestruct) == 0x000008, "Wrong alignment on FPropDestruct");
static_assert(sizeof(FPropDestruct) == 0x000018, "Wrong size on FPropDestruct");
static_assert(offsetof(FPropDestruct, _destructEffect) == 0x000000, "Member 'FPropDestruct::_destructEffect' has a wrong offset!");
static_assert(offsetof(FPropDestruct, _destructMaterialList) == 0x000008, "Member 'FPropDestruct::_destructMaterialList' has a wrong offset!");

// ScriptStruct InGameModule.PropDestructInfo
// 0x0020 (0x0020 - 0x0000)
struct FPropDestructInfo final
{
public:
	TArray<struct FPropDestructTmp>               _destructInfoList;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPropDestructMaterial>          _destructMaterialList;                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropDestructInfo) == 0x000008, "Wrong alignment on FPropDestructInfo");
static_assert(sizeof(FPropDestructInfo) == 0x000020, "Wrong size on FPropDestructInfo");
static_assert(offsetof(FPropDestructInfo, _destructInfoList) == 0x000000, "Member 'FPropDestructInfo::_destructInfoList' has a wrong offset!");
static_assert(offsetof(FPropDestructInfo, _destructMaterialList) == 0x000010, "Member 'FPropDestructInfo::_destructMaterialList' has a wrong offset!");

// ScriptStruct InGameModule.BotOnlyTeamMember
// 0x0010 (0x0010 - 0x0000)
struct FBotOnlyTeamMember final
{
public:
	TArray<class APlayerStateBattle*>             _members;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotOnlyTeamMember) == 0x000008, "Wrong alignment on FBotOnlyTeamMember");
static_assert(sizeof(FBotOnlyTeamMember) == 0x000010, "Wrong size on FBotOnlyTeamMember");
static_assert(offsetof(FBotOnlyTeamMember, _members) == 0x000000, "Member 'FBotOnlyTeamMember::_members' has a wrong offset!");

// ScriptStruct InGameModule.BulletSpawnInit
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FBulletSpawnInit final
{
public:
	class UProjectileReplicateBattleComponent*    Replicator;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0xA8];                                       // 0x0008(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletSpawnInit) == 0x000010, "Wrong alignment on FBulletSpawnInit");
static_assert(sizeof(FBulletSpawnInit) == 0x0000B0, "Wrong size on FBulletSpawnInit");
static_assert(offsetof(FBulletSpawnInit, Replicator) == 0x000000, "Member 'FBulletSpawnInit::Replicator' has a wrong offset!");

// ScriptStruct InGameModule.SaveBulletInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSaveBulletInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveBulletInfo) == 0x000008, "Wrong alignment on FSaveBulletInfo");
static_assert(sizeof(FSaveBulletInfo) == 0x000030, "Wrong size on FSaveBulletInfo");

// ScriptStruct InGameModule.BulletSpawnEffectInfoList
// 0x0060 (0x0060 - 0x0000)
struct FBulletSpawnEffectInfoList final
{
public:
	TArray<struct FBattleEventEffectInfo>         _hitTbl;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _hitVanishTbl;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _wallHitTbl;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _wallHitVanishTbl;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _breakTbl;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBattleEventEffectInfo>         _vanishTbl;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletSpawnEffectInfoList) == 0x000008, "Wrong alignment on FBulletSpawnEffectInfoList");
static_assert(sizeof(FBulletSpawnEffectInfoList) == 0x000060, "Wrong size on FBulletSpawnEffectInfoList");
static_assert(offsetof(FBulletSpawnEffectInfoList, _hitTbl) == 0x000000, "Member 'FBulletSpawnEffectInfoList::_hitTbl' has a wrong offset!");
static_assert(offsetof(FBulletSpawnEffectInfoList, _hitVanishTbl) == 0x000010, "Member 'FBulletSpawnEffectInfoList::_hitVanishTbl' has a wrong offset!");
static_assert(offsetof(FBulletSpawnEffectInfoList, _wallHitTbl) == 0x000020, "Member 'FBulletSpawnEffectInfoList::_wallHitTbl' has a wrong offset!");
static_assert(offsetof(FBulletSpawnEffectInfoList, _wallHitVanishTbl) == 0x000030, "Member 'FBulletSpawnEffectInfoList::_wallHitVanishTbl' has a wrong offset!");
static_assert(offsetof(FBulletSpawnEffectInfoList, _breakTbl) == 0x000040, "Member 'FBulletSpawnEffectInfoList::_breakTbl' has a wrong offset!");
static_assert(offsetof(FBulletSpawnEffectInfoList, _vanishTbl) == 0x000050, "Member 'FBulletSpawnEffectInfoList::_vanishTbl' has a wrong offset!");

// ScriptStruct InGameModule.Cement3RepInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FCement3RepInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCement3RepInfo) == 0x000004, "Wrong alignment on FCement3RepInfo");
static_assert(sizeof(FCement3RepInfo) == 0x000010, "Wrong size on FCement3RepInfo");

// ScriptStruct InGameModule.Cement3GenRep
// 0x0050 (0x0050 - 0x0000)
struct FCement3GenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Side;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 ImpactNormal;                                      // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ImpactPoint;                                       // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rot;                                               // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Scale;                                             // 0x0030(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ImpactDirection;                                   // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCement3GenRep) == 0x000010, "Wrong alignment on FCement3GenRep");
static_assert(sizeof(FCement3GenRep) == 0x000050, "Wrong size on FCement3GenRep");
static_assert(offsetof(FCement3GenRep, SerialID) == 0x000000, "Member 'FCement3GenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCement3GenRep, Side) == 0x000001, "Member 'FCement3GenRep::Side' has a wrong offset!");
static_assert(offsetof(FCement3GenRep, ImpactNormal) == 0x000004, "Member 'FCement3GenRep::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FCement3GenRep, ImpactPoint) == 0x000010, "Member 'FCement3GenRep::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FCement3GenRep, Rot) == 0x000020, "Member 'FCement3GenRep::Rot' has a wrong offset!");
static_assert(offsetof(FCement3GenRep, Scale) == 0x000030, "Member 'FCement3GenRep::Scale' has a wrong offset!");
static_assert(offsetof(FCement3GenRep, ImpactDirection) == 0x00003C, "Member 'FCement3GenRep::ImpactDirection' has a wrong offset!");

// ScriptStruct InGameModule.Ch003Unique2ParticleInfo
// 0x0020 (0x0020 - 0x0000)
struct FCh003Unique2ParticleInfo final
{
public:
	class UParticleSystem*                        _weaponParticle;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _offset;                                           // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotate;                                           // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh003Unique2ParticleInfo) == 0x000008, "Wrong alignment on FCh003Unique2ParticleInfo");
static_assert(sizeof(FCh003Unique2ParticleInfo) == 0x000020, "Wrong size on FCh003Unique2ParticleInfo");
static_assert(offsetof(FCh003Unique2ParticleInfo, _weaponParticle) == 0x000000, "Member 'FCh003Unique2ParticleInfo::_weaponParticle' has a wrong offset!");
static_assert(offsetof(FCh003Unique2ParticleInfo, _offset) == 0x000008, "Member 'FCh003Unique2ParticleInfo::_offset' has a wrong offset!");
static_assert(offsetof(FCh003Unique2ParticleInfo, _rotate) == 0x000014, "Member 'FCh003Unique2ParticleInfo::_rotate' has a wrong offset!");

// ScriptStruct InGameModule.Ch003Unique3DecorationBulletInfo
// 0x0018 (0x0018 - 0x0000)
struct FCh003Unique3DecorationBulletInfo final
{
public:
	class UStaticMesh*                            _staticMesh;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              _outlineMaterialInstanceList;                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh003Unique3DecorationBulletInfo) == 0x000008, "Wrong alignment on FCh003Unique3DecorationBulletInfo");
static_assert(sizeof(FCh003Unique3DecorationBulletInfo) == 0x000018, "Wrong size on FCh003Unique3DecorationBulletInfo");
static_assert(offsetof(FCh003Unique3DecorationBulletInfo, _staticMesh) == 0x000000, "Member 'FCh003Unique3DecorationBulletInfo::_staticMesh' has a wrong offset!");
static_assert(offsetof(FCh003Unique3DecorationBulletInfo, _outlineMaterialInstanceList) == 0x000008, "Member 'FCh003Unique3DecorationBulletInfo::_outlineMaterialInstanceList' has a wrong offset!");

// ScriptStruct InGameModule.Ch003Unique3SpawnRep
// 0x0028 (0x0028 - 0x0000)
struct FCh003Unique3SpawnRep final
{
public:
	struct FVector_NetQuantize100                 _spawnLocation;                                    // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 _spawnDirection;                                   // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _groundHeight;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _floatHeight;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _seed;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          _teamId;                                           // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bSetFloatHeight;                                  // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh003Unique3SpawnRep) == 0x000004, "Wrong alignment on FCh003Unique3SpawnRep");
static_assert(sizeof(FCh003Unique3SpawnRep) == 0x000028, "Wrong size on FCh003Unique3SpawnRep");
static_assert(offsetof(FCh003Unique3SpawnRep, _spawnLocation) == 0x000000, "Member 'FCh003Unique3SpawnRep::_spawnLocation' has a wrong offset!");
static_assert(offsetof(FCh003Unique3SpawnRep, _spawnDirection) == 0x00000C, "Member 'FCh003Unique3SpawnRep::_spawnDirection' has a wrong offset!");
static_assert(offsetof(FCh003Unique3SpawnRep, _groundHeight) == 0x000018, "Member 'FCh003Unique3SpawnRep::_groundHeight' has a wrong offset!");
static_assert(offsetof(FCh003Unique3SpawnRep, _floatHeight) == 0x00001C, "Member 'FCh003Unique3SpawnRep::_floatHeight' has a wrong offset!");
static_assert(offsetof(FCh003Unique3SpawnRep, _seed) == 0x000020, "Member 'FCh003Unique3SpawnRep::_seed' has a wrong offset!");
static_assert(offsetof(FCh003Unique3SpawnRep, _teamId) == 0x000024, "Member 'FCh003Unique3SpawnRep::_teamId' has a wrong offset!");
static_assert(offsetof(FCh003Unique3SpawnRep, _bSetFloatHeight) == 0x000025, "Member 'FCh003Unique3SpawnRep::_bSetFloatHeight' has a wrong offset!");

// ScriptStruct InGameModule.Ch004Unique2Info
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FCh004Unique2Info final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh004Unique2Info) == 0x000010, "Wrong alignment on FCh004Unique2Info");
static_assert(sizeof(FCh004Unique2Info) == 0x000070, "Wrong size on FCh004Unique2Info");

// ScriptStruct InGameModule.SpawnCh004Unique3ChildVar01Data
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FSpawnCh004Unique3ChildVar01Data final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnCh004Unique3ChildVar01Data) == 0x000004, "Wrong alignment on FSpawnCh004Unique3ChildVar01Data");
static_assert(sizeof(FSpawnCh004Unique3ChildVar01Data) == 0x00001C, "Wrong size on FSpawnCh004Unique3ChildVar01Data");

// ScriptStruct InGameModule.ThunderShotGenRep
// 0x0010 (0x0010 - 0x0000)
struct FThunderShotGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  CreateLocate;                                      // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FThunderShotGenRep) == 0x000004, "Wrong alignment on FThunderShotGenRep");
static_assert(sizeof(FThunderShotGenRep) == 0x000010, "Wrong size on FThunderShotGenRep");
static_assert(offsetof(FThunderShotGenRep, SerialID) == 0x000000, "Member 'FThunderShotGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FThunderShotGenRep, CreateLocate) == 0x000004, "Member 'FThunderShotGenRep::CreateLocate' has a wrong offset!");

// ScriptStruct InGameModule.Ch010Unique2PutGenRep
// 0x0014 (0x0014 - 0x0000)
struct FCh010Unique2PutGenRep final
{
public:
	int32                                         OpenNumR;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenNumL;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 CreateLocate;                                      // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh010Unique2PutGenRep) == 0x000004, "Wrong alignment on FCh010Unique2PutGenRep");
static_assert(sizeof(FCh010Unique2PutGenRep) == 0x000014, "Wrong size on FCh010Unique2PutGenRep");
static_assert(offsetof(FCh010Unique2PutGenRep, OpenNumR) == 0x000000, "Member 'FCh010Unique2PutGenRep::OpenNumR' has a wrong offset!");
static_assert(offsetof(FCh010Unique2PutGenRep, OpenNumL) == 0x000004, "Member 'FCh010Unique2PutGenRep::OpenNumL' has a wrong offset!");
static_assert(offsetof(FCh010Unique2PutGenRep, CreateLocate) == 0x000008, "Member 'FCh010Unique2PutGenRep::CreateLocate' has a wrong offset!");

// ScriptStruct InGameModule.Ch010Unique3GenRep
// 0x0020 (0x0020 - 0x0000)
struct FCh010Unique3GenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 FixCreateLocate;                                   // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 FixTargetLocate;                                   // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MakingState;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh010Unique3GenRep) == 0x000004, "Wrong alignment on FCh010Unique3GenRep");
static_assert(sizeof(FCh010Unique3GenRep) == 0x000020, "Wrong size on FCh010Unique3GenRep");
static_assert(offsetof(FCh010Unique3GenRep, SerialID) == 0x000000, "Member 'FCh010Unique3GenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCh010Unique3GenRep, FixCreateLocate) == 0x000004, "Member 'FCh010Unique3GenRep::FixCreateLocate' has a wrong offset!");
static_assert(offsetof(FCh010Unique3GenRep, FixTargetLocate) == 0x000010, "Member 'FCh010Unique3GenRep::FixTargetLocate' has a wrong offset!");
static_assert(offsetof(FCh010Unique3GenRep, MakingState) == 0x00001C, "Member 'FCh010Unique3GenRep::MakingState' has a wrong offset!");

// ScriptStruct InGameModule.Ch010Unique3ShotGenRep
// 0x000C (0x000C - 0x0000)
struct FCh010Unique3ShotGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Addtime;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh010Unique3ShotGenRep) == 0x000004, "Wrong alignment on FCh010Unique3ShotGenRep");
static_assert(sizeof(FCh010Unique3ShotGenRep) == 0x00000C, "Wrong size on FCh010Unique3ShotGenRep");
static_assert(offsetof(FCh010Unique3ShotGenRep, SerialID) == 0x000000, "Member 'FCh010Unique3ShotGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCh010Unique3ShotGenRep, Addtime) == 0x000004, "Member 'FCh010Unique3ShotGenRep::Addtime' has a wrong offset!");
static_assert(offsetof(FCh010Unique3ShotGenRep, Seed) == 0x000008, "Member 'FCh010Unique3ShotGenRep::Seed' has a wrong offset!");

// ScriptStruct InGameModule.Ch010Unique3ShotGrandChildGenRep
// 0x0010 (0x0010 - 0x0000)
struct FCh010Unique3ShotGrandChildGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          Seed;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  Normal;                                            // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh010Unique3ShotGrandChildGenRep) == 0x000004, "Wrong alignment on FCh010Unique3ShotGrandChildGenRep");
static_assert(sizeof(FCh010Unique3ShotGrandChildGenRep) == 0x000010, "Wrong size on FCh010Unique3ShotGrandChildGenRep");
static_assert(offsetof(FCh010Unique3ShotGrandChildGenRep, SerialID) == 0x000000, "Member 'FCh010Unique3ShotGrandChildGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCh010Unique3ShotGrandChildGenRep, Seed) == 0x000001, "Member 'FCh010Unique3ShotGrandChildGenRep::Seed' has a wrong offset!");
static_assert(offsetof(FCh010Unique3ShotGrandChildGenRep, Normal) == 0x000004, "Member 'FCh010Unique3ShotGrandChildGenRep::Normal' has a wrong offset!");

// ScriptStruct InGameModule.Ch012Unique2Info
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FCh012Unique2Info final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh012Unique2Info) == 0x000010, "Wrong alignment on FCh012Unique2Info");
static_assert(sizeof(FCh012Unique2Info) == 0x000060, "Wrong size on FCh012Unique2Info");

// ScriptStruct InGameModule.Ch023Unique2ShotChildGenRep
// 0x0018 (0x0018 - 0x0000)
struct FCh023Unique2ShotChildGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  _impactNormal;                                     // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBattle*                       _hitCharacter;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh023Unique2ShotChildGenRep) == 0x000008, "Wrong alignment on FCh023Unique2ShotChildGenRep");
static_assert(sizeof(FCh023Unique2ShotChildGenRep) == 0x000018, "Wrong size on FCh023Unique2ShotChildGenRep");
static_assert(offsetof(FCh023Unique2ShotChildGenRep, SerialID) == 0x000000, "Member 'FCh023Unique2ShotChildGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCh023Unique2ShotChildGenRep, _impactNormal) == 0x000004, "Member 'FCh023Unique2ShotChildGenRep::_impactNormal' has a wrong offset!");
static_assert(offsetof(FCh023Unique2ShotChildGenRep, _hitCharacter) == 0x000010, "Member 'FCh023Unique2ShotChildGenRep::_hitCharacter' has a wrong offset!");

// ScriptStruct InGameModule.Ch034Unique1Param
// 0x0020 (0x0020 - 0x0000)
struct FCh034Unique1Param final
{
public:
	float                                         _startHomingTimeSeconds;                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _startDirection;                                   // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _easingType;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableUpMoving;                                  // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _impactNormal;                                     // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh034Unique1Param) == 0x000004, "Wrong alignment on FCh034Unique1Param");
static_assert(sizeof(FCh034Unique1Param) == 0x000020, "Wrong size on FCh034Unique1Param");
static_assert(offsetof(FCh034Unique1Param, _startHomingTimeSeconds) == 0x000000, "Member 'FCh034Unique1Param::_startHomingTimeSeconds' has a wrong offset!");
static_assert(offsetof(FCh034Unique1Param, _startDirection) == 0x000004, "Member 'FCh034Unique1Param::_startDirection' has a wrong offset!");
static_assert(offsetof(FCh034Unique1Param, _easingType) == 0x000010, "Member 'FCh034Unique1Param::_easingType' has a wrong offset!");
static_assert(offsetof(FCh034Unique1Param, _bEnableUpMoving) == 0x000011, "Member 'FCh034Unique1Param::_bEnableUpMoving' has a wrong offset!");
static_assert(offsetof(FCh034Unique1Param, _impactNormal) == 0x000014, "Member 'FCh034Unique1Param::_impactNormal' has a wrong offset!");

// ScriptStruct InGameModule.Ch034Unique1LevelData
// 0x0020 (0x0020 - 0x0000)
struct FCh034Unique1LevelData final
{
public:
	TArray<int32>                                 _useShotIndexList;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 _spawnDelayList;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCh034Unique1LevelData) == 0x000008, "Wrong alignment on FCh034Unique1LevelData");
static_assert(sizeof(FCh034Unique1LevelData) == 0x000020, "Wrong size on FCh034Unique1LevelData");
static_assert(offsetof(FCh034Unique1LevelData, _useShotIndexList) == 0x000000, "Member 'FCh034Unique1LevelData::_useShotIndexList' has a wrong offset!");
static_assert(offsetof(FCh034Unique1LevelData, _spawnDelayList) == 0x000010, "Member 'FCh034Unique1LevelData::_spawnDelayList' has a wrong offset!");

// ScriptStruct InGameModule.Ch043Unique1ShotGenRep
// 0x0028 (0x0028 - 0x0000)
struct FCh043Unique1ShotGenRep final
{
public:
	int32                                         RandSeed;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InitTarget;                                        // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TargetList;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int8                                          SerialID;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh043Unique1ShotGenRep) == 0x000008, "Wrong alignment on FCh043Unique1ShotGenRep");
static_assert(sizeof(FCh043Unique1ShotGenRep) == 0x000028, "Wrong size on FCh043Unique1ShotGenRep");
static_assert(offsetof(FCh043Unique1ShotGenRep, RandSeed) == 0x000000, "Member 'FCh043Unique1ShotGenRep::RandSeed' has a wrong offset!");
static_assert(offsetof(FCh043Unique1ShotGenRep, InitTarget) == 0x000004, "Member 'FCh043Unique1ShotGenRep::InitTarget' has a wrong offset!");
static_assert(offsetof(FCh043Unique1ShotGenRep, TargetList) == 0x000010, "Member 'FCh043Unique1ShotGenRep::TargetList' has a wrong offset!");
static_assert(offsetof(FCh043Unique1ShotGenRep, SerialID) == 0x000020, "Member 'FCh043Unique1ShotGenRep::SerialID' has a wrong offset!");

// ScriptStruct InGameModule.ResponceHitRep
// 0x0004 (0x0004 - 0x0000)
struct FResponceHitRep final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResponceHitRep) == 0x000004, "Wrong alignment on FResponceHitRep");
static_assert(sizeof(FResponceHitRep) == 0x000004, "Wrong size on FResponceHitRep");
static_assert(offsetof(FResponceHitRep, Index) == 0x000000, "Member 'FResponceHitRep::Index' has a wrong offset!");

// ScriptStruct InGameModule.Ch046BulletInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCh046BulletInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh046BulletInfo) == 0x000004, "Wrong alignment on FCh046BulletInfo");
static_assert(sizeof(FCh046BulletInfo) == 0x00000C, "Wrong size on FCh046BulletInfo");

// ScriptStruct InGameModule.Ch046Unique1GeneratorInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FCh046Unique1GeneratorInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh046Unique1GeneratorInfo) == 0x000004, "Wrong alignment on FCh046Unique1GeneratorInfo");
static_assert(sizeof(FCh046Unique1GeneratorInfo) == 0x000030, "Wrong size on FCh046Unique1GeneratorInfo");

// ScriptStruct InGameModule.BulletKineticData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FBulletKineticData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletKineticData) == 0x000004, "Wrong alignment on FBulletKineticData");
static_assert(sizeof(FBulletKineticData) == 0x000008, "Wrong size on FBulletKineticData");

// ScriptStruct InGameModule.CrackStateRep
// 0x0006 (0x0006 - 0x0000)
struct FCrackStateRep final
{
public:
	uint16                                        Ammo;                                              // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        MaxAmmo;                                           // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          Level;                                             // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x1];                                        // 0x0005(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrackStateRep) == 0x000002, "Wrong alignment on FCrackStateRep");
static_assert(sizeof(FCrackStateRep) == 0x000006, "Wrong size on FCrackStateRep");
static_assert(offsetof(FCrackStateRep, Ammo) == 0x000000, "Member 'FCrackStateRep::Ammo' has a wrong offset!");
static_assert(offsetof(FCrackStateRep, MaxAmmo) == 0x000002, "Member 'FCrackStateRep::MaxAmmo' has a wrong offset!");
static_assert(offsetof(FCrackStateRep, Level) == 0x000004, "Member 'FCrackStateRep::Level' has a wrong offset!");

// ScriptStruct InGameModule.ReceiveDamageGenRepImpl
// 0x0020 (0x0020 - 0x0000)
struct FReceiveDamageGenRepImpl final
{
public:
	int64                                         Timestamp;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ImpactPoint;                                       // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitMarkType;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MeleeAttack;                                       // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReceiveDamageGenRepImpl) == 0x000008, "Wrong alignment on FReceiveDamageGenRepImpl");
static_assert(sizeof(FReceiveDamageGenRepImpl) == 0x000020, "Wrong size on FReceiveDamageGenRepImpl");
static_assert(offsetof(FReceiveDamageGenRepImpl, Timestamp) == 0x000000, "Member 'FReceiveDamageGenRepImpl::Timestamp' has a wrong offset!");
static_assert(offsetof(FReceiveDamageGenRepImpl, Damage) == 0x000008, "Member 'FReceiveDamageGenRepImpl::Damage' has a wrong offset!");
static_assert(offsetof(FReceiveDamageGenRepImpl, ImpactPoint) == 0x00000C, "Member 'FReceiveDamageGenRepImpl::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FReceiveDamageGenRepImpl, HitMarkType) == 0x000018, "Member 'FReceiveDamageGenRepImpl::HitMarkType' has a wrong offset!");
static_assert(offsetof(FReceiveDamageGenRepImpl, MeleeAttack) == 0x000019, "Member 'FReceiveDamageGenRepImpl::MeleeAttack' has a wrong offset!");

// ScriptStruct InGameModule.ReceiveDamageGenRep
// 0x0010 (0x0010 - 0x0000)
struct FReceiveDamageGenRep final
{
public:
	TArray<struct FReceiveDamageGenRepImpl>       DataTbl;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReceiveDamageGenRep) == 0x000008, "Wrong alignment on FReceiveDamageGenRep");
static_assert(sizeof(FReceiveDamageGenRep) == 0x000010, "Wrong size on FReceiveDamageGenRep");
static_assert(offsetof(FReceiveDamageGenRep, DataTbl) == 0x000000, "Member 'FReceiveDamageGenRep::DataTbl' has a wrong offset!");

// ScriptStruct InGameModule.Ch101SpecialGenRep
// 0x0014 (0x0014 - 0x0000)
struct FCh101SpecialGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 CreateLocate;                                      // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         RotYaw;                                            // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh101SpecialGenRep) == 0x000004, "Wrong alignment on FCh101SpecialGenRep");
static_assert(sizeof(FCh101SpecialGenRep) == 0x000014, "Wrong size on FCh101SpecialGenRep");
static_assert(offsetof(FCh101SpecialGenRep, SerialID) == 0x000000, "Member 'FCh101SpecialGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCh101SpecialGenRep, CreateLocate) == 0x000004, "Member 'FCh101SpecialGenRep::CreateLocate' has a wrong offset!");
static_assert(offsetof(FCh101SpecialGenRep, RotYaw) == 0x000010, "Member 'FCh101SpecialGenRep::RotYaw' has a wrong offset!");

// ScriptStruct InGameModule.Ch102SpecialGenRep
// 0x0014 (0x0014 - 0x0000)
struct FCh102SpecialGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  CreateLocate;                                      // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         RotYaw;                                            // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCh102SpecialGenRep) == 0x000004, "Wrong alignment on FCh102SpecialGenRep");
static_assert(sizeof(FCh102SpecialGenRep) == 0x000014, "Wrong size on FCh102SpecialGenRep");
static_assert(offsetof(FCh102SpecialGenRep, SerialID) == 0x000000, "Member 'FCh102SpecialGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCh102SpecialGenRep, CreateLocate) == 0x000004, "Member 'FCh102SpecialGenRep::CreateLocate' has a wrong offset!");
static_assert(offsetof(FCh102SpecialGenRep, RotYaw) == 0x000010, "Member 'FCh102SpecialGenRep::RotYaw' has a wrong offset!");

// ScriptStruct InGameModule.HairShotGenRep
// 0x0010 (0x0010 - 0x0000)
struct FHairShotGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  NewTarget;                                         // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHairShotGenRep) == 0x000004, "Wrong alignment on FHairShotGenRep");
static_assert(sizeof(FHairShotGenRep) == 0x000010, "Wrong size on FHairShotGenRep");
static_assert(offsetof(FHairShotGenRep, SerialID) == 0x000000, "Member 'FHairShotGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FHairShotGenRep, NewTarget) == 0x000004, "Member 'FHairShotGenRep::NewTarget' has a wrong offset!");

// ScriptStruct InGameModule.NetworkRegisterAttackActionData
// 0x0018 (0x0018 - 0x0000)
struct FNetworkRegisterAttackActionData final
{
public:
	int8                                          _level;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UActionAttackBase>          _attackActionClass;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagazineRegisterType                         _magazineRegisterType;                             // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkRegisterAttackActionData) == 0x000008, "Wrong alignment on FNetworkRegisterAttackActionData");
static_assert(sizeof(FNetworkRegisterAttackActionData) == 0x000018, "Wrong size on FNetworkRegisterAttackActionData");
static_assert(offsetof(FNetworkRegisterAttackActionData, _level) == 0x000000, "Member 'FNetworkRegisterAttackActionData::_level' has a wrong offset!");
static_assert(offsetof(FNetworkRegisterAttackActionData, _attackActionClass) == 0x000008, "Member 'FNetworkRegisterAttackActionData::_attackActionClass' has a wrong offset!");
static_assert(offsetof(FNetworkRegisterAttackActionData, _attackID) == 0x000010, "Member 'FNetworkRegisterAttackActionData::_attackID' has a wrong offset!");
static_assert(offsetof(FNetworkRegisterAttackActionData, _magazineRegisterType) == 0x000011, "Member 'FNetworkRegisterAttackActionData::_magazineRegisterType' has a wrong offset!");

// ScriptStruct InGameModule.NetworkAttackActionData
// 0x0028 (0x0028 - 0x0000)
struct FNetworkAttackActionData final
{
public:
	int32                                         _serial;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 _targetLocation;                                   // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _targetActor;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          _uniqueLevel;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandId                                    _commandID;                                        // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bBeginGround;                                     // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkAttackActionData) == 0x000008, "Wrong alignment on FNetworkAttackActionData");
static_assert(sizeof(FNetworkAttackActionData) == 0x000028, "Wrong size on FNetworkAttackActionData");
static_assert(offsetof(FNetworkAttackActionData, _serial) == 0x000000, "Member 'FNetworkAttackActionData::_serial' has a wrong offset!");
static_assert(offsetof(FNetworkAttackActionData, _attackID) == 0x000004, "Member 'FNetworkAttackActionData::_attackID' has a wrong offset!");
static_assert(offsetof(FNetworkAttackActionData, _targetLocation) == 0x000008, "Member 'FNetworkAttackActionData::_targetLocation' has a wrong offset!");
static_assert(offsetof(FNetworkAttackActionData, _targetActor) == 0x000018, "Member 'FNetworkAttackActionData::_targetActor' has a wrong offset!");
static_assert(offsetof(FNetworkAttackActionData, _uniqueLevel) == 0x000020, "Member 'FNetworkAttackActionData::_uniqueLevel' has a wrong offset!");
static_assert(offsetof(FNetworkAttackActionData, _commandID) == 0x000021, "Member 'FNetworkAttackActionData::_commandID' has a wrong offset!");
static_assert(offsetof(FNetworkAttackActionData, _bBeginGround) == 0x000022, "Member 'FNetworkAttackActionData::_bBeginGround' has a wrong offset!");

// ScriptStruct InGameModule.NetworkActionData
// 0x0014 (0x0014 - 0x0000)
struct FNetworkActionData final
{
public:
	int32                                         _serial;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _actionName;                                       // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionKind                                   _actionKind;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _actionArgment;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkActionData) == 0x000004, "Wrong alignment on FNetworkActionData");
static_assert(sizeof(FNetworkActionData) == 0x000014, "Wrong size on FNetworkActionData");
static_assert(offsetof(FNetworkActionData, _serial) == 0x000000, "Member 'FNetworkActionData::_serial' has a wrong offset!");
static_assert(offsetof(FNetworkActionData, _actionName) == 0x000004, "Member 'FNetworkActionData::_actionName' has a wrong offset!");
static_assert(offsetof(FNetworkActionData, _actionKind) == 0x00000C, "Member 'FNetworkActionData::_actionKind' has a wrong offset!");
static_assert(offsetof(FNetworkActionData, _actionArgment) == 0x000010, "Member 'FNetworkActionData::_actionArgment' has a wrong offset!");

// ScriptStruct InGameModule.RegistActionClassData
// 0x0010 (0x0010 - 0x0000)
struct FRegistActionClassData
{
public:
	class FName                                   _name;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActionBase>                _actionBaseClass;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegistActionClassData) == 0x000008, "Wrong alignment on FRegistActionClassData");
static_assert(sizeof(FRegistActionClassData) == 0x000010, "Wrong size on FRegistActionClassData");
static_assert(offsetof(FRegistActionClassData, _name) == 0x000000, "Member 'FRegistActionClassData::_name' has a wrong offset!");
static_assert(offsetof(FRegistActionClassData, _actionBaseClass) == 0x000008, "Member 'FRegistActionClassData::_actionBaseClass' has a wrong offset!");

// ScriptStruct InGameModule.RegistDamageClassData
// 0x0000 (0x0010 - 0x0010)
struct FRegistDamageClassData final : public FRegistActionClassData
{
};
static_assert(alignof(FRegistDamageClassData) == 0x000008, "Wrong alignment on FRegistDamageClassData");
static_assert(sizeof(FRegistDamageClassData) == 0x000010, "Wrong size on FRegistDamageClassData");

// ScriptStruct InGameModule.RegistAttackClassData
// 0x0018 (0x0018 - 0x0000)
struct FRegistAttackClassData final
{
public:
	EAttackId                                     _attackID;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UActionAttackBase>          _actionAttackClass;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegistAttackClassData) == 0x000008, "Wrong alignment on FRegistAttackClassData");
static_assert(sizeof(FRegistAttackClassData) == 0x000018, "Wrong size on FRegistAttackClassData");
static_assert(offsetof(FRegistAttackClassData, _attackID) == 0x000000, "Member 'FRegistAttackClassData::_attackID' has a wrong offset!");
static_assert(offsetof(FRegistAttackClassData, _actionAttackClass) == 0x000008, "Member 'FRegistAttackClassData::_actionAttackClass' has a wrong offset!");

// ScriptStruct InGameModule.HitGroupRemoveReservedInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FHitGroupRemoveReservedInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitGroupRemoveReservedInfo) == 0x000004, "Wrong alignment on FHitGroupRemoveReservedInfo");
static_assert(sizeof(FHitGroupRemoveReservedInfo) == 0x00000C, "Wrong size on FHitGroupRemoveReservedInfo");

// ScriptStruct InGameModule.HitLimitInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FHitLimitInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitLimitInfo) == 0x000004, "Wrong alignment on FHitLimitInfo");
static_assert(sizeof(FHitLimitInfo) == 0x00000C, "Wrong size on FHitLimitInfo");

// ScriptStruct InGameModule.HitGroupInfo
// 0x0068 (0x0068 - 0x0000)
struct FHitGroupInfo final
{
public:
	TMap<uint32, struct FHitLimitInfo>            HitLimitTbl;                                       // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            Prims;                                             // 0x0050(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitGroupInfo) == 0x000008, "Wrong alignment on FHitGroupInfo");
static_assert(sizeof(FHitGroupInfo) == 0x000068, "Wrong size on FHitGroupInfo");
static_assert(offsetof(FHitGroupInfo, HitLimitTbl) == 0x000000, "Member 'FHitGroupInfo::HitLimitTbl' has a wrong offset!");
static_assert(offsetof(FHitGroupInfo, Prims) == 0x000050, "Member 'FHitGroupInfo::Prims' has a wrong offset!");

// ScriptStruct InGameModule.AttackPitchRotationInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FAttackPitchRotationInfo final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackPitchRotationInfo) == 0x000004, "Wrong alignment on FAttackPitchRotationInfo");
static_assert(sizeof(FAttackPitchRotationInfo) == 0x00001C, "Wrong size on FAttackPitchRotationInfo");

// ScriptStruct InGameModule.AttackTurnToLeverInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FAttackTurnToLeverInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackTurnToLeverInfo) == 0x000004, "Wrong alignment on FAttackTurnToLeverInfo");
static_assert(sizeof(FAttackTurnToLeverInfo) == 0x000014, "Wrong size on FAttackTurnToLeverInfo");

// ScriptStruct InGameModule.AttackTurnToCameraInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FAttackTurnToCameraInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackTurnToCameraInfo) == 0x000004, "Wrong alignment on FAttackTurnToCameraInfo");
static_assert(sizeof(FAttackTurnToCameraInfo) == 0x000010, "Wrong size on FAttackTurnToCameraInfo");

// ScriptStruct InGameModule.AttackChaseInfo
// 0x0038 (0x0038 - 0x0000)
struct FAttackChaseInfo final
{
public:
	float                                         _chaseEndDistance;                                 // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _chaseTargetOffset;                                // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _turnTime;                                         // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _turnEasing;                                       // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _turnRate;                                         // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _initialSpeed;                                     // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _lastSpeed;                                        // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _speedSpan;                                        // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inertiaRate;                                      // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inertiaTime;                                      // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bIgnorePassing;                                   // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bClearSpeedAsEnd;                                 // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAlwaysSetSpeed;                                  // 0x0032(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableSetSpeed;                                  // 0x0033(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bTargetDirectionTo2D;                             // 0x0034(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableUpDirectionChase;                          // 0x0035(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackChaseInfo) == 0x000004, "Wrong alignment on FAttackChaseInfo");
static_assert(sizeof(FAttackChaseInfo) == 0x000038, "Wrong size on FAttackChaseInfo");
static_assert(offsetof(FAttackChaseInfo, _chaseEndDistance) == 0x000000, "Member 'FAttackChaseInfo::_chaseEndDistance' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _chaseTargetOffset) == 0x000004, "Member 'FAttackChaseInfo::_chaseTargetOffset' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _turnTime) == 0x000010, "Member 'FAttackChaseInfo::_turnTime' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _turnEasing) == 0x000014, "Member 'FAttackChaseInfo::_turnEasing' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _turnRate) == 0x000018, "Member 'FAttackChaseInfo::_turnRate' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _initialSpeed) == 0x00001C, "Member 'FAttackChaseInfo::_initialSpeed' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _lastSpeed) == 0x000020, "Member 'FAttackChaseInfo::_lastSpeed' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _speedSpan) == 0x000024, "Member 'FAttackChaseInfo::_speedSpan' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _inertiaRate) == 0x000028, "Member 'FAttackChaseInfo::_inertiaRate' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _inertiaTime) == 0x00002C, "Member 'FAttackChaseInfo::_inertiaTime' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _bIgnorePassing) == 0x000030, "Member 'FAttackChaseInfo::_bIgnorePassing' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _bClearSpeedAsEnd) == 0x000031, "Member 'FAttackChaseInfo::_bClearSpeedAsEnd' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _bAlwaysSetSpeed) == 0x000032, "Member 'FAttackChaseInfo::_bAlwaysSetSpeed' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _bEnableSetSpeed) == 0x000033, "Member 'FAttackChaseInfo::_bEnableSetSpeed' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _bTargetDirectionTo2D) == 0x000034, "Member 'FAttackChaseInfo::_bTargetDirectionTo2D' has a wrong offset!");
static_assert(offsetof(FAttackChaseInfo, _bEnableUpDirectionChase) == 0x000035, "Member 'FAttackChaseInfo::_bEnableUpDirectionChase' has a wrong offset!");

// ScriptStruct InGameModule.AttackLockOnData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FAttackLockOnData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackLockOnData) == 0x000004, "Wrong alignment on FAttackLockOnData");
static_assert(sizeof(FAttackLockOnData) == 0x000020, "Wrong size on FAttackLockOnData");

// ScriptStruct InGameModule.AttackTargetData
// 0x0018 (0x0018 - 0x0000)
struct FAttackTargetData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _targetActor;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackTargetData) == 0x000008, "Wrong alignment on FAttackTargetData");
static_assert(sizeof(FAttackTargetData) == 0x000018, "Wrong size on FAttackTargetData");
static_assert(offsetof(FAttackTargetData, _targetActor) == 0x000010, "Member 'FAttackTargetData::_targetActor' has a wrong offset!");

// ScriptStruct InGameModule.ProjectileArgPram
// 0x0020 (0x0020 - 0x0000)
struct FProjectileArgPram final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttackTargetData>              _targetList;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileArgPram) == 0x000008, "Wrong alignment on FProjectileArgPram");
static_assert(sizeof(FProjectileArgPram) == 0x000020, "Wrong size on FProjectileArgPram");
static_assert(offsetof(FProjectileArgPram, _targetList) == 0x000010, "Member 'FProjectileArgPram::_targetList' has a wrong offset!");

// ScriptStruct InGameModule.AttackPhaseReserveData
// 0x0002 (0x0002 - 0x0000)
struct FAttackPhaseReserveData final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackPhaseReserveData) == 0x000001, "Wrong alignment on FAttackPhaseReserveData");
static_assert(sizeof(FAttackPhaseReserveData) == 0x000002, "Wrong size on FAttackPhaseReserveData");

// ScriptStruct InGameModule.AttackPhaseData
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FAttackPhaseData final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackPhaseData) == 0x000004, "Wrong alignment on FAttackPhaseData");
static_assert(sizeof(FAttackPhaseData) == 0x000014, "Wrong size on FAttackPhaseData");

// ScriptStruct InGameModule.NetAttackTargetData
// 0x0018 (0x0018 - 0x0000)
struct FNetAttackTargetData final
{
public:
	struct FVector_NetQuantize                    _targetLocation;                                   // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _targetActor;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetAttackTargetData) == 0x000008, "Wrong alignment on FNetAttackTargetData");
static_assert(sizeof(FNetAttackTargetData) == 0x000018, "Wrong size on FNetAttackTargetData");
static_assert(offsetof(FNetAttackTargetData, _targetLocation) == 0x000000, "Member 'FNetAttackTargetData::_targetLocation' has a wrong offset!");
static_assert(offsetof(FNetAttackTargetData, _targetActor) == 0x000010, "Member 'FNetAttackTargetData::_targetActor' has a wrong offset!");

// ScriptStruct InGameModule.NetAttackHitData
// 0x0018 (0x0018 - 0x0000)
struct FNetAttackHitData final
{
public:
	struct FVector_NetQuantize                    _hitLocation;                                      // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _hitCharacter;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetAttackHitData) == 0x000008, "Wrong alignment on FNetAttackHitData");
static_assert(sizeof(FNetAttackHitData) == 0x000018, "Wrong size on FNetAttackHitData");
static_assert(offsetof(FNetAttackHitData, _hitLocation) == 0x000000, "Member 'FNetAttackHitData::_hitLocation' has a wrong offset!");
static_assert(offsetof(FNetAttackHitData, _hitCharacter) == 0x000010, "Member 'FNetAttackHitData::_hitCharacter' has a wrong offset!");

// ScriptStruct InGameModule.AttackHitData
// 0x0048 (0x0048 - 0x0000)
struct FAttackHitData final
{
public:
	class ACharacterBattle*                       _hitCharacter;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x40];                                       // 0x0008(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackHitData) == 0x000008, "Wrong alignment on FAttackHitData");
static_assert(sizeof(FAttackHitData) == 0x000048, "Wrong size on FAttackHitData");
static_assert(offsetof(FAttackHitData, _hitCharacter) == 0x000000, "Member 'FAttackHitData::_hitCharacter' has a wrong offset!");

// ScriptStruct InGameModule.CharacterAttackHitRep
// 0x0038 (0x0038 - 0x0000)
struct FCharacterAttackHitRep final
{
public:
	uint8                                         SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  ImpactPoint;                                       // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PDamageCauser;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBattle*                       PHitChara;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CharaID;                                           // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DamageParamName;                                   // 0x0024(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageCauserType                             DamageCauserType;                                  // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterAttackHitRep) == 0x000008, "Wrong alignment on FCharacterAttackHitRep");
static_assert(sizeof(FCharacterAttackHitRep) == 0x000038, "Wrong size on FCharacterAttackHitRep");
static_assert(offsetof(FCharacterAttackHitRep, SerialID) == 0x000000, "Member 'FCharacterAttackHitRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, ImpactPoint) == 0x000004, "Member 'FCharacterAttackHitRep::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, PDamageCauser) == 0x000010, "Member 'FCharacterAttackHitRep::PDamageCauser' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, PHitChara) == 0x000018, "Member 'FCharacterAttackHitRep::PHitChara' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, Level) == 0x000020, "Member 'FCharacterAttackHitRep::Level' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, CharaID) == 0x000021, "Member 'FCharacterAttackHitRep::CharaID' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, DamageParamName) == 0x000024, "Member 'FCharacterAttackHitRep::DamageParamName' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, DamageCauserType) == 0x00002C, "Member 'FCharacterAttackHitRep::DamageCauserType' has a wrong offset!");
static_assert(offsetof(FCharacterAttackHitRep, Delay) == 0x000030, "Member 'FCharacterAttackHitRep::Delay' has a wrong offset!");

// ScriptStruct InGameModule.SpecialDamageParam
// 0x0008 (0x0008 - 0x0000)
struct FSpecialDamageParam final
{
public:
	class FName                                   _soundCueName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialDamageParam) == 0x000004, "Wrong alignment on FSpecialDamageParam");
static_assert(sizeof(FSpecialDamageParam) == 0x000008, "Wrong size on FSpecialDamageParam");
static_assert(offsetof(FSpecialDamageParam, _soundCueName) == 0x000000, "Member 'FSpecialDamageParam::_soundCueName' has a wrong offset!");

// ScriptStruct InGameModule.NetTeamRollBuff
// 0x0014 (0x0014 - 0x0000)
struct FNetTeamRollBuff final
{
public:
	float                                         _attackAdjust;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _durableAdjust;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _speedAdjust;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _healingAdjust;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _reloadAdjust;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetTeamRollBuff) == 0x000004, "Wrong alignment on FNetTeamRollBuff");
static_assert(sizeof(FNetTeamRollBuff) == 0x000014, "Wrong size on FNetTeamRollBuff");
static_assert(offsetof(FNetTeamRollBuff, _attackAdjust) == 0x000000, "Member 'FNetTeamRollBuff::_attackAdjust' has a wrong offset!");
static_assert(offsetof(FNetTeamRollBuff, _durableAdjust) == 0x000004, "Member 'FNetTeamRollBuff::_durableAdjust' has a wrong offset!");
static_assert(offsetof(FNetTeamRollBuff, _speedAdjust) == 0x000008, "Member 'FNetTeamRollBuff::_speedAdjust' has a wrong offset!");
static_assert(offsetof(FNetTeamRollBuff, _healingAdjust) == 0x00000C, "Member 'FNetTeamRollBuff::_healingAdjust' has a wrong offset!");
static_assert(offsetof(FNetTeamRollBuff, _reloadAdjust) == 0x000010, "Member 'FNetTeamRollBuff::_reloadAdjust' has a wrong offset!");

// ScriptStruct InGameModule.ChargeEffectInfo
// 0x0010 (0x0010 - 0x0000)
struct FChargeEffectInfo final
{
public:
	class UBattleCustomParticleSystemComponent*   _particle;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bScaled;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandId                                    _commandID;                                        // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChargeEffectInfo) == 0x000008, "Wrong alignment on FChargeEffectInfo");
static_assert(sizeof(FChargeEffectInfo) == 0x000010, "Wrong size on FChargeEffectInfo");
static_assert(offsetof(FChargeEffectInfo, _particle) == 0x000000, "Member 'FChargeEffectInfo::_particle' has a wrong offset!");
static_assert(offsetof(FChargeEffectInfo, _bScaled) == 0x000008, "Member 'FChargeEffectInfo::_bScaled' has a wrong offset!");
static_assert(offsetof(FChargeEffectInfo, _commandID) == 0x000009, "Member 'FChargeEffectInfo::_commandID' has a wrong offset!");

// ScriptStruct InGameModule.CharacterConditionData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterConditionData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterConditionBase*                _condition;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterConditionData) == 0x000008, "Wrong alignment on FCharacterConditionData");
static_assert(sizeof(FCharacterConditionData) == 0x000010, "Wrong size on FCharacterConditionData");
static_assert(offsetof(FCharacterConditionData, _condition) == 0x000008, "Member 'FCharacterConditionData::_condition' has a wrong offset!");

// ScriptStruct InGameModule.CharacterCondition
// 0x00B0 (0x00B0 - 0x0000)
struct FCharacterCondition final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterConditionData>        _dataList;                                         // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UConditionEffectDataAsset*              _conditionDataAsset;                               // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterCondition) == 0x000008, "Wrong alignment on FCharacterCondition");
static_assert(sizeof(FCharacterCondition) == 0x0000B0, "Wrong size on FCharacterCondition");
static_assert(offsetof(FCharacterCondition, _dataList) == 0x000078, "Member 'FCharacterCondition::_dataList' has a wrong offset!");
static_assert(offsetof(FCharacterCondition, _conditionDataAsset) == 0x0000A8, "Member 'FCharacterCondition::_conditionDataAsset' has a wrong offset!");

// ScriptStruct InGameModule.DeactivateParticleChainData
// 0x0018 (0x0018 - 0x0000)
struct FDeactivateParticleChainData final
{
public:
	int32                                         _particleIndex;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _fadeOutCurve;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _fadeOutParamName;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeactivateParticleChainData) == 0x000008, "Wrong alignment on FDeactivateParticleChainData");
static_assert(sizeof(FDeactivateParticleChainData) == 0x000018, "Wrong size on FDeactivateParticleChainData");
static_assert(offsetof(FDeactivateParticleChainData, _particleIndex) == 0x000000, "Member 'FDeactivateParticleChainData::_particleIndex' has a wrong offset!");
static_assert(offsetof(FDeactivateParticleChainData, _fadeOutCurve) == 0x000008, "Member 'FDeactivateParticleChainData::_fadeOutCurve' has a wrong offset!");
static_assert(offsetof(FDeactivateParticleChainData, _fadeOutParamName) == 0x000010, "Member 'FDeactivateParticleChainData::_fadeOutParamName' has a wrong offset!");

// ScriptStruct InGameModule.CharacterConditionControlData
// 0x0028 (0x0028 - 0x0000)
struct FCharacterConditionControlData final
{
public:
	int32                                         _serial;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterConditionId                         _id;                                               // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _level;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _span;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _value;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _interval;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _subLevel;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bApplyAutonomousProxy;                            // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _instigatedPlayer;                                 // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterConditionControlData) == 0x000008, "Wrong alignment on FCharacterConditionControlData");
static_assert(sizeof(FCharacterConditionControlData) == 0x000028, "Wrong size on FCharacterConditionControlData");
static_assert(offsetof(FCharacterConditionControlData, _serial) == 0x000000, "Member 'FCharacterConditionControlData::_serial' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _id) == 0x000004, "Member 'FCharacterConditionControlData::_id' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _level) == 0x000008, "Member 'FCharacterConditionControlData::_level' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _span) == 0x00000C, "Member 'FCharacterConditionControlData::_span' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _value) == 0x000010, "Member 'FCharacterConditionControlData::_value' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _interval) == 0x000014, "Member 'FCharacterConditionControlData::_interval' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _subLevel) == 0x000018, "Member 'FCharacterConditionControlData::_subLevel' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _bApplyAutonomousProxy) == 0x00001C, "Member 'FCharacterConditionControlData::_bApplyAutonomousProxy' has a wrong offset!");
static_assert(offsetof(FCharacterConditionControlData, _instigatedPlayer) == 0x000020, "Member 'FCharacterConditionControlData::_instigatedPlayer' has a wrong offset!");

// ScriptStruct InGameModule.NetworkCharacterConditionData
// 0x0018 (0x0018 - 0x0000)
struct FNetworkCharacterConditionData final
{
public:
	int32                                         _serial;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterConditionControlData> _conditionList;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkCharacterConditionData) == 0x000008, "Wrong alignment on FNetworkCharacterConditionData");
static_assert(sizeof(FNetworkCharacterConditionData) == 0x000018, "Wrong size on FNetworkCharacterConditionData");
static_assert(offsetof(FNetworkCharacterConditionData, _serial) == 0x000000, "Member 'FNetworkCharacterConditionData::_serial' has a wrong offset!");
static_assert(offsetof(FNetworkCharacterConditionData, _conditionList) == 0x000008, "Member 'FNetworkCharacterConditionData::_conditionList' has a wrong offset!");

// ScriptStruct InGameModule.CharacterConditionParam
// 0x0010 (0x0010 - 0x0000)
struct FCharacterConditionParam final
{
public:
	ECharacterConditionGroup                      _group;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxLevel;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _priority;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bClearOnDamageBoot;                               // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bClearOnDamageBootDying;                          // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bClearOnAttackBoot;                               // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bClearOnReflesh;                                  // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterConditionParam) == 0x000004, "Wrong alignment on FCharacterConditionParam");
static_assert(sizeof(FCharacterConditionParam) == 0x000010, "Wrong size on FCharacterConditionParam");
static_assert(offsetof(FCharacterConditionParam, _group) == 0x000000, "Member 'FCharacterConditionParam::_group' has a wrong offset!");
static_assert(offsetof(FCharacterConditionParam, _maxLevel) == 0x000004, "Member 'FCharacterConditionParam::_maxLevel' has a wrong offset!");
static_assert(offsetof(FCharacterConditionParam, _priority) == 0x000008, "Member 'FCharacterConditionParam::_priority' has a wrong offset!");
static_assert(offsetof(FCharacterConditionParam, _bClearOnDamageBoot) == 0x00000C, "Member 'FCharacterConditionParam::_bClearOnDamageBoot' has a wrong offset!");
static_assert(offsetof(FCharacterConditionParam, _bClearOnDamageBootDying) == 0x00000D, "Member 'FCharacterConditionParam::_bClearOnDamageBootDying' has a wrong offset!");
static_assert(offsetof(FCharacterConditionParam, _bClearOnAttackBoot) == 0x00000E, "Member 'FCharacterConditionParam::_bClearOnAttackBoot' has a wrong offset!");
static_assert(offsetof(FCharacterConditionParam, _bClearOnReflesh) == 0x00000F, "Member 'FCharacterConditionParam::_bClearOnReflesh' has a wrong offset!");

// ScriptStruct InGameModule.TableRowCharacterCondition
// 0x0018 (0x0020 - 0x0008)
struct FTableRowCharacterCondition final : public FTableRowBase
{
public:
	TSubclassOf<class UCharacterConditionBase>    _conditionClass;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterConditionParam               _param;                                            // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTableRowCharacterCondition) == 0x000008, "Wrong alignment on FTableRowCharacterCondition");
static_assert(sizeof(FTableRowCharacterCondition) == 0x000020, "Wrong size on FTableRowCharacterCondition");
static_assert(offsetof(FTableRowCharacterCondition, _conditionClass) == 0x000008, "Member 'FTableRowCharacterCondition::_conditionClass' has a wrong offset!");
static_assert(offsetof(FTableRowCharacterCondition, _param) == 0x000010, "Member 'FTableRowCharacterCondition::_param' has a wrong offset!");

// ScriptStruct InGameModule.SimpleCharacterState
// 0x0018 (0x0018 - 0x0000)
struct FSimpleCharacterState final
{
public:
	class UAnimationAsset*                        _animation;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bLoopAnimation;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAutoChangeNext;                                  // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _nextState;                                        // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleCharacterState) == 0x000008, "Wrong alignment on FSimpleCharacterState");
static_assert(sizeof(FSimpleCharacterState) == 0x000018, "Wrong size on FSimpleCharacterState");
static_assert(offsetof(FSimpleCharacterState, _animation) == 0x000000, "Member 'FSimpleCharacterState::_animation' has a wrong offset!");
static_assert(offsetof(FSimpleCharacterState, _bLoopAnimation) == 0x000008, "Member 'FSimpleCharacterState::_bLoopAnimation' has a wrong offset!");
static_assert(offsetof(FSimpleCharacterState, _bAutoChangeNext) == 0x000009, "Member 'FSimpleCharacterState::_bAutoChangeNext' has a wrong offset!");
static_assert(offsetof(FSimpleCharacterState, _nextState) == 0x00000C, "Member 'FSimpleCharacterState::_nextState' has a wrong offset!");

// ScriptStruct InGameModule.NetDamageBootInfo
// 0x0050 (0x0050 - 0x0000)
struct FNetDamageBootInfo final
{
public:
	uint32                                        _serverPriorityActionSerialNo;                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         _damageValue;                                      // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         _guardValue;                                       // 0x0006(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _bDead : 1;                                        // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bDying : 1;                                       // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bBootDying : 1;                                   // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bSuperArmor : 1;                                  // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bBreakDown : 1;                                   // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EGuardState                                   _guardState;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _instigatedCharacter;                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 _damageCauser;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    _hitLocation;                                      // 0x0020(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _attackSerialNo;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _damageParamCharacterId;                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _damageParamName;                                  // 0x0034(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 _damageDirection;                                  // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _damageActionIndex;                                // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionKind                                   _damageActionKind;                                 // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageCauserType                             _damageCauserType;                                 // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetDamageBootInfo) == 0x000008, "Wrong alignment on FNetDamageBootInfo");
static_assert(sizeof(FNetDamageBootInfo) == 0x000050, "Wrong size on FNetDamageBootInfo");
static_assert(offsetof(FNetDamageBootInfo, _serverPriorityActionSerialNo) == 0x000000, "Member 'FNetDamageBootInfo::_serverPriorityActionSerialNo' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageValue) == 0x000004, "Member 'FNetDamageBootInfo::_damageValue' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _guardValue) == 0x000006, "Member 'FNetDamageBootInfo::_guardValue' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _guardState) == 0x00000C, "Member 'FNetDamageBootInfo::_guardState' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _instigatedCharacter) == 0x000010, "Member 'FNetDamageBootInfo::_instigatedCharacter' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageCauser) == 0x000018, "Member 'FNetDamageBootInfo::_damageCauser' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _hitLocation) == 0x000020, "Member 'FNetDamageBootInfo::_hitLocation' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _attackSerialNo) == 0x00002C, "Member 'FNetDamageBootInfo::_attackSerialNo' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageParamCharacterId) == 0x000030, "Member 'FNetDamageBootInfo::_damageParamCharacterId' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageParamName) == 0x000034, "Member 'FNetDamageBootInfo::_damageParamName' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageDirection) == 0x00003C, "Member 'FNetDamageBootInfo::_damageDirection' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageActionIndex) == 0x000048, "Member 'FNetDamageBootInfo::_damageActionIndex' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageActionKind) == 0x000049, "Member 'FNetDamageBootInfo::_damageActionKind' has a wrong offset!");
static_assert(offsetof(FNetDamageBootInfo, _damageCauserType) == 0x00004A, "Member 'FNetDamageBootInfo::_damageCauserType' has a wrong offset!");

// ScriptStruct InGameModule.TakeDamageArgument
// 0x0060 (0x0060 - 0x0000)
struct FTakeDamageArgument final
{
public:
	class ACharacterBattle*                       _instigatedCharacter;                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 _damageCauser;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    _hitLocation;                                      // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 _damageCauser_location;                            // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 _damageCauser_velocity;                            // 0x0028(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 _damageCauser_forward;                             // 0x0034(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _attackSerialNo;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _damageParamCharacterId;                           // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _damageParamName;                                  // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _uniqueLevel;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _damageAttenuation;                                // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageCauserType                             _damageCauserType;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterConditionId                         _conditionID;                                      // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _genID;                                            // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTakeDamageArgument) == 0x000008, "Wrong alignment on FTakeDamageArgument");
static_assert(sizeof(FTakeDamageArgument) == 0x000060, "Wrong size on FTakeDamageArgument");
static_assert(offsetof(FTakeDamageArgument, _instigatedCharacter) == 0x000000, "Member 'FTakeDamageArgument::_instigatedCharacter' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageCauser) == 0x000008, "Member 'FTakeDamageArgument::_damageCauser' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _hitLocation) == 0x000010, "Member 'FTakeDamageArgument::_hitLocation' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageCauser_location) == 0x00001C, "Member 'FTakeDamageArgument::_damageCauser_location' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageCauser_velocity) == 0x000028, "Member 'FTakeDamageArgument::_damageCauser_velocity' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageCauser_forward) == 0x000034, "Member 'FTakeDamageArgument::_damageCauser_forward' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _attackSerialNo) == 0x000040, "Member 'FTakeDamageArgument::_attackSerialNo' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageParamCharacterId) == 0x000044, "Member 'FTakeDamageArgument::_damageParamCharacterId' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageParamName) == 0x000048, "Member 'FTakeDamageArgument::_damageParamName' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _uniqueLevel) == 0x000050, "Member 'FTakeDamageArgument::_uniqueLevel' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageAttenuation) == 0x000054, "Member 'FTakeDamageArgument::_damageAttenuation' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _damageCauserType) == 0x000058, "Member 'FTakeDamageArgument::_damageCauserType' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _attackID) == 0x000059, "Member 'FTakeDamageArgument::_attackID' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _conditionID) == 0x00005A, "Member 'FTakeDamageArgument::_conditionID' has a wrong offset!");
static_assert(offsetof(FTakeDamageArgument, _genID) == 0x00005C, "Member 'FTakeDamageArgument::_genID' has a wrong offset!");

// ScriptStruct InGameModule.CharacterGauge
// 0x0020 (0x0020 - 0x0000)
struct FCharacterGauge final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateBattle*                     _instigatedPlayer;                                 // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterGauge) == 0x000008, "Wrong alignment on FCharacterGauge");
static_assert(sizeof(FCharacterGauge) == 0x000020, "Wrong size on FCharacterGauge");
static_assert(offsetof(FCharacterGauge, _instigatedPlayer) == 0x000018, "Member 'FCharacterGauge::_instigatedPlayer' has a wrong offset!");

// ScriptStruct InGameModule.CharacterGiantAnimationData
// 0x0058 (0x0058 - 0x0000)
struct FCharacterGiantAnimationData final
{
public:
	class UClass*                                 _animationBlueprintClass;                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAnimationId, class FName>               _changeList;                                       // 0x0008(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterGiantAnimationData) == 0x000008, "Wrong alignment on FCharacterGiantAnimationData");
static_assert(sizeof(FCharacterGiantAnimationData) == 0x000058, "Wrong size on FCharacterGiantAnimationData");
static_assert(offsetof(FCharacterGiantAnimationData, _animationBlueprintClass) == 0x000000, "Member 'FCharacterGiantAnimationData::_animationBlueprintClass' has a wrong offset!");
static_assert(offsetof(FCharacterGiantAnimationData, _changeList) == 0x000008, "Member 'FCharacterGiantAnimationData::_changeList' has a wrong offset!");

// ScriptStruct InGameModule.InteractInfo
// 0x0020 (0x0020 - 0x0000)
struct FInteractInfo final
{
public:
	class UInteractTargetComponent*               _interactTarget;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractInfo) == 0x000008, "Wrong alignment on FInteractInfo");
static_assert(sizeof(FInteractInfo) == 0x000020, "Wrong size on FInteractInfo");
static_assert(offsetof(FInteractInfo, _interactTarget) == 0x000000, "Member 'FInteractInfo::_interactTarget' has a wrong offset!");

// ScriptStruct InGameModule.RiseCementGenRep
// 0x0003 (0x0003 - 0x0000)
struct FRiseCementGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          Count;                                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bmoveFront;                                        // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRiseCementGenRep) == 0x000001, "Wrong alignment on FRiseCementGenRep");
static_assert(sizeof(FRiseCementGenRep) == 0x000003, "Wrong size on FRiseCementGenRep");
static_assert(offsetof(FRiseCementGenRep, SerialID) == 0x000000, "Member 'FRiseCementGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FRiseCementGenRep, Count) == 0x000001, "Member 'FRiseCementGenRep::Count' has a wrong offset!");
static_assert(offsetof(FRiseCementGenRep, bmoveFront) == 0x000002, "Member 'FRiseCementGenRep::bmoveFront' has a wrong offset!");

// ScriptStruct InGameModule.NetRespawnParam
// 0x0010 (0x0010 - 0x0000)
struct FNetRespawnParam final
{
public:
	struct FVector_NetQuantize                    _respawnLocation;                                  // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerId;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetRespawnParam) == 0x000004, "Wrong alignment on FNetRespawnParam");
static_assert(sizeof(FNetRespawnParam) == 0x000010, "Wrong size on FNetRespawnParam");
static_assert(offsetof(FNetRespawnParam, _respawnLocation) == 0x000000, "Member 'FNetRespawnParam::_respawnLocation' has a wrong offset!");
static_assert(offsetof(FNetRespawnParam, _playerId) == 0x00000C, "Member 'FNetRespawnParam::_playerId' has a wrong offset!");

// ScriptStruct InGameModule.SpecialActionFlags
// 0x0003 (0x0003 - 0x0000)
struct FSpecialActionFlags final
{
public:
	bool                                          _bWallDash;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bWallWalk;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bVerticalFixedWallCrawl;                          // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSpecialActionFlags) == 0x000001, "Wrong alignment on FSpecialActionFlags");
static_assert(sizeof(FSpecialActionFlags) == 0x000003, "Wrong size on FSpecialActionFlags");
static_assert(offsetof(FSpecialActionFlags, _bWallDash) == 0x000000, "Member 'FSpecialActionFlags::_bWallDash' has a wrong offset!");
static_assert(offsetof(FSpecialActionFlags, _bWallWalk) == 0x000001, "Member 'FSpecialActionFlags::_bWallWalk' has a wrong offset!");
static_assert(offsetof(FSpecialActionFlags, _bVerticalFixedWallCrawl) == 0x000002, "Member 'FSpecialActionFlags::_bVerticalFixedWallCrawl' has a wrong offset!");

// ScriptStruct InGameModule.ItemBoxSpawnGroup
// 0x0020 (0x0020 - 0x0000)
struct FItemBoxSpawnGroup final
{
public:
	TSubclassOf<class ASupplyBox>                 _itemBoxAsset;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _time;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _range;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _groupName;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _loop;                                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemBoxSpawnGroup) == 0x000008, "Wrong alignment on FItemBoxSpawnGroup");
static_assert(sizeof(FItemBoxSpawnGroup) == 0x000020, "Wrong size on FItemBoxSpawnGroup");
static_assert(offsetof(FItemBoxSpawnGroup, _itemBoxAsset) == 0x000000, "Member 'FItemBoxSpawnGroup::_itemBoxAsset' has a wrong offset!");
static_assert(offsetof(FItemBoxSpawnGroup, _time) == 0x000008, "Member 'FItemBoxSpawnGroup::_time' has a wrong offset!");
static_assert(offsetof(FItemBoxSpawnGroup, _range) == 0x00000C, "Member 'FItemBoxSpawnGroup::_range' has a wrong offset!");
static_assert(offsetof(FItemBoxSpawnGroup, _groupName) == 0x000010, "Member 'FItemBoxSpawnGroup::_groupName' has a wrong offset!");
static_assert(offsetof(FItemBoxSpawnGroup, _loop) == 0x000018, "Member 'FItemBoxSpawnGroup::_loop' has a wrong offset!");

// ScriptStruct InGameModule.ItemBoxSpawnRateTableRow
// 0x0010 (0x0018 - 0x0008)
struct FItemBoxSpawnRateTableRow final : public FTableRowBase
{
public:
	TArray<struct FItemBoxSpawnGroup>             _itemBoxSpawnGroup;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemBoxSpawnRateTableRow) == 0x000008, "Wrong alignment on FItemBoxSpawnRateTableRow");
static_assert(sizeof(FItemBoxSpawnRateTableRow) == 0x000018, "Wrong size on FItemBoxSpawnRateTableRow");
static_assert(offsetof(FItemBoxSpawnRateTableRow, _itemBoxSpawnGroup) == 0x000008, "Member 'FItemBoxSpawnRateTableRow::_itemBoxSpawnGroup' has a wrong offset!");

// ScriptStruct InGameModule.CommentaryVoicePlayListInfo
// 0x0008 (0x0008 - 0x0000)
struct FCommentaryVoicePlayListInfo final
{
public:
	ECommentaryVoiceType                          _voiceType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _cueIndex;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommentaryVoicePlayListInfo) == 0x000004, "Wrong alignment on FCommentaryVoicePlayListInfo");
static_assert(sizeof(FCommentaryVoicePlayListInfo) == 0x000008, "Wrong size on FCommentaryVoicePlayListInfo");
static_assert(offsetof(FCommentaryVoicePlayListInfo, _voiceType) == 0x000000, "Member 'FCommentaryVoicePlayListInfo::_voiceType' has a wrong offset!");
static_assert(offsetof(FCommentaryVoicePlayListInfo, _cueIndex) == 0x000004, "Member 'FCommentaryVoicePlayListInfo::_cueIndex' has a wrong offset!");

// ScriptStruct InGameModule.CommentaryVoiceInfo
// 0x0018 (0x0018 - 0x0000)
struct FCommentaryVoiceInfo final
{
public:
	ECommentaryVoiceType                          _voiceType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundAtomCue*>                  _voice;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommentaryVoiceInfo) == 0x000008, "Wrong alignment on FCommentaryVoiceInfo");
static_assert(sizeof(FCommentaryVoiceInfo) == 0x000018, "Wrong size on FCommentaryVoiceInfo");
static_assert(offsetof(FCommentaryVoiceInfo, _voiceType) == 0x000000, "Member 'FCommentaryVoiceInfo::_voiceType' has a wrong offset!");
static_assert(offsetof(FCommentaryVoiceInfo, _voice) == 0x000008, "Member 'FCommentaryVoiceInfo::_voice' has a wrong offset!");

// ScriptStruct InGameModule.StatusInfo
// 0x002C (0x002C - 0x0000)
struct alignas(0x04) FStatusInfo final
{
public:
	uint8                                         Pad_0[0x2C];                                       // 0x0000(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusInfo) == 0x000004, "Wrong alignment on FStatusInfo");
static_assert(sizeof(FStatusInfo) == 0x00002C, "Wrong size on FStatusInfo");

// ScriptStruct InGameModule.CatchGenRep
// 0x0028 (0x0028 - 0x0000)
struct FCatchGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  CharaID;                                           // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DBID;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DBIndexID;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         JsonIDX;                                           // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 TargetLocation;                                    // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCatchGenRep) == 0x000008, "Wrong alignment on FCatchGenRep");
static_assert(sizeof(FCatchGenRep) == 0x000028, "Wrong size on FCatchGenRep");
static_assert(offsetof(FCatchGenRep, SerialID) == 0x000000, "Member 'FCatchGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FCatchGenRep, CharaID) == 0x000001, "Member 'FCatchGenRep::CharaID' has a wrong offset!");
static_assert(offsetof(FCatchGenRep, DBID) == 0x000004, "Member 'FCatchGenRep::DBID' has a wrong offset!");
static_assert(offsetof(FCatchGenRep, DBIndexID) == 0x000008, "Member 'FCatchGenRep::DBIndexID' has a wrong offset!");
static_assert(offsetof(FCatchGenRep, Level) == 0x00000C, "Member 'FCatchGenRep::Level' has a wrong offset!");
static_assert(offsetof(FCatchGenRep, JsonIDX) == 0x00000D, "Member 'FCatchGenRep::JsonIDX' has a wrong offset!");
static_assert(offsetof(FCatchGenRep, TargetLocation) == 0x000010, "Member 'FCatchGenRep::TargetLocation' has a wrong offset!");
static_assert(offsetof(FCatchGenRep, TargetActor) == 0x000020, "Member 'FCatchGenRep::TargetActor' has a wrong offset!");

// ScriptStruct InGameModule.CompressReleaseGenRep
// 0x0030 (0x0030 - 0x0000)
struct FCompressReleaseGenRep final
{
public:
	ECharacterId                                  CharaID;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHashID                                DBID;                                              // 0x0004(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	struct FHashID                                DBIndexID;                                         // 0x0008(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          JsonIDX;                                           // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 TargetLocation;                                    // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 OverwriteScale;                                    // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompressReleaseGenRep) == 0x000008, "Wrong alignment on FCompressReleaseGenRep");
static_assert(sizeof(FCompressReleaseGenRep) == 0x000030, "Wrong size on FCompressReleaseGenRep");
static_assert(offsetof(FCompressReleaseGenRep, CharaID) == 0x000000, "Member 'FCompressReleaseGenRep::CharaID' has a wrong offset!");
static_assert(offsetof(FCompressReleaseGenRep, DBID) == 0x000004, "Member 'FCompressReleaseGenRep::DBID' has a wrong offset!");
static_assert(offsetof(FCompressReleaseGenRep, DBIndexID) == 0x000008, "Member 'FCompressReleaseGenRep::DBIndexID' has a wrong offset!");
static_assert(offsetof(FCompressReleaseGenRep, Level) == 0x00000C, "Member 'FCompressReleaseGenRep::Level' has a wrong offset!");
static_assert(offsetof(FCompressReleaseGenRep, JsonIDX) == 0x00000D, "Member 'FCompressReleaseGenRep::JsonIDX' has a wrong offset!");
static_assert(offsetof(FCompressReleaseGenRep, TargetLocation) == 0x000010, "Member 'FCompressReleaseGenRep::TargetLocation' has a wrong offset!");
static_assert(offsetof(FCompressReleaseGenRep, OverwriteScale) == 0x00001C, "Member 'FCompressReleaseGenRep::OverwriteScale' has a wrong offset!");
static_assert(offsetof(FCompressReleaseGenRep, TargetActor) == 0x000028, "Member 'FCompressReleaseGenRep::TargetActor' has a wrong offset!");

// ScriptStruct InGameModule.ProjectileHitRep
// 0x0060 (0x0060 - 0x0000)
struct FProjectileHitRep final
{
public:
	struct FVector_NetQuantize100                 ImpactPoint;                                       // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PHitActor;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PAttacker;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 DamageCauser_location;                             // 0x0020(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 DamageCauser_velocity;                             // 0x002C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 DamageCauser_forward;                              // 0x0038(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  DamageParamCharacter;                              // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DamageParamName;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAdjustMul;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttackId;                                          // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionID;                                       // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GenID;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bulletIndex;                                       // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastHit;                                           // 0x005D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileHitRep) == 0x000008, "Wrong alignment on FProjectileHitRep");
static_assert(sizeof(FProjectileHitRep) == 0x000060, "Wrong size on FProjectileHitRep");
static_assert(offsetof(FProjectileHitRep, ImpactPoint) == 0x000000, "Member 'FProjectileHitRep::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, PHitActor) == 0x000010, "Member 'FProjectileHitRep::PHitActor' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, PAttacker) == 0x000018, "Member 'FProjectileHitRep::PAttacker' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, DamageCauser_location) == 0x000020, "Member 'FProjectileHitRep::DamageCauser_location' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, DamageCauser_velocity) == 0x00002C, "Member 'FProjectileHitRep::DamageCauser_velocity' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, DamageCauser_forward) == 0x000038, "Member 'FProjectileHitRep::DamageCauser_forward' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, Level) == 0x000044, "Member 'FProjectileHitRep::Level' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, DamageParamCharacter) == 0x000045, "Member 'FProjectileHitRep::DamageParamCharacter' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, DamageParamName) == 0x000048, "Member 'FProjectileHitRep::DamageParamName' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, DamageAdjustMul) == 0x000050, "Member 'FProjectileHitRep::DamageAdjustMul' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, AttackId) == 0x000054, "Member 'FProjectileHitRep::AttackId' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, ConditionID) == 0x000055, "Member 'FProjectileHitRep::ConditionID' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, GenID) == 0x000058, "Member 'FProjectileHitRep::GenID' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, bulletIndex) == 0x00005C, "Member 'FProjectileHitRep::bulletIndex' has a wrong offset!");
static_assert(offsetof(FProjectileHitRep, LastHit) == 0x00005D, "Member 'FProjectileHitRep::LastHit' has a wrong offset!");

// ScriptStruct InGameModule.ConditionValue
// 0x0008 (0x0008 - 0x0000)
struct FConditionValue final
{
public:
	float                                         _value;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _span;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionValue) == 0x000004, "Wrong alignment on FConditionValue");
static_assert(sizeof(FConditionValue) == 0x000008, "Wrong size on FConditionValue");
static_assert(offsetof(FConditionValue, _value) == 0x000000, "Member 'FConditionValue::_value' has a wrong offset!");
static_assert(offsetof(FConditionValue, _span) == 0x000004, "Member 'FConditionValue::_span' has a wrong offset!");

// ScriptStruct InGameModule.TableRowConditionValue
// 0x0010 (0x0018 - 0x0008)
struct FTableRowConditionValue final : public FTableRowBase
{
public:
	TArray<struct FConditionValue>                _data;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTableRowConditionValue) == 0x000008, "Wrong alignment on FTableRowConditionValue");
static_assert(sizeof(FTableRowConditionValue) == 0x000018, "Wrong size on FTableRowConditionValue");
static_assert(offsetof(FTableRowConditionValue, _data) == 0x000008, "Member 'FTableRowConditionValue::_data' has a wrong offset!");

// ScriptStruct InGameModule.StageBarrierSpawnPointTableRow
// 0x0010 (0x0018 - 0x0008)
struct FStageBarrierSpawnPointTableRow final : public FTableRowBase
{
public:
	struct FVector                                _position;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _group;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStageBarrierSpawnPointTableRow) == 0x000008, "Wrong alignment on FStageBarrierSpawnPointTableRow");
static_assert(sizeof(FStageBarrierSpawnPointTableRow) == 0x000018, "Wrong size on FStageBarrierSpawnPointTableRow");
static_assert(offsetof(FStageBarrierSpawnPointTableRow, _position) == 0x000008, "Member 'FStageBarrierSpawnPointTableRow::_position' has a wrong offset!");
static_assert(offsetof(FStageBarrierSpawnPointTableRow, _group) == 0x000014, "Member 'FStageBarrierSpawnPointTableRow::_group' has a wrong offset!");

// ScriptStruct InGameModule.ConditionSoundData
// 0x0020 (0x0020 - 0x0000)
struct FConditionSoundData final
{
public:
	class FString                                 _CueName;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAttach;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _socketName;                                       // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bPlay2D;                                          // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEndStop;                                         // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bPlayLocalOnly;                                   // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionSoundData) == 0x000008, "Wrong alignment on FConditionSoundData");
static_assert(sizeof(FConditionSoundData) == 0x000020, "Wrong size on FConditionSoundData");
static_assert(offsetof(FConditionSoundData, _CueName) == 0x000000, "Member 'FConditionSoundData::_CueName' has a wrong offset!");
static_assert(offsetof(FConditionSoundData, _bAttach) == 0x000010, "Member 'FConditionSoundData::_bAttach' has a wrong offset!");
static_assert(offsetof(FConditionSoundData, _socketName) == 0x000014, "Member 'FConditionSoundData::_socketName' has a wrong offset!");
static_assert(offsetof(FConditionSoundData, _bPlay2D) == 0x00001C, "Member 'FConditionSoundData::_bPlay2D' has a wrong offset!");
static_assert(offsetof(FConditionSoundData, _bEndStop) == 0x00001D, "Member 'FConditionSoundData::_bEndStop' has a wrong offset!");
static_assert(offsetof(FConditionSoundData, _bPlayLocalOnly) == 0x00001E, "Member 'FConditionSoundData::_bPlayLocalOnly' has a wrong offset!");

// ScriptStruct InGameModule.ConditionEffectData
// 0x00E0 (0x00E0 - 0x0000)
struct FConditionEffectData final
{
public:
	bool                                          _bReferencedLevel;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _overLevel;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _lessLevel;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        SpawnParticle;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _spawnSeconds;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _offset;                                           // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotate;                                           // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          _bBodySizeScale;                                   // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterBodySize, float>               _bodySizeScaleMap;                                 // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	class FName                                   _socketName;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewType                                     _viewType;                                         // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _fadeOutCurve;                                     // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _fadeOutParamName;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bIgnoreRotation;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bSpawnChangeConditionLevel;                       // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bSpawnAgain;                                      // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConditionSoundData                    _SoundData;                                        // 0x00B0(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          _bEnablePostProcess;                               // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      _postProcessMaterial;                              // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionEffectData) == 0x000008, "Wrong alignment on FConditionEffectData");
static_assert(sizeof(FConditionEffectData) == 0x0000E0, "Wrong size on FConditionEffectData");
static_assert(offsetof(FConditionEffectData, _bReferencedLevel) == 0x000000, "Member 'FConditionEffectData::_bReferencedLevel' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _overLevel) == 0x000004, "Member 'FConditionEffectData::_overLevel' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _lessLevel) == 0x000008, "Member 'FConditionEffectData::_lessLevel' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, SpawnParticle) == 0x000010, "Member 'FConditionEffectData::SpawnParticle' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _spawnSeconds) == 0x000018, "Member 'FConditionEffectData::_spawnSeconds' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _offset) == 0x00001C, "Member 'FConditionEffectData::_offset' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _rotate) == 0x000028, "Member 'FConditionEffectData::_rotate' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _bBodySizeScale) == 0x000034, "Member 'FConditionEffectData::_bBodySizeScale' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _bodySizeScaleMap) == 0x000038, "Member 'FConditionEffectData::_bodySizeScaleMap' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _socketName) == 0x000088, "Member 'FConditionEffectData::_socketName' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _viewType) == 0x000090, "Member 'FConditionEffectData::_viewType' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _fadeOutCurve) == 0x000098, "Member 'FConditionEffectData::_fadeOutCurve' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _fadeOutParamName) == 0x0000A0, "Member 'FConditionEffectData::_fadeOutParamName' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _bIgnoreRotation) == 0x0000A8, "Member 'FConditionEffectData::_bIgnoreRotation' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _bSpawnChangeConditionLevel) == 0x0000A9, "Member 'FConditionEffectData::_bSpawnChangeConditionLevel' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _bSpawnAgain) == 0x0000AA, "Member 'FConditionEffectData::_bSpawnAgain' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _SoundData) == 0x0000B0, "Member 'FConditionEffectData::_SoundData' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _bEnablePostProcess) == 0x0000D0, "Member 'FConditionEffectData::_bEnablePostProcess' has a wrong offset!");
static_assert(offsetof(FConditionEffectData, _postProcessMaterial) == 0x0000D8, "Member 'FConditionEffectData::_postProcessMaterial' has a wrong offset!");

// ScriptStruct InGameModule.ConditionDataList
// 0x0020 (0x0020 - 0x0000)
struct FConditionDataList final
{
public:
	TArray<struct FConditionEffectData>           _conditionEffectDataList;                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FConditionEffectData>           _destroyEffectDataList;                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionDataList) == 0x000008, "Wrong alignment on FConditionDataList");
static_assert(sizeof(FConditionDataList) == 0x000020, "Wrong size on FConditionDataList");
static_assert(offsetof(FConditionDataList, _conditionEffectDataList) == 0x000000, "Member 'FConditionDataList::_conditionEffectDataList' has a wrong offset!");
static_assert(offsetof(FConditionDataList, _destroyEffectDataList) == 0x000010, "Member 'FConditionDataList::_destroyEffectDataList' has a wrong offset!");

// ScriptStruct InGameModule.SupplyLobbySpawnPointTableRow
// 0x0018 (0x0020 - 0x0008)
struct FSupplyLobbySpawnPointTableRow final : public FTableRowBase
{
public:
	struct FVector                                _position;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _group;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _supplyType;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSupplyLobbySpawnPointTableRow) == 0x000008, "Wrong alignment on FSupplyLobbySpawnPointTableRow");
static_assert(sizeof(FSupplyLobbySpawnPointTableRow) == 0x000020, "Wrong size on FSupplyLobbySpawnPointTableRow");
static_assert(offsetof(FSupplyLobbySpawnPointTableRow, _position) == 0x000008, "Member 'FSupplyLobbySpawnPointTableRow::_position' has a wrong offset!");
static_assert(offsetof(FSupplyLobbySpawnPointTableRow, _group) == 0x000014, "Member 'FSupplyLobbySpawnPointTableRow::_group' has a wrong offset!");
static_assert(offsetof(FSupplyLobbySpawnPointTableRow, _supplyType) == 0x000018, "Member 'FSupplyLobbySpawnPointTableRow::_supplyType' has a wrong offset!");

// ScriptStruct InGameModule.ConditionMaterialData
// 0x0010 (0x0010 - 0x0000)
struct FConditionMaterialData final
{
public:
	class FString                                 _presetName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionMaterialData) == 0x000008, "Wrong alignment on FConditionMaterialData");
static_assert(sizeof(FConditionMaterialData) == 0x000010, "Wrong size on FConditionMaterialData");
static_assert(offsetof(FConditionMaterialData, _presetName) == 0x000000, "Member 'FConditionMaterialData::_presetName' has a wrong offset!");

// ScriptStruct InGameModule.SupplyBoxSpawnPointTableRow
// 0x0020 (0x0028 - 0x0008)
struct FSupplyBoxSpawnPointTableRow final : public FTableRowBase
{
public:
	struct FVector                                _position;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotation;                                         // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         _areaCode;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAlwaysSpawn;                                     // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupplyBoxSize                                _supplyBoxSize;                                    // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupplyBoxSpawnType                           _supplyBoxSpawnType;                               // 0x0026(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSupplyBoxSpawnPointTableRow) == 0x000008, "Wrong alignment on FSupplyBoxSpawnPointTableRow");
static_assert(sizeof(FSupplyBoxSpawnPointTableRow) == 0x000028, "Wrong size on FSupplyBoxSpawnPointTableRow");
static_assert(offsetof(FSupplyBoxSpawnPointTableRow, _position) == 0x000008, "Member 'FSupplyBoxSpawnPointTableRow::_position' has a wrong offset!");
static_assert(offsetof(FSupplyBoxSpawnPointTableRow, _rotation) == 0x000014, "Member 'FSupplyBoxSpawnPointTableRow::_rotation' has a wrong offset!");
static_assert(offsetof(FSupplyBoxSpawnPointTableRow, _areaCode) == 0x000020, "Member 'FSupplyBoxSpawnPointTableRow::_areaCode' has a wrong offset!");
static_assert(offsetof(FSupplyBoxSpawnPointTableRow, _bAlwaysSpawn) == 0x000024, "Member 'FSupplyBoxSpawnPointTableRow::_bAlwaysSpawn' has a wrong offset!");
static_assert(offsetof(FSupplyBoxSpawnPointTableRow, _supplyBoxSize) == 0x000025, "Member 'FSupplyBoxSpawnPointTableRow::_supplyBoxSize' has a wrong offset!");
static_assert(offsetof(FSupplyBoxSpawnPointTableRow, _supplyBoxSpawnType) == 0x000026, "Member 'FSupplyBoxSpawnPointTableRow::_supplyBoxSpawnType' has a wrong offset!");

// ScriptStruct InGameModule.HitWallResult
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FHitWallResult final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitWallResult) == 0x000010, "Wrong alignment on FHitWallResult");
static_assert(sizeof(FHitWallResult) == 0x000050, "Wrong size on FHitWallResult");

// ScriptStruct InGameModule.CustomBulletGroundDecal
// 0x0010 (0x0010 - 0x0000)
struct FCustomBulletGroundDecal final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    DecalObject;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomBulletGroundDecal) == 0x000008, "Wrong alignment on FCustomBulletGroundDecal");
static_assert(sizeof(FCustomBulletGroundDecal) == 0x000010, "Wrong size on FCustomBulletGroundDecal");
static_assert(offsetof(FCustomBulletGroundDecal, Interval) == 0x000000, "Member 'FCustomBulletGroundDecal::Interval' has a wrong offset!");
static_assert(offsetof(FCustomBulletGroundDecal, DecalObject) == 0x000008, "Member 'FCustomBulletGroundDecal::DecalObject' has a wrong offset!");

// ScriptStruct InGameModule.CopyModeData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FCopyModeData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCopyModeData) == 0x000004, "Wrong alignment on FCopyModeData");
static_assert(sizeof(FCopyModeData) == 0x000008, "Wrong size on FCopyModeData");

// ScriptStruct InGameModule.CustomBulletGroundEffect
// 0x0008 (0x0008 - 0x0000)
struct FCustomBulletGroundEffect final
{
public:
	float                                         CheckHeight;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactHeightOffset;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomBulletGroundEffect) == 0x000004, "Wrong alignment on FCustomBulletGroundEffect");
static_assert(sizeof(FCustomBulletGroundEffect) == 0x000008, "Wrong size on FCustomBulletGroundEffect");
static_assert(offsetof(FCustomBulletGroundEffect, CheckHeight) == 0x000000, "Member 'FCustomBulletGroundEffect::CheckHeight' has a wrong offset!");
static_assert(offsetof(FCustomBulletGroundEffect, ImpactHeightOffset) == 0x000004, "Member 'FCustomBulletGroundEffect::ImpactHeightOffset' has a wrong offset!");

// ScriptStruct InGameModule.DamageIndicatorInfo
// 0x0020 (0x0020 - 0x0000)
struct FDamageIndicatorInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _instigator;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageIndicatorInfo) == 0x000008, "Wrong alignment on FDamageIndicatorInfo");
static_assert(sizeof(FDamageIndicatorInfo) == 0x000020, "Wrong size on FDamageIndicatorInfo");
static_assert(offsetof(FDamageIndicatorInfo, _instigator) == 0x000008, "Member 'FDamageIndicatorInfo::_instigator' has a wrong offset!");

// ScriptStruct InGameModule.NetSupplyHolderData
// 0x0030 (0x0030 - 0x0000)
struct FNetSupplyHolderData final
{
public:
	TArray<uint32>                                _serverSerialList;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                _levelList;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          _bEnable;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _index;                                            // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupplyHolderType                             _type;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupplyManipulationType                       _manipulation;                                     // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetSupplyHolderData) == 0x000008, "Wrong alignment on FNetSupplyHolderData");
static_assert(sizeof(FNetSupplyHolderData) == 0x000030, "Wrong size on FNetSupplyHolderData");
static_assert(offsetof(FNetSupplyHolderData, _serverSerialList) == 0x000000, "Member 'FNetSupplyHolderData::_serverSerialList' has a wrong offset!");
static_assert(offsetof(FNetSupplyHolderData, _levelList) == 0x000010, "Member 'FNetSupplyHolderData::_levelList' has a wrong offset!");
static_assert(offsetof(FNetSupplyHolderData, _bEnable) == 0x000020, "Member 'FNetSupplyHolderData::_bEnable' has a wrong offset!");
static_assert(offsetof(FNetSupplyHolderData, _index) == 0x000024, "Member 'FNetSupplyHolderData::_index' has a wrong offset!");
static_assert(offsetof(FNetSupplyHolderData, _type) == 0x000028, "Member 'FNetSupplyHolderData::_type' has a wrong offset!");
static_assert(offsetof(FNetSupplyHolderData, _manipulation) == 0x000029, "Member 'FNetSupplyHolderData::_manipulation' has a wrong offset!");

// ScriptStruct InGameModule.DogTagInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDogTagInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDogTagInfo) == 0x000008, "Wrong alignment on FDogTagInfo");
static_assert(sizeof(FDogTagInfo) == 0x000018, "Wrong size on FDogTagInfo");

// ScriptStruct InGameModule.SupplySpawnPointTableRow
// 0x0018 (0x0020 - 0x0008)
struct FSupplySpawnPointTableRow final : public FTableRowBase
{
public:
	struct FVector                                _position;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _group;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupplyCode                                   _supplyType;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAlwaysSpawn;                                     // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSupplySpawnPointTableRow) == 0x000008, "Wrong alignment on FSupplySpawnPointTableRow");
static_assert(sizeof(FSupplySpawnPointTableRow) == 0x000020, "Wrong size on FSupplySpawnPointTableRow");
static_assert(offsetof(FSupplySpawnPointTableRow, _position) == 0x000008, "Member 'FSupplySpawnPointTableRow::_position' has a wrong offset!");
static_assert(offsetof(FSupplySpawnPointTableRow, _group) == 0x000014, "Member 'FSupplySpawnPointTableRow::_group' has a wrong offset!");
static_assert(offsetof(FSupplySpawnPointTableRow, _supplyType) == 0x000018, "Member 'FSupplySpawnPointTableRow::_supplyType' has a wrong offset!");
static_assert(offsetof(FSupplySpawnPointTableRow, _bAlwaysSpawn) == 0x000019, "Member 'FSupplySpawnPointTableRow::_bAlwaysSpawn' has a wrong offset!");

// ScriptStruct InGameModule.DogTagData
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x02) FDogTagData final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDogTagData) == 0x000002, "Wrong alignment on FDogTagData");
static_assert(sizeof(FDogTagData) == 0x000004, "Wrong size on FDogTagData");

// ScriptStruct InGameModule.DuplicationData
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x10) FDuplicationData final
{
public:
	bool                                          _bStocking;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _charaId;                                          // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerId;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x12D];                                      // 0x0003(0x012D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDuplicationData) == 0x000010, "Wrong alignment on FDuplicationData");
static_assert(sizeof(FDuplicationData) == 0x000130, "Wrong size on FDuplicationData");
static_assert(offsetof(FDuplicationData, _bStocking) == 0x000000, "Member 'FDuplicationData::_bStocking' has a wrong offset!");
static_assert(offsetof(FDuplicationData, _charaId) == 0x000001, "Member 'FDuplicationData::_charaId' has a wrong offset!");
static_assert(offsetof(FDuplicationData, _playerId) == 0x000002, "Member 'FDuplicationData::_playerId' has a wrong offset!");

// ScriptStruct InGameModule.SupplyHolderOldData
// 0x0002 (0x0002 - 0x0000)
struct FSupplyHolderOldData final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSupplyHolderOldData) == 0x000001, "Wrong alignment on FSupplyHolderOldData");
static_assert(sizeof(FSupplyHolderOldData) == 0x000002, "Wrong size on FSupplyHolderOldData");

// ScriptStruct InGameModule.EffectScaleInfo
// 0x0010 (0x0010 - 0x0000)
struct FEffectScaleInfo final
{
public:
	ERestraintType                                _restraintType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _scale;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectScaleInfo) == 0x000004, "Wrong alignment on FEffectScaleInfo");
static_assert(sizeof(FEffectScaleInfo) == 0x000010, "Wrong size on FEffectScaleInfo");
static_assert(offsetof(FEffectScaleInfo, _restraintType) == 0x000000, "Member 'FEffectScaleInfo::_restraintType' has a wrong offset!");
static_assert(offsetof(FEffectScaleInfo, _scale) == 0x000004, "Member 'FEffectScaleInfo::_scale' has a wrong offset!");

// ScriptStruct InGameModule.EffectScaleTableRow
// 0x0010 (0x0018 - 0x0008)
struct FEffectScaleTableRow final : public FTableRowBase
{
public:
	TArray<struct FEffectScaleInfo>               _info;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectScaleTableRow) == 0x000008, "Wrong alignment on FEffectScaleTableRow");
static_assert(sizeof(FEffectScaleTableRow) == 0x000018, "Wrong size on FEffectScaleTableRow");
static_assert(offsetof(FEffectScaleTableRow, _info) == 0x000008, "Member 'FEffectScaleTableRow::_info' has a wrong offset!");

// ScriptStruct InGameModule.FanShapedInfo
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x10) FFanShapedInfo final
{
public:
	uint8                                         Pad_0[0x88];                                       // 0x0000(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                _spawnParticleList;                                // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGraduallyAlpha>                _graduallyAlpha;                                   // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFanShapedInfo) == 0x000010, "Wrong alignment on FFanShapedInfo");
static_assert(sizeof(FFanShapedInfo) == 0x0000C0, "Wrong size on FFanShapedInfo");
static_assert(offsetof(FFanShapedInfo, _spawnParticleList) == 0x000088, "Member 'FFanShapedInfo::_spawnParticleList' has a wrong offset!");
static_assert(offsetof(FFanShapedInfo, _graduallyAlpha) == 0x0000B0, "Member 'FFanShapedInfo::_graduallyAlpha' has a wrong offset!");

// ScriptStruct InGameModule.MoveFogGrabRep
// 0x0018 (0x0018 - 0x0000)
struct FMoveFogGrabRep final
{
public:
	struct FVector_NetQuantize100                 CurrentVelocity;                                   // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentRotator;                                    // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveFogGrabRep) == 0x000004, "Wrong alignment on FMoveFogGrabRep");
static_assert(sizeof(FMoveFogGrabRep) == 0x000018, "Wrong size on FMoveFogGrabRep");
static_assert(offsetof(FMoveFogGrabRep, CurrentVelocity) == 0x000000, "Member 'FMoveFogGrabRep::CurrentVelocity' has a wrong offset!");
static_assert(offsetof(FMoveFogGrabRep, CurrentRotator) == 0x00000C, "Member 'FMoveFogGrabRep::CurrentRotator' has a wrong offset!");

// ScriptStruct InGameModule.BotInfoToSpawn
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FBotInfoToSpawn final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotInfoToSpawn) == 0x000004, "Wrong alignment on FBotInfoToSpawn");
static_assert(sizeof(FBotInfoToSpawn) == 0x000010, "Wrong size on FBotInfoToSpawn");

// ScriptStruct InGameModule.GameTeamInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FGameTeamInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameTeamInfo) == 0x000008, "Wrong alignment on FGameTeamInfo");
static_assert(sizeof(FGameTeamInfo) == 0x000020, "Wrong size on FGameTeamInfo");

// ScriptStruct InGameModule.GimmickSpawnMaxInfo
// 0x0008 (0x0008 - 0x0000)
struct FGimmickSpawnMaxInfo final
{
public:
	EGimmickCode                                  _code;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _spawnMax;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGimmickSpawnMaxInfo) == 0x000004, "Wrong alignment on FGimmickSpawnMaxInfo");
static_assert(sizeof(FGimmickSpawnMaxInfo) == 0x000008, "Wrong size on FGimmickSpawnMaxInfo");
static_assert(offsetof(FGimmickSpawnMaxInfo, _code) == 0x000000, "Member 'FGimmickSpawnMaxInfo::_code' has a wrong offset!");
static_assert(offsetof(FGimmickSpawnMaxInfo, _spawnMax) == 0x000004, "Member 'FGimmickSpawnMaxInfo::_spawnMax' has a wrong offset!");

// ScriptStruct InGameModule.GimmickSpawnParam
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FGimmickSpawnParam final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGimmickSpawnParam) == 0x000010, "Wrong alignment on FGimmickSpawnParam");
static_assert(sizeof(FGimmickSpawnParam) == 0x000040, "Wrong size on FGimmickSpawnParam");

// ScriptStruct InGameModule.GimmickSpawnPointTableRow
// 0x0020 (0x0028 - 0x0008)
struct FGimmickSpawnPointTableRow final : public FTableRowBase
{
public:
	struct FVector                                _position;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotation;                                         // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EGimmickCode                                  _gimmickCode;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAlwaysSpawn;                                     // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGimmickSpawnPointTableRow) == 0x000008, "Wrong alignment on FGimmickSpawnPointTableRow");
static_assert(sizeof(FGimmickSpawnPointTableRow) == 0x000028, "Wrong size on FGimmickSpawnPointTableRow");
static_assert(offsetof(FGimmickSpawnPointTableRow, _position) == 0x000008, "Member 'FGimmickSpawnPointTableRow::_position' has a wrong offset!");
static_assert(offsetof(FGimmickSpawnPointTableRow, _rotation) == 0x000014, "Member 'FGimmickSpawnPointTableRow::_rotation' has a wrong offset!");
static_assert(offsetof(FGimmickSpawnPointTableRow, _gimmickCode) == 0x000020, "Member 'FGimmickSpawnPointTableRow::_gimmickCode' has a wrong offset!");
static_assert(offsetof(FGimmickSpawnPointTableRow, _bAlwaysSpawn) == 0x000021, "Member 'FGimmickSpawnPointTableRow::_bAlwaysSpawn' has a wrong offset!");

// ScriptStruct InGameModule.GraduallyAlphaRow
// 0x0018 (0x0020 - 0x0008)
struct FGraduallyAlphaRow final : public FTableRowBase
{
public:
	float                                         beginDist;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDist;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAlpha;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGraduallyAlphaRow) == 0x000008, "Wrong alignment on FGraduallyAlphaRow");
static_assert(sizeof(FGraduallyAlphaRow) == 0x000020, "Wrong size on FGraduallyAlphaRow");
static_assert(offsetof(FGraduallyAlphaRow, beginDist) == 0x000008, "Member 'FGraduallyAlphaRow::beginDist' has a wrong offset!");
static_assert(offsetof(FGraduallyAlphaRow, EndDist) == 0x00000C, "Member 'FGraduallyAlphaRow::EndDist' has a wrong offset!");
static_assert(offsetof(FGraduallyAlphaRow, EndAlpha) == 0x000010, "Member 'FGraduallyAlphaRow::EndAlpha' has a wrong offset!");
static_assert(offsetof(FGraduallyAlphaRow, ParameterName) == 0x000014, "Member 'FGraduallyAlphaRow::ParameterName' has a wrong offset!");

// ScriptStruct InGameModule.EnableXYZ
// 0x0003 (0x0003 - 0x0000)
struct FEnableXYZ final
{
public:
	bool                                          _pich;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _yaw;                                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _roll;                                             // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnableXYZ) == 0x000001, "Wrong alignment on FEnableXYZ");
static_assert(sizeof(FEnableXYZ) == 0x000003, "Wrong size on FEnableXYZ");
static_assert(offsetof(FEnableXYZ, _pich) == 0x000000, "Member 'FEnableXYZ::_pich' has a wrong offset!");
static_assert(offsetof(FEnableXYZ, _yaw) == 0x000001, "Member 'FEnableXYZ::_yaw' has a wrong offset!");
static_assert(offsetof(FEnableXYZ, _roll) == 0x000002, "Member 'FEnableXYZ::_roll' has a wrong offset!");

// ScriptStruct InGameModule.GroundShavingDecal
// 0x0010 (0x0010 - 0x0000)
struct FGroundShavingDecal final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    DecalObject;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundShavingDecal) == 0x000008, "Wrong alignment on FGroundShavingDecal");
static_assert(sizeof(FGroundShavingDecal) == 0x000010, "Wrong size on FGroundShavingDecal");
static_assert(offsetof(FGroundShavingDecal, Interval) == 0x000000, "Member 'FGroundShavingDecal::Interval' has a wrong offset!");
static_assert(offsetof(FGroundShavingDecal, DecalObject) == 0x000008, "Member 'FGroundShavingDecal::DecalObject' has a wrong offset!");

// ScriptStruct InGameModule.GroundShavingEffect
// 0x0008 (0x0008 - 0x0000)
struct FGroundShavingEffect final
{
public:
	float                                         CheckHeight;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactHeightOffset;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundShavingEffect) == 0x000004, "Wrong alignment on FGroundShavingEffect");
static_assert(sizeof(FGroundShavingEffect) == 0x000008, "Wrong size on FGroundShavingEffect");
static_assert(offsetof(FGroundShavingEffect, CheckHeight) == 0x000000, "Member 'FGroundShavingEffect::CheckHeight' has a wrong offset!");
static_assert(offsetof(FGroundShavingEffect, ImpactHeightOffset) == 0x000004, "Member 'FGroundShavingEffect::ImpactHeightOffset' has a wrong offset!");

// ScriptStruct InGameModule.HairMeshSetup
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x10) FHairMeshSetup final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Mesh;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   baseBoneName;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodeCount;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckLoopNodeCount;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x14];                                      // 0x0020(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReverseWait;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    baseHitPrimitive;                                  // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleSize;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHairMeshSetup) == 0x000010, "Wrong alignment on FHairMeshSetup");
static_assert(sizeof(FHairMeshSetup) == 0x0000A0, "Wrong size on FHairMeshSetup");
static_assert(offsetof(FHairMeshSetup, Mesh) == 0x000008, "Member 'FHairMeshSetup::Mesh' has a wrong offset!");
static_assert(offsetof(FHairMeshSetup, baseBoneName) == 0x000010, "Member 'FHairMeshSetup::baseBoneName' has a wrong offset!");
static_assert(offsetof(FHairMeshSetup, NodeCount) == 0x000018, "Member 'FHairMeshSetup::NodeCount' has a wrong offset!");
static_assert(offsetof(FHairMeshSetup, CheckLoopNodeCount) == 0x00001C, "Member 'FHairMeshSetup::CheckLoopNodeCount' has a wrong offset!");
static_assert(offsetof(FHairMeshSetup, ReverseWait) == 0x000034, "Member 'FHairMeshSetup::ReverseWait' has a wrong offset!");
static_assert(offsetof(FHairMeshSetup, baseHitPrimitive) == 0x000088, "Member 'FHairMeshSetup::baseHitPrimitive' has a wrong offset!");
static_assert(offsetof(FHairMeshSetup, CapsuleSize) == 0x000090, "Member 'FHairMeshSetup::CapsuleSize' has a wrong offset!");

// ScriptStruct InGameModule.HairSplineSetup
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FHairSplineSetup final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodeCount;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonTargetSpeedRate;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingRate;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextNodeTime;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverseWait;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Quake;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x44];                                      // 0x002C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHairSplineSetup) == 0x000010, "Wrong alignment on FHairSplineSetup");
static_assert(sizeof(FHairSplineSetup) == 0x000070, "Wrong size on FHairSplineSetup");
static_assert(offsetof(FHairSplineSetup, Mesh) == 0x000008, "Member 'FHairSplineSetup::Mesh' has a wrong offset!");
static_assert(offsetof(FHairSplineSetup, NodeCount) == 0x000010, "Member 'FHairSplineSetup::NodeCount' has a wrong offset!");
static_assert(offsetof(FHairSplineSetup, Speed) == 0x000014, "Member 'FHairSplineSetup::Speed' has a wrong offset!");
static_assert(offsetof(FHairSplineSetup, NonTargetSpeedRate) == 0x000018, "Member 'FHairSplineSetup::NonTargetSpeedRate' has a wrong offset!");
static_assert(offsetof(FHairSplineSetup, HomingRate) == 0x00001C, "Member 'FHairSplineSetup::HomingRate' has a wrong offset!");
static_assert(offsetof(FHairSplineSetup, NextNodeTime) == 0x000020, "Member 'FHairSplineSetup::NextNodeTime' has a wrong offset!");
static_assert(offsetof(FHairSplineSetup, ReverseWait) == 0x000024, "Member 'FHairSplineSetup::ReverseWait' has a wrong offset!");
static_assert(offsetof(FHairSplineSetup, Quake) == 0x000028, "Member 'FHairSplineSetup::Quake' has a wrong offset!");

// ScriptStruct InGameModule.HeroShapeImpl
// 0x0200 (0x0200 - 0x0000)
struct alignas(0x10) FHeroShapeImpl final
{
public:
	bool                                          _bulletBlock;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _meleeBulletBlock;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enemyBulletThrow;                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _friendBulletThrow;                                // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _usedMultiTrace;                                   // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _receiveOnly;                                      // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _generatedMoveStop;                                // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameBlockType                                _gameBlockType;                                    // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8[0x178];                                      // 0x0008(0x0178)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _ownerPrim;                                        // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterBattle*                       _ownerBtl;                                         // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBulletManageList*                      _bulletManagerList;                                // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x30];                                     // 0x0198(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _workIgnoreTbl;                                    // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x28];                                     // 0x01D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroShapeImpl) == 0x000010, "Wrong alignment on FHeroShapeImpl");
static_assert(sizeof(FHeroShapeImpl) == 0x000200, "Wrong size on FHeroShapeImpl");
static_assert(offsetof(FHeroShapeImpl, _bulletBlock) == 0x000000, "Member 'FHeroShapeImpl::_bulletBlock' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _meleeBulletBlock) == 0x000001, "Member 'FHeroShapeImpl::_meleeBulletBlock' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _enemyBulletThrow) == 0x000002, "Member 'FHeroShapeImpl::_enemyBulletThrow' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _friendBulletThrow) == 0x000003, "Member 'FHeroShapeImpl::_friendBulletThrow' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _usedMultiTrace) == 0x000004, "Member 'FHeroShapeImpl::_usedMultiTrace' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _receiveOnly) == 0x000005, "Member 'FHeroShapeImpl::_receiveOnly' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _generatedMoveStop) == 0x000006, "Member 'FHeroShapeImpl::_generatedMoveStop' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _gameBlockType) == 0x000007, "Member 'FHeroShapeImpl::_gameBlockType' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _ownerPrim) == 0x000180, "Member 'FHeroShapeImpl::_ownerPrim' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _ownerBtl) == 0x000188, "Member 'FHeroShapeImpl::_ownerBtl' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _bulletManagerList) == 0x000190, "Member 'FHeroShapeImpl::_bulletManagerList' has a wrong offset!");
static_assert(offsetof(FHeroShapeImpl, _workIgnoreTbl) == 0x0001C8, "Member 'FHeroShapeImpl::_workIgnoreTbl' has a wrong offset!");

// ScriptStruct InGameModule.HitEffectCorrectionOffsetInfo
// 0x000C (0x000C - 0x0000)
struct FHitEffectCorrectionOffsetInfo final
{
public:
	float                                         _offsetSize;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _minOffsetDistance;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _maxOffsetDistance;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitEffectCorrectionOffsetInfo) == 0x000004, "Wrong alignment on FHitEffectCorrectionOffsetInfo");
static_assert(sizeof(FHitEffectCorrectionOffsetInfo) == 0x00000C, "Wrong size on FHitEffectCorrectionOffsetInfo");
static_assert(offsetof(FHitEffectCorrectionOffsetInfo, _offsetSize) == 0x000000, "Member 'FHitEffectCorrectionOffsetInfo::_offsetSize' has a wrong offset!");
static_assert(offsetof(FHitEffectCorrectionOffsetInfo, _minOffsetDistance) == 0x000004, "Member 'FHitEffectCorrectionOffsetInfo::_minOffsetDistance' has a wrong offset!");
static_assert(offsetof(FHitEffectCorrectionOffsetInfo, _maxOffsetDistance) == 0x000008, "Member 'FHitEffectCorrectionOffsetInfo::_maxOffsetDistance' has a wrong offset!");

// ScriptStruct InGameModule.HitEffectCorrectionScaleInfo
// 0x000C (0x000C - 0x0000)
struct FHitEffectCorrectionScaleInfo final
{
public:
	float                                         _scaleSize;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _minScaleDistance;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _maxScaleDistance;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitEffectCorrectionScaleInfo) == 0x000004, "Wrong alignment on FHitEffectCorrectionScaleInfo");
static_assert(sizeof(FHitEffectCorrectionScaleInfo) == 0x00000C, "Wrong size on FHitEffectCorrectionScaleInfo");
static_assert(offsetof(FHitEffectCorrectionScaleInfo, _scaleSize) == 0x000000, "Member 'FHitEffectCorrectionScaleInfo::_scaleSize' has a wrong offset!");
static_assert(offsetof(FHitEffectCorrectionScaleInfo, _minScaleDistance) == 0x000004, "Member 'FHitEffectCorrectionScaleInfo::_minScaleDistance' has a wrong offset!");
static_assert(offsetof(FHitEffectCorrectionScaleInfo, _maxScaleDistance) == 0x000008, "Member 'FHitEffectCorrectionScaleInfo::_maxScaleDistance' has a wrong offset!");

// ScriptStruct InGameModule.HitEffectCorrectionInfo
// 0x0018 (0x0018 - 0x0000)
struct FHitEffectCorrectionInfo final
{
public:
	struct FHitEffectCorrectionOffsetInfo         _offsetInfo;                                       // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitEffectCorrectionScaleInfo          _scaleInfo;                                        // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitEffectCorrectionInfo) == 0x000004, "Wrong alignment on FHitEffectCorrectionInfo");
static_assert(sizeof(FHitEffectCorrectionInfo) == 0x000018, "Wrong size on FHitEffectCorrectionInfo");
static_assert(offsetof(FHitEffectCorrectionInfo, _offsetInfo) == 0x000000, "Member 'FHitEffectCorrectionInfo::_offsetInfo' has a wrong offset!");
static_assert(offsetof(FHitEffectCorrectionInfo, _scaleInfo) == 0x00000C, "Member 'FHitEffectCorrectionInfo::_scaleInfo' has a wrong offset!");

// ScriptStruct InGameModule.HitEffectInfo
// 0x0018 (0x0018 - 0x0000)
struct FHitEffectInfo final
{
public:
	class UParticleSystem*                        _effectParticle;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _soundCueName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultScale;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitEffectInfo) == 0x000008, "Wrong alignment on FHitEffectInfo");
static_assert(sizeof(FHitEffectInfo) == 0x000018, "Wrong size on FHitEffectInfo");
static_assert(offsetof(FHitEffectInfo, _effectParticle) == 0x000000, "Member 'FHitEffectInfo::_effectParticle' has a wrong offset!");
static_assert(offsetof(FHitEffectInfo, _soundCueName) == 0x000008, "Member 'FHitEffectInfo::_soundCueName' has a wrong offset!");
static_assert(offsetof(FHitEffectInfo, _defaultScale) == 0x000010, "Member 'FHitEffectInfo::_defaultScale' has a wrong offset!");

// ScriptStruct InGameModule.CharacterIndividualHudData
// 0x0060 (0x0068 - 0x0008)
struct FCharacterIndividualHudData final : public FTableRowBase
{
public:
	class FString                                 _characterName;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            _characterFaceSprite;                              // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStringTable>            _symbolChatStringTable;                            // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterIndividualHudData) == 0x000008, "Wrong alignment on FCharacterIndividualHudData");
static_assert(sizeof(FCharacterIndividualHudData) == 0x000068, "Wrong size on FCharacterIndividualHudData");
static_assert(offsetof(FCharacterIndividualHudData, _characterName) == 0x000008, "Member 'FCharacterIndividualHudData::_characterName' has a wrong offset!");
static_assert(offsetof(FCharacterIndividualHudData, _characterFaceSprite) == 0x000018, "Member 'FCharacterIndividualHudData::_characterFaceSprite' has a wrong offset!");
static_assert(offsetof(FCharacterIndividualHudData, _symbolChatStringTable) == 0x000040, "Member 'FCharacterIndividualHudData::_symbolChatStringTable' has a wrong offset!");

// ScriptStruct InGameModule.EmoteCommandTableRow
// 0x0030 (0x0038 - 0x0008)
struct FEmoteCommandTableRow final : public FTableRowBase
{
public:
	class UPaperSprite*                           _iconSprite;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         _emoteAnim;                                        // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmoteCommandTableRow) == 0x000008, "Wrong alignment on FEmoteCommandTableRow");
static_assert(sizeof(FEmoteCommandTableRow) == 0x000038, "Wrong size on FEmoteCommandTableRow");
static_assert(offsetof(FEmoteCommandTableRow, _iconSprite) == 0x000008, "Member 'FEmoteCommandTableRow::_iconSprite' has a wrong offset!");
static_assert(offsetof(FEmoteCommandTableRow, _emoteAnim) == 0x000010, "Member 'FEmoteCommandTableRow::_emoteAnim' has a wrong offset!");

// ScriptStruct InGameModule.HudCommandTableRow
// 0x0020 (0x0028 - 0x0008)
struct FHudCommandTableRow final : public FTableRowBase
{
public:
	class UPaperSprite*                           _iconSprite;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   _iconDescription;                                  // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHudCommandTableRow) == 0x000008, "Wrong alignment on FHudCommandTableRow");
static_assert(sizeof(FHudCommandTableRow) == 0x000028, "Wrong size on FHudCommandTableRow");
static_assert(offsetof(FHudCommandTableRow, _iconSprite) == 0x000008, "Member 'FHudCommandTableRow::_iconSprite' has a wrong offset!");
static_assert(offsetof(FHudCommandTableRow, _iconDescription) == 0x000010, "Member 'FHudCommandTableRow::_iconDescription' has a wrong offset!");

// ScriptStruct InGameModule.MagazineViewInfo
// 0x0028 (0x0028 - 0x0000)
struct FMagazineViewInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGSkillMagazine*                      _skill;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMagazineViewInfo) == 0x000008, "Wrong alignment on FMagazineViewInfo");
static_assert(sizeof(FMagazineViewInfo) == 0x000028, "Wrong size on FMagazineViewInfo");
static_assert(offsetof(FMagazineViewInfo, _skill) == 0x000008, "Member 'FMagazineViewInfo::_skill' has a wrong offset!");

// ScriptStruct InGameModule.DebugFieldLoadMagazineInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FDebugFieldLoadMagazineInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugFieldLoadMagazineInfo) == 0x000008, "Wrong alignment on FDebugFieldLoadMagazineInfo");
static_assert(sizeof(FDebugFieldLoadMagazineInfo) == 0x000030, "Wrong size on FDebugFieldLoadMagazineInfo");

// ScriptStruct InGameModule.GroundMaterialRow
// 0x0018 (0x0020 - 0x0008)
struct FGroundMaterialRow final : public FTableRowBase
{
public:
	class UMaterialInstance*                      _ice;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _fire;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _spark;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundMaterialRow) == 0x000008, "Wrong alignment on FGroundMaterialRow");
static_assert(sizeof(FGroundMaterialRow) == 0x000020, "Wrong size on FGroundMaterialRow");
static_assert(offsetof(FGroundMaterialRow, _ice) == 0x000008, "Member 'FGroundMaterialRow::_ice' has a wrong offset!");
static_assert(offsetof(FGroundMaterialRow, _fire) == 0x000010, "Member 'FGroundMaterialRow::_fire' has a wrong offset!");
static_assert(offsetof(FGroundMaterialRow, _spark) == 0x000018, "Member 'FGroundMaterialRow::_spark' has a wrong offset!");

// ScriptStruct InGameModule.InGameMaterialRow
// 0x0078 (0x0080 - 0x0008)
struct FInGameMaterialRow final : public FTableRowBase
{
public:
	class UMaterialInstance*                      _default;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _concrete;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _grass;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _sand;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _rock;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _water;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _deepWater;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _ice;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _tree;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _metal;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _paper;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _plastic;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _cloth;                                            // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _ignore;                                           // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      _wood;                                             // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInGameMaterialRow) == 0x000008, "Wrong alignment on FInGameMaterialRow");
static_assert(sizeof(FInGameMaterialRow) == 0x000080, "Wrong size on FInGameMaterialRow");
static_assert(offsetof(FInGameMaterialRow, _default) == 0x000008, "Member 'FInGameMaterialRow::_default' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _concrete) == 0x000010, "Member 'FInGameMaterialRow::_concrete' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _grass) == 0x000018, "Member 'FInGameMaterialRow::_grass' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _sand) == 0x000020, "Member 'FInGameMaterialRow::_sand' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _rock) == 0x000028, "Member 'FInGameMaterialRow::_rock' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _water) == 0x000030, "Member 'FInGameMaterialRow::_water' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _deepWater) == 0x000038, "Member 'FInGameMaterialRow::_deepWater' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _ice) == 0x000040, "Member 'FInGameMaterialRow::_ice' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _tree) == 0x000048, "Member 'FInGameMaterialRow::_tree' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _metal) == 0x000050, "Member 'FInGameMaterialRow::_metal' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _paper) == 0x000058, "Member 'FInGameMaterialRow::_paper' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _plastic) == 0x000060, "Member 'FInGameMaterialRow::_plastic' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _cloth) == 0x000068, "Member 'FInGameMaterialRow::_cloth' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _ignore) == 0x000070, "Member 'FInGameMaterialRow::_ignore' has a wrong offset!");
static_assert(offsetof(FInGameMaterialRow, _wood) == 0x000078, "Member 'FInGameMaterialRow::_wood' has a wrong offset!");

// ScriptStruct InGameModule.InGameParticleEffectRow
// 0x0078 (0x0080 - 0x0008)
struct FInGameParticleEffectRow final : public FTableRowBase
{
public:
	class UParticleSystem*                        _default;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _concrete;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _grass;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _sand;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _rock;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _water;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _deepWater;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _ice;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _tree;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _metal;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _paper;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _plastic;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _cloth;                                            // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _ignore;                                           // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        _wood;                                             // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInGameParticleEffectRow) == 0x000008, "Wrong alignment on FInGameParticleEffectRow");
static_assert(sizeof(FInGameParticleEffectRow) == 0x000080, "Wrong size on FInGameParticleEffectRow");
static_assert(offsetof(FInGameParticleEffectRow, _default) == 0x000008, "Member 'FInGameParticleEffectRow::_default' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _concrete) == 0x000010, "Member 'FInGameParticleEffectRow::_concrete' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _grass) == 0x000018, "Member 'FInGameParticleEffectRow::_grass' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _sand) == 0x000020, "Member 'FInGameParticleEffectRow::_sand' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _rock) == 0x000028, "Member 'FInGameParticleEffectRow::_rock' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _water) == 0x000030, "Member 'FInGameParticleEffectRow::_water' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _deepWater) == 0x000038, "Member 'FInGameParticleEffectRow::_deepWater' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _ice) == 0x000040, "Member 'FInGameParticleEffectRow::_ice' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _tree) == 0x000048, "Member 'FInGameParticleEffectRow::_tree' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _metal) == 0x000050, "Member 'FInGameParticleEffectRow::_metal' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _paper) == 0x000058, "Member 'FInGameParticleEffectRow::_paper' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _plastic) == 0x000060, "Member 'FInGameParticleEffectRow::_plastic' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _cloth) == 0x000068, "Member 'FInGameParticleEffectRow::_cloth' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _ignore) == 0x000070, "Member 'FInGameParticleEffectRow::_ignore' has a wrong offset!");
static_assert(offsetof(FInGameParticleEffectRow, _wood) == 0x000078, "Member 'FInGameParticleEffectRow::_wood' has a wrong offset!");

// ScriptStruct InGameModule.EffTransform
// 0x0024 (0x0024 - 0x0000)
struct FEffTransform final
{
public:
	struct FVector                                Locate;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffTransform) == 0x000004, "Wrong alignment on FEffTransform");
static_assert(sizeof(FEffTransform) == 0x000024, "Wrong size on FEffTransform");
static_assert(offsetof(FEffTransform, Locate) == 0x000000, "Member 'FEffTransform::Locate' has a wrong offset!");
static_assert(offsetof(FEffTransform, Rot) == 0x00000C, "Member 'FEffTransform::Rot' has a wrong offset!");
static_assert(offsetof(FEffTransform, Scale) == 0x000018, "Member 'FEffTransform::Scale' has a wrong offset!");

// ScriptStruct InGameModule.PlayEffectNotifyViewerInfo
// 0x0002 (0x0002 - 0x0000)
struct FPlayEffectNotifyViewerInfo final
{
public:
	bool                                          _loopDestroy;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _viewingCharacterID;                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayEffectNotifyViewerInfo) == 0x000001, "Wrong alignment on FPlayEffectNotifyViewerInfo");
static_assert(sizeof(FPlayEffectNotifyViewerInfo) == 0x000002, "Wrong size on FPlayEffectNotifyViewerInfo");
static_assert(offsetof(FPlayEffectNotifyViewerInfo, _loopDestroy) == 0x000000, "Member 'FPlayEffectNotifyViewerInfo::_loopDestroy' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyViewerInfo, _viewingCharacterID) == 0x000001, "Member 'FPlayEffectNotifyViewerInfo::_viewingCharacterID' has a wrong offset!");

// ScriptStruct InGameModule.PlayEffectNotifyBaseInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FPlayEffectNotifyBaseInfo
{
public:
	EViewType                                     _viewType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterId, struct FEffTransform>      _offsetTRSs;                                       // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	class FName                                   _socketName;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _effectRoot;                                       // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _attached;                                         // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _detachTimer;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _locateOnly;                                       // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _onGround;                                         // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _notNagaraActionOnly;                              // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _snapHeight;                                       // 0x006B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _snapHeightValue;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _snapFloor;                                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _locallyControlOnly;                               // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _castShadow;                                       // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bIgnoreHitSlow;                                   // 0x0073(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _tag;                                              // 0x0074(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraduallyAlpha                        _graduallyAlpha;                                   // 0x0080(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FPlayEffectNotifyViewerInfo            _viewerInfo;                                       // 0x00C0(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _notifyUniqueID;                                   // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _assetPath;                                        // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleCustomParticleSystemComponent*   _workPSC;                                          // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPlayEffectNotifyBaseInfo) == 0x000008, "Wrong alignment on FPlayEffectNotifyBaseInfo");
static_assert(sizeof(FPlayEffectNotifyBaseInfo) == 0x0000D8, "Wrong size on FPlayEffectNotifyBaseInfo");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _viewType) == 0x000000, "Member 'FPlayEffectNotifyBaseInfo::_viewType' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _offsetTRSs) == 0x000008, "Member 'FPlayEffectNotifyBaseInfo::_offsetTRSs' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _socketName) == 0x000058, "Member 'FPlayEffectNotifyBaseInfo::_socketName' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _effectRoot) == 0x000060, "Member 'FPlayEffectNotifyBaseInfo::_effectRoot' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _attached) == 0x000061, "Member 'FPlayEffectNotifyBaseInfo::_attached' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _detachTimer) == 0x000064, "Member 'FPlayEffectNotifyBaseInfo::_detachTimer' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _locateOnly) == 0x000068, "Member 'FPlayEffectNotifyBaseInfo::_locateOnly' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _onGround) == 0x000069, "Member 'FPlayEffectNotifyBaseInfo::_onGround' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _notNagaraActionOnly) == 0x00006A, "Member 'FPlayEffectNotifyBaseInfo::_notNagaraActionOnly' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _snapHeight) == 0x00006B, "Member 'FPlayEffectNotifyBaseInfo::_snapHeight' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _snapHeightValue) == 0x00006C, "Member 'FPlayEffectNotifyBaseInfo::_snapHeightValue' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _snapFloor) == 0x000070, "Member 'FPlayEffectNotifyBaseInfo::_snapFloor' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _locallyControlOnly) == 0x000071, "Member 'FPlayEffectNotifyBaseInfo::_locallyControlOnly' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _castShadow) == 0x000072, "Member 'FPlayEffectNotifyBaseInfo::_castShadow' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _bIgnoreHitSlow) == 0x000073, "Member 'FPlayEffectNotifyBaseInfo::_bIgnoreHitSlow' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _tag) == 0x000074, "Member 'FPlayEffectNotifyBaseInfo::_tag' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _graduallyAlpha) == 0x000080, "Member 'FPlayEffectNotifyBaseInfo::_graduallyAlpha' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _viewerInfo) == 0x0000C0, "Member 'FPlayEffectNotifyBaseInfo::_viewerInfo' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _notifyUniqueID) == 0x0000C4, "Member 'FPlayEffectNotifyBaseInfo::_notifyUniqueID' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _assetPath) == 0x0000C8, "Member 'FPlayEffectNotifyBaseInfo::_assetPath' has a wrong offset!");
static_assert(offsetof(FPlayEffectNotifyBaseInfo, _workPSC) == 0x0000D0, "Member 'FPlayEffectNotifyBaseInfo::_workPSC' has a wrong offset!");

// ScriptStruct InGameModule.PlayEffectNotifyInfo
// 0x0018 (0x00F0 - 0x00D8)
struct FPlayEffectNotifyInfo final : public FPlayEffectNotifyBaseInfo
{
public:
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAttackVisualLevel>                    VisualLevel;                                       // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayEffectNotifyInfo) == 0x000008, "Wrong alignment on FPlayEffectNotifyInfo");
static_assert(sizeof(FPlayEffectNotifyInfo) == 0x0000F0, "Wrong size on FPlayEffectNotifyInfo");
static_assert(offsetof(FPlayEffectNotifyInfo, VisualLevel) == 0x0000E0, "Member 'FPlayEffectNotifyInfo::VisualLevel' has a wrong offset!");

// ScriptStruct InGameModule.PlayEffecTemplate
// 0x00F0 (0x00F8 - 0x0008)
struct FPlayEffecTemplate final : public FTableRowBase
{
public:
	struct FPlayEffectNotifyInfo                  Info;                                              // 0x0008(0x00F0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayEffecTemplate) == 0x000008, "Wrong alignment on FPlayEffecTemplate");
static_assert(sizeof(FPlayEffecTemplate) == 0x0000F8, "Wrong size on FPlayEffecTemplate");
static_assert(offsetof(FPlayEffecTemplate, Info) == 0x000008, "Member 'FPlayEffecTemplate::Info' has a wrong offset!");

// ScriptStruct InGameModule.GroundCheckParam
// 0x0030 (0x0030 - 0x0000)
struct FGroundCheckParam final
{
public:
	struct FVector                                _startLocation;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _checkDistance;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bCheckNormal;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _capsule;                                          // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _ignoreList;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundCheckParam) == 0x000008, "Wrong alignment on FGroundCheckParam");
static_assert(sizeof(FGroundCheckParam) == 0x000030, "Wrong size on FGroundCheckParam");
static_assert(offsetof(FGroundCheckParam, _startLocation) == 0x000000, "Member 'FGroundCheckParam::_startLocation' has a wrong offset!");
static_assert(offsetof(FGroundCheckParam, _checkDistance) == 0x00000C, "Member 'FGroundCheckParam::_checkDistance' has a wrong offset!");
static_assert(offsetof(FGroundCheckParam, _bCheckNormal) == 0x000010, "Member 'FGroundCheckParam::_bCheckNormal' has a wrong offset!");
static_assert(offsetof(FGroundCheckParam, _capsule) == 0x000018, "Member 'FGroundCheckParam::_capsule' has a wrong offset!");
static_assert(offsetof(FGroundCheckParam, _ignoreList) == 0x000020, "Member 'FGroundCheckParam::_ignoreList' has a wrong offset!");

// ScriptStruct InGameModule.InventoryAllySkillInfo
// 0x0008 (0x0008 - 0x0000)
struct FInventoryAllySkillInfo final
{
public:
	EMdAbilityType                                _abilityType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _level;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryAllySkillInfo) == 0x000004, "Wrong alignment on FInventoryAllySkillInfo");
static_assert(sizeof(FInventoryAllySkillInfo) == 0x000008, "Wrong size on FInventoryAllySkillInfo");
static_assert(offsetof(FInventoryAllySkillInfo, _abilityType) == 0x000000, "Member 'FInventoryAllySkillInfo::_abilityType' has a wrong offset!");
static_assert(offsetof(FInventoryAllySkillInfo, _attackID) == 0x000001, "Member 'FInventoryAllySkillInfo::_attackID' has a wrong offset!");
static_assert(offsetof(FInventoryAllySkillInfo, _level) == 0x000004, "Member 'FInventoryAllySkillInfo::_level' has a wrong offset!");

// ScriptStruct InGameModule.InventoryAllySkillWidgetInfo
// 0x0010 (0x0010 - 0x0000)
struct FInventoryAllySkillWidgetInfo final
{
public:
	TArray<class UInventoryAllySkillWidget*>      _skillUniqueList;                                  // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryAllySkillWidgetInfo) == 0x000008, "Wrong alignment on FInventoryAllySkillWidgetInfo");
static_assert(sizeof(FInventoryAllySkillWidgetInfo) == 0x000010, "Wrong size on FInventoryAllySkillWidgetInfo");
static_assert(offsetof(FInventoryAllySkillWidgetInfo, _skillUniqueList) == 0x000000, "Member 'FInventoryAllySkillWidgetInfo::_skillUniqueList' has a wrong offset!");

// ScriptStruct InGameModule.KillEventAssistPersona
// 0x0004 (0x0004 - 0x0000)
struct FKillEventAssistPersona final
{
public:
	uint8                                         _playerId;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         _assistPoint;                                      // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillEventAssistPersona) == 0x000002, "Wrong alignment on FKillEventAssistPersona");
static_assert(sizeof(FKillEventAssistPersona) == 0x000004, "Wrong size on FKillEventAssistPersona");
static_assert(offsetof(FKillEventAssistPersona, _playerId) == 0x000000, "Member 'FKillEventAssistPersona::_playerId' has a wrong offset!");
static_assert(offsetof(FKillEventAssistPersona, _assistPoint) == 0x000002, "Member 'FKillEventAssistPersona::_assistPoint' has a wrong offset!");

// ScriptStruct InGameModule.KillEventPlayerPersona
// 0x001C (0x001C - 0x0000)
struct FKillEventPlayerPersona final
{
public:
	class FName                                   _playerName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerId;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterCode;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _teamId;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _squadId;                                          // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _killCount;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isBot;                                            // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillEventPlayerPersona) == 0x000004, "Wrong alignment on FKillEventPlayerPersona");
static_assert(sizeof(FKillEventPlayerPersona) == 0x00001C, "Wrong size on FKillEventPlayerPersona");
static_assert(offsetof(FKillEventPlayerPersona, _playerName) == 0x000000, "Member 'FKillEventPlayerPersona::_playerName' has a wrong offset!");
static_assert(offsetof(FKillEventPlayerPersona, _playerId) == 0x000008, "Member 'FKillEventPlayerPersona::_playerId' has a wrong offset!");
static_assert(offsetof(FKillEventPlayerPersona, _characterCode) == 0x00000C, "Member 'FKillEventPlayerPersona::_characterCode' has a wrong offset!");
static_assert(offsetof(FKillEventPlayerPersona, _teamId) == 0x000010, "Member 'FKillEventPlayerPersona::_teamId' has a wrong offset!");
static_assert(offsetof(FKillEventPlayerPersona, _squadId) == 0x000011, "Member 'FKillEventPlayerPersona::_squadId' has a wrong offset!");
static_assert(offsetof(FKillEventPlayerPersona, _killCount) == 0x000014, "Member 'FKillEventPlayerPersona::_killCount' has a wrong offset!");
static_assert(offsetof(FKillEventPlayerPersona, _isBot) == 0x000018, "Member 'FKillEventPlayerPersona::_isBot' has a wrong offset!");

// ScriptStruct InGameModule.LeadersKillCount
// 0x000C (0x000C - 0x0000)
struct FLeadersKillCount final
{
public:
	uint8                                         _playerId;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _killCount;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _leaderKillCount;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeadersKillCount) == 0x000004, "Wrong alignment on FLeadersKillCount");
static_assert(sizeof(FLeadersKillCount) == 0x00000C, "Wrong size on FLeadersKillCount");
static_assert(offsetof(FLeadersKillCount, _playerId) == 0x000000, "Member 'FLeadersKillCount::_playerId' has a wrong offset!");
static_assert(offsetof(FLeadersKillCount, _killCount) == 0x000004, "Member 'FLeadersKillCount::_killCount' has a wrong offset!");
static_assert(offsetof(FLeadersKillCount, _leaderKillCount) == 0x000008, "Member 'FLeadersKillCount::_leaderKillCount' has a wrong offset!");

// ScriptStruct InGameModule.TeamKillCount
// 0x0008 (0x0008 - 0x0000)
struct FTeamKillCount final
{
public:
	uint8                                         _teamId;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _killCount;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamKillCount) == 0x000004, "Wrong alignment on FTeamKillCount");
static_assert(sizeof(FTeamKillCount) == 0x000008, "Wrong size on FTeamKillCount");
static_assert(offsetof(FTeamKillCount, _teamId) == 0x000000, "Member 'FTeamKillCount::_teamId' has a wrong offset!");
static_assert(offsetof(FTeamKillCount, _killCount) == 0x000004, "Member 'FTeamKillCount::_killCount' has a wrong offset!");

// ScriptStruct InGameModule.KillCount
// 0x000C (0x000C - 0x0000)
struct FKillCount final
{
public:
	uint8                                         _playerId;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _killCount;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _assistCount;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillCount) == 0x000004, "Wrong alignment on FKillCount");
static_assert(sizeof(FKillCount) == 0x00000C, "Wrong size on FKillCount");
static_assert(offsetof(FKillCount, _playerId) == 0x000000, "Member 'FKillCount::_playerId' has a wrong offset!");
static_assert(offsetof(FKillCount, _killCount) == 0x000004, "Member 'FKillCount::_killCount' has a wrong offset!");
static_assert(offsetof(FKillCount, _assistCount) == 0x000008, "Member 'FKillCount::_assistCount' has a wrong offset!");

// ScriptStruct InGameModule.KillLogInfo
// 0x004C (0x004C - 0x0000)
struct FKillLogInfo final
{
public:
	float                                         _killTime;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKillEventPlayerPersona                _killerPersona;                                    // 0x0004(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FKillEventPlayerPersona                _deathPersona;                                     // 0x0020(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          _bIsAlreadyPosted;                                 // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageCauserType                             _damageCauserType;                                 // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    _deadSpot;                                         // 0x0040(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillLogInfo) == 0x000004, "Wrong alignment on FKillLogInfo");
static_assert(sizeof(FKillLogInfo) == 0x00004C, "Wrong size on FKillLogInfo");
static_assert(offsetof(FKillLogInfo, _killTime) == 0x000000, "Member 'FKillLogInfo::_killTime' has a wrong offset!");
static_assert(offsetof(FKillLogInfo, _killerPersona) == 0x000004, "Member 'FKillLogInfo::_killerPersona' has a wrong offset!");
static_assert(offsetof(FKillLogInfo, _deathPersona) == 0x000020, "Member 'FKillLogInfo::_deathPersona' has a wrong offset!");
static_assert(offsetof(FKillLogInfo, _bIsAlreadyPosted) == 0x00003C, "Member 'FKillLogInfo::_bIsAlreadyPosted' has a wrong offset!");
static_assert(offsetof(FKillLogInfo, _damageCauserType) == 0x00003D, "Member 'FKillLogInfo::_damageCauserType' has a wrong offset!");
static_assert(offsetof(FKillLogInfo, _deadSpot) == 0x000040, "Member 'FKillLogInfo::_deadSpot' has a wrong offset!");

// ScriptStruct InGameModule.LeadersBattleScoreInfo
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x02) FLeadersBattleScoreInfo final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeadersBattleScoreInfo) == 0x000002, "Wrong alignment on FLeadersBattleScoreInfo");
static_assert(sizeof(FLeadersBattleScoreInfo) == 0x000004, "Wrong size on FLeadersBattleScoreInfo");

// ScriptStruct InGameModule.NetLeadersBattleScoreInfo
// 0x0004 (0x0004 - 0x0000)
struct FNetLeadersBattleScoreInfo final
{
public:
	ELeadersBattleTeamType                        _team;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        _score;                                            // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetLeadersBattleScoreInfo) == 0x000002, "Wrong alignment on FNetLeadersBattleScoreInfo");
static_assert(sizeof(FNetLeadersBattleScoreInfo) == 0x000004, "Wrong size on FNetLeadersBattleScoreInfo");
static_assert(offsetof(FNetLeadersBattleScoreInfo, _team) == 0x000000, "Member 'FNetLeadersBattleScoreInfo::_team' has a wrong offset!");
static_assert(offsetof(FNetLeadersBattleScoreInfo, _score) == 0x000002, "Member 'FNetLeadersBattleScoreInfo::_score' has a wrong offset!");

// ScriptStruct InGameModule.LeadersTeamInfo
// 0x0018 (0x0018 - 0x0000)
struct FLeadersTeamInfo final
{
public:
	TArray<class APlayerStateLeadersBattle*>      _members;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         _currentLeaderIndex;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeadersTeamInfo) == 0x000008, "Wrong alignment on FLeadersTeamInfo");
static_assert(sizeof(FLeadersTeamInfo) == 0x000018, "Wrong size on FLeadersTeamInfo");
static_assert(offsetof(FLeadersTeamInfo, _members) == 0x000000, "Member 'FLeadersTeamInfo::_members' has a wrong offset!");
static_assert(offsetof(FLeadersTeamInfo, _currentLeaderIndex) == 0x000010, "Member 'FLeadersTeamInfo::_currentLeaderIndex' has a wrong offset!");

// ScriptStruct InGameModule.RequestUIData
// 0x0020 (0x0020 - 0x0000)
struct FRequestUIData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractTargetComponent*               _interactTarget;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBattle*                       _character;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequestUIData) == 0x000008, "Wrong alignment on FRequestUIData");
static_assert(sizeof(FRequestUIData) == 0x000020, "Wrong size on FRequestUIData");
static_assert(offsetof(FRequestUIData, _interactTarget) == 0x000008, "Member 'FRequestUIData::_interactTarget' has a wrong offset!");
static_assert(offsetof(FRequestUIData, _character) == 0x000010, "Member 'FRequestUIData::_character' has a wrong offset!");

// ScriptStruct InGameModule.MapData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FMapData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapData) == 0x000004, "Wrong alignment on FMapData");
static_assert(sizeof(FMapData) == 0x00001C, "Wrong size on FMapData");

// ScriptStruct InGameModule.Magazine
// 0x005C (0x005C - 0x0000)
struct alignas(0x04) FMagazine final
{
public:
	uint8                                         Pad_0[0x5C];                                       // 0x0000(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMagazine) == 0x000004, "Wrong alignment on FMagazine");
static_assert(sizeof(FMagazine) == 0x00005C, "Wrong size on FMagazine");

// ScriptStruct InGameModule.MagazineState
// 0x002C (0x002C - 0x0000)
struct FMagazineState final
{
public:
	int32                                         _currentAmmo;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _currentReloadTime;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _currentReloadStartSpan;                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _currentReloadTimeRate;                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x1C];                                      // 0x0010(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMagazineState) == 0x000004, "Wrong alignment on FMagazineState");
static_assert(sizeof(FMagazineState) == 0x00002C, "Wrong size on FMagazineState");
static_assert(offsetof(FMagazineState, _currentAmmo) == 0x000000, "Member 'FMagazineState::_currentAmmo' has a wrong offset!");
static_assert(offsetof(FMagazineState, _currentReloadTime) == 0x000004, "Member 'FMagazineState::_currentReloadTime' has a wrong offset!");
static_assert(offsetof(FMagazineState, _currentReloadStartSpan) == 0x000008, "Member 'FMagazineState::_currentReloadStartSpan' has a wrong offset!");
static_assert(offsetof(FMagazineState, _currentReloadTimeRate) == 0x00000C, "Member 'FMagazineState::_currentReloadTimeRate' has a wrong offset!");

// ScriptStruct InGameModule.MagazineInfo
// 0x002C (0x002C - 0x0000)
struct alignas(0x04) FMagazineInfo final
{
public:
	uint8                                         Pad_0[0x2C];                                       // 0x0000(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMagazineInfo) == 0x000004, "Wrong alignment on FMagazineInfo");
static_assert(sizeof(FMagazineInfo) == 0x00002C, "Wrong size on FMagazineInfo");

// ScriptStruct InGameModule.MapCharacterFaceInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x04) FMapCharacterFaceInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapCharacterFaceInfo) == 0x000004, "Wrong alignment on FMapCharacterFaceInfo");
static_assert(sizeof(FMapCharacterFaceInfo) == 0x000038, "Wrong size on FMapCharacterFaceInfo");

// ScriptStruct InGameModule.PresetMaterialScalarParam
// 0x0020 (0x0020 - 0x0000)
struct FPresetMaterialScalarParam final
{
public:
	class FName                                   _paramName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _value;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultValue;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inSpan;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _fadeInEasingType;                                 // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _outSpan;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _fadeOutEasingType;                                // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialGroupFlag                            _group;                                            // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPresetMaterialScalarParam) == 0x000004, "Wrong alignment on FPresetMaterialScalarParam");
static_assert(sizeof(FPresetMaterialScalarParam) == 0x000020, "Wrong size on FPresetMaterialScalarParam");
static_assert(offsetof(FPresetMaterialScalarParam, _paramName) == 0x000000, "Member 'FPresetMaterialScalarParam::_paramName' has a wrong offset!");
static_assert(offsetof(FPresetMaterialScalarParam, _value) == 0x000008, "Member 'FPresetMaterialScalarParam::_value' has a wrong offset!");
static_assert(offsetof(FPresetMaterialScalarParam, _defaultValue) == 0x00000C, "Member 'FPresetMaterialScalarParam::_defaultValue' has a wrong offset!");
static_assert(offsetof(FPresetMaterialScalarParam, _inSpan) == 0x000010, "Member 'FPresetMaterialScalarParam::_inSpan' has a wrong offset!");
static_assert(offsetof(FPresetMaterialScalarParam, _fadeInEasingType) == 0x000014, "Member 'FPresetMaterialScalarParam::_fadeInEasingType' has a wrong offset!");
static_assert(offsetof(FPresetMaterialScalarParam, _outSpan) == 0x000018, "Member 'FPresetMaterialScalarParam::_outSpan' has a wrong offset!");
static_assert(offsetof(FPresetMaterialScalarParam, _fadeOutEasingType) == 0x00001C, "Member 'FPresetMaterialScalarParam::_fadeOutEasingType' has a wrong offset!");
static_assert(offsetof(FPresetMaterialScalarParam, _group) == 0x00001D, "Member 'FPresetMaterialScalarParam::_group' has a wrong offset!");

// ScriptStruct InGameModule.PresetMaterialVectorParam
// 0x002C (0x002C - 0x0000)
struct FPresetMaterialVectorParam final
{
public:
	class FName                                   _paramName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _value;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _defaultValue;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialGroupFlag                            _group;                                            // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPresetMaterialVectorParam) == 0x000004, "Wrong alignment on FPresetMaterialVectorParam");
static_assert(sizeof(FPresetMaterialVectorParam) == 0x00002C, "Wrong size on FPresetMaterialVectorParam");
static_assert(offsetof(FPresetMaterialVectorParam, _paramName) == 0x000000, "Member 'FPresetMaterialVectorParam::_paramName' has a wrong offset!");
static_assert(offsetof(FPresetMaterialVectorParam, _value) == 0x000008, "Member 'FPresetMaterialVectorParam::_value' has a wrong offset!");
static_assert(offsetof(FPresetMaterialVectorParam, _defaultValue) == 0x000018, "Member 'FPresetMaterialVectorParam::_defaultValue' has a wrong offset!");
static_assert(offsetof(FPresetMaterialVectorParam, _group) == 0x000028, "Member 'FPresetMaterialVectorParam::_group' has a wrong offset!");

// ScriptStruct InGameModule.PresetMaterialTextureParam
// 0x0010 (0x0010 - 0x0000)
struct FPresetMaterialTextureParam final
{
public:
	class FName                                   _paramName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _value;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresetMaterialTextureParam) == 0x000008, "Wrong alignment on FPresetMaterialTextureParam");
static_assert(sizeof(FPresetMaterialTextureParam) == 0x000010, "Wrong size on FPresetMaterialTextureParam");
static_assert(offsetof(FPresetMaterialTextureParam, _paramName) == 0x000000, "Member 'FPresetMaterialTextureParam::_paramName' has a wrong offset!");
static_assert(offsetof(FPresetMaterialTextureParam, _value) == 0x000008, "Member 'FPresetMaterialTextureParam::_value' has a wrong offset!");

// ScriptStruct InGameModule.TableRowMaterialPreset
// 0x0030 (0x0038 - 0x0008)
struct FTableRowMaterialPreset final : public FTableRowBase
{
public:
	TArray<struct FPresetMaterialScalarParam>     _scalars;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPresetMaterialVectorParam>     _vectors;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPresetMaterialTextureParam>    _textures;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTableRowMaterialPreset) == 0x000008, "Wrong alignment on FTableRowMaterialPreset");
static_assert(sizeof(FTableRowMaterialPreset) == 0x000038, "Wrong size on FTableRowMaterialPreset");
static_assert(offsetof(FTableRowMaterialPreset, _scalars) == 0x000008, "Member 'FTableRowMaterialPreset::_scalars' has a wrong offset!");
static_assert(offsetof(FTableRowMaterialPreset, _vectors) == 0x000018, "Member 'FTableRowMaterialPreset::_vectors' has a wrong offset!");
static_assert(offsetof(FTableRowMaterialPreset, _textures) == 0x000028, "Member 'FTableRowMaterialPreset::_textures' has a wrong offset!");

// ScriptStruct InGameModule.ServerMoveArgument
// 0x0034 (0x0034 - 0x0000)
struct FServerMoveArgument final
{
public:
	float                                         _timeStamp;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  _velocity;                                         // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  _accel;                                            // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 _location;                                         // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotation;                                         // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerMoveArgument) == 0x000004, "Wrong alignment on FServerMoveArgument");
static_assert(sizeof(FServerMoveArgument) == 0x000034, "Wrong size on FServerMoveArgument");
static_assert(offsetof(FServerMoveArgument, _timeStamp) == 0x000000, "Member 'FServerMoveArgument::_timeStamp' has a wrong offset!");
static_assert(offsetof(FServerMoveArgument, _velocity) == 0x000004, "Member 'FServerMoveArgument::_velocity' has a wrong offset!");
static_assert(offsetof(FServerMoveArgument, _accel) == 0x000010, "Member 'FServerMoveArgument::_accel' has a wrong offset!");
static_assert(offsetof(FServerMoveArgument, _location) == 0x00001C, "Member 'FServerMoveArgument::_location' has a wrong offset!");
static_assert(offsetof(FServerMoveArgument, _rotation) == 0x000028, "Member 'FServerMoveArgument::_rotation' has a wrong offset!");

// ScriptStruct InGameModule.RotateVector
// 0x0100 (0x0100 - 0x0000)
struct alignas(0x10) FRotateVector final
{
public:
	uint8                                         Pad_0[0x100];                                      // 0x0000(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRotateVector) == 0x000010, "Wrong alignment on FRotateVector");
static_assert(sizeof(FRotateVector) == 0x000100, "Wrong size on FRotateVector");

// ScriptStruct InGameModule.Speed
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x04) FSpeed final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpeed) == 0x000004, "Wrong alignment on FSpeed");
static_assert(sizeof(FSpeed) == 0x000040, "Wrong size on FSpeed");

// ScriptStruct InGameModule.GrabInfo
// 0x0020 (0x0020 - 0x0000)
struct FGrabInfo final
{
public:
	class ACharacterBattle*                       _grabbedCharacter;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGrabInfo) == 0x000008, "Wrong alignment on FGrabInfo");
static_assert(sizeof(FGrabInfo) == 0x000020, "Wrong size on FGrabInfo");
static_assert(offsetof(FGrabInfo, _grabbedCharacter) == 0x000000, "Member 'FGrabInfo::_grabbedCharacter' has a wrong offset!");

// ScriptStruct InGameModule.NPCCitizenStateRep
// 0x0010 (0x0010 - 0x0000)
struct FNPCCitizenStateRep final
{
public:
	ENPCCitizenState                              State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       PickupCharacter;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCCitizenStateRep) == 0x000008, "Wrong alignment on FNPCCitizenStateRep");
static_assert(sizeof(FNPCCitizenStateRep) == 0x000010, "Wrong size on FNPCCitizenStateRep");
static_assert(offsetof(FNPCCitizenStateRep, State) == 0x000000, "Member 'FNPCCitizenStateRep::State' has a wrong offset!");
static_assert(offsetof(FNPCCitizenStateRep, PickupCharacter) == 0x000008, "Member 'FNPCCitizenStateRep::PickupCharacter' has a wrong offset!");

// ScriptStruct InGameModule.NPCCitizenSpawnPointTableRow
// 0x0020 (0x0028 - 0x0008)
struct FNPCCitizenSpawnPointTableRow final : public FTableRowBase
{
public:
	struct FVector                                _position;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotation;                                         // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ECitizenType                                  _citizenType;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCCitizenSpawnPointTableRow) == 0x000008, "Wrong alignment on FNPCCitizenSpawnPointTableRow");
static_assert(sizeof(FNPCCitizenSpawnPointTableRow) == 0x000028, "Wrong size on FNPCCitizenSpawnPointTableRow");
static_assert(offsetof(FNPCCitizenSpawnPointTableRow, _position) == 0x000008, "Member 'FNPCCitizenSpawnPointTableRow::_position' has a wrong offset!");
static_assert(offsetof(FNPCCitizenSpawnPointTableRow, _rotation) == 0x000014, "Member 'FNPCCitizenSpawnPointTableRow::_rotation' has a wrong offset!");
static_assert(offsetof(FNPCCitizenSpawnPointTableRow, _citizenType) == 0x000020, "Member 'FNPCCitizenSpawnPointTableRow::_citizenType' has a wrong offset!");

// ScriptStruct InGameModule.RateTableRowBase
// 0x0008 (0x0010 - 0x0008)
struct FRateTableRowBase : public FTableRowBase
{
public:
	int32                                         _rate;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRateTableRowBase) == 0x000008, "Wrong alignment on FRateTableRowBase");
static_assert(sizeof(FRateTableRowBase) == 0x000010, "Wrong size on FRateTableRowBase");
static_assert(offsetof(FRateTableRowBase, _rate) == 0x000008, "Member 'FRateTableRowBase::_rate' has a wrong offset!");

// ScriptStruct InGameModule.NPCCitizenSpawnRateTableRow
// 0x0000 (0x0010 - 0x0010)
struct FNPCCitizenSpawnRateTableRow final : public FRateTableRowBase
{
};
static_assert(alignof(FNPCCitizenSpawnRateTableRow) == 0x000008, "Wrong alignment on FNPCCitizenSpawnRateTableRow");
static_assert(sizeof(FNPCCitizenSpawnRateTableRow) == 0x000010, "Wrong size on FNPCCitizenSpawnRateTableRow");

// ScriptStruct InGameModule.ParticleNotifyData
// 0x00E0 (0x00E0 - 0x0000)
struct FParticleNotifyData final
{
public:
	class UParticleSystem*                        _particle;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayEffectNotifyBaseInfo              _notifyInfo;                                       // 0x0008(0x00D8)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleNotifyData) == 0x000008, "Wrong alignment on FParticleNotifyData");
static_assert(sizeof(FParticleNotifyData) == 0x0000E0, "Wrong size on FParticleNotifyData");
static_assert(offsetof(FParticleNotifyData, _particle) == 0x000000, "Member 'FParticleNotifyData::_particle' has a wrong offset!");
static_assert(offsetof(FParticleNotifyData, _notifyInfo) == 0x000008, "Member 'FParticleNotifyData::_notifyInfo' has a wrong offset!");

// ScriptStruct InGameModule.TableRowParticleData
// 0x0050 (0x0058 - 0x0008)
struct FTableRowParticleData final : public FTableRowBase
{
public:
	TMap<class FName, struct FParticleNotifyData> _list;                                             // 0x0008(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTableRowParticleData) == 0x000008, "Wrong alignment on FTableRowParticleData");
static_assert(sizeof(FTableRowParticleData) == 0x000058, "Wrong size on FTableRowParticleData");
static_assert(offsetof(FTableRowParticleData, _list) == 0x000008, "Member 'FTableRowParticleData::_list' has a wrong offset!");

// ScriptStruct InGameModule.TickIntervalControlRow
// 0x0018 (0x0020 - 0x0008)
struct FTickIntervalControlRow final : public FTableRowBase
{
public:
	float                                         FarRange;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarRangeInterval;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddleRange;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddleRangeInterval;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToTargetDot;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTickIntervalControlRow) == 0x000008, "Wrong alignment on FTickIntervalControlRow");
static_assert(sizeof(FTickIntervalControlRow) == 0x000020, "Wrong size on FTickIntervalControlRow");
static_assert(offsetof(FTickIntervalControlRow, FarRange) == 0x000008, "Member 'FTickIntervalControlRow::FarRange' has a wrong offset!");
static_assert(offsetof(FTickIntervalControlRow, FarRangeInterval) == 0x00000C, "Member 'FTickIntervalControlRow::FarRangeInterval' has a wrong offset!");
static_assert(offsetof(FTickIntervalControlRow, MiddleRange) == 0x000010, "Member 'FTickIntervalControlRow::MiddleRange' has a wrong offset!");
static_assert(offsetof(FTickIntervalControlRow, MiddleRangeInterval) == 0x000014, "Member 'FTickIntervalControlRow::MiddleRangeInterval' has a wrong offset!");
static_assert(offsetof(FTickIntervalControlRow, ToTargetDot) == 0x000018, "Member 'FTickIntervalControlRow::ToTargetDot' has a wrong offset!");

// ScriptStruct InGameModule.BriefingSignalPinInfo
// 0x000C (0x000C - 0x0000)
struct FBriefingSignalPinInfo final
{
public:
	struct FVector2D                              _position;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAlert;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBriefingSignalPinInfo) == 0x000004, "Wrong alignment on FBriefingSignalPinInfo");
static_assert(sizeof(FBriefingSignalPinInfo) == 0x00000C, "Wrong size on FBriefingSignalPinInfo");
static_assert(offsetof(FBriefingSignalPinInfo, _position) == 0x000000, "Member 'FBriefingSignalPinInfo::_position' has a wrong offset!");
static_assert(offsetof(FBriefingSignalPinInfo, _bAlert) == 0x000008, "Member 'FBriefingSignalPinInfo::_bAlert' has a wrong offset!");

// ScriptStruct InGameModule.EnemyDamageStat
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FEnemyDamageStat final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyDamageStat) == 0x000004, "Wrong alignment on FEnemyDamageStat");
static_assert(sizeof(FEnemyDamageStat) == 0x000018, "Wrong size on FEnemyDamageStat");

// ScriptStruct InGameModule.SpecialRuleParamRate
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSpecialRuleParamRate final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialRuleParamRate) == 0x000004, "Wrong alignment on FSpecialRuleParamRate");
static_assert(sizeof(FSpecialRuleParamRate) == 0x00000C, "Wrong size on FSpecialRuleParamRate");

// ScriptStruct InGameModule.RepHitEnemyInfo
// 0x0018 (0x0018 - 0x0000)
struct FRepHitEnemyInfo final
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _dispHealth;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _dispGuardPoint;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _dispLocation;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepHitEnemyInfo) == 0x000008, "Wrong alignment on FRepHitEnemyInfo");
static_assert(sizeof(FRepHitEnemyInfo) == 0x000018, "Wrong size on FRepHitEnemyInfo");
static_assert(offsetof(FRepHitEnemyInfo, _playerState) == 0x000000, "Member 'FRepHitEnemyInfo::_playerState' has a wrong offset!");
static_assert(offsetof(FRepHitEnemyInfo, _dispHealth) == 0x000008, "Member 'FRepHitEnemyInfo::_dispHealth' has a wrong offset!");
static_assert(offsetof(FRepHitEnemyInfo, _dispGuardPoint) == 0x00000C, "Member 'FRepHitEnemyInfo::_dispGuardPoint' has a wrong offset!");
static_assert(offsetof(FRepHitEnemyInfo, _dispLocation) == 0x000010, "Member 'FRepHitEnemyInfo::_dispLocation' has a wrong offset!");

// ScriptStruct InGameModule.TaskParam
// 0x0020 (0x0020 - 0x0000)
struct FTaskParam final
{
public:
	class UMaterialInterface*                     _materials;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   _text;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTaskParam) == 0x000008, "Wrong alignment on FTaskParam");
static_assert(sizeof(FTaskParam) == 0x000020, "Wrong size on FTaskParam");
static_assert(offsetof(FTaskParam, _materials) == 0x000000, "Member 'FTaskParam::_materials' has a wrong offset!");
static_assert(offsetof(FTaskParam, _text) == 0x000008, "Member 'FTaskParam::_text' has a wrong offset!");

// ScriptStruct InGameModule.RepDyingRecoverData
// 0x0010 (0x0010 - 0x0000)
struct FRepDyingRecoverData final
{
public:
	int8                                          _serial;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBattle*                       _rescueCharacter;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepDyingRecoverData) == 0x000008, "Wrong alignment on FRepDyingRecoverData");
static_assert(sizeof(FRepDyingRecoverData) == 0x000010, "Wrong size on FRepDyingRecoverData");
static_assert(offsetof(FRepDyingRecoverData, _serial) == 0x000000, "Member 'FRepDyingRecoverData::_serial' has a wrong offset!");
static_assert(offsetof(FRepDyingRecoverData, _rescueCharacter) == 0x000008, "Member 'FRepDyingRecoverData::_rescueCharacter' has a wrong offset!");

// ScriptStruct InGameModule.RepHealthData
// 0x0010 (0x0010 - 0x0000)
struct FRepHealthData final
{
public:
	float                                         _mainHealth;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _dyingHealth;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _bDead : 1;                                        // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bDying : 1;                                       // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bBootDying : 1;                                   // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _bEnableCondition : 1;                             // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepHealthData) == 0x000004, "Wrong alignment on FRepHealthData");
static_assert(sizeof(FRepHealthData) == 0x000010, "Wrong size on FRepHealthData");
static_assert(offsetof(FRepHealthData, _mainHealth) == 0x000000, "Member 'FRepHealthData::_mainHealth' has a wrong offset!");
static_assert(offsetof(FRepHealthData, _dyingHealth) == 0x000004, "Member 'FRepHealthData::_dyingHealth' has a wrong offset!");

// ScriptStruct InGameModule.SupplySpawnRateTableRow
// 0x0010 (0x0020 - 0x0010)
struct FSupplySpawnRateTableRow final : public FRateTableRowBase
{
public:
	ESupplyCode                                   _code;                                             // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _fixedNum;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _pickMax;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSupplySpawnRateTableRow) == 0x000008, "Wrong alignment on FSupplySpawnRateTableRow");
static_assert(sizeof(FSupplySpawnRateTableRow) == 0x000020, "Wrong size on FSupplySpawnRateTableRow");
static_assert(offsetof(FSupplySpawnRateTableRow, _code) == 0x000010, "Member 'FSupplySpawnRateTableRow::_code' has a wrong offset!");
static_assert(offsetof(FSupplySpawnRateTableRow, _fixedNum) == 0x000014, "Member 'FSupplySpawnRateTableRow::_fixedNum' has a wrong offset!");
static_assert(offsetof(FSupplySpawnRateTableRow, _pickMax) == 0x000018, "Member 'FSupplySpawnRateTableRow::_pickMax' has a wrong offset!");

// ScriptStruct InGameModule.RespawnTagInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRespawnTagInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRespawnTagInfo) == 0x000008, "Wrong alignment on FRespawnTagInfo");
static_assert(sizeof(FRespawnTagInfo) == 0x000018, "Wrong size on FRespawnTagInfo");

// ScriptStruct InGameModule.OverheadIconInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOverheadIconInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverheadIconInfo) == 0x000008, "Wrong alignment on FOverheadIconInfo");
static_assert(sizeof(FOverheadIconInfo) == 0x000018, "Wrong size on FOverheadIconInfo");

// ScriptStruct InGameModule.PlaySoundNotifyInfo
// 0x006C (0x0078 - 0x000C)
struct FPlaySoundNotifyInfo final : public FPlaySoundNotifyBaseInfo
{
public:
	bool                                          _bCheckStateGiant;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _giantSoundName;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _notNagaraActionOnly;                              // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterConditionId, class FString>    _conditionCueList;                                 // 0x0028(0x0050)(Edit, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPlaySoundNotifyInfo) == 0x000008, "Wrong alignment on FPlaySoundNotifyInfo");
static_assert(sizeof(FPlaySoundNotifyInfo) == 0x000078, "Wrong size on FPlaySoundNotifyInfo");
static_assert(offsetof(FPlaySoundNotifyInfo, _bCheckStateGiant) == 0x00000C, "Member 'FPlaySoundNotifyInfo::_bCheckStateGiant' has a wrong offset!");
static_assert(offsetof(FPlaySoundNotifyInfo, _giantSoundName) == 0x000010, "Member 'FPlaySoundNotifyInfo::_giantSoundName' has a wrong offset!");
static_assert(offsetof(FPlaySoundNotifyInfo, _notNagaraActionOnly) == 0x000020, "Member 'FPlaySoundNotifyInfo::_notNagaraActionOnly' has a wrong offset!");
static_assert(offsetof(FPlaySoundNotifyInfo, _conditionCueList) == 0x000028, "Member 'FPlaySoundNotifyInfo::_conditionCueList' has a wrong offset!");

// ScriptStruct InGameModule.FirstLocationData
// 0x0020 (0x0020 - 0x0000)
struct FFirstLocationData final
{
public:
	struct FVector2D                              _firstLocation;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _note;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bPreview;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFirstLocationData) == 0x000008, "Wrong alignment on FFirstLocationData");
static_assert(sizeof(FFirstLocationData) == 0x000020, "Wrong size on FFirstLocationData");
static_assert(offsetof(FFirstLocationData, _firstLocation) == 0x000000, "Member 'FFirstLocationData::_firstLocation' has a wrong offset!");
static_assert(offsetof(FFirstLocationData, _note) == 0x000008, "Member 'FFirstLocationData::_note' has a wrong offset!");
static_assert(offsetof(FFirstLocationData, _bPreview) == 0x000018, "Member 'FFirstLocationData::_bPreview' has a wrong offset!");

// ScriptStruct InGameModule.LastLocationData
// 0x0020 (0x0020 - 0x0000)
struct FLastLocationData final
{
public:
	struct FVector2D                              _phase4CircleLocation;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _note;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bPreview;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLastLocationData) == 0x000008, "Wrong alignment on FLastLocationData");
static_assert(sizeof(FLastLocationData) == 0x000020, "Wrong size on FLastLocationData");
static_assert(offsetof(FLastLocationData, _phase4CircleLocation) == 0x000000, "Member 'FLastLocationData::_phase4CircleLocation' has a wrong offset!");
static_assert(offsetof(FLastLocationData, _note) == 0x000008, "Member 'FLastLocationData::_note' has a wrong offset!");
static_assert(offsetof(FLastLocationData, _bPreview) == 0x000018, "Member 'FLastLocationData::_bPreview' has a wrong offset!");

// ScriptStruct InGameModule.PoisonMistLocationData
// 0x0028 (0x0028 - 0x0000)
struct FPoisonMistLocationData final
{
public:
	class FString                                 _note;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _phase3CircleLocation;                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLastLocationData>              _lastLocationData;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoisonMistLocationData) == 0x000008, "Wrong alignment on FPoisonMistLocationData");
static_assert(sizeof(FPoisonMistLocationData) == 0x000028, "Wrong size on FPoisonMistLocationData");
static_assert(offsetof(FPoisonMistLocationData, _note) == 0x000000, "Member 'FPoisonMistLocationData::_note' has a wrong offset!");
static_assert(offsetof(FPoisonMistLocationData, _phase3CircleLocation) == 0x000010, "Member 'FPoisonMistLocationData::_phase3CircleLocation' has a wrong offset!");
static_assert(offsetof(FPoisonMistLocationData, _lastLocationData) == 0x000018, "Member 'FPoisonMistLocationData::_lastLocationData' has a wrong offset!");

// ScriptStruct InGameModule.PoisonMistLocationTableRow
// 0x0028 (0x0030 - 0x0008)
struct FPoisonMistLocationTableRow final : public FTableRowBase
{
public:
	class FString                                 _note;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _phase2CircleLocation;                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPoisonMistLocationData>        _locationDataList;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoisonMistLocationTableRow) == 0x000008, "Wrong alignment on FPoisonMistLocationTableRow");
static_assert(sizeof(FPoisonMistLocationTableRow) == 0x000030, "Wrong size on FPoisonMistLocationTableRow");
static_assert(offsetof(FPoisonMistLocationTableRow, _note) == 0x000008, "Member 'FPoisonMistLocationTableRow::_note' has a wrong offset!");
static_assert(offsetof(FPoisonMistLocationTableRow, _phase2CircleLocation) == 0x000018, "Member 'FPoisonMistLocationTableRow::_phase2CircleLocation' has a wrong offset!");
static_assert(offsetof(FPoisonMistLocationTableRow, _locationDataList) == 0x000020, "Member 'FPoisonMistLocationTableRow::_locationDataList' has a wrong offset!");

// ScriptStruct InGameModule.PoisonMistTableRow
// 0x0010 (0x0018 - 0x0008)
struct FPoisonMistTableRow final : public FTableRowBase
{
public:
	float                                         _shrinkStartScale;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _shrinkCompleteScale;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _damagePerSecond;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBiasType                                     _biasType;                                         // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPoisonMistTableRow) == 0x000008, "Wrong alignment on FPoisonMistTableRow");
static_assert(sizeof(FPoisonMistTableRow) == 0x000018, "Wrong size on FPoisonMistTableRow");
static_assert(offsetof(FPoisonMistTableRow, _shrinkStartScale) == 0x000008, "Member 'FPoisonMistTableRow::_shrinkStartScale' has a wrong offset!");
static_assert(offsetof(FPoisonMistTableRow, _shrinkCompleteScale) == 0x00000C, "Member 'FPoisonMistTableRow::_shrinkCompleteScale' has a wrong offset!");
static_assert(offsetof(FPoisonMistTableRow, _damagePerSecond) == 0x000010, "Member 'FPoisonMistTableRow::_damagePerSecond' has a wrong offset!");
static_assert(offsetof(FPoisonMistTableRow, _biasType) == 0x000014, "Member 'FPoisonMistTableRow::_biasType' has a wrong offset!");

// ScriptStruct InGameModule.PoisonMistTimeTableRow
// 0x0008 (0x0010 - 0x0008)
struct FPoisonMistTimeTableRow final : public FTableRowBase
{
public:
	float                                         _shrinkStartIntervalSeconds;                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _shrinkCompleteSeconds;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoisonMistTimeTableRow) == 0x000008, "Wrong alignment on FPoisonMistTimeTableRow");
static_assert(sizeof(FPoisonMistTimeTableRow) == 0x000010, "Wrong size on FPoisonMistTimeTableRow");
static_assert(offsetof(FPoisonMistTimeTableRow, _shrinkStartIntervalSeconds) == 0x000008, "Member 'FPoisonMistTimeTableRow::_shrinkStartIntervalSeconds' has a wrong offset!");
static_assert(offsetof(FPoisonMistTimeTableRow, _shrinkCompleteSeconds) == 0x00000C, "Member 'FPoisonMistTimeTableRow::_shrinkCompleteSeconds' has a wrong offset!");

// ScriptStruct InGameModule.PoisonMistMovementData
// 0x000C (0x000C - 0x0000)
struct FPoisonMistMovementData final
{
public:
	float                                         _minMovementDistanceSquared;                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _maxMovementDistanceSquared;                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _startMovementPhase;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoisonMistMovementData) == 0x000004, "Wrong alignment on FPoisonMistMovementData");
static_assert(sizeof(FPoisonMistMovementData) == 0x00000C, "Wrong size on FPoisonMistMovementData");
static_assert(offsetof(FPoisonMistMovementData, _minMovementDistanceSquared) == 0x000000, "Member 'FPoisonMistMovementData::_minMovementDistanceSquared' has a wrong offset!");
static_assert(offsetof(FPoisonMistMovementData, _maxMovementDistanceSquared) == 0x000004, "Member 'FPoisonMistMovementData::_maxMovementDistanceSquared' has a wrong offset!");
static_assert(offsetof(FPoisonMistMovementData, _startMovementPhase) == 0x000008, "Member 'FPoisonMistMovementData::_startMovementPhase' has a wrong offset!");

// ScriptStruct InGameModule.StagePoisonMistData
// 0x01B8 (0x01B8 - 0x0000)
struct FStagePoisonMistData final
{
public:
	class FName                                   _name;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFirstLocationData>             _firstLocation;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPoisonMistLocationTableRow> _locationList;                                     // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPoisonMistTableRow> _scaleList;                                        // 0x0068(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPoisonMistTimeTableRow> _timeList;                                         // 0x00B8(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FPoisonMistMovementData                _movement;                                         // 0x0108(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPoisonMistTimeTableRow> _timeTableListByKillBattle;                        // 0x0118(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPoisonMistTimeTableRow> _timeTableListByTeamOrbBattle;                     // 0x0168(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStagePoisonMistData) == 0x000008, "Wrong alignment on FStagePoisonMistData");
static_assert(sizeof(FStagePoisonMistData) == 0x0001B8, "Wrong size on FStagePoisonMistData");
static_assert(offsetof(FStagePoisonMistData, _name) == 0x000000, "Member 'FStagePoisonMistData::_name' has a wrong offset!");
static_assert(offsetof(FStagePoisonMistData, _firstLocation) == 0x000008, "Member 'FStagePoisonMistData::_firstLocation' has a wrong offset!");
static_assert(offsetof(FStagePoisonMistData, _locationList) == 0x000018, "Member 'FStagePoisonMistData::_locationList' has a wrong offset!");
static_assert(offsetof(FStagePoisonMistData, _scaleList) == 0x000068, "Member 'FStagePoisonMistData::_scaleList' has a wrong offset!");
static_assert(offsetof(FStagePoisonMistData, _timeList) == 0x0000B8, "Member 'FStagePoisonMistData::_timeList' has a wrong offset!");
static_assert(offsetof(FStagePoisonMistData, _movement) == 0x000108, "Member 'FStagePoisonMistData::_movement' has a wrong offset!");
static_assert(offsetof(FStagePoisonMistData, _timeTableListByKillBattle) == 0x000118, "Member 'FStagePoisonMistData::_timeTableListByKillBattle' has a wrong offset!");
static_assert(offsetof(FStagePoisonMistData, _timeTableListByTeamOrbBattle) == 0x000168, "Member 'FStagePoisonMistData::_timeTableListByTeamOrbBattle' has a wrong offset!");

// ScriptStruct InGameModule.StagePoisonMistDataList
// 0x0010 (0x0010 - 0x0000)
struct FStagePoisonMistDataList final
{
public:
	TArray<struct FStagePoisonMistData>           _stagePoisonMistDataList;                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStagePoisonMistDataList) == 0x000008, "Wrong alignment on FStagePoisonMistDataList");
static_assert(sizeof(FStagePoisonMistDataList) == 0x000010, "Wrong size on FStagePoisonMistDataList");
static_assert(offsetof(FStagePoisonMistDataList, _stagePoisonMistDataList) == 0x000000, "Member 'FStagePoisonMistDataList::_stagePoisonMistDataList' has a wrong offset!");

// ScriptStruct InGameModule.TeamKillBattlePoisonMistTable
// 0x0004 (0x0004 - 0x0000)
struct FTeamKillBattlePoisonMistTable final
{
public:
	int32                                         _stopPhase;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamKillBattlePoisonMistTable) == 0x000004, "Wrong alignment on FTeamKillBattlePoisonMistTable");
static_assert(sizeof(FTeamKillBattlePoisonMistTable) == 0x000004, "Wrong size on FTeamKillBattlePoisonMistTable");
static_assert(offsetof(FTeamKillBattlePoisonMistTable, _stopPhase) == 0x000000, "Member 'FTeamKillBattlePoisonMistTable::_stopPhase' has a wrong offset!");

// ScriptStruct InGameModule.TeamOrbPoisonMistTable
// 0x0028 (0x0028 - 0x0000)
struct FTeamOrbPoisonMistTable final
{
public:
	int32                                         _moveModePhase;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _minMoveLength;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _completeMoveSeconds;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _intervalSecondsList;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         _damagePerSeconds;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamOrbPoisonMistTable) == 0x000008, "Wrong alignment on FTeamOrbPoisonMistTable");
static_assert(sizeof(FTeamOrbPoisonMistTable) == 0x000028, "Wrong size on FTeamOrbPoisonMistTable");
static_assert(offsetof(FTeamOrbPoisonMistTable, _moveModePhase) == 0x000000, "Member 'FTeamOrbPoisonMistTable::_moveModePhase' has a wrong offset!");
static_assert(offsetof(FTeamOrbPoisonMistTable, _minMoveLength) == 0x000004, "Member 'FTeamOrbPoisonMistTable::_minMoveLength' has a wrong offset!");
static_assert(offsetof(FTeamOrbPoisonMistTable, _completeMoveSeconds) == 0x000008, "Member 'FTeamOrbPoisonMistTable::_completeMoveSeconds' has a wrong offset!");
static_assert(offsetof(FTeamOrbPoisonMistTable, _intervalSecondsList) == 0x000010, "Member 'FTeamOrbPoisonMistTable::_intervalSecondsList' has a wrong offset!");
static_assert(offsetof(FTeamOrbPoisonMistTable, _damagePerSeconds) == 0x000020, "Member 'FTeamOrbPoisonMistTable::_damagePerSeconds' has a wrong offset!");

// ScriptStruct InGameModule.SquadKingsPoisonMistTable
// 0x0004 (0x0004 - 0x0000)
struct FSquadKingsPoisonMistTable final
{
public:
	float                                         _forcedStartShrinkSeconds;                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSquadKingsPoisonMistTable) == 0x000004, "Wrong alignment on FSquadKingsPoisonMistTable");
static_assert(sizeof(FSquadKingsPoisonMistTable) == 0x000004, "Wrong size on FSquadKingsPoisonMistTable");
static_assert(offsetof(FSquadKingsPoisonMistTable, _forcedStartShrinkSeconds) == 0x000000, "Member 'FSquadKingsPoisonMistTable::_forcedStartShrinkSeconds' has a wrong offset!");

// ScriptStruct InGameModule.PoisonMistFadeRow
// 0x0008 (0x0010 - 0x0008)
struct FPoisonMistFadeRow final : public FTableRowBase
{
public:
	float                                         _alphaDeltaTimeSeconds;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _easingType;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPoisonMistFadeRow) == 0x000008, "Wrong alignment on FPoisonMistFadeRow");
static_assert(sizeof(FPoisonMistFadeRow) == 0x000010, "Wrong size on FPoisonMistFadeRow");
static_assert(offsetof(FPoisonMistFadeRow, _alphaDeltaTimeSeconds) == 0x000008, "Member 'FPoisonMistFadeRow::_alphaDeltaTimeSeconds' has a wrong offset!");
static_assert(offsetof(FPoisonMistFadeRow, _easingType) == 0x00000C, "Member 'FPoisonMistFadeRow::_easingType' has a wrong offset!");

// ScriptStruct InGameModule.PortalGenRep
// 0x0008 (0x0008 - 0x0000)
struct FPortalGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarpUsedConsumptionTime;                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPortalGenRep) == 0x000004, "Wrong alignment on FPortalGenRep");
static_assert(sizeof(FPortalGenRep) == 0x000008, "Wrong size on FPortalGenRep");
static_assert(offsetof(FPortalGenRep, SerialID) == 0x000000, "Member 'FPortalGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FPortalGenRep, WarpUsedConsumptionTime) == 0x000004, "Member 'FPortalGenRep::WarpUsedConsumptionTime' has a wrong offset!");

// ScriptStruct InGameModule.PortalShotGenRep
// 0x0010 (0x0010 - 0x0000)
struct FPortalShotGenRep final
{
public:
	int8                                          SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  CreatePortalLocate;                                // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPortalShotGenRep) == 0x000004, "Wrong alignment on FPortalShotGenRep");
static_assert(sizeof(FPortalShotGenRep) == 0x000010, "Wrong size on FPortalShotGenRep");
static_assert(offsetof(FPortalShotGenRep, SerialID) == 0x000000, "Member 'FPortalShotGenRep::SerialID' has a wrong offset!");
static_assert(offsetof(FPortalShotGenRep, CreatePortalLocate) == 0x000004, "Member 'FPortalShotGenRep::CreatePortalLocate' has a wrong offset!");

// ScriptStruct InGameModule.StageInfo
// 0x0020 (0x0020 - 0x0000)
struct FStageInfo final
{
public:
	float                                         _maxRadius;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               _areaRectangleVector4;                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStageInfo) == 0x000010, "Wrong alignment on FStageInfo");
static_assert(sizeof(FStageInfo) == 0x000020, "Wrong size on FStageInfo");
static_assert(offsetof(FStageInfo, _maxRadius) == 0x000000, "Member 'FStageInfo::_maxRadius' has a wrong offset!");
static_assert(offsetof(FStageInfo, _areaRectangleVector4) == 0x000010, "Member 'FStageInfo::_areaRectangleVector4' has a wrong offset!");

// ScriptStruct InGameModule.DestroyBulletGenRep
// 0x000C (0x000C - 0x0000)
struct FDestroyBulletGenRep final
{
public:
	int32                                         Serial;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Idx;                                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletDestroyType                            DestroyType;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestroyBulletGenRep) == 0x000004, "Wrong alignment on FDestroyBulletGenRep");
static_assert(sizeof(FDestroyBulletGenRep) == 0x00000C, "Wrong size on FDestroyBulletGenRep");
static_assert(offsetof(FDestroyBulletGenRep, Serial) == 0x000000, "Member 'FDestroyBulletGenRep::Serial' has a wrong offset!");
static_assert(offsetof(FDestroyBulletGenRep, Idx) == 0x000004, "Member 'FDestroyBulletGenRep::Idx' has a wrong offset!");
static_assert(offsetof(FDestroyBulletGenRep, DestroyType) == 0x000008, "Member 'FDestroyBulletGenRep::DestroyType' has a wrong offset!");

// ScriptStruct InGameModule.HitSavedInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FHitSavedInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitSavedInfo) == 0x000004, "Wrong alignment on FHitSavedInfo");
static_assert(sizeof(FHitSavedInfo) == 0x00000C, "Wrong size on FHitSavedInfo");

// ScriptStruct InGameModule.ProjectileTransform
// 0x0024 (0x0024 - 0x0000)
struct FProjectileTransform final
{
public:
	struct FVector                                Locate;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileTransform) == 0x000004, "Wrong alignment on FProjectileTransform");
static_assert(sizeof(FProjectileTransform) == 0x000024, "Wrong size on FProjectileTransform");
static_assert(offsetof(FProjectileTransform, Locate) == 0x000000, "Member 'FProjectileTransform::Locate' has a wrong offset!");
static_assert(offsetof(FProjectileTransform, Rot) == 0x00000C, "Member 'FProjectileTransform::Rot' has a wrong offset!");
static_assert(offsetof(FProjectileTransform, Scale) == 0x000018, "Member 'FProjectileTransform::Scale' has a wrong offset!");

// ScriptStruct InGameModule.BulletPoolArray
// 0x0010 (0x0010 - 0x0000)
struct FBulletPoolArray final
{
public:
	TArray<class ABullet*>                        bullets;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletPoolArray) == 0x000008, "Wrong alignment on FBulletPoolArray");
static_assert(sizeof(FBulletPoolArray) == 0x000010, "Wrong size on FBulletPoolArray");
static_assert(offsetof(FBulletPoolArray, bullets) == 0x000000, "Member 'FBulletPoolArray::bullets' has a wrong offset!");

// ScriptStruct InGameModule.CreateGeneratorSetup
// 0x0110 (0x0110 - 0x0000)
struct alignas(0x10) FCreateGeneratorSetup final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OverrideOwner;                                     // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OverrideLockonActor;                               // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Parent;                                            // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateGeneratorSetup) == 0x000010, "Wrong alignment on FCreateGeneratorSetup");
static_assert(sizeof(FCreateGeneratorSetup) == 0x000110, "Wrong size on FCreateGeneratorSetup");
static_assert(offsetof(FCreateGeneratorSetup, OverrideOwner) == 0x0000A0, "Member 'FCreateGeneratorSetup::OverrideOwner' has a wrong offset!");
static_assert(offsetof(FCreateGeneratorSetup, OverrideLockonActor) == 0x0000A8, "Member 'FCreateGeneratorSetup::OverrideLockonActor' has a wrong offset!");
static_assert(offsetof(FCreateGeneratorSetup, Parent) == 0x0000B0, "Member 'FCreateGeneratorSetup::Parent' has a wrong offset!");

// ScriptStruct InGameModule.BulletHitRep
// 0x0018 (0x0018 - 0x0000)
struct FBulletHitRep final
{
public:
	int16                                         GenID;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         PlayerId;                                          // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bulletIndex;                                       // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 DamageCauser_velocity;                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastHit;                                           // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletHitRep) == 0x000004, "Wrong alignment on FBulletHitRep");
static_assert(sizeof(FBulletHitRep) == 0x000018, "Wrong size on FBulletHitRep");
static_assert(offsetof(FBulletHitRep, GenID) == 0x000000, "Member 'FBulletHitRep::GenID' has a wrong offset!");
static_assert(offsetof(FBulletHitRep, PlayerId) == 0x000002, "Member 'FBulletHitRep::PlayerId' has a wrong offset!");
static_assert(offsetof(FBulletHitRep, bulletIndex) == 0x000004, "Member 'FBulletHitRep::bulletIndex' has a wrong offset!");
static_assert(offsetof(FBulletHitRep, DamageCauser_velocity) == 0x000008, "Member 'FBulletHitRep::DamageCauser_velocity' has a wrong offset!");
static_assert(offsetof(FBulletHitRep, LastHit) == 0x000014, "Member 'FBulletHitRep::LastHit' has a wrong offset!");

// ScriptStruct InGameModule.RestraintParticleInfo
// 0x0024 (0x0024 - 0x0000)
struct FRestraintParticleInfo final
{
public:
	class FName                                   _beginParticleName;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _loopParticleName;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _endParticleName;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _soundCueName;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _stopTimeSecounds;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRestraintParticleInfo) == 0x000004, "Wrong alignment on FRestraintParticleInfo");
static_assert(sizeof(FRestraintParticleInfo) == 0x000024, "Wrong size on FRestraintParticleInfo");
static_assert(offsetof(FRestraintParticleInfo, _beginParticleName) == 0x000000, "Member 'FRestraintParticleInfo::_beginParticleName' has a wrong offset!");
static_assert(offsetof(FRestraintParticleInfo, _loopParticleName) == 0x000008, "Member 'FRestraintParticleInfo::_loopParticleName' has a wrong offset!");
static_assert(offsetof(FRestraintParticleInfo, _endParticleName) == 0x000010, "Member 'FRestraintParticleInfo::_endParticleName' has a wrong offset!");
static_assert(offsetof(FRestraintParticleInfo, _soundCueName) == 0x000018, "Member 'FRestraintParticleInfo::_soundCueName' has a wrong offset!");
static_assert(offsetof(FRestraintParticleInfo, _stopTimeSecounds) == 0x000020, "Member 'FRestraintParticleInfo::_stopTimeSecounds' has a wrong offset!");

// ScriptStruct InGameModule.SalvoBulletSetting
// 0x0020 (0x0020 - 0x0000)
struct FSalvoBulletSetting final
{
public:
	class FName                                   _socketName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _offsetLocation;                                   // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _offsetRotation;                                   // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSalvoBulletSetting) == 0x000004, "Wrong alignment on FSalvoBulletSetting");
static_assert(sizeof(FSalvoBulletSetting) == 0x000020, "Wrong size on FSalvoBulletSetting");
static_assert(offsetof(FSalvoBulletSetting, _socketName) == 0x000000, "Member 'FSalvoBulletSetting::_socketName' has a wrong offset!");
static_assert(offsetof(FSalvoBulletSetting, _offsetLocation) == 0x000008, "Member 'FSalvoBulletSetting::_offsetLocation' has a wrong offset!");
static_assert(offsetof(FSalvoBulletSetting, _offsetRotation) == 0x000014, "Member 'FSalvoBulletSetting::_offsetRotation' has a wrong offset!");

// ScriptStruct InGameModule.DrawDamageInfo
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FDrawDamageInfo final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDrawDamageInfo) == 0x000008, "Wrong alignment on FDrawDamageInfo");
static_assert(sizeof(FDrawDamageInfo) == 0x000068, "Wrong size on FDrawDamageInfo");

// ScriptStruct InGameModule.StatusMatParams
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FStatusMatParams final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusMatParams) == 0x000004, "Wrong alignment on FStatusMatParams");
static_assert(sizeof(FStatusMatParams) == 0x00000C, "Wrong size on FStatusMatParams");

// ScriptStruct InGameModule.SkillInfo
// 0x0010 (0x0010 - 0x0000)
struct FSkillInfo final
{
public:
	uint8                                         _level;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _variationNo;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _masterCharacterId;                                // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UActionAttackBase>          _actionAttackClass;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillInfo) == 0x000008, "Wrong alignment on FSkillInfo");
static_assert(sizeof(FSkillInfo) == 0x000010, "Wrong size on FSkillInfo");
static_assert(offsetof(FSkillInfo, _level) == 0x000000, "Member 'FSkillInfo::_level' has a wrong offset!");
static_assert(offsetof(FSkillInfo, _variationNo) == 0x000001, "Member 'FSkillInfo::_variationNo' has a wrong offset!");
static_assert(offsetof(FSkillInfo, _masterCharacterId) == 0x000002, "Member 'FSkillInfo::_masterCharacterId' has a wrong offset!");
static_assert(offsetof(FSkillInfo, _actionAttackClass) == 0x000008, "Member 'FSkillInfo::_actionAttackClass' has a wrong offset!");

// ScriptStruct InGameModule.SupplyCreateArgument
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FSupplyCreateArgument final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSupplyCreateArgument) == 0x000004, "Wrong alignment on FSupplyCreateArgument");
static_assert(sizeof(FSupplyCreateArgument) == 0x000018, "Wrong size on FSupplyCreateArgument");

// ScriptStruct InGameModule.SupplyFloatEffects
// 0x0018 (0x0018 - 0x0000)
struct FSupplyFloatEffects final
{
public:
	float                                         _value;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _description;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupplyFloatEffects) == 0x000008, "Wrong alignment on FSupplyFloatEffects");
static_assert(sizeof(FSupplyFloatEffects) == 0x000018, "Wrong size on FSupplyFloatEffects");
static_assert(offsetof(FSupplyFloatEffects, _value) == 0x000000, "Member 'FSupplyFloatEffects::_value' has a wrong offset!");
static_assert(offsetof(FSupplyFloatEffects, _description) == 0x000008, "Member 'FSupplyFloatEffects::_description' has a wrong offset!");

// ScriptStruct InGameModule.NetUseSupplyResult
// 0x0001 (0x0001 - 0x0000)
struct FNetUseSupplyResult final
{
public:
	bool                                          _bStoped;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetUseSupplyResult) == 0x000001, "Wrong alignment on FNetUseSupplyResult");
static_assert(sizeof(FNetUseSupplyResult) == 0x000001, "Wrong size on FNetUseSupplyResult");
static_assert(offsetof(FNetUseSupplyResult, _bStoped) == 0x000000, "Member 'FNetUseSupplyResult::_bStoped' has a wrong offset!");

// ScriptStruct InGameModule.SkillHolderInitializeData
// 0x0018 (0x0018 - 0x0000)
struct FSkillHolderInitializeData final
{
public:
	uint32                                        _serialId;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _assetkey;                                         // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _characterId;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackId                                     _attackID;                                         // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _level;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _variation;                                        // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillHolderInitializeData) == 0x000004, "Wrong alignment on FSkillHolderInitializeData");
static_assert(sizeof(FSkillHolderInitializeData) == 0x000018, "Wrong size on FSkillHolderInitializeData");
static_assert(offsetof(FSkillHolderInitializeData, _serialId) == 0x000000, "Member 'FSkillHolderInitializeData::_serialId' has a wrong offset!");
static_assert(offsetof(FSkillHolderInitializeData, _assetkey) == 0x000004, "Member 'FSkillHolderInitializeData::_assetkey' has a wrong offset!");
static_assert(offsetof(FSkillHolderInitializeData, _characterId) == 0x00000C, "Member 'FSkillHolderInitializeData::_characterId' has a wrong offset!");
static_assert(offsetof(FSkillHolderInitializeData, _attackID) == 0x00000D, "Member 'FSkillHolderInitializeData::_attackID' has a wrong offset!");
static_assert(offsetof(FSkillHolderInitializeData, _level) == 0x000010, "Member 'FSkillHolderInitializeData::_level' has a wrong offset!");
static_assert(offsetof(FSkillHolderInitializeData, _variation) == 0x000014, "Member 'FSkillHolderInitializeData::_variation' has a wrong offset!");

// ScriptStruct InGameModule.SupplySpawnParam
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FSupplySpawnParam final
{
public:
	uint8                                         Pad_0[0x6C];                                       // 0x0000(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lifeTimeDropedPlayer;                             // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _ignoreList;                                       // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupplySpawnParam) == 0x000010, "Wrong alignment on FSupplySpawnParam");
static_assert(sizeof(FSupplySpawnParam) == 0x000080, "Wrong size on FSupplySpawnParam");
static_assert(offsetof(FSupplySpawnParam, _lifeTimeDropedPlayer) == 0x00006C, "Member 'FSupplySpawnParam::_lifeTimeDropedPlayer' has a wrong offset!");
static_assert(offsetof(FSupplySpawnParam, _ignoreList) == 0x000070, "Member 'FSupplySpawnParam::_ignoreList' has a wrong offset!");

// ScriptStruct InGameModule.SupplySpawnFromBoxRow
// 0x0000 (0x0010 - 0x0010)
struct FSupplySpawnFromBoxRow final : public FRateTableRowBase
{
};
static_assert(alignof(FSupplySpawnFromBoxRow) == 0x000008, "Wrong alignment on FSupplySpawnFromBoxRow");
static_assert(sizeof(FSupplySpawnFromBoxRow) == 0x000010, "Wrong size on FSupplySpawnFromBoxRow");

// ScriptStruct InGameModule.TakeCharacterImageAnimTableRow
// 0x0038 (0x0040 - 0x0008)
struct FTakeCharacterImageAnimTableRow final : public FTableRowBase
{
public:
	class FString                                 Filename;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           Asset;                                             // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTakeCharacterImageAnimTableRow) == 0x000008, "Wrong alignment on FTakeCharacterImageAnimTableRow");
static_assert(sizeof(FTakeCharacterImageAnimTableRow) == 0x000040, "Wrong size on FTakeCharacterImageAnimTableRow");
static_assert(offsetof(FTakeCharacterImageAnimTableRow, Filename) == 0x000008, "Member 'FTakeCharacterImageAnimTableRow::Filename' has a wrong offset!");
static_assert(offsetof(FTakeCharacterImageAnimTableRow, Asset) == 0x000018, "Member 'FTakeCharacterImageAnimTableRow::Asset' has a wrong offset!");

// ScriptStruct InGameModule.TransformingData
// 0x0002 (0x0002 - 0x0000)
struct FTransformingData final
{
public:
	ECharacterId                                  _charaId;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerId;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformingData) == 0x000001, "Wrong alignment on FTransformingData");
static_assert(sizeof(FTransformingData) == 0x000002, "Wrong size on FTransformingData");
static_assert(offsetof(FTransformingData, _charaId) == 0x000000, "Member 'FTransformingData::_charaId' has a wrong offset!");
static_assert(offsetof(FTransformingData, _playerId) == 0x000001, "Member 'FTransformingData::_playerId' has a wrong offset!");

// ScriptStruct InGameModule.JoinedPlayer
// 0x0010 (0x0010 - 0x0000)
struct FJoinedPlayer final
{
public:
	class APlayerStateBattle*                     _playerState;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJoinedPlayer) == 0x000008, "Wrong alignment on FJoinedPlayer");
static_assert(sizeof(FJoinedPlayer) == 0x000010, "Wrong size on FJoinedPlayer");
static_assert(offsetof(FJoinedPlayer, _playerState) == 0x000000, "Member 'FJoinedPlayer::_playerState' has a wrong offset!");

// ScriptStruct InGameModule.ItemParticleInfo
// 0x0010 (0x0010 - 0x0000)
struct FItemParticleInfo final
{
public:
	TArray<class FName>                           _particlePassName;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemParticleInfo) == 0x000008, "Wrong alignment on FItemParticleInfo");
static_assert(sizeof(FItemParticleInfo) == 0x000010, "Wrong size on FItemParticleInfo");
static_assert(offsetof(FItemParticleInfo, _particlePassName) == 0x000000, "Member 'FItemParticleInfo::_particlePassName' has a wrong offset!");

}

