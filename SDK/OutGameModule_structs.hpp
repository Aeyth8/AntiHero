#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OutGameModule

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "MasterDataModule_structs.hpp"
#include "CommonModule_structs.hpp"
#include "Engine_structs.hpp"
#include "UMG_structs.hpp"
#include "BackendSubsystem_structs.hpp"


namespace SDK
{

// Enum OutGameModule.EOutGameCharacterAnimationType
// NumValues: 0x0004
enum class EOutGameCharacterAnimationType : uint8
{
	IDLE                                     = 0,
	CHARACTOR_APPEAR                         = 1,
	NONE                                     = 2,
	MAX                                      = 3,
};

// Enum OutGameModule.EOffsetsType
// NumValues: 0x0003
enum class EOffsetsType : uint8
{
	PIXEL                                    = 0,
	PERCENT                                  = 1,
	EOffsetsType_MAX                         = 2,
};

// Enum OutGameModule.ETabIconSpaceType
// NumValues: 0x0004
enum class ETabIconSpaceType : uint8
{
	NOT_SECURE_SPACE                         = 0,
	SECURE_SPACE                             = 1,
	SECURE_SPACE_SYMMETRICAL                 = 2,
	ETabIconSpaceType_MAX                    = 3,
};

// Enum OutGameModule.ESettingButtonBGType
// NumValues: 0x0005
enum class ESettingButtonBGType : uint8
{
	NONE                                     = 0,
	UP                                       = 1,
	CENTER                                   = 2,
	BOTTOM                                   = 3,
	MAX                                      = 4,
};

// Enum OutGameModule.ESettingSwitchType
// NumValues: 0x0003
enum class ESettingSwitchType : uint8
{
	LEFT                                     = 0,
	RIGHT                                    = 1,
	MAX                                      = 2,
};

// Enum OutGameModule.ESceneCaptureAvatarTypeId
// NumValues: 0x000A
enum class ESceneCaptureAvatarTypeId : uint8
{
	NONE                                     = 0,
	HAIR                                     = 1,
	EYEBROWS                                 = 2,
	EYES                                     = 3,
	PUPILS                                   = 4,
	NOSE                                     = 5,
	MOUTH                                    = 6,
	FACECOUNTOUR                             = 7,
	BODYSCALE                                = 8,
	ESceneCaptureAvatarTypeId_MAX            = 9,
};

// Enum OutGameModule.EEventType
// NumValues: 0x0004
enum class EEventType : uint8
{
	NONE                                     = 0,
	RANKING                                  = 1,
	SHOP                                     = 2,
	Max                                      = 3,
};

// Enum OutGameModule.EGashaLevelSequenceType
// NumValues: 0x0004
enum class EGashaLevelSequenceType : uint8
{
	ALL                                      = 0,
	ONCE_SHOT                                = 1,
	TEN_SHOT                                 = 2,
	MAX                                      = 3,
};

// Enum OutGameModule.EGashaLevelSequenceRarity
// NumValues: 0x0005
enum class EGashaLevelSequenceRarity : uint8
{
	ALL                                      = 0,
	NORMAL                                   = 1,
	GOLD                                     = 2,
	RAINBOW                                  = 3,
	MAX                                      = 4,
};

// Enum OutGameModule.EPresetWidgetType
// NumValues: 0x0005
enum class EPresetWidgetType : uint8
{
	DisplayOnly                              = 0,
	SaveAndCall                              = 1,
	Save                                     = 2,
	Call                                     = 3,
	EPresetWidgetType_MAX                    = 4,
};

// Enum OutGameModule.EPlayMenuStatusSequenceType
// NumValues: 0x0005
enum class EPlayMenuStatusSequenceType : uint8
{
	NONE                                     = 0,
	IN_PREPARATION                           = 1,
	READY                                    = 2,
	BATTLE                                   = 3,
	Max                                      = 4,
};

// Enum OutGameModule.EPlayMenuStatusType
// NumValues: 0x0007
enum class EPlayMenuStatusType : uint8
{
	Invalid                                  = 0,
	SOLO                                     = 1,
	SQUAD_LEADER                             = 2,
	SQUAD_MEMBER                             = 3,
	SQUAD_LEADER_PREPARETION                 = 4,
	SQUAD_MEMBER_PREPARETION                 = 5,
	Max                                      = 6,
};

// Enum OutGameModule.EItemSeasonType
// NumValues: 0x0005
enum class EItemSeasonType : uint8
{
	FreepassItem                             = 0,
	PremiumItem                              = 1,
	SpecialItem                              = 2,
	None                                     = 3,
	EItemSeasonType_MAX                      = 4,
};

// Enum OutGameModule.ESeasonType
// NumValues: 0x0003
enum class ESeasonType : uint8
{
	SeasonLicense                            = 0,
	SpecialLicense                           = 1,
	ESeasonType_MAX                          = 2,
};

// Enum OutGameModule.EItemType
// NumValues: 0x0005
enum class EItemType : uint8
{
	FreepassItem                             = 0,
	PremiumItem                              = 1,
	SpecialItem                              = 2,
	None                                     = 3,
	EItemType_MAX                            = 4,
};

// Enum OutGameModule.ESeasonImageSize
// NumValues: 0x0004
enum class ESeasonImageSize : uint8
{
	L                                        = 0,
	M                                        = 1,
	S                                        = 2,
	ESeasonImageSize_MAX                     = 3,
};

// Enum OutGameModule.ELicencePurchaseType
// NumValues: 0x0005
enum class ELicencePurchaseType : uint8
{
	ProLicence                               = 0,
	ProLicenceExp                            = 1,
	SpecialExp                               = 2,
	SpecielExpMultiple                       = 3,
	ELicencePurchaseType_MAX                 = 4,
};

// Enum OutGameModule.ESquadMemberInvitationStatus
// NumValues: 0x0005
enum class ESquadMemberInvitationStatus : uint8
{
	NONE                                     = 0,
	UNAPPLIED                                = 1,
	APPLYING                                 = 2,
	MEMBER                                   = 3,
	MAX                                      = 4,
};

// Enum OutGameModule.EStaffRollTextType
// NumValues: 0x000A
enum class EStaffRollTextType : uint8
{
	Large                                    = 0,
	Middle                                   = 1,
	MiddleDouble                             = 2,
	Small                                    = 3,
	SmalleDouble                             = 4,
	Image                                    = 5,
	Default                                  = 6,
	DefaultSingle                            = 7,
	DefaultDouble                            = 8,
	EStaffRollTextType_MAX                   = 9,
};

// Enum OutGameModule.ESettingSaveStatusType
// NumValues: 0x0004
enum class ESettingSaveStatusType : uint8
{
	NONE                                     = 0,
	SAVE_COMPLETION                          = 1,
	SAVE_WAIT                                = 2,
	MAX                                      = 3,
};

// Enum OutGameModule.EBootWidgetNextLevel
// NumValues: 0x0004
enum class EBootWidgetNextLevel : uint8
{
	INIT_SETTING                             = 0,
	XBOX_ACCOUNTSELECT                       = 1,
	TITLE                                    = 2,
	EBootWidgetNextLevel_MAX                 = 3,
};

// Enum OutGameModule.EBootWidgetPhaseType
// NumValues: 0x0006
enum class EBootWidgetPhaseType : uint8
{
	NONE                                     = 0,
	WARNING                                  = 1,
	BEWARE_OF_ILLEGAL_COPYING                = 2,
	LOGO                                     = 3,
	EXIT                                     = 4,
	EBootWidgetPhaseType_MAX                 = 5,
};

// Enum OutGameModule.EOutCameraType
// NumValues: 0x0008
enum class EOutCameraType : uint8
{
	NONE                                     = 0,
	ONE_SQUAD                                = 1,
	TWO_SQUAD                                = 2,
	THREE_SQUAD                              = 3,
	FOUR_SQUAD                               = 4,
	PLAYER_SELECT                            = 5,
	DUO_BATTLE                               = 6,
	MAX                                      = 7,
};

// Enum OutGameModule.ECharacterOutGameSpawnPointType
// NumValues: 0x0006
enum class ECharacterOutGameSpawnPointType : uint8
{
	S                                        = 0,
	M                                        = 1,
	L                                        = 2,
	LL                                       = 3,
	XL                                       = 4,
	Max                                      = 5,
};

// Enum OutGameModule.EContactNoticeRequestId
// NumValues: 0x0003
enum class EContactNoticeRequestId : uint8
{
	LOAD_NOTICE                              = 0,
	DELETE_OPENED_NOTICE                     = 1,
	MAX                                      = 2,
};

// Enum OutGameModule.EContactWidgetRequestType
// NumValues: 0x0004
enum class EContactWidgetRequestType : uint8
{
	INFORMATION                              = 0,
	INVITATION                               = 1,
	SQUAD_RECEIVED_INVITATION                = 2,
	MAX                                      = 3,
};

// Enum OutGameModule.EEventRewardType
// NumValues: 0x0003
enum class EEventRewardType : uint8
{
	REWARD                                   = 0,
	SPECIALEFFECT                            = 1,
	EEventRewardType_MAX                     = 2,
};

// Enum OutGameModule.ENotFocusOutSide
// NumValues: 0x0004
enum class ENotFocusOutSide : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ENotFocusOutSide_MAX                     = 3,
};

// Enum OutGameModule.EGashaOfferRatioColorIndex
// NumValues: 0x0005
enum class EGashaOfferRatioColorIndex : uint8
{
	NONE                                     = 0,
	HEADER                                   = 1,
	EVEN                                     = 2,
	ODD                                      = 3,
	MAX                                      = 4,
};

// Enum OutGameModule.EGashaOfferRatioOrder
// NumValues: 0x0004
enum class EGashaOfferRatioOrder : uint8
{
	NONE                                     = 0,
	ITEM_NAME                                = 1,
	ITEM_RATIO                               = 2,
	MAX                                      = 3,
};

// Enum OutGameModule.EGuildChatType
// NumValues: 0x0003
enum class EGuildChatType : uint8
{
	Message                                  = 0,
	Date                                     = 1,
	EGuildChatType_MAX                       = 2,
};

// Enum OutGameModule.EItemIconCoverType
// NumValues: 0x0003
enum class EItemIconCoverType : uint8
{
	NONE                                     = 0,
	LOCK                                     = 1,
	MAX                                      = 2,
};

// Enum OutGameModule.EKeyConfigCommandListType
// NumValues: 0x0007
enum class EKeyConfigCommandListType : uint8
{
	BUTTON                                   = 0,
	TOUCH_BUTTON_RIGHT                       = 1,
	TOUCH_BUTTON_LEFT                        = 2,
	ARROW                                    = 3,
	LONG_ARROW                               = 4,
	DERIVED                                  = 5,
	MAX                                      = 6,
};

// Enum OutGameModule.EPlayMenuHamburgerLargeIconType
// NumValues: 0x0006
enum class EPlayMenuHamburgerLargeIconType : uint8
{
	NONE                                     = 100,
	PLOFILE                                  = 0,
	GALLERY                                  = 1,
	RANKING                                  = 2,
	GUILD                                    = 3,
	Max                                      = 4,
};

// Enum OutGameModule.EPlayMenuHamburgerDebugListType
// NumValues: 0x0011
enum class EPlayMenuHamburgerDebugListType : uint8
{
	OFFLINE_ST01                             = 0,
	OFFLINE_ST02                             = 1,
	SPECTATING                               = 2,
	MASTER_DATA                              = 3,
	DEV_ONLINE                               = 4,
	CAMERATEST                               = 5,
	CAMERATEST_L                             = 6,
	CAMERATEST_LL                            = 7,
	OPEN_DIP                                 = 8,
	COSMOS_WEB_API                           = 9,
	VOICE_CHAT                               = 10,
	NETWORK_TEST                             = 11,
	TUTORIAL_TEST                            = 12,
	STORE_TEST                               = 13,
	PLATFORM_TEST                            = 14,
	AVATAR_DEBUG                             = 15,
	MAX                                      = 16,
};

// Enum OutGameModule.EPlayMenuPlayerStatusSwitchType
// NumValues: 0x0007
enum class EPlayMenuPlayerStatusSwitchType : uint8
{
	ONE_SQUAD                                = 0,
	TWO_SQUAD                                = 1,
	THREE_SQUAD                              = 2,
	FOUR_SQUAD                               = 3,
	DUO_BATTLE                               = 4,
	SOLO_BATTLE                              = 5,
	MAX                                      = 6,
};

// Enum OutGameModule.EPlayMenuRankingLeagueState
// NumValues: 0x0004
enum class EPlayMenuRankingLeagueState : uint8
{
	UP                                       = 0,
	DOWN                                     = 1,
	KEEP                                     = 2,
	EPlayMenuRankingLeagueState_MAX          = 3,
};

// Enum OutGameModule.EPlayMenuRankingStep
// NumValues: 0x0008
enum class EPlayMenuRankingStep : uint8
{
	NONE                                     = 0,
	EVENT                                    = 1,
	MVP                                      = 2,
	BILLBOARD                                = 3,
	ELITE                                    = 4,
	GUILD_TOP                                = 5,
	EXIT                                     = 6,
	MAX                                      = 7,
};

// Enum OutGameModule.EEventState
// NumValues: 0x0004
enum class EEventState : uint8
{
	HOLD                                     = 0,
	AGGREGATE                                = 1,
	END                                      = 2,
	MAX                                      = 3,
};

// Enum OutGameModule.ESettingActiveWidgetType
// NumValues: 0x0005
enum class ESettingActiveWidgetType : uint8
{
	GAMEPLAY                                 = 0,
	KEYCONFIG                                = 1,
	VIDEO                                    = 2,
	SOUND                                    = 3,
	MAX                                      = 4,
};

// Enum OutGameModule.EShopItemViewType
// NumValues: 0x0005
enum class EShopItemViewType : uint8
{
	Large1                                   = 0,
	Middle1                                  = 1,
	Small2                                   = 2,
	GameMoney                                = 3,
	EShopItemViewType_MAX                    = 4,
};

// Enum OutGameModule.EShopContentsType
// NumValues: 0x0007
enum class EShopContentsType : uint8
{
	CHARACTER                                = 0,
	EXTRA                                    = 1,
	TICKET                                   = 2,
	EVENT                                    = 3,
	GAMEMONEY                                = 4,
	HEROCRYSTAL                              = 5,
	MAX                                      = 6,
};

// Enum OutGameModule.ETitleInitSettingNextLevel
// NumValues: 0x0003
enum class ETitleInitSettingNextLevel : uint8
{
	XBOX_ACCOUNTSELECT                       = 0,
	TITLE                                    = 1,
	ETitleInitSettingNextLevel_MAX           = 2,
};

// Enum OutGameModule.ETitleStep
// NumValues: 0x000C
enum class ETitleStep : uint8
{
	NONE                                     = 0,
	INIT                                     = 1,
	CHECK_NETWORK_STATUS                     = 2,
	WAITING_FOR_LOADING_DOWNLOAD             = 3,
	WAITING_FOR_LOADING_ARRANGEMENT          = 4,
	WAITING_FOR_LOADING_END                  = 5,
	WAITING_FOR_INPUT                        = 6,
	LOGIN_REQUEST                            = 7,
	LOGIN_COMPLATE                           = 8,
	FADE_OUT_END                             = 9,
	TERMS_OF_SERVICE                         = 10,
	MAX                                      = 11,
};

// Enum OutGameModule.EUniformWidthType
// NumValues: 0x0003
enum class EUniformWidthType : uint8
{
	CLOSE_GAP                                = 0,
	SIZE_ADJUST                              = 1,
	EUniformWidthType_MAX                    = 2,
};

// ScriptStruct OutGameModule.BonusTypeInfo
// 0x0028 (0x0028 - 0x0000)
struct FBonusTypeInfo final
{
public:
	class UPaperSprite*                           _image;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _textColor;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _outlineColor;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBonusTypeInfo) == 0x000008, "Wrong alignment on FBonusTypeInfo");
static_assert(sizeof(FBonusTypeInfo) == 0x000028, "Wrong size on FBonusTypeInfo");
static_assert(offsetof(FBonusTypeInfo, _image) == 0x000000, "Member 'FBonusTypeInfo::_image' has a wrong offset!");
static_assert(offsetof(FBonusTypeInfo, _textColor) == 0x000008, "Member 'FBonusTypeInfo::_textColor' has a wrong offset!");
static_assert(offsetof(FBonusTypeInfo, _outlineColor) == 0x000018, "Member 'FBonusTypeInfo::_outlineColor' has a wrong offset!");

// ScriptStruct OutGameModule.ScoreInfo
// 0x0010 (0x0010 - 0x0000)
struct FScoreInfo
{
public:
	class FString                                 _title;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreInfo) == 0x000008, "Wrong alignment on FScoreInfo");
static_assert(sizeof(FScoreInfo) == 0x000010, "Wrong size on FScoreInfo");
static_assert(offsetof(FScoreInfo, _title) == 0x000000, "Member 'FScoreInfo::_title' has a wrong offset!");

// ScriptStruct OutGameModule.ScoreMagnification
// 0x0028 (0x0038 - 0x0010)
struct FScoreMagnification final : public FScoreInfo
{
public:
	float                                         _magnification;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _text;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScoreMagnification) == 0x000008, "Wrong alignment on FScoreMagnification");
static_assert(sizeof(FScoreMagnification) == 0x000038, "Wrong size on FScoreMagnification");
static_assert(offsetof(FScoreMagnification, _magnification) == 0x000010, "Member 'FScoreMagnification::_magnification' has a wrong offset!");
static_assert(offsetof(FScoreMagnification, _text) == 0x000018, "Member 'FScoreMagnification::_text' has a wrong offset!");

// ScriptStruct OutGameModule.TabHeaderIconInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FTabHeaderIconInfo final
{
public:
	struct FSlateBrush                            _icon;                                             // 0x0000(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              _offset;                                           // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTabHeaderIconInfo) == 0x000010, "Wrong alignment on FTabHeaderIconInfo");
static_assert(sizeof(FTabHeaderIconInfo) == 0x0000E0, "Wrong size on FTabHeaderIconInfo");
static_assert(offsetof(FTabHeaderIconInfo, _icon) == 0x000000, "Member 'FTabHeaderIconInfo::_icon' has a wrong offset!");
static_assert(offsetof(FTabHeaderIconInfo, _offset) == 0x0000D0, "Member 'FTabHeaderIconInfo::_offset' has a wrong offset!");

// ScriptStruct OutGameModule.TabInfo
// 0x0280 (0x0280 - 0x0000)
struct FTabInfo final
{
public:
	class FText                                   _tabName;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        _widgets;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          _bEnable;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDispDefaultBG;                                   // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDispTabBG;                                       // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bRatio;                                           // 0x002B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _topPatternSize;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _bottomPatternSize;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            _selectColor;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _unselectColor;                                    // 0x0060(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTabHeaderIconInfo                     _leftIcon;                                         // 0x00A0(0x00E0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTabHeaderIconInfo                     _rightIcon;                                        // 0x0180(0x00E0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETabIconSpaceType                             _iconSpaceType;                                    // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          _levelList;                                        // 0x0268(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTabInfo) == 0x000010, "Wrong alignment on FTabInfo");
static_assert(sizeof(FTabInfo) == 0x000280, "Wrong size on FTabInfo");
static_assert(offsetof(FTabInfo, _tabName) == 0x000000, "Member 'FTabInfo::_tabName' has a wrong offset!");
static_assert(offsetof(FTabInfo, _widgets) == 0x000018, "Member 'FTabInfo::_widgets' has a wrong offset!");
static_assert(offsetof(FTabInfo, _bEnable) == 0x000028, "Member 'FTabInfo::_bEnable' has a wrong offset!");
static_assert(offsetof(FTabInfo, _bDispDefaultBG) == 0x000029, "Member 'FTabInfo::_bDispDefaultBG' has a wrong offset!");
static_assert(offsetof(FTabInfo, _bDispTabBG) == 0x00002A, "Member 'FTabInfo::_bDispTabBG' has a wrong offset!");
static_assert(offsetof(FTabInfo, _bRatio) == 0x00002B, "Member 'FTabInfo::_bRatio' has a wrong offset!");
static_assert(offsetof(FTabInfo, _topPatternSize) == 0x00002C, "Member 'FTabInfo::_topPatternSize' has a wrong offset!");
static_assert(offsetof(FTabInfo, _bottomPatternSize) == 0x000030, "Member 'FTabInfo::_bottomPatternSize' has a wrong offset!");
static_assert(offsetof(FTabInfo, _selectColor) == 0x000038, "Member 'FTabInfo::_selectColor' has a wrong offset!");
static_assert(offsetof(FTabInfo, _unselectColor) == 0x000060, "Member 'FTabInfo::_unselectColor' has a wrong offset!");
static_assert(offsetof(FTabInfo, _leftIcon) == 0x0000A0, "Member 'FTabInfo::_leftIcon' has a wrong offset!");
static_assert(offsetof(FTabInfo, _rightIcon) == 0x000180, "Member 'FTabInfo::_rightIcon' has a wrong offset!");
static_assert(offsetof(FTabInfo, _iconSpaceType) == 0x000260, "Member 'FTabInfo::_iconSpaceType' has a wrong offset!");
static_assert(offsetof(FTabInfo, _levelList) == 0x000268, "Member 'FTabInfo::_levelList' has a wrong offset!");

// ScriptStruct OutGameModule.HistoryInfo
// 0x0018 (0x0018 - 0x0000)
struct FHistoryInfo final
{
public:
	int32                                         _itemCode;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 _itemCategory;                                     // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              _created;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _gashaCode;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _itemNum;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHistoryInfo) == 0x000008, "Wrong alignment on FHistoryInfo");
static_assert(sizeof(FHistoryInfo) == 0x000018, "Wrong size on FHistoryInfo");
static_assert(offsetof(FHistoryInfo, _itemCode) == 0x000000, "Member 'FHistoryInfo::_itemCode' has a wrong offset!");
static_assert(offsetof(FHistoryInfo, _itemCategory) == 0x000004, "Member 'FHistoryInfo::_itemCategory' has a wrong offset!");
static_assert(offsetof(FHistoryInfo, _created) == 0x000008, "Member 'FHistoryInfo::_created' has a wrong offset!");
static_assert(offsetof(FHistoryInfo, _gashaCode) == 0x000010, "Member 'FHistoryInfo::_gashaCode' has a wrong offset!");
static_assert(offsetof(FHistoryInfo, _itemNum) == 0x000014, "Member 'FHistoryInfo::_itemNum' has a wrong offset!");

// ScriptStruct OutGameModule.SquadMemberInvitationData
// 0x0010 (0x0010 - 0x0000)
struct FSquadMemberInvitationData final
{
public:
	TArray<class FText>                           _textLists;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSquadMemberInvitationData) == 0x000008, "Wrong alignment on FSquadMemberInvitationData");
static_assert(sizeof(FSquadMemberInvitationData) == 0x000010, "Wrong size on FSquadMemberInvitationData");
static_assert(offsetof(FSquadMemberInvitationData, _textLists) == 0x000000, "Member 'FSquadMemberInvitationData::_textLists' has a wrong offset!");

// ScriptStruct OutGameModule.ScoreRatio
// 0x0008 (0x0018 - 0x0010)
struct FScoreRatio : public FScoreInfo
{
public:
	float                                         _ratio;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScoreRatio) == 0x000008, "Wrong alignment on FScoreRatio");
static_assert(sizeof(FScoreRatio) == 0x000018, "Wrong size on FScoreRatio");
static_assert(offsetof(FScoreRatio, _ratio) == 0x000010, "Member 'FScoreRatio::_ratio' has a wrong offset!");

// ScriptStruct OutGameModule.ScoreRatioWindowInfo
// 0x0028 (0x0040 - 0x0018)
struct FScoreRatioWindowInfo : public FScoreRatio
{
public:
	class FString                                 _baseScoreTitle;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _ratioTitle;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScoreRatioWindowInfo) == 0x000008, "Wrong alignment on FScoreRatioWindowInfo");
static_assert(sizeof(FScoreRatioWindowInfo) == 0x000040, "Wrong size on FScoreRatioWindowInfo");
static_assert(offsetof(FScoreRatioWindowInfo, _baseScoreTitle) == 0x000018, "Member 'FScoreRatioWindowInfo::_baseScoreTitle' has a wrong offset!");
static_assert(offsetof(FScoreRatioWindowInfo, _ratioTitle) == 0x000028, "Member 'FScoreRatioWindowInfo::_ratioTitle' has a wrong offset!");

// ScriptStruct OutGameModule.GashaLevelSequence
// 0x0010 (0x0010 - 0x0000)
struct FGashaLevelSequence final
{
public:
	class ULevelSequence*                         _sequence;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGashaLevelSequenceRarity                     _rarity;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGashaLevelSequenceType                       _type;                                             // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGashaLevelSequence) == 0x000008, "Wrong alignment on FGashaLevelSequence");
static_assert(sizeof(FGashaLevelSequence) == 0x000010, "Wrong size on FGashaLevelSequence");
static_assert(offsetof(FGashaLevelSequence, _sequence) == 0x000000, "Member 'FGashaLevelSequence::_sequence' has a wrong offset!");
static_assert(offsetof(FGashaLevelSequence, _rarity) == 0x000008, "Member 'FGashaLevelSequence::_rarity' has a wrong offset!");
static_assert(offsetof(FGashaLevelSequence, _type) == 0x000009, "Member 'FGashaLevelSequence::_type' has a wrong offset!");

// ScriptStruct OutGameModule.SortButtonText
// 0x0030 (0x0030 - 0x0000)
struct FSortButtonText final
{
public:
	class FText                                   _sortCategoryText;                                 // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           _sortItemTexts;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         _defaultIndex;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSortButtonText) == 0x000008, "Wrong alignment on FSortButtonText");
static_assert(sizeof(FSortButtonText) == 0x000030, "Wrong size on FSortButtonText");
static_assert(offsetof(FSortButtonText, _sortCategoryText) == 0x000000, "Member 'FSortButtonText::_sortCategoryText' has a wrong offset!");
static_assert(offsetof(FSortButtonText, _sortItemTexts) == 0x000018, "Member 'FSortButtonText::_sortItemTexts' has a wrong offset!");
static_assert(offsetof(FSortButtonText, _defaultIndex) == 0x000028, "Member 'FSortButtonText::_defaultIndex' has a wrong offset!");

// ScriptStruct OutGameModule.GashaOfferRatioItem
// 0x0028 (0x0028 - 0x0000)
struct FGashaOfferRatioItem final
{
public:
	int32                                         _rarity;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _itemName;                                         // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         _rate;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bPickupFlg;                                       // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGashaOfferRatioItem) == 0x000008, "Wrong alignment on FGashaOfferRatioItem");
static_assert(sizeof(FGashaOfferRatioItem) == 0x000028, "Wrong size on FGashaOfferRatioItem");
static_assert(offsetof(FGashaOfferRatioItem, _rarity) == 0x000000, "Member 'FGashaOfferRatioItem::_rarity' has a wrong offset!");
static_assert(offsetof(FGashaOfferRatioItem, _itemName) == 0x000008, "Member 'FGashaOfferRatioItem::_itemName' has a wrong offset!");
static_assert(offsetof(FGashaOfferRatioItem, _rate) == 0x000020, "Member 'FGashaOfferRatioItem::_rate' has a wrong offset!");
static_assert(offsetof(FGashaOfferRatioItem, _bPickupFlg) == 0x000024, "Member 'FGashaOfferRatioItem::_bPickupFlg' has a wrong offset!");

// ScriptStruct OutGameModule.PlayMenuStatusTypeParam
// 0x0008 (0x0008 - 0x0000)
struct FPlayMenuStatusTypeParam final
{
public:
	float                                         _transY;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _sizeY;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayMenuStatusTypeParam) == 0x000004, "Wrong alignment on FPlayMenuStatusTypeParam");
static_assert(sizeof(FPlayMenuStatusTypeParam) == 0x000008, "Wrong size on FPlayMenuStatusTypeParam");
static_assert(offsetof(FPlayMenuStatusTypeParam, _transY) == 0x000000, "Member 'FPlayMenuStatusTypeParam::_transY' has a wrong offset!");
static_assert(offsetof(FPlayMenuStatusTypeParam, _sizeY) == 0x000004, "Member 'FPlayMenuStatusTypeParam::_sizeY' has a wrong offset!");

// ScriptStruct OutGameModule.BattleRuleCategoryInfo
// 0x0020 (0x0020 - 0x0000)
struct FBattleRuleCategoryInfo final
{
public:
	class FText                                   _titleName;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         _imageIndex;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleRuleCategoryInfo) == 0x000008, "Wrong alignment on FBattleRuleCategoryInfo");
static_assert(sizeof(FBattleRuleCategoryInfo) == 0x000020, "Wrong size on FBattleRuleCategoryInfo");
static_assert(offsetof(FBattleRuleCategoryInfo, _titleName) == 0x000000, "Member 'FBattleRuleCategoryInfo::_titleName' has a wrong offset!");
static_assert(offsetof(FBattleRuleCategoryInfo, _imageIndex) == 0x000018, "Member 'FBattleRuleCategoryInfo::_imageIndex' has a wrong offset!");

// ScriptStruct OutGameModule.BattleRuleDetailsInfo
// 0x0098 (0x0098 - 0x0000)
struct FBattleRuleDetailsInfo final
{
public:
	struct FSlateColor                            _basePlateColor;                                   // 0x0000(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _basePlateDotColor;                                // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _rulePlateColor;                                   // 0x0050(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   _name;                                             // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         _imageIndex;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOverrideGameMode;                                // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleRuleDetailsInfo) == 0x000008, "Wrong alignment on FBattleRuleDetailsInfo");
static_assert(sizeof(FBattleRuleDetailsInfo) == 0x000098, "Wrong size on FBattleRuleDetailsInfo");
static_assert(offsetof(FBattleRuleDetailsInfo, _basePlateColor) == 0x000000, "Member 'FBattleRuleDetailsInfo::_basePlateColor' has a wrong offset!");
static_assert(offsetof(FBattleRuleDetailsInfo, _basePlateDotColor) == 0x000028, "Member 'FBattleRuleDetailsInfo::_basePlateDotColor' has a wrong offset!");
static_assert(offsetof(FBattleRuleDetailsInfo, _rulePlateColor) == 0x000050, "Member 'FBattleRuleDetailsInfo::_rulePlateColor' has a wrong offset!");
static_assert(offsetof(FBattleRuleDetailsInfo, _name) == 0x000078, "Member 'FBattleRuleDetailsInfo::_name' has a wrong offset!");
static_assert(offsetof(FBattleRuleDetailsInfo, _imageIndex) == 0x000090, "Member 'FBattleRuleDetailsInfo::_imageIndex' has a wrong offset!");
static_assert(offsetof(FBattleRuleDetailsInfo, _bOverrideGameMode) == 0x000094, "Member 'FBattleRuleDetailsInfo::_bOverrideGameMode' has a wrong offset!");

// ScriptStruct OutGameModule.BattleRuleStageInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FBattleRuleStageInfo final
{
public:
	struct FSlateColor                            _stageNamePlateColor;                              // 0x0000(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _stageNameDotImageColor;                           // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _timerPlateColor;                                  // 0x0050(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _illustratePlateColor;                             // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          _bOverrideGameMode;                                // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleRuleStageInfo) == 0x000008, "Wrong alignment on FBattleRuleStageInfo");
static_assert(sizeof(FBattleRuleStageInfo) == 0x0000A8, "Wrong size on FBattleRuleStageInfo");
static_assert(offsetof(FBattleRuleStageInfo, _stageNamePlateColor) == 0x000000, "Member 'FBattleRuleStageInfo::_stageNamePlateColor' has a wrong offset!");
static_assert(offsetof(FBattleRuleStageInfo, _stageNameDotImageColor) == 0x000028, "Member 'FBattleRuleStageInfo::_stageNameDotImageColor' has a wrong offset!");
static_assert(offsetof(FBattleRuleStageInfo, _timerPlateColor) == 0x000050, "Member 'FBattleRuleStageInfo::_timerPlateColor' has a wrong offset!");
static_assert(offsetof(FBattleRuleStageInfo, _illustratePlateColor) == 0x000078, "Member 'FBattleRuleStageInfo::_illustratePlateColor' has a wrong offset!");
static_assert(offsetof(FBattleRuleStageInfo, _bOverrideGameMode) == 0x0000A0, "Member 'FBattleRuleStageInfo::_bOverrideGameMode' has a wrong offset!");

// ScriptStruct OutGameModule.BattleRuleInfo
// 0x000C (0x000C - 0x0000)
struct FBattleRuleInfo final
{
public:
	EPlayModeModeCategory                         _contents;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMdGameMode                                   _gameModeTypes;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfPeople;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _stageId;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleRuleInfo) == 0x000004, "Wrong alignment on FBattleRuleInfo");
static_assert(sizeof(FBattleRuleInfo) == 0x00000C, "Wrong size on FBattleRuleInfo");
static_assert(offsetof(FBattleRuleInfo, _contents) == 0x000000, "Member 'FBattleRuleInfo::_contents' has a wrong offset!");
static_assert(offsetof(FBattleRuleInfo, _gameModeTypes) == 0x000001, "Member 'FBattleRuleInfo::_gameModeTypes' has a wrong offset!");
static_assert(offsetof(FBattleRuleInfo, _numberOfPeople) == 0x000004, "Member 'FBattleRuleInfo::_numberOfPeople' has a wrong offset!");
static_assert(offsetof(FBattleRuleInfo, _stageId) == 0x000008, "Member 'FBattleRuleInfo::_stageId' has a wrong offset!");

// ScriptStruct OutGameModule.BootLogoStepData
// 0x0038 (0x0038 - 0x0000)
struct FBootLogoStepData final
{
public:
	class UTexture2D*                             _logoTexture;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _timer;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _inputTimer;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _fadeInColor;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _fadeOutColor;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _fadeInSkip;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBootLogoStepData) == 0x000008, "Wrong alignment on FBootLogoStepData");
static_assert(sizeof(FBootLogoStepData) == 0x000038, "Wrong size on FBootLogoStepData");
static_assert(offsetof(FBootLogoStepData, _logoTexture) == 0x000000, "Member 'FBootLogoStepData::_logoTexture' has a wrong offset!");
static_assert(offsetof(FBootLogoStepData, _timer) == 0x000008, "Member 'FBootLogoStepData::_timer' has a wrong offset!");
static_assert(offsetof(FBootLogoStepData, _inputTimer) == 0x00000C, "Member 'FBootLogoStepData::_inputTimer' has a wrong offset!");
static_assert(offsetof(FBootLogoStepData, _fadeInColor) == 0x000010, "Member 'FBootLogoStepData::_fadeInColor' has a wrong offset!");
static_assert(offsetof(FBootLogoStepData, _fadeOutColor) == 0x000020, "Member 'FBootLogoStepData::_fadeOutColor' has a wrong offset!");
static_assert(offsetof(FBootLogoStepData, _fadeInSkip) == 0x000030, "Member 'FBootLogoStepData::_fadeInSkip' has a wrong offset!");

// ScriptStruct OutGameModule.OutGameSpawnPointTypeTableRow
// 0x0008 (0x0010 - 0x0008)
struct FOutGameSpawnPointTypeTableRow final : public FTableRowBase
{
public:
	ECharacterId                                  _id;                                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterOutGameSpawnPointType               _type;                                             // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOutGameSpawnPointTypeTableRow) == 0x000008, "Wrong alignment on FOutGameSpawnPointTypeTableRow");
static_assert(sizeof(FOutGameSpawnPointTypeTableRow) == 0x000010, "Wrong size on FOutGameSpawnPointTypeTableRow");
static_assert(offsetof(FOutGameSpawnPointTypeTableRow, _id) == 0x000008, "Member 'FOutGameSpawnPointTypeTableRow::_id' has a wrong offset!");
static_assert(offsetof(FOutGameSpawnPointTypeTableRow, _type) == 0x000009, "Member 'FOutGameSpawnPointTypeTableRow::_type' has a wrong offset!");

// ScriptStruct OutGameModule.CameraActorOutGameListInfo
// 0x0018 (0x0018 - 0x0000)
struct FCameraActorOutGameListInfo final
{
public:
	struct FVector                                _cameraLocation;                                   // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _cameraRotation;                                   // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraActorOutGameListInfo) == 0x000004, "Wrong alignment on FCameraActorOutGameListInfo");
static_assert(sizeof(FCameraActorOutGameListInfo) == 0x000018, "Wrong size on FCameraActorOutGameListInfo");
static_assert(offsetof(FCameraActorOutGameListInfo, _cameraLocation) == 0x000000, "Member 'FCameraActorOutGameListInfo::_cameraLocation' has a wrong offset!");
static_assert(offsetof(FCameraActorOutGameListInfo, _cameraRotation) == 0x00000C, "Member 'FCameraActorOutGameListInfo::_cameraRotation' has a wrong offset!");

// ScriptStruct OutGameModule.CustomMatchGameRuleEachStageInfo
// 0x0010 (0x0010 - 0x0000)
struct FCustomMatchGameRuleEachStageInfo final
{
public:
	TArray<class UCustomMatchGameRuleEntryObject*> _objectList;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomMatchGameRuleEachStageInfo) == 0x000008, "Wrong alignment on FCustomMatchGameRuleEachStageInfo");
static_assert(sizeof(FCustomMatchGameRuleEachStageInfo) == 0x000010, "Wrong size on FCustomMatchGameRuleEachStageInfo");
static_assert(offsetof(FCustomMatchGameRuleEachStageInfo, _objectList) == 0x000000, "Member 'FCustomMatchGameRuleEachStageInfo::_objectList' has a wrong offset!");

// ScriptStruct OutGameModule.CustomMatchResultInfo
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FCustomMatchResultInfo final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomMatchResultInfo) == 0x000008, "Wrong alignment on FCustomMatchResultInfo");
static_assert(sizeof(FCustomMatchResultInfo) == 0x000040, "Wrong size on FCustomMatchResultInfo");

// ScriptStruct OutGameModule.CompositionTeamInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCompositionTeamInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompositionTeamInfo) == 0x000008, "Wrong alignment on FCompositionTeamInfo");
static_assert(sizeof(FCompositionTeamInfo) == 0x000018, "Wrong size on FCompositionTeamInfo");

// ScriptStruct OutGameModule.GashaPaymentSelectData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGashaPaymentSelectData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGashaPaymentSelectData) == 0x000004, "Wrong alignment on FGashaPaymentSelectData");
static_assert(sizeof(FGashaPaymentSelectData) == 0x00000C, "Wrong size on FGashaPaymentSelectData");

// ScriptStruct OutGameModule.GashaOfferRatioOrderItem
// 0x0020 (0x0020 - 0x0000)
struct FGashaOfferRatioOrderItem final
{
public:
	class FText                                   _text;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGashaOfferRatioOrder                         _order;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGashaOfferRatioOrderItem) == 0x000008, "Wrong alignment on FGashaOfferRatioOrderItem");
static_assert(sizeof(FGashaOfferRatioOrderItem) == 0x000020, "Wrong size on FGashaOfferRatioOrderItem");
static_assert(offsetof(FGashaOfferRatioOrderItem, _text) == 0x000000, "Member 'FGashaOfferRatioOrderItem::_text' has a wrong offset!");
static_assert(offsetof(FGashaOfferRatioOrderItem, _order) == 0x000018, "Member 'FGashaOfferRatioOrderItem::_order' has a wrong offset!");

// ScriptStruct OutGameModule.GuildLevelTableRow
// 0x0060 (0x0068 - 0x0008)
struct FGuildLevelTableRow final : public FTableRowBase
{
public:
	int32                                         _level;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              _bgMainTexture;                                    // 0x0010(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              _bgFullScreenTexture;                              // 0x0038(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _bgmControlValue;                                  // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuildLevelTableRow) == 0x000008, "Wrong alignment on FGuildLevelTableRow");
static_assert(sizeof(FGuildLevelTableRow) == 0x000068, "Wrong size on FGuildLevelTableRow");
static_assert(offsetof(FGuildLevelTableRow, _level) == 0x000008, "Member 'FGuildLevelTableRow::_level' has a wrong offset!");
static_assert(offsetof(FGuildLevelTableRow, _bgMainTexture) == 0x000010, "Member 'FGuildLevelTableRow::_bgMainTexture' has a wrong offset!");
static_assert(offsetof(FGuildLevelTableRow, _bgFullScreenTexture) == 0x000038, "Member 'FGuildLevelTableRow::_bgFullScreenTexture' has a wrong offset!");
static_assert(offsetof(FGuildLevelTableRow, _bgmControlValue) == 0x000060, "Member 'FGuildLevelTableRow::_bgmControlValue' has a wrong offset!");

// ScriptStruct OutGameModule.MissionColorInfo
// 0x0060 (0x0060 - 0x0000)
struct FMissionColorInfo final
{
public:
	struct FLinearColor                           _bgColor;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _topColor;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _preBarColor;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _nowBarColor;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _clearBGColor;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _clearPatternColor;                                // 0x0050(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionColorInfo) == 0x000004, "Wrong alignment on FMissionColorInfo");
static_assert(sizeof(FMissionColorInfo) == 0x000060, "Wrong size on FMissionColorInfo");
static_assert(offsetof(FMissionColorInfo, _bgColor) == 0x000000, "Member 'FMissionColorInfo::_bgColor' has a wrong offset!");
static_assert(offsetof(FMissionColorInfo, _topColor) == 0x000010, "Member 'FMissionColorInfo::_topColor' has a wrong offset!");
static_assert(offsetof(FMissionColorInfo, _preBarColor) == 0x000020, "Member 'FMissionColorInfo::_preBarColor' has a wrong offset!");
static_assert(offsetof(FMissionColorInfo, _nowBarColor) == 0x000030, "Member 'FMissionColorInfo::_nowBarColor' has a wrong offset!");
static_assert(offsetof(FMissionColorInfo, _clearBGColor) == 0x000040, "Member 'FMissionColorInfo::_clearBGColor' has a wrong offset!");
static_assert(offsetof(FMissionColorInfo, _clearPatternColor) == 0x000050, "Member 'FMissionColorInfo::_clearPatternColor' has a wrong offset!");

// ScriptStruct OutGameModule.MissionTransition
// 0x0030 (0x0030 - 0x0000)
struct FMissionTransition final
{
public:
	TSoftObjectPtr<class UWorld>                  _level;                                            // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _tabIdx;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionTransition) == 0x000008, "Wrong alignment on FMissionTransition");
static_assert(sizeof(FMissionTransition) == 0x000030, "Wrong size on FMissionTransition");
static_assert(offsetof(FMissionTransition, _level) == 0x000000, "Member 'FMissionTransition::_level' has a wrong offset!");
static_assert(offsetof(FMissionTransition, _tabIdx) == 0x000028, "Member 'FMissionTransition::_tabIdx' has a wrong offset!");

// ScriptStruct OutGameModule.MissionTableRow
// 0x0050 (0x0058 - 0x0008)
struct FMissionTableRow final : public FTableRowBase
{
public:
	TMap<EMdMissionTransition, struct FMissionTransition> _categoryTransitionList;                           // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTableRow) == 0x000008, "Wrong alignment on FMissionTableRow");
static_assert(sizeof(FMissionTableRow) == 0x000058, "Wrong size on FMissionTableRow");
static_assert(offsetof(FMissionTableRow, _categoryTransitionList) == 0x000008, "Member 'FMissionTableRow::_categoryTransitionList' has a wrong offset!");

// ScriptStruct OutGameModule.ItemData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FItemData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemData) == 0x000008, "Wrong alignment on FItemData");
static_assert(sizeof(FItemData) == 0x000018, "Wrong size on FItemData");

// ScriptStruct OutGameModule.BattleInfo
// 0x0098 (0x0098 - 0x0000)
struct FBattleInfo final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            _baseImageColor;                                   // 0x0018(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _baseDotImageColor;                                // 0x0040(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            Color;                                             // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          _bOverrideGameMode;                                // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleInfo) == 0x000008, "Wrong alignment on FBattleInfo");
static_assert(sizeof(FBattleInfo) == 0x000098, "Wrong size on FBattleInfo");
static_assert(offsetof(FBattleInfo, Text) == 0x000000, "Member 'FBattleInfo::Text' has a wrong offset!");
static_assert(offsetof(FBattleInfo, _baseImageColor) == 0x000018, "Member 'FBattleInfo::_baseImageColor' has a wrong offset!");
static_assert(offsetof(FBattleInfo, _baseDotImageColor) == 0x000040, "Member 'FBattleInfo::_baseDotImageColor' has a wrong offset!");
static_assert(offsetof(FBattleInfo, Color) == 0x000068, "Member 'FBattleInfo::Color' has a wrong offset!");
static_assert(offsetof(FBattleInfo, _bOverrideGameMode) == 0x000090, "Member 'FBattleInfo::_bOverrideGameMode' has a wrong offset!");

// ScriptStruct OutGameModule.PlayMenuHamburgerLargeIconInfo
// 0x0048 (0x0048 - 0x0000)
struct FPlayMenuHamburgerLargeIconInfo final
{
public:
	class UTexture2D*                             _texture;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   _titleText;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  _level;                                            // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayMenuHamburgerLargeIconInfo) == 0x000008, "Wrong alignment on FPlayMenuHamburgerLargeIconInfo");
static_assert(sizeof(FPlayMenuHamburgerLargeIconInfo) == 0x000048, "Wrong size on FPlayMenuHamburgerLargeIconInfo");
static_assert(offsetof(FPlayMenuHamburgerLargeIconInfo, _texture) == 0x000000, "Member 'FPlayMenuHamburgerLargeIconInfo::_texture' has a wrong offset!");
static_assert(offsetof(FPlayMenuHamburgerLargeIconInfo, _titleText) == 0x000008, "Member 'FPlayMenuHamburgerLargeIconInfo::_titleText' has a wrong offset!");
static_assert(offsetof(FPlayMenuHamburgerLargeIconInfo, _level) == 0x000020, "Member 'FPlayMenuHamburgerLargeIconInfo::_level' has a wrong offset!");

// ScriptStruct OutGameModule.PlayMenuRankingMessageParam
// 0x0020 (0x0020 - 0x0000)
struct FPlayMenuRankingMessageParam final
{
public:
	class FText                                   _messageText;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          _voiceAtomCue;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayMenuRankingMessageParam) == 0x000008, "Wrong alignment on FPlayMenuRankingMessageParam");
static_assert(sizeof(FPlayMenuRankingMessageParam) == 0x000020, "Wrong size on FPlayMenuRankingMessageParam");
static_assert(offsetof(FPlayMenuRankingMessageParam, _messageText) == 0x000000, "Member 'FPlayMenuRankingMessageParam::_messageText' has a wrong offset!");
static_assert(offsetof(FPlayMenuRankingMessageParam, _voiceAtomCue) == 0x000018, "Member 'FPlayMenuRankingMessageParam::_voiceAtomCue' has a wrong offset!");

// ScriptStruct OutGameModule.LeaguData
// 0x0048 (0x0048 - 0x0000)
struct FLeaguData final
{
public:
	struct FMasterDataMGuildLeagues               _myLeague;                                         // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         _myScore;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _myRank;                                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERankingLeagueChange                          RankingLeagueChange;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaguData) == 0x000008, "Wrong alignment on FLeaguData");
static_assert(sizeof(FLeaguData) == 0x000048, "Wrong size on FLeaguData");
static_assert(offsetof(FLeaguData, _myLeague) == 0x000000, "Member 'FLeaguData::_myLeague' has a wrong offset!");
static_assert(offsetof(FLeaguData, _myScore) == 0x000038, "Member 'FLeaguData::_myScore' has a wrong offset!");
static_assert(offsetof(FLeaguData, _myRank) == 0x00003C, "Member 'FLeaguData::_myRank' has a wrong offset!");
static_assert(offsetof(FLeaguData, RankingLeagueChange) == 0x000040, "Member 'FLeaguData::RankingLeagueChange' has a wrong offset!");

// ScriptStruct OutGameModule.ResultMissionInfo
// 0x0078 (0x0078 - 0x0000)
struct FResultMissionInfo final
{
public:
	class FText                                   _categoryTitle;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMissionColorInfo                      _color;                                            // 0x0018(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResultMissionInfo) == 0x000008, "Wrong alignment on FResultMissionInfo");
static_assert(sizeof(FResultMissionInfo) == 0x000078, "Wrong size on FResultMissionInfo");
static_assert(offsetof(FResultMissionInfo, _categoryTitle) == 0x000000, "Member 'FResultMissionInfo::_categoryTitle' has a wrong offset!");
static_assert(offsetof(FResultMissionInfo, _color) == 0x000018, "Member 'FResultMissionInfo::_color' has a wrong offset!");

// ScriptStruct OutGameModule.PlayerSupportScore
// 0x0090 (0x00D0 - 0x0040)
struct FPlayerSupportScore final : public FScoreRatioWindowInfo
{
public:
	struct FScoreRatio                            _itemSupport;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScoreRatio                            _peopleAction;                                     // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScoreRatio                            _resuscitation;                                    // 0x0070(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScoreRatio                            _cooperationAction;                                // 0x0088(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScoreRatio                            _enemyInfoShare;                                   // 0x00A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScoreRatio                            _cheer;                                            // 0x00B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSupportScore) == 0x000008, "Wrong alignment on FPlayerSupportScore");
static_assert(sizeof(FPlayerSupportScore) == 0x0000D0, "Wrong size on FPlayerSupportScore");
static_assert(offsetof(FPlayerSupportScore, _itemSupport) == 0x000040, "Member 'FPlayerSupportScore::_itemSupport' has a wrong offset!");
static_assert(offsetof(FPlayerSupportScore, _peopleAction) == 0x000058, "Member 'FPlayerSupportScore::_peopleAction' has a wrong offset!");
static_assert(offsetof(FPlayerSupportScore, _resuscitation) == 0x000070, "Member 'FPlayerSupportScore::_resuscitation' has a wrong offset!");
static_assert(offsetof(FPlayerSupportScore, _cooperationAction) == 0x000088, "Member 'FPlayerSupportScore::_cooperationAction' has a wrong offset!");
static_assert(offsetof(FPlayerSupportScore, _enemyInfoShare) == 0x0000A0, "Member 'FPlayerSupportScore::_enemyInfoShare' has a wrong offset!");
static_assert(offsetof(FPlayerSupportScore, _cheer) == 0x0000B8, "Member 'FPlayerSupportScore::_cheer' has a wrong offset!");

// ScriptStruct OutGameModule.ScoreTableRow
// 0x0108 (0x0110 - 0x0008)
struct FScoreTableRow final : public FTableRowBase
{
public:
	struct FScoreMagnification                    _damageScore;                                      // 0x0008(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerSupportScore                    _supportScore;                                     // 0x0040(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreTableRow) == 0x000008, "Wrong alignment on FScoreTableRow");
static_assert(sizeof(FScoreTableRow) == 0x000110, "Wrong size on FScoreTableRow");
static_assert(offsetof(FScoreTableRow, _damageScore) == 0x000008, "Member 'FScoreTableRow::_damageScore' has a wrong offset!");
static_assert(offsetof(FScoreTableRow, _supportScore) == 0x000040, "Member 'FScoreTableRow::_supportScore' has a wrong offset!");

// ScriptStruct OutGameModule.ItemParam
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FItemParam final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemParam) == 0x000008, "Wrong alignment on FItemParam");
static_assert(sizeof(FItemParam) == 0x000030, "Wrong size on FItemParam");

// ScriptStruct OutGameModule.ItemcellParam
// 0x0040 (0x0040 - 0x0000)
struct FItemcellParam final
{
public:
	EMdRarityItemCategory                         _itemCategory;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _rarity;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   _itemName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   _charaName;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         _quantity;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemcellParam) == 0x000008, "Wrong alignment on FItemcellParam");
static_assert(sizeof(FItemcellParam) == 0x000040, "Wrong size on FItemcellParam");
static_assert(offsetof(FItemcellParam, _itemCategory) == 0x000000, "Member 'FItemcellParam::_itemCategory' has a wrong offset!");
static_assert(offsetof(FItemcellParam, _rarity) == 0x000004, "Member 'FItemcellParam::_rarity' has a wrong offset!");
static_assert(offsetof(FItemcellParam, _itemName) == 0x000008, "Member 'FItemcellParam::_itemName' has a wrong offset!");
static_assert(offsetof(FItemcellParam, _charaName) == 0x000020, "Member 'FItemcellParam::_charaName' has a wrong offset!");
static_assert(offsetof(FItemcellParam, _quantity) == 0x000038, "Member 'FItemcellParam::_quantity' has a wrong offset!");

// ScriptStruct OutGameModule.ItemCode
// 0x0008 (0x0008 - 0x0000)
struct FItemCode final
{
public:
	int32                                         Code;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     Type;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemCode) == 0x000004, "Wrong alignment on FItemCode");
static_assert(sizeof(FItemCode) == 0x000008, "Wrong size on FItemCode");
static_assert(offsetof(FItemCode, Code) == 0x000000, "Member 'FItemCode::Code' has a wrong offset!");
static_assert(offsetof(FItemCode, Type) == 0x000004, "Member 'FItemCode::Type' has a wrong offset!");

// ScriptStruct OutGameModule.ShopItemPackLayoutTableRow
// 0x0128 (0x0130 - 0x0008)
struct FShopItemPackLayoutTableRow final : public FTableRowBase
{
public:
	struct FAnchorData                            _itemAnchorData;                                   // 0x0008(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          _bIsBgImage;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _bgImage;                                          // 0x0040(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FWidgetTransform>               _itemTransformArray;                               // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FWidgetTransform>               _countTransformArray;                              // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FShopItemPackLayoutTableRow) == 0x000010, "Wrong alignment on FShopItemPackLayoutTableRow");
static_assert(sizeof(FShopItemPackLayoutTableRow) == 0x000130, "Wrong size on FShopItemPackLayoutTableRow");
static_assert(offsetof(FShopItemPackLayoutTableRow, _itemAnchorData) == 0x000008, "Member 'FShopItemPackLayoutTableRow::_itemAnchorData' has a wrong offset!");
static_assert(offsetof(FShopItemPackLayoutTableRow, _bIsBgImage) == 0x000030, "Member 'FShopItemPackLayoutTableRow::_bIsBgImage' has a wrong offset!");
static_assert(offsetof(FShopItemPackLayoutTableRow, _bgImage) == 0x000040, "Member 'FShopItemPackLayoutTableRow::_bgImage' has a wrong offset!");
static_assert(offsetof(FShopItemPackLayoutTableRow, _itemTransformArray) == 0x000110, "Member 'FShopItemPackLayoutTableRow::_itemTransformArray' has a wrong offset!");
static_assert(offsetof(FShopItemPackLayoutTableRow, _countTransformArray) == 0x000120, "Member 'FShopItemPackLayoutTableRow::_countTransformArray' has a wrong offset!");

// ScriptStruct OutGameModule.TitleCallTableRow
// 0x0008 (0x0010 - 0x0008)
struct FTitleCallTableRow final : public FTableRowBase
{
public:
	ECharacterId                                  _id;                                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isTarget;                                         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTitleCallTableRow) == 0x000008, "Wrong alignment on FTitleCallTableRow");
static_assert(sizeof(FTitleCallTableRow) == 0x000010, "Wrong size on FTitleCallTableRow");
static_assert(offsetof(FTitleCallTableRow, _id) == 0x000008, "Member 'FTitleCallTableRow::_id' has a wrong offset!");
static_assert(offsetof(FTitleCallTableRow, _isTarget) == 0x000009, "Member 'FTitleCallTableRow::_isTarget' has a wrong offset!");

}

