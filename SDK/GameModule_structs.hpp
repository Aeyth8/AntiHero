#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameModule

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "MasterDataModule_structs.hpp"
#include "CommonModule_structs.hpp"
#include "SlateCore_structs.hpp"
#include "BykingUnrealModule_structs.hpp"
#include "BackendSubsystem_structs.hpp"
#include "UMG_structs.hpp"
#include "CriWareRuntime_structs.hpp"


namespace SDK
{

// Enum GameModule.EAnimationLeanType
// NumValues: 0x0004
enum class EAnimationLeanType : uint8
{
	Walk                                     = 0,
	Air                                      = 1,
	DashAir                                  = 2,
	EAnimationLeanType_MAX                   = 3,
};

// Enum GameModule.EAnimationMoveType
// NumValues: 0x0004
enum class EAnimationMoveType : uint8
{
	Walk                                     = 0,
	CrouchingMove                            = 1,
	Wallcrawl                                = 2,
	EAnimationMoveType_MAX                   = 3,
};

// Enum GameModule.EPS4TouchPadIconType
// NumValues: 0x0004
enum class EPS4TouchPadIconType : uint8
{
	TouchPadWhole                            = 0,
	TouchPadRight                            = 1,
	TouchPadLeft                             = 2,
	EPS4TouchPadIconType_MAX                 = 3,
};

// Enum GameModule.EKeyConfigurableCommand
// NumValues: 0x0021
enum class EKeyConfigurableCommand : uint8
{
	VirtualAccept                            = 0,
	VirtualBack                              = 1,
	OptionMenu                               = 2,
	Unique1                                  = 3,
	Unique2                                  = 4,
	Unique3                                  = 5,
	Sprint                                   = 6,
	Melee                                    = 7,
	Action                                   = 8,
	SpecialAction                            = 9,
	Jump                                     = 10,
	Marker                                   = 11,
	Supply                                   = 12,
	MiniMap                                  = 13,
	Inventory                                = 14,
	Aim                                      = 15,
	Crouch                                   = 16,
	PrimeAbility                             = 17,
	SecondAbility                            = 18,
	Emote                                    = 19,
	Symbol                                   = 20,
	LevelUpShortCut                          = 21,
	SelectSupply                             = 22,
	SelectMarker                             = 23,
	MapMarker                                = 24,
	MoveUp                                   = 25,
	MoveDown                                 = 26,
	MoveLeft                                 = 27,
	MoveRight                                = 28,
	PlusUltra                                = 29,
	TextChat                                 = 30,
	Dodge                                    = 31,
	MAX                                      = 32,
};

// Enum GameModule.EGameOptionAuraAreaType
// NumValues: 0x0005
enum class EGameOptionAuraAreaType : uint8
{
	INVALID                                  = 0,
	AREA_ALL                                 = 1,
	AREA_MAINMENU                            = 2,
	AREA_MAINMENU_AND_LOBBY                  = 3,
	MAX                                      = 4,
};

// Enum GameModule.EGameOptionAuraDispType
// NumValues: 0x0006
enum class EGameOptionAuraDispType : uint8
{
	INVALID                                  = 0,
	DISP_ALL                                 = 1,
	DISP_TEAM                                = 2,
	DISP_SELF                                = 3,
	DISP_HIDDEN                              = 4,
	MAX                                      = 5,
};

// Enum GameModule.EBattleStartSequenceType
// NumValues: 0x000A
enum class EBattleStartSequenceType : uint8
{
	PREPARATION                              = 0,
	READY_MEMER_CHECK                        = 1,
	READY_CHARACTER_DUPLICATE                = 2,
	READY_BATTLE                             = 3,
	READY_BATTLE_WAIT                        = 4,
	READY_LOBBY_SEARCH                       = 5,
	BATTLE_START                             = 6,
	IS_BATTLE                                = 7,
	RESULT                                   = 8,
	MAX                                      = 9,
};

// Enum GameModule.EFriendRequesetType
// NumValues: 0x0006
enum class EFriendRequesetType : uint8
{
	FriendApproval                           = 0,
	FriendDeny                               = 1,
	FriendSend                               = 2,
	FriendSendCancel                         = 3,
	FriendDelete                             = 4,
	MAX                                      = 5,
};

// Enum GameModule.ELoginBonusTransitionType
// NumValues: 0x0005
enum class ELoginBonusTransitionType : uint8
{
	INVALID                                  = 0,
	NORMAL                                   = 1,
	SHOP                                     = 2,
	CONFIRM                                  = 3,
	MAX                                      = 4,
};

// Enum GameModule.EWaitMessageType
// NumValues: 0x0004
enum class EWaitMessageType : uint8
{
	NoneMessage                              = 0,
	Dialog001                                = 1,
	Dialog002                                = 2,
	MAX                                      = 3,
};

// Enum GameModule.EGameAfterLoginStepType
// NumValues: 0x0006
enum class EGameAfterLoginStepType : uint8
{
	INVALID                                  = 0,
	TERMS_OF_SERVICE                         = 1,
	TUTORIAL                                 = 2,
	LOGIN_BONUS                              = 3,
	MAIN_MENU                                = 4,
	MAX                                      = 5,
};

// Enum GameModule.ETutorialPopupScene
// NumValues: 0x0017
enum class ETutorialPopupScene : uint8
{
	None                                     = 0,
	MainMenu                                 = 1,
	Mission                                  = 2,
	Shop                                     = 3,
	Ticket                                   = 4,
	Gacha                                    = 5,
	Customize                                = 6,
	Gold                                     = 7,
	Profile                                  = 8,
	Formation                                = 9,
	PieceTicket                              = 10,
	CloseTutorial                            = 11,
	License                                  = 12,
	MyAdvertisement                          = 13,
	AvatarCreate                             = 14,
	Guild                                    = 15,
	Ranking                                  = 16,
	Training                                 = 17,
	Gallery                                  = 18,
	ShopHeroSoul                             = 19,
	Variation                                = 20,
	CustomMatch                              = 21,
	ETutorialPopupScene_MAX                  = 22,
};

// Enum GameModule.EGashaImageSizeType
// NumValues: 0x0004
enum class EGashaImageSizeType : uint8
{
	S                                        = 0,
	L                                        = 1,
	LL                                       = 2,
	MAX                                      = 3,
};

// Enum GameModule.EGashaLawType
// NumValues: 0x0003
enum class EGashaLawType : uint8
{
	SPECIFIED_COMMERCIAL_TRANSACTIONS        = 0,
	PAYMENT_SERVICES_ACT                     = 1,
	MAX                                      = 2,
};

// Enum GameModule.ETeamCommentaryMessage
// NumValues: 0x0005
enum class ETeamCommentaryMessage : uint8
{
	UNDEF                                    = 0,
	SQUAD_MEMBER_COMPLETE                    = 1,
	BATTLE_READY                             = 2,
	NOTICE_MESSAGE                           = 3,
	ETeamCommentaryMessage_MAX               = 4,
};

// Enum GameModule.EGameModeType
// NumValues: 0x0009
enum class EGameModeType : uint8
{
	DEFAULT                                  = 0,
	VISUAL_LOBBY                             = 1,
	SOLO_BATTLE                              = 2,
	DUO_BATTLE                               = 3,
	SQUAD_BATTLE                             = 4,
	LEADERS_BATTLE                           = 5,
	TUTORIAL                                 = 6,
	TRAINING                                 = 7,
	EGameModeType_MAX                        = 8,
};

// Enum GameModule.ETextChatLevelType
// NumValues: 0x0007
enum class ETextChatLevelType : uint8
{
	MainMenu                                 = 0,
	Mission                                  = 1,
	OutGameTab                               = 2,
	OutGamePL                                = 3,
	InGame                                   = 4,
	Other                                    = 5,
	ETextChatLevelType_MAX                   = 6,
};

// Enum GameModule.EAvatarColorParts
// NumValues: 0x000B
enum class EAvatarColorParts : uint8
{
	Hair_1                                   = 0,
	Hair_2                                   = 1,
	Hair_Eyebrows                            = 2,
	Skin_1                                   = 3,
	Pupil_L1                                 = 4,
	Pupil_L2                                 = 5,
	Pupil_R1                                 = 6,
	Pupil_R2                                 = 7,
	Num                                      = 8,
	None                                     = 9,
	EAvatarColorParts_MAX                    = 10,
};

// Enum GameModule.EAvatarDetailedAppearanceColorSettingItem
// NumValues: 0x0007
enum class EAvatarDetailedAppearanceColorSettingItem : uint8
{
	BASE                                     = 0,
	HAIR                                     = 1,
	EYEBROW                                  = 2,
	EYES                                     = 3,
	EYES_DIFFERENT                           = 4,
	RIGHT_EYE                                = 5,
	MAX                                      = 6,
};

// Enum GameModule.EAvatarDetailedAppearanceSettingDetailItem
// NumValues: 0x0008
enum class EAvatarDetailedAppearanceSettingDetailItem : uint8
{
	HAIR                                     = 0,
	EYES                                     = 1,
	EYEBROWS                                 = 2,
	PUPILS                                   = 3,
	NOSE                                     = 4,
	MOUTH                                    = 5,
	CONTOR                                   = 6,
	MAX                                      = 7,
};

// Enum GameModule.EAvatarFaceParts
// NumValues: 0x000A
enum class EAvatarFaceParts : uint8
{
	Ears                                     = 0,
	Eyebrows                                 = 1,
	Pupils                                   = 2,
	Eyes                                     = 3,
	Nose                                     = 4,
	Hair                                     = 5,
	Mouth                                    = 6,
	Contour                                  = 7,
	Face                                     = 8,
	MAX                                      = 9,
};

// Enum GameModule.ECostumeColorParts
// NumValues: 0x000B
enum class ECostumeColorParts : uint8
{
	Clothes_R                                = 0,
	Clothes_G                                = 1,
	Clothes_B                                = 2,
	Clothes_C                                = 3,
	Clothes_M                                = 4,
	Clothes_Y                                = 5,
	Clothes_BK                               = 6,
	Clothes_SP                               = 7,
	Num                                      = 8,
	None                                     = 9,
	ECostumeColorParts_MAX                   = 10,
};

// Enum GameModule.EAbilitySlot
// NumValues: 0x0003
enum class EAbilitySlot : uint8
{
	SLOT1                                    = 0,
	SLOT2                                    = 1,
	MAX                                      = 2,
};

// Enum GameModule.EAnimationSlot
// NumValues: 0x0008
enum class EAnimationSlot : uint8
{
	DEFAULT                                  = 0,
	DAMAGE                                   = 1,
	NAGARA                                   = 2,
	NAGARA_GUARD                             = 3,
	PARTS                                    = 4,
	FACE                                     = 5,
	NUM                                      = 6,
	EAnimationSlot_MAX                       = 7,
};

// Enum GameModule.EAnimOutGameId
// NumValues: 0x0015
enum class EAnimOutGameId : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	CharaSeleFall                            = 2,
	CharaSeleLand                            = 3,
	CharaSeleIdle                            = 4,
	CharaSeleDecid                           = 5,
	CharaSeleDecidIdle                       = 6,
	GatyaAct100                              = 7,
	FaceIdle                                 = 8,
	FaceAttackPre                            = 9,
	FaceAttack                               = 10,
	FaceDmgWeak                              = 11,
	FaceDmgStrong                            = 12,
	FaceDeath                                = 13,
	FaceAct001                               = 14,
	FaceAct002                               = 15,
	FaceAct003                               = 16,
	FaceAct004                               = 17,
	FaceAct005                               = 18,
	FaceAct006                               = 19,
	EAnimOutGameId_MAX                       = 20,
};

// Enum GameModule.EAnimationId
// NumValues: 0x00C8
enum class EAnimationId : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	RunFront                                 = 2,
	JumpBegin                                = 3,
	JumpRise                                 = 4,
	JumpTop                                  = 5,
	Fall                                     = 6,
	ForwardJumpBegin                         = 7,
	ForwardJumpRise                          = 8,
	ForwardJumpTop                           = 9,
	ForwardFall                              = 10,
	Land                                     = 11,
	HighJumpBegin                            = 12,
	HighJumpRise                             = 13,
	ForwardHighJumpBegin                     = 14,
	ForwardHighJumpRise                      = 15,
	DashBegin                                = 16,
	DashLoop                                 = 17,
	DashStop                                 = 18,
	DashAirBegin                             = 19,
	DashAirLoop                              = 20,
	DashAirStop                              = 21,
	DashAirAction                            = 22,
	HoveringFront                            = 23,
	WallcrawlBeginAir                        = 24,
	WallcrawlIdle                            = 25,
	WallcrawlPeak                            = 26,
	AvoidF                                   = 27,
	DyingIdle                                = 28,
	DyingLoop                                = 29,
	DyingDeath                               = 30,
	DyingBeginFaceDown                       = 31,
	DyingBeginFaceUp                         = 32,
	DyingEnd                                 = 33,
	RecoverFriendBegin                       = 34,
	RecoverFriendLoop                        = 35,
	RecoverFriendEnd                         = 36,
	RecoverCitizenBegin                      = 37,
	RecoverCitizenLoop                       = 38,
	RecoverCitizenEnd                        = 39,
	CrouchIdle                               = 40,
	CrouchBegin                              = 41,
	CrouchEnd                                = 42,
	PickUpItem                               = 43,
	UseItemStart                             = 44,
	UseItemLoop                              = 45,
	UseItemEnd                               = 46,
	BoxOpneStart                             = 47,
	BoxOpneLoop                              = 48,
	BoxOpneEnd                               = 49,
	UseReviveItemStart                       = 50,
	UseReviveItemLoop                        = 51,
	UseReviveItemEnd                         = 52,
	RevivalIdle                              = 53,
	Revival                                  = 54,
	TongueIdle                               = 55,
	ParkourJump                              = 56,
	ParkourLand                              = 57,
	PlusUltraBegin                           = 58,
	PlusUltraBeginAir                        = 59,
	PartsIdle                                = 60,
	PartsDamage                              = 61,
	DmgDownFaceDown                          = 62,
	DmgFrontNagara                           = 63,
	DmgRightNagara                           = 64,
	DmgBackNagara                            = 65,
	DmgLeftNagara                            = 66,
	DmgFrontWeak                             = 67,
	DmgRightWeak                             = 68,
	DmgBackWeak                              = 69,
	DmgLeftWeak                              = 70,
	DmgFrontWeakAir                          = 71,
	DmgRightWeakAir                          = 72,
	DmgBackWeakAir                           = 73,
	DmgLeftWeakAir                           = 74,
	DmgBlowOffBack                           = 75,
	DmgKnockDownFaceUp                       = 76,
	DmgGetUpFaceUp                           = 77,
	DmgBlowOffFront                          = 78,
	DmgKnockDownFaceDown                     = 79,
	DmgGetUpFaceDown                         = 80,
	DmgBlowOffBackMomi                       = 81,
	DmgFreezingA                             = 82,
	DmgCaught                                = 83,
	DmgElectricShock                         = 84,
	DmgStun                                  = 85,
	DmgCaptured                              = 86,
	DmgCapturedAir                           = 87,
	DmgSoundWave                             = 88,
	RecoverFront                             = 89,
	DmgDyingWeak                             = 90,
	DmgFallOffBack                           = 91,
	CoopBind                                 = 92,
	CoopCatchChestFront                      = 93,
	CoopCatchChestFrontLoop                  = 94,
	CoopCatchChestBack                       = 95,
	CoopPiggybackBegin                       = 96,
	CoopPiggyback                            = 97,
	CoopPiggybackEnd                         = 98,
	CoopCarryFlight                          = 99,
	FaceIdle                                 = 100,
	FaceAttackPre                            = 101,
	FaceAttack                               = 102,
	FaceDmgWeak                              = 103,
	FaceDmgStrong                            = 104,
	FaceDeath                                = 105,
	FaceAct001                               = 106,
	FaceAct002                               = 107,
	FaceAct003                               = 108,
	FaceAct004                               = 109,
	FaceAct005                               = 110,
	FaceAct006                               = 111,
	AimingIdle                               = 112,
	AimShotSmall                             = 113,
	AimShotSmallR                            = 114,
	AimShotLarge                             = 115,
	AimShotBegin                             = 116,
	AimShotLoop                              = 117,
	AimShotEnd                               = 118,
	AO_AimUpLower                            = 119,
	AO_AimLeftRight                          = 120,
	AimGuardIdle                             = 121,
	AimGuardReaction                         = 122,
	AimGuardReactionAir                      = 123,
	AO_AimGuardUpLower                       = 124,
	AO_AimGuardLeftRight                     = 125,
	AttackStepIn                             = 126,
	Attack1                                  = 127,
	Attack2                                  = 128,
	Attack3                                  = 129,
	Attack4                                  = 130,
	Attack5                                  = 131,
	AttackStepInAir                          = 132,
	AttackAir1                               = 133,
	AttackAir2                               = 134,
	AttackAir3                               = 135,
	KillAttackStart                          = 136,
	KillAttackBegin                          = 137,
	KillAttackLoop                           = 138,
	KillAttack                               = 139,
	AttackUnique1_0                          = 140,
	AttackUnique1_1                          = 141,
	AttackUnique1_2                          = 142,
	AttackUnique1_3                          = 143,
	AttackUnique1_4                          = 144,
	AttackUnique1_5                          = 145,
	AttackUnique1_6                          = 146,
	AttackUnique2_0                          = 147,
	AttackUnique2_1                          = 148,
	AttackUnique2_2                          = 149,
	AttackUnique2_3                          = 150,
	AttackUnique2_4                          = 151,
	AttackUnique2_5                          = 152,
	AttackUnique2_6                          = 153,
	AttackUnique2_7                          = 154,
	AttackUnique2_8                          = 155,
	AttackUnique2_9                          = 156,
	AttackUnique3_0                          = 157,
	AttackUnique3_1                          = 158,
	AttackUnique3_2                          = 159,
	AttackUnique3_3                          = 160,
	AttackUnique3_4                          = 161,
	AttackUnique3_5                          = 162,
	AttackUnique3_6                          = 163,
	AttackUniqueAir1_0                       = 164,
	AttackUniqueAir1_1                       = 165,
	AttackUniqueAir1_2                       = 166,
	AttackUniqueAir1_3                       = 167,
	AttackUniqueAir1_4                       = 168,
	AttackUniqueAir1_5                       = 169,
	AttackUniqueAir1_6                       = 170,
	AttackUniqueAir2_0                       = 171,
	AttackUniqueAir2_1                       = 172,
	AttackUniqueAir2_2                       = 173,
	AttackUniqueAir2_3                       = 174,
	AttackUniqueAir2_4                       = 175,
	AttackUniqueAir2_5                       = 176,
	AttackUniqueAir2_6                       = 177,
	AttackUniqueAir3_0                       = 178,
	AttackUniqueAir3_1                       = 179,
	AttackUniqueAir3_2                       = 180,
	AttackUniqueAir3_3                       = 181,
	AttackUniqueAir3_4                       = 182,
	AttackUniqueAir3_5                       = 183,
	AttackUniqueAir3_6                       = 184,
	SpecialAction0                           = 185,
	SpecialAction1                           = 186,
	SpecialAction2                           = 187,
	SpecialAction3                           = 188,
	SpecialAction4                           = 189,
	SpecialAction5                           = 190,
	SpecialAction6                           = 191,
	TutorialAct000                           = 192,
	TutorialAct001                           = 193,
	TutorialAct002                           = 194,
	TutorialAct003                           = 195,
	TutorialAct004                           = 196,
	TutorialAct005                           = 197,
	GatyaAct100                              = 198,
	EAnimationId_MAX                         = 199,
};

// Enum GameModule.EAvatarDetailedAppearanceSettingBaseItem
// NumValues: 0x0004
enum class EAvatarDetailedAppearanceSettingBaseItem : uint8
{
	BASE                                     = 0,
	HEIGHT                                   = 1,
	BODY                                     = 2,
	MAX                                      = 3,
};

// Enum GameModule.EAvatarMenuType
// NumValues: 0x0005
enum class EAvatarMenuType : uint8
{
	PLAYFORPOWER                             = 0,
	VOICE                                    = 1,
	BATTLE_STYLE                             = 2,
	DETAILED_APPEARANCE_SETTINGS             = 3,
	MAX                                      = 4,
};

// Enum GameModule.EAvatarSlotType
// NumValues: 0x0009
enum class EAvatarSlotType : uint8
{
	MENU                                     = 0,
	SELECT                                   = 1,
	PLAYFORPOWER                             = 2,
	VOICE                                    = 3,
	BATTLE_STYLE                             = 4,
	BASE_SETTINGS                            = 5,
	DETAIL_SETTINGS                          = 6,
	COLOR_SETTINGS                           = 7,
	MAX                                      = 8,
};

// Enum GameModule.EBattleRecordUnitType
// NumValues: 0x0003
enum class EBattleRecordUnitType : uint8
{
	INTEGER                                  = 0,
	TRUNCATEDECIMAL                          = 1,
	MAX                                      = 2,
};

// Enum GameModule.EBattleRecordType
// NumValues: 0x0007
enum class EBattleRecordType : uint8
{
	DISPLAY                                  = 0,
	TOTAL                                    = 1,
	SEASON                                   = 2,
	TOTALANDSEASON                           = 3,
	DUMMY                                    = 4,
	EMBLEM                                   = 5,
	MAX                                      = 6,
};

// Enum GameModule.EBattleRecordSize
// NumValues: 0x0003
enum class EBattleRecordSize : uint8
{
	LARGE                                    = 0,
	SMALL                                    = 1,
	MAX                                      = 2,
};

// Enum GameModule.EBattleRecordFramType
// NumValues: 0x0004
enum class EBattleRecordFramType : uint8
{
	TOP                                      = 0,
	MIDDLE                                   = 1,
	BUTTON                                   = 2,
	MAX                                      = 3,
};

// Enum GameModule.ECharacterConditionId
// NumValues: 0x0042
enum class ECharacterConditionId : uint8
{
	NONE                                     = 0,
	POISON_MIST                              = 1,
	BURN                                     = 2,
	FREEZE                                   = 3,
	DECAY                                    = 4,
	BLUE_FLAME                               = 5,
	THUNDER                                  = 6,
	UNIQUE_SEAL                              = 7,
	NOISE                                    = 8,
	GRAB                                     = 9,
	DECREASE_HEALTH                          = 10,
	RECOVER_HEALTH                           = 11,
	CONTINUOUS_RECOVER_HEALTH                = 12,
	INFLUENCE_OF_ALLY_ABILITY_HEAL           = 13,
	TRANSFORM_STOCKING                       = 14,
	TRANSFORM                                = 15,
	COPY_STOCKING                            = 16,
	COPY                                     = 17,
	DUPLICATE                                = 18,
	DYING                                    = 19,
	GUARD                                    = 20,
	UNIQUE_LEVEL_UP                          = 21,
	REBUILD                                  = 22,
	SPEED_DOWN                               = 23,
	SKILL_PIGGYBACK                          = 24,
	SKILL_PIGGYBACK_CH001                    = 25,
	SKILL_PIGGYBACK_CH005                    = 26,
	SKILL_LOWGRAVITY                         = 27,
	SKILL_LOWGRAVITY_TO_ENEMY                = 28,
	SKILL_SPEEDUP                            = 29,
	SKILL_SPEEDDOWN                          = 30,
	SKILL_AHO                                = 31,
	UNBREAKABLE                              = 32,
	SKILL_WEAR_BLUE_FLAME                    = 33,
	SKILL_PIGGYBACK_CH012                    = 34,
	GIANT                                    = 35,
	INFECTIONDECAY_SORCE                     = 36,
	INFECTIONDECAY_BEFORE                    = 37,
	INFECTIONDECAY_AFTER                     = 38,
	SKILL_STEAL                              = 39,
	ABILITY_ATTACK                           = 40,
	ABILITY_DURABLE                          = 41,
	ABILITY_MOVESPEED                        = 42,
	ABILITY_HEAL                             = 43,
	ABILITY_TECHNIQUE                        = 44,
	SUPERARMOR_FOR_ATTACK                    = 45,
	SUPERARMOR_FOR_DAMAGE                    = 46,
	SUPERARMOR_FOR_PLUS                      = 47,
	PLUS_ULTRA                               = 48,
	SHOW_INVINCIBLE                          = 49,
	COMPRESSION                              = 50,
	COMPRESSION_REGENERATION                 = 51,
	OPTICALDAZZLEPAINT                       = 52,
	TRANSPARENT_0                            = 53,
	TELEPORT                                 = 54,
	DISP_HEALTH_ON_HIT                       = 55,
	DISP_GUARDPOINT_ON_HIT                   = 56,
	DISP_LOCATION_ON_HIT                     = 57,
	KING                                     = 58,
	ORB_PENALTY                              = 59,
	LEADER                                   = 60,
	RULE_HP_REGENERATION                     = 61,
	RULE_GP_REGENERATION                     = 62,
	SUPPROTROLE_REGENERATION                 = 63,
	RULE_RESPAWNED                           = 64,
	MAX                                      = 65,
};

// Enum GameModule.EContactListEntryType
// NumValues: 0x0003
enum class EContactListEntryType : uint8
{
	NOTICE                                   = 0,
	INVITATION                               = 1,
	MAX                                      = 2,
};

// Enum GameModule.ECosmosInviteTarget
// NumValues: 0x0005
enum class ECosmosInviteTarget : uint8
{
	ALL                                      = 0,
	SQUAD                                    = 1,
	SCOUT                                    = 2,
	FRIEND                                   = 3,
	MAX                                      = 4,
};

// Enum GameModule.ECurveCalcType
// NumValues: 0x0003
enum class ECurveCalcType : uint8
{
	RATE                                     = 0,
	TIME                                     = 1,
	MAX                                      = 2,
};

// Enum GameModule.EFriendListCategoryType
// NumValues: 0x0005
enum class EFriendListCategoryType : uint8
{
	Friends                                  = 0,
	ApprovalWaitting                         = 1,
	ApprovalApplying                         = 2,
	AddFriend                                = 3,
	MAX                                      = 4,
};

// Enum GameModule.EEffState
// NumValues: 0x0006
enum class EEffState : uint8
{
	NONE                                     = 0,
	STOP_NOTIFY_DEACTIVATE                   = 1,
	STOP_NOTIFY_DELETE                       = 2,
	DEMO                                     = 4,
	LOOP_DESTROY                             = 8,
	EEffState_MAX                            = 9,
};

// Enum GameModule.EGameOptionCharacterUnlockStatus
// NumValues: 0x0005
enum class EGameOptionCharacterUnlockStatus : uint8
{
	NODATA                                   = 0,
	LOCKED                                   = 1,
	NEW_UNLOCKED                             = 2,
	UNLOCKED                                 = 3,
	MAX                                      = 4,
};

// Enum GameModule.EGameOptionFPSSetting
// NumValues: 0x0005
enum class EGameOptionFPSSetting : uint8
{
	UNLIMITED                                = 0,
	FPS60                                    = 60,
	FPS120                                   = 120,
	FPS240                                   = 240,
	MAX                                      = 241,
};

// Enum GameModule.ECameraAccelerationType
// NumValues: 0x0005
enum class ECameraAccelerationType : uint8
{
	INVALID                                  = 0,
	LINEAR                                   = 1,
	QUICK_TURN                               = 2,
	SLOW_STARTER                             = 3,
	MAX                                      = 4,
};

// Enum GameModule.EDamageVisibleType
// NumValues: 0x0005
enum class EDamageVisibleType : uint8
{
	INVALID                                  = 0,
	HIDDEM                                   = 1,
	SINGLE                                   = 2,
	TOTAL                                    = 3,
	MAX                                      = 4,
};

// Enum GameModule.ESettingOpenFrom
// NumValues: 0x0005
enum class ESettingOpenFrom : uint8
{
	Invalid                                  = 0,
	FromBattle                               = 1,
	FromTitle                                = 2,
	FromMainMenu                             = 3,
	ESettingOpenFrom_MAX                     = 4,
};

// Enum GameModule.EItemGetArrayType
// NumValues: 0x0003
enum class EItemGetArrayType : uint8
{
	NORMAL                                   = 0,
	PREMIUM                                  = 1,
	MAX                                      = 2,
};

// Enum GameModule.EPlayerVoiceChatState
// NumValues: 0x0005
enum class EPlayerVoiceChatState : uint8
{
	None                                     = 0,
	Connected                                = 1,
	Muted                                    = 2,
	Talking                                  = 4,
	EPlayerVoiceChatState_MAX                = 5,
};

// Enum GameModule.EGamePlayerStatus
// NumValues: 0x0004
enum class EGamePlayerStatus : uint8
{
	OFFLINE                                  = 0,
	WAITING                                  = 1,
	BATTLE                                   = 2,
	MAX                                      = 3,
};

// Enum GameModule.ESettingGraphicQuality
// NumValues: 0x0004
enum class ESettingGraphicQuality : uint8
{
	LOW                                      = 0,
	MID                                      = 1,
	HIGH                                     = 2,
	MAX                                      = 3,
};

// Enum GameModule.ESupportedLanguage
// NumValues: 0x0007
enum class ESupportedLanguage : uint8
{
	Ja                                       = 0,
	En                                       = 1,
	Fr                                       = 2,
	It                                       = 3,
	De                                       = 4,
	Es                                       = 5,
	ESupportedLanguage_MAX                   = 6,
};

// Enum GameModule.EGashaSuggestionVoiceType
// NumValues: 0x0005
enum class EGashaSuggestionVoiceType : uint8
{
	NONE                                     = 0,
	CONFIRM                                  = 1,
	SUGGEST_HIGH                             = 2,
	SUGGEST_MIDDLE                           = 3,
	MAX                                      = 4,
};

// Enum GameModule.EAttachType
// NumValues: 0x0005
enum class EAttachType : uint8
{
	KeepRelativeTransform                    = 0,
	KeepWorldTransform                       = 1,
	SnapToTargetNotIncludingScale            = 2,
	SnapToTargetIncludingScale               = 3,
	EAttachType_MAX                          = 4,
};

// Enum GameModule.EHitEffectType
// NumValues: 0x0003
enum class EHitEffectType : uint8
{
	Normal                                   = 0,
	MAX                                      = 1,
	INVALID                                  = 2,
};

// Enum GameModule.EMarkerType
// NumValues: 0x000B
enum class EMarkerType : uint8
{
	Default                                  = 0,
	Going                                    = 1,
	GetTogether                              = 2,
	Danger                                   = 3,
	FoundSupply                              = 4,
	Help                                     = 5,
	Search                                   = 6,
	SOS                                      = 7,
	Point                                    = 8,
	FoundEnemy                               = 9,
	MAX                                      = 10,
};

// Enum GameModule.EAttackType
// NumValues: 0x0006
enum class EAttackType : uint8
{
	NONE                                     = 0,
	UNIQUE1                                  = 1,
	UNIQUE2                                  = 2,
	UNIQUE3                                  = 3,
	SPECIAL                                  = 4,
	MAX                                      = 5,
};

// Enum GameModule.EButtonBits
// NumValues: 0x0012
enum class EButtonBits : uint16
{
	BB_NONE                                  = 0,
	BB_ACTION                                = 1,
	BB_JUMP                                  = 2,
	BB_DASH                                  = 4,
	BB_CROUCH                                = 8,
	BB_DODGE                                 = 16,
	BB_AIMING                                = 32,
	BB_AIMING_MOUSE                          = 64,
	BB_SPECIAL                               = 128,
	BB_PLUS_ULTRA                            = 256,
	BB_MELEE                                 = 512,
	BB_UNIQUE1                               = 1024,
	BB_UNIQUE2                               = 2048,
	BB_UNIQUE3                               = 4096,
	BB_UNIQUE2_PAD                           = 8192,
	BB_UNIQUE3_PAD                           = 16384,
	BB_JUMP_PAD                              = 32768,
	BB_MAX                                   = 32769,
};

// Enum GameModule.EItemVisiblityType
// NumValues: 0x0003
enum class EItemVisiblityType : uint8
{
	DEFAULT                                  = 0,
	TEAM_ONLY                                = 1,
	MAX                                      = 2,
};

// Enum GameModule.EDropItemType
// NumValues: 0x0004
enum class EDropItemType : uint8
{
	BELONGINGS                               = 0,
	SKILL_ITEMS                              = 1,
	NONE                                     = 2,
	MAX                                      = 3,
};

// Enum GameModule.ESkillSlot
// NumValues: 0x0004
enum class ESkillSlot : uint8
{
	SLOT1                                    = 0,
	SLOT2                                    = 1,
	SLOT3                                    = 2,
	MAX                                      = 3,
};

// Enum GameModule.EItemIconIndex
// NumValues: 0x0003
enum class EItemIconIndex : uint8
{
	RECOVERY_DROP_SMALL                      = 0,
	RECOVERY_DROP_BIG                        = 1,
	RECOVERY_DROP_MAX                        = 2,
};

// Enum GameModule.ELeaderboardFramType
// NumValues: 0x0005
enum class ELeaderboardFramType : uint8
{
	TopDamage                                = 0,
	TopKill                                  = 1,
	TopResucueAndAssault                     = 2,
	TopItemSupport                           = 3,
	MAX                                      = 4,
};

// Enum GameModule.EMaterialOverWriteType
// NumValues: 0x0004
enum class EMaterialOverWriteType : uint8
{
	NONE                                     = 0,
	OPTICALDAZZLEPAINT                       = 1,
	RESPAWN                                  = 2,
	EMaterialOverWriteType_MAX               = 3,
};

// Enum GameModule.EMaterialCustomFlag
// NumValues: 0x000B
enum class EMaterialCustomFlag : uint8
{
	None                                     = 0,
	Hair                                     = 1,
	Head                                     = 2,
	Face                                     = 3,
	Body                                     = 4,
	Hand                                     = 5,
	EYE                                      = 6,
	EYESHADOW                                = 7,
	ARMOR                                    = 8,
	MASK                                     = 9,
	MAX                                      = 10,
};

// Enum GameModule.EMaterialOverwriteFlag
// NumValues: 0x0006
enum class EMaterialOverwriteFlag : uint8
{
	None                                     = 0,
	OWA                                      = 1,
	OWB                                      = 2,
	OWC                                      = 3,
	OWD                                      = 4,
	MAX                                      = 5,
};

// Enum GameModule.EMaterialHideFlag
// NumValues: 0x001A
enum class EMaterialHideFlag : uint8
{
	HideNone                                 = 0,
	HideA                                    = 1,
	HideB                                    = 2,
	HideC                                    = 3,
	HideD                                    = 4,
	HideE                                    = 5,
	HideF                                    = 6,
	HideG                                    = 7,
	HideM                                    = 8,
	HideHand                                 = 9,
	HideArm                                  = 10,
	HideTongue                               = 11,
	ShideA                                   = 12,
	ShideB                                   = 13,
	ShideC                                   = 14,
	ShideD                                   = 15,
	ShideE                                   = 16,
	ShideF                                   = 17,
	ShideG                                   = 18,
	ShideH                                   = 19,
	ShideI                                   = 20,
	ShideM                                   = 21,
	ShideHand                                = 22,
	ShideArm                                 = 23,
	ShideTongue                              = 24,
	MAX                                      = 25,
};

// Enum GameModule.EMaterialGroupFlag
// NumValues: 0x0008
enum class EMaterialGroupFlag : uint8
{
	GroupNone                                = 0,
	GPA                                      = 1,
	GPB                                      = 2,
	GPC                                      = 3,
	GPD                                      = 4,
	GPTongue                                 = 5,
	GPAvatarEyes                             = 6,
	MAX                                      = 7,
};

// Enum GameModule.EMaterialTransitionPriority
// NumValues: 0x0008
enum class EMaterialTransitionPriority : uint8
{
	VeryLow                                  = 0,
	Low                                      = 1,
	InLower                                  = 2,
	Middle                                   = 3,
	OnMiddle                                 = 4,
	High                                     = 5,
	VeryHigher                               = 6,
	MAX                                      = 7,
};

// Enum GameModule.EMaterialFlags
// NumValues: 0x000A
enum class EMaterialFlags : uint8
{
	HMF_None                                 = 0,
	HMF_GP                                   = 1,
	HMF_Hide                                 = 2,
	HMF_Shide                                = 4,
	HMF_OLM                                  = 8,
	HMF_TM                                   = 16,
	HMF_CV                                   = 32,
	HMF_DCL                                  = 64,
	HMF_OW                                   = 128,
	HMF_MAX                                  = 129,
};

// Enum GameModule.ENumberAlignment
// NumValues: 0x0004
enum class ENumberAlignment : uint8
{
	LEFT                                     = 0,
	RIGHT                                    = 1,
	MIDDLE                                   = 2,
	ENumberAlignment_MAX                     = 3,
};

// Enum GameModule.ENetworkErrorType
// NumValues: 0x0007
enum class ENetworkErrorType : uint8
{
	Invalid                                  = 0,
	DisplayMessage                           = 1,
	NoDisplayMessage                         = 2,
	ReturnTitle                              = 3,
	ReturnTitleWithTrackingNumber            = 4,
	ReturnTitleChangeAccount                 = 5,
	ENetworkErrorType_MAX                    = 6,
};

// Enum GameModule.ESelectGameRuleTypeId
// NumValues: 0x0004
enum class ESelectGameRuleTypeId : uint8
{
	NONE                                     = 0,
	STAGE_CONFIRMATION                       = 1,
	MAINMENU_ICON                            = 2,
	MAX                                      = 3,
};

// Enum GameModule.EFaceIconTypeId
// NumValues: 0x0007
enum class EFaceIconTypeId : uint8
{
	NONE                                     = 0,
	CHARASELECT                              = 1,
	CHARAIMAGE                               = 2,
	BILLBOARDCHART                           = 3,
	BATTLEHISTORY                            = 4,
	GASHAICON                                = 5,
	MAX                                      = 6,
};

// Enum GameModule.ESceneCaptureTypeId
// NumValues: 0x000C
enum class ESceneCaptureTypeId : uint8
{
	NONE                                     = 0,
	DEFAULT                                  = 1,
	MYPROFILE                                = 2,
	LEADERBOARD                              = 3,
	BUSTUP                                   = 4,
	FACEUP                                   = 5,
	COORDINATION                             = 6,
	CUSTOMIZE                                = 7,
	CUSTOMIZEDETAIL                          = 8,
	GASHA                                    = 9,
	INGAMEPROFILE                            = 10,
	MAX                                      = 11,
};

// Enum GameModule.ELanguageType
// NumValues: 0x0010
enum class ELanguageType : uint8
{
	AR                                       = 0,
	BP                                       = 1,
	DE                                       = 2,
	EN                                       = 3,
	ES                                       = 4,
	FR                                       = 5,
	IND                                      = 6,
	IT                                       = 7,
	JA                                       = 8,
	KR                                       = 9,
	PO                                       = 10,
	RU                                       = 11,
	TH                                       = 12,
	ZHCN                                     = 13,
	ZHTW                                     = 14,
	MAX                                      = 15,
};

// Enum GameModule.EAnyDataType
// NumValues: 0x0006
enum class EAnyDataType : uint8
{
	BOOL                                     = 0,
	INT                                      = 1,
	FLOAT                                    = 2,
	VECTOR                                   = 3,
	NONE                                     = 4,
	EAnyDataType_MAX                         = 5,
};

// Enum GameModule.EReplicateType
// NumValues: 0x0005
enum class EReplicateType : uint8
{
	ERR                                      = 0,
	ANIMATION                                = 1,
	REPLICATOR                               = 2,
	BP_REPLICATOR                            = 3,
	EReplicateType_MAX                       = 4,
};

// Enum GameModule.EDirType
// NumValues: 0x0007
enum class EDirType : uint8
{
	TARGET                                   = 0,
	CHARACTER_FORWARD                        = 1,
	MOVE_DIRECTION                           = 2,
	SET_TRS                                  = 3,
	REALTIME_TARGET                          = 4,
	NONE                                     = 5,
	EDirType_MAX                             = 6,
};

// Enum GameModule.EDBType
// NumValues: 0x0003
enum class EDBType : uint8
{
	BULLET                                   = 0,
	GENERATOR                                = 1,
	MAX                                      = 2,
};

// Enum GameModule.EInterpType
// NumValues: 0x0004
enum class EInterpType : uint8
{
	LINEAR                                   = 0,
	ADD                                      = 1,
	SUB                                      = 2,
	EInterpType_MAX                          = 3,
};

// Enum GameModule.EHitType
// NumValues: 0x0004
enum class EHitType : uint8
{
	CHARACTER                                = 0,
	BACKGROUND                               = 1,
	CUSTOM                                   = 2,
	MAX                                      = 3,
};

// Enum GameModule.EBulletDestroyType
// NumValues: 0x0007
enum class EBulletDestroyType : uint8
{
	CHARACTER_HIT                            = 0,
	BACKGROUND_HIT                           = 1,
	LIFE_SPAN                                = 2,
	BREAK                                    = 3,
	VANISH                                   = 4,
	COMPRESS                                 = 5,
	EBulletDestroyType_MAX                   = 6,
};

// Enum GameModule.EProjectileGeneratorID
// NumValues: 0x0008
enum class EProjectileGeneratorID : uint8
{
	__NONE__                                 = 0,
	__COMMON__                               = 1,
	AttackLow                                = 2,
	AttackHigh                               = 3,
	Shot                                     = 4,
	Test                                     = 5,
	__DEKU__                                 = 6,
	EProjectileGeneratorID_MAX               = 7,
};

// Enum GameModule.ESoundCategory
// NumValues: 0x0005
enum class ESoundCategory : uint8
{
	UNDEF                                    = 0,
	SE                                       = 1,
	VOICE                                    = 2,
	BGM                                      = 4,
	ESoundCategory_MAX                       = 5,
};

// Enum GameModule.ELeadersBattleTeamType
// NumValues: 0x0005
enum class ELeadersBattleTeamType : uint8
{
	UNDEF                                    = 0,
	TEAM_RED                                 = 1,
	TEAM_BLUE                                = 2,
	TEAM_GREEN                               = 3,
	MAX                                      = 4,
};

// Enum GameModule.EInteractActionType
// NumValues: 0x0005
enum class EInteractActionType : uint32
{
	Bully                                    = 0,
	Open                                     = 1,
	PickUp                                   = 2,
	Rescue                                   = 3,
	EInteractActionType_MAX                  = 4,
};

// Enum GameModule.ESupplyType
// NumValues: 0x000E
enum class ESupplyType : uint8
{
	NONE                                     = 0,
	HEALTHRECOVER                            = 1,
	GUARDRECOVER                             = 2,
	HEALTHANDGUARDRECOVER                    = 3,
	LEVELUP                                  = 4,
	PLUSULTRA                                = 5,
	ABILITY                                  = 6,
	SHOULDER                                 = 7,
	ORB                                      = 8,
	ALLALLYS_LEVELUP                         = 9,
	DOGTAG                                   = 10,
	RESPAWN_FLAGMENT                         = 11,
	RESPAWN                                  = 12,
	MAX                                      = 13,
};

// Enum GameModule.ESurfaceType
// NumValues: 0x0011
enum class ESurfaceType : uint8
{
	Default                                  = 0,
	Concrete                                 = 1,
	Grass                                    = 2,
	Sand                                     = 3,
	Rock                                     = 4,
	Water                                    = 5,
	DeepWater                                = 6,
	Ice                                      = 7,
	Wood                                     = 8,
	Metal                                    = 9,
	Paper                                    = 10,
	Plastic                                  = 11,
	Cloth                                    = 12,
	Ignore                                   = 13,
	Tree                                     = 14,
	None                                     = 15,
	ESurfaceType_MAX                         = 16,
};

// Enum GameModule.EDebugGameViewType
// NumValues: 0x000F
enum class EDebugGameViewType : uint8
{
	ALL                                      = 0,
	MYSELF                                   = 1,
	OTHER_ALL                                = 2,
	FRIEND_AND_MYSELF                        = 3,
	FRIEND_ONLY                              = 4,
	ENEMY_ONLY                               = 5,
	DISABLE                                  = 6,
	Locally_Control_Only                     = 7,
	WAZA_MOJI                                = 8,
	MYSELF_SCALE                             = 9,
	GAMEVIEW_MYSELF                          = 10,
	GAMEVIEW_FRIEND_ONLY                     = 11,
	GAMEVIEW_ENEMY_ONLY                      = 12,
	GAMEVIEW_SPECTATING                      = 13,
	EDebugGameViewType_MAX                   = 14,
};

// Enum GameModule.EViewType
// NumValues: 0x0009
enum class EViewType : uint8
{
	ALL                                      = 0,
	MYSELF                                   = 1,
	OTHER_ALL                                = 2,
	FRIEND_AND_MYSELF                        = 3,
	FRIEND_ONLY                              = 4,
	ENEMY_ONLY                               = 5,
	SELF_AND_ENEMY                           = 6,
	DISABLE                                  = 7,
	EViewType_MAX                            = 8,
};

// Enum GameModule.EWheelItemType
// NumValues: 0x0005
enum class EWheelItemType : uint32
{
	None                                     = 0,
	ImageOnly                                = 1,
	TextOnly                                 = 2,
	ImageAndText                             = 3,
	Max                                      = 4,
};

// Enum GameModule.EWheelControlStick
// NumValues: 0x0004
enum class EWheelControlStick : uint8
{
	RightStick                               = 0,
	LeftStick                                = 1,
	BothSticks                               = 2,
	EWheelControlStick_MAX                   = 3,
};

// ScriptStruct GameModule.DamageAttenuation
// 0x000C (0x000C - 0x0000)
struct FDamageAttenuation final
{
public:
	class FName                                   CurveAssetName;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurveCalcType                                CurveCalcType;                                     // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageAttenuation) == 0x000004, "Wrong alignment on FDamageAttenuation");
static_assert(sizeof(FDamageAttenuation) == 0x00000C, "Wrong size on FDamageAttenuation");
static_assert(offsetof(FDamageAttenuation, CurveAssetName) == 0x000000, "Member 'FDamageAttenuation::CurveAssetName' has a wrong offset!");
static_assert(offsetof(FDamageAttenuation, CurveCalcType) == 0x000008, "Member 'FDamageAttenuation::CurveCalcType' has a wrong offset!");

// ScriptStruct GameModule.HitCollision
// 0x0034 (0x0034 - 0x0000)
struct FHitCollision final
{
public:
	class FName                                   DamageParam;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCount;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideCharacterHitCount;                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrateDamageMul;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         beginTime;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGrounded;                                        // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CompareLocation;                                   // 0x0022(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareHeight;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreInterval;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideHitSpan;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopGeneratedBlock;                                // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitCollision) == 0x000004, "Wrong alignment on FHitCollision");
static_assert(sizeof(FHitCollision) == 0x000034, "Wrong size on FHitCollision");
static_assert(offsetof(FHitCollision, DamageParam) == 0x000000, "Member 'FHitCollision::DamageParam' has a wrong offset!");
static_assert(offsetof(FHitCollision, Interval) == 0x000008, "Member 'FHitCollision::Interval' has a wrong offset!");
static_assert(offsetof(FHitCollision, HitCount) == 0x00000C, "Member 'FHitCollision::HitCount' has a wrong offset!");
static_assert(offsetof(FHitCollision, OverrideCharacterHitCount) == 0x000010, "Member 'FHitCollision::OverrideCharacterHitCount' has a wrong offset!");
static_assert(offsetof(FHitCollision, PenetrateDamageMul) == 0x000014, "Member 'FHitCollision::PenetrateDamageMul' has a wrong offset!");
static_assert(offsetof(FHitCollision, beginTime) == 0x000018, "Member 'FHitCollision::beginTime' has a wrong offset!");
static_assert(offsetof(FHitCollision, EndTime) == 0x00001C, "Member 'FHitCollision::EndTime' has a wrong offset!");
static_assert(offsetof(FHitCollision, Active) == 0x000020, "Member 'FHitCollision::Active' has a wrong offset!");
static_assert(offsetof(FHitCollision, IsGrounded) == 0x000021, "Member 'FHitCollision::IsGrounded' has a wrong offset!");
static_assert(offsetof(FHitCollision, CompareLocation) == 0x000022, "Member 'FHitCollision::CompareLocation' has a wrong offset!");
static_assert(offsetof(FHitCollision, CompareHeight) == 0x000024, "Member 'FHitCollision::CompareHeight' has a wrong offset!");
static_assert(offsetof(FHitCollision, IgnoreInterval) == 0x000028, "Member 'FHitCollision::IgnoreInterval' has a wrong offset!");
static_assert(offsetof(FHitCollision, OverrideHitSpan) == 0x00002C, "Member 'FHitCollision::OverrideHitSpan' has a wrong offset!");
static_assert(offsetof(FHitCollision, StopGeneratedBlock) == 0x000030, "Member 'FHitCollision::StopGeneratedBlock' has a wrong offset!");

// ScriptStruct GameModule.AccessaryEffectRegistData
// 0x0030 (0x0030 - 0x0000)
struct FAccessaryEffectRegistData final
{
public:
	class UParticleSystem*                        _emitterTemplate;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _attachPointName;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _location;                                         // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _rotation;                                         // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               _locationType;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAutoDestroy;                                     // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccessaryEffectRegistData) == 0x000008, "Wrong alignment on FAccessaryEffectRegistData");
static_assert(sizeof(FAccessaryEffectRegistData) == 0x000030, "Wrong size on FAccessaryEffectRegistData");
static_assert(offsetof(FAccessaryEffectRegistData, _emitterTemplate) == 0x000000, "Member 'FAccessaryEffectRegistData::_emitterTemplate' has a wrong offset!");
static_assert(offsetof(FAccessaryEffectRegistData, _attachPointName) == 0x000008, "Member 'FAccessaryEffectRegistData::_attachPointName' has a wrong offset!");
static_assert(offsetof(FAccessaryEffectRegistData, _location) == 0x000010, "Member 'FAccessaryEffectRegistData::_location' has a wrong offset!");
static_assert(offsetof(FAccessaryEffectRegistData, _rotation) == 0x00001C, "Member 'FAccessaryEffectRegistData::_rotation' has a wrong offset!");
static_assert(offsetof(FAccessaryEffectRegistData, _locationType) == 0x000028, "Member 'FAccessaryEffectRegistData::_locationType' has a wrong offset!");
static_assert(offsetof(FAccessaryEffectRegistData, _bAutoDestroy) == 0x000029, "Member 'FAccessaryEffectRegistData::_bAutoDestroy' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataPlayerRPData
// 0x000C (0x000C - 0x0000)
struct FPlayerDataPlayerRPData final
{
public:
	int32                                         _rpCode;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _calcValue;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _rp;                                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataPlayerRPData) == 0x000004, "Wrong alignment on FPlayerDataPlayerRPData");
static_assert(sizeof(FPlayerDataPlayerRPData) == 0x00000C, "Wrong size on FPlayerDataPlayerRPData");
static_assert(offsetof(FPlayerDataPlayerRPData, _rpCode) == 0x000000, "Member 'FPlayerDataPlayerRPData::_rpCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerRPData, _calcValue) == 0x000004, "Member 'FPlayerDataPlayerRPData::_calcValue' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerRPData, _rp) == 0x000008, "Member 'FPlayerDataPlayerRPData::_rp' has a wrong offset!");

// ScriptStruct GameModule.EffStatus
// 0x0030 (0x0030 - 0x0000)
struct FEffStatus final
{
public:
	class UCustomParticleSystemComponent*         PSC;                                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PsTemplateName;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEffStatus) == 0x000008, "Wrong alignment on FEffStatus");
static_assert(sizeof(FEffStatus) == 0x000030, "Wrong size on FEffStatus");
static_assert(offsetof(FEffStatus, PSC) == 0x000000, "Member 'FEffStatus::PSC' has a wrong offset!");
static_assert(offsetof(FEffStatus, PsTemplateName) == 0x000008, "Member 'FEffStatus::PsTemplateName' has a wrong offset!");

// ScriptStruct GameModule.EffStatusImpl
// 0x0010 (0x0010 - 0x0000)
struct FEffStatusImpl final
{
public:
	TArray<struct FEffStatus>                     Effs;                                              // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffStatusImpl) == 0x000008, "Wrong alignment on FEffStatusImpl");
static_assert(sizeof(FEffStatusImpl) == 0x000010, "Wrong size on FEffStatusImpl");
static_assert(offsetof(FEffStatusImpl, Effs) == 0x000000, "Member 'FEffStatusImpl::Effs' has a wrong offset!");

// ScriptStruct GameModule.SlotAssetData
// 0x0010 (0x0010 - 0x0000)
struct FSlotAssetData final
{
public:
	TArray<class UAnimMontage*>                   _montages;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotAssetData) == 0x000008, "Wrong alignment on FSlotAssetData");
static_assert(sizeof(FSlotAssetData) == 0x000010, "Wrong size on FSlotAssetData");
static_assert(offsetof(FSlotAssetData, _montages) == 0x000000, "Member 'FSlotAssetData::_montages' has a wrong offset!");

// ScriptStruct GameModule.SpecifiedDirectoryParam
// 0x0030 (0x0030 - 0x0000)
struct FSpecifiedDirectoryParam final
{
public:
	class FName                                   _bundleName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         _directory;                                        // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
	bool                                          _bRecurseDirectory;                                // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bUseRegex;                                        // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _regexPattern;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecifiedDirectoryParam) == 0x000008, "Wrong alignment on FSpecifiedDirectoryParam");
static_assert(sizeof(FSpecifiedDirectoryParam) == 0x000030, "Wrong size on FSpecifiedDirectoryParam");
static_assert(offsetof(FSpecifiedDirectoryParam, _bundleName) == 0x000000, "Member 'FSpecifiedDirectoryParam::_bundleName' has a wrong offset!");
static_assert(offsetof(FSpecifiedDirectoryParam, _directory) == 0x000008, "Member 'FSpecifiedDirectoryParam::_directory' has a wrong offset!");
static_assert(offsetof(FSpecifiedDirectoryParam, _bRecurseDirectory) == 0x000018, "Member 'FSpecifiedDirectoryParam::_bRecurseDirectory' has a wrong offset!");
static_assert(offsetof(FSpecifiedDirectoryParam, _bUseRegex) == 0x000019, "Member 'FSpecifiedDirectoryParam::_bUseRegex' has a wrong offset!");
static_assert(offsetof(FSpecifiedDirectoryParam, _regexPattern) == 0x000020, "Member 'FSpecifiedDirectoryParam::_regexPattern' has a wrong offset!");

// ScriptStruct GameModule.GashaResultData
// 0x0018 (0x0018 - 0x0000)
struct FGashaResultData final
{
public:
	EMdRarity                                     _rarity;                                           // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _itemCode;                                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMdRarityItemCategory                         _itemCategory;                                     // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _characterId;                                      // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bFirst;                                           // 0x000A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _num;                                              // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMdRarity                                     _boxRarity;                                        // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMdRarity                                     _bomRarity;                                        // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _aura;                                             // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGashaResultData) == 0x000004, "Wrong alignment on FGashaResultData");
static_assert(sizeof(FGashaResultData) == 0x000018, "Wrong size on FGashaResultData");
static_assert(offsetof(FGashaResultData, _rarity) == 0x000000, "Member 'FGashaResultData::_rarity' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _itemCode) == 0x000004, "Member 'FGashaResultData::_itemCode' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _itemCategory) == 0x000008, "Member 'FGashaResultData::_itemCategory' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _characterId) == 0x000009, "Member 'FGashaResultData::_characterId' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _bFirst) == 0x00000A, "Member 'FGashaResultData::_bFirst' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _num) == 0x00000C, "Member 'FGashaResultData::_num' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _boxRarity) == 0x000010, "Member 'FGashaResultData::_boxRarity' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _bomRarity) == 0x000011, "Member 'FGashaResultData::_bomRarity' has a wrong offset!");
static_assert(offsetof(FGashaResultData, _aura) == 0x000014, "Member 'FGashaResultData::_aura' has a wrong offset!");

// ScriptStruct GameModule.AnimationPlayParams
// 0x0004 (0x0004 - 0x0000)
struct FAnimationPlayParams final
{
public:
	uint8                                         _playRate;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        _buffer;                                           // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimationPlayParams) == 0x000002, "Wrong alignment on FAnimationPlayParams");
static_assert(sizeof(FAnimationPlayParams) == 0x000004, "Wrong size on FAnimationPlayParams");
static_assert(offsetof(FAnimationPlayParams, _playRate) == 0x000000, "Member 'FAnimationPlayParams::_playRate' has a wrong offset!");
static_assert(offsetof(FAnimationPlayParams, _buffer) == 0x000002, "Member 'FAnimationPlayParams::_buffer' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataBonusData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerDataBonusData final
{
public:
	int32                                         _bonusCode;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _bonus;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataBonusData) == 0x000004, "Wrong alignment on FPlayerDataBonusData");
static_assert(sizeof(FPlayerDataBonusData) == 0x000008, "Wrong size on FPlayerDataBonusData");
static_assert(offsetof(FPlayerDataBonusData, _bonusCode) == 0x000000, "Member 'FPlayerDataBonusData::_bonusCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataBonusData, _bonus) == 0x000004, "Member 'FPlayerDataBonusData::_bonus' has a wrong offset!");

// ScriptStruct GameModule.LoadIGashaResultImageData
// 0x0038 (0x0038 - 0x0000)
struct FLoadIGashaResultImageData final
{
public:
	TSoftObjectPtr<class UPaperSprite>            _spritePtr;                                        // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPaperSprite*                           _sprite;                                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _itemCode;                                         // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMdRarityItemCategory                         _itemCategory;                                     // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGashaImageSizeType                           _imageSize;                                        // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadIGashaResultImageData) == 0x000008, "Wrong alignment on FLoadIGashaResultImageData");
static_assert(sizeof(FLoadIGashaResultImageData) == 0x000038, "Wrong size on FLoadIGashaResultImageData");
static_assert(offsetof(FLoadIGashaResultImageData, _spritePtr) == 0x000000, "Member 'FLoadIGashaResultImageData::_spritePtr' has a wrong offset!");
static_assert(offsetof(FLoadIGashaResultImageData, _sprite) == 0x000028, "Member 'FLoadIGashaResultImageData::_sprite' has a wrong offset!");
static_assert(offsetof(FLoadIGashaResultImageData, _itemCode) == 0x000030, "Member 'FLoadIGashaResultImageData::_itemCode' has a wrong offset!");
static_assert(offsetof(FLoadIGashaResultImageData, _itemCategory) == 0x000034, "Member 'FLoadIGashaResultImageData::_itemCategory' has a wrong offset!");
static_assert(offsetof(FLoadIGashaResultImageData, _imageSize) == 0x000035, "Member 'FLoadIGashaResultImageData::_imageSize' has a wrong offset!");

// ScriptStruct GameModule.FriendInfo
// 0x0048 (0x0048 - 0x0000)
struct FFriendInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _emblemIds;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 _userId;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _name;                                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              _lastLogin;                                        // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _status;                                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOnline;                                          // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFriendInfo) == 0x000008, "Wrong alignment on FFriendInfo");
static_assert(sizeof(FFriendInfo) == 0x000048, "Wrong size on FFriendInfo");
static_assert(offsetof(FFriendInfo, _emblemIds) == 0x000008, "Member 'FFriendInfo::_emblemIds' has a wrong offset!");
static_assert(offsetof(FFriendInfo, _userId) == 0x000018, "Member 'FFriendInfo::_userId' has a wrong offset!");
static_assert(offsetof(FFriendInfo, _name) == 0x000028, "Member 'FFriendInfo::_name' has a wrong offset!");
static_assert(offsetof(FFriendInfo, _lastLogin) == 0x000038, "Member 'FFriendInfo::_lastLogin' has a wrong offset!");
static_assert(offsetof(FFriendInfo, _status) == 0x000040, "Member 'FFriendInfo::_status' has a wrong offset!");
static_assert(offsetof(FFriendInfo, _bOnline) == 0x000044, "Member 'FFriendInfo::_bOnline' has a wrong offset!");

// ScriptStruct GameModule.MyADDisplayData
// 0x0060 (0x0060 - 0x0000)
struct FMyADDisplayData final
{
public:
	class FString                                 _userId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _id;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _backgroundId;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _effectId;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _messageId;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _message;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _name;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _status;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bProfileFlg;                                      // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              _publishedAt;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHiddenDisplay;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _firstEmblemCode;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _secondEmblemCode;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _thirdEmblemCode;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMyADDisplayData) == 0x000008, "Wrong alignment on FMyADDisplayData");
static_assert(sizeof(FMyADDisplayData) == 0x000060, "Wrong size on FMyADDisplayData");
static_assert(offsetof(FMyADDisplayData, _userId) == 0x000000, "Member 'FMyADDisplayData::_userId' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _id) == 0x000010, "Member 'FMyADDisplayData::_id' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _backgroundId) == 0x000020, "Member 'FMyADDisplayData::_backgroundId' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _effectId) == 0x000024, "Member 'FMyADDisplayData::_effectId' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _messageId) == 0x000028, "Member 'FMyADDisplayData::_messageId' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _message) == 0x00002C, "Member 'FMyADDisplayData::_message' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _name) == 0x000030, "Member 'FMyADDisplayData::_name' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _status) == 0x000040, "Member 'FMyADDisplayData::_status' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _bProfileFlg) == 0x000044, "Member 'FMyADDisplayData::_bProfileFlg' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _publishedAt) == 0x000048, "Member 'FMyADDisplayData::_publishedAt' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _bHiddenDisplay) == 0x000050, "Member 'FMyADDisplayData::_bHiddenDisplay' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _firstEmblemCode) == 0x000054, "Member 'FMyADDisplayData::_firstEmblemCode' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _secondEmblemCode) == 0x000058, "Member 'FMyADDisplayData::_secondEmblemCode' has a wrong offset!");
static_assert(offsetof(FMyADDisplayData, _thirdEmblemCode) == 0x00005C, "Member 'FMyADDisplayData::_thirdEmblemCode' has a wrong offset!");

// ScriptStruct GameModule.NoticeImageInfo
// 0x0018 (0x0018 - 0x0000)
struct FNoticeImageInfo final
{
public:
	class UTexture2D*                             NotificationTexture;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Code;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Code2;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Code3;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNoticeImageInfo) == 0x000008, "Wrong alignment on FNoticeImageInfo");
static_assert(sizeof(FNoticeImageInfo) == 0x000018, "Wrong size on FNoticeImageInfo");
static_assert(offsetof(FNoticeImageInfo, NotificationTexture) == 0x000000, "Member 'FNoticeImageInfo::NotificationTexture' has a wrong offset!");
static_assert(offsetof(FNoticeImageInfo, Code) == 0x000008, "Member 'FNoticeImageInfo::Code' has a wrong offset!");
static_assert(offsetof(FNoticeImageInfo, Code2) == 0x00000C, "Member 'FNoticeImageInfo::Code2' has a wrong offset!");
static_assert(offsetof(FNoticeImageInfo, Code3) == 0x000010, "Member 'FNoticeImageInfo::Code3' has a wrong offset!");

// ScriptStruct GameModule.AvatarCreateSlotTextData
// 0x0070 (0x0070 - 0x0000)
struct FAvatarCreateSlotTextData final
{
public:
	class FText                                   _itemText;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _itemColor;                                        // 0x0018(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAnchorData                            _itemAnchor;                                       // 0x0040(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          _itemHorizontalAlignment;                          // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            _itemVerticalAlignment;                            // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvatarCreateSlotTextData) == 0x000008, "Wrong alignment on FAvatarCreateSlotTextData");
static_assert(sizeof(FAvatarCreateSlotTextData) == 0x000070, "Wrong size on FAvatarCreateSlotTextData");
static_assert(offsetof(FAvatarCreateSlotTextData, _itemText) == 0x000000, "Member 'FAvatarCreateSlotTextData::_itemText' has a wrong offset!");
static_assert(offsetof(FAvatarCreateSlotTextData, _itemColor) == 0x000018, "Member 'FAvatarCreateSlotTextData::_itemColor' has a wrong offset!");
static_assert(offsetof(FAvatarCreateSlotTextData, _itemAnchor) == 0x000040, "Member 'FAvatarCreateSlotTextData::_itemAnchor' has a wrong offset!");
static_assert(offsetof(FAvatarCreateSlotTextData, _itemHorizontalAlignment) == 0x000068, "Member 'FAvatarCreateSlotTextData::_itemHorizontalAlignment' has a wrong offset!");
static_assert(offsetof(FAvatarCreateSlotTextData, _itemVerticalAlignment) == 0x000069, "Member 'FAvatarCreateSlotTextData::_itemVerticalAlignment' has a wrong offset!");

// ScriptStruct GameModule.AvatarCreateImageData
// 0x0078 (0x0078 - 0x0000)
struct FAvatarCreateImageData final
{
public:
	struct FAvatarCreateSlotTextData              _category;                                         // 0x0000(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UPaperSprite*                           _image;                                            // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvatarCreateImageData) == 0x000008, "Wrong alignment on FAvatarCreateImageData");
static_assert(sizeof(FAvatarCreateImageData) == 0x000078, "Wrong size on FAvatarCreateImageData");
static_assert(offsetof(FAvatarCreateImageData, _category) == 0x000000, "Member 'FAvatarCreateImageData::_category' has a wrong offset!");
static_assert(offsetof(FAvatarCreateImageData, _image) == 0x000070, "Member 'FAvatarCreateImageData::_image' has a wrong offset!");

// ScriptStruct GameModule.BGMData
// 0x0008 (0x0010 - 0x0008)
struct FBGMData final : public FTableRowBase
{
public:
	class USoundAtomCue*                          _bgmAtomCue;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBGMData) == 0x000008, "Wrong alignment on FBGMData");
static_assert(sizeof(FBGMData) == 0x000010, "Wrong size on FBGMData");
static_assert(offsetof(FBGMData, _bgmAtomCue) == 0x000008, "Member 'FBGMData::_bgmAtomCue' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataEmblemParam
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPlayerDataEmblemParam final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataEmblemParam) == 0x000008, "Wrong alignment on FPlayerDataEmblemParam");
static_assert(sizeof(FPlayerDataEmblemParam) == 0x000020, "Wrong size on FPlayerDataEmblemParam");

// ScriptStruct GameModule.BlueprintInfo
// 0x0030 (0x0030 - 0x0000)
struct FBlueprintInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     SubClass;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlueprintInfo) == 0x000008, "Wrong alignment on FBlueprintInfo");
static_assert(sizeof(FBlueprintInfo) == 0x000030, "Wrong size on FBlueprintInfo");
static_assert(offsetof(FBlueprintInfo, SubClass) == 0x000020, "Member 'FBlueprintInfo::SubClass' has a wrong offset!");

// ScriptStruct GameModule.BulletSpeed
// 0x0020 (0x0020 - 0x0000)
struct FBulletSpeed final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerateStartTime;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedApplyWaitTime;                                // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerateTime;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitAccelarate;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletSpeed) == 0x000004, "Wrong alignment on FBulletSpeed");
static_assert(sizeof(FBulletSpeed) == 0x000020, "Wrong size on FBulletSpeed");
static_assert(offsetof(FBulletSpeed, Speed) == 0x000000, "Member 'FBulletSpeed::Speed' has a wrong offset!");
static_assert(offsetof(FBulletSpeed, Acceleration) == 0x000004, "Member 'FBulletSpeed::Acceleration' has a wrong offset!");
static_assert(offsetof(FBulletSpeed, AccelerateStartTime) == 0x000008, "Member 'FBulletSpeed::AccelerateStartTime' has a wrong offset!");
static_assert(offsetof(FBulletSpeed, SpeedApplyWaitTime) == 0x00000C, "Member 'FBulletSpeed::SpeedApplyWaitTime' has a wrong offset!");
static_assert(offsetof(FBulletSpeed, AccelerateTime) == 0x000010, "Member 'FBulletSpeed::AccelerateTime' has a wrong offset!");
static_assert(offsetof(FBulletSpeed, MinSpeed) == 0x000014, "Member 'FBulletSpeed::MinSpeed' has a wrong offset!");
static_assert(offsetof(FBulletSpeed, MaxSpeed) == 0x000018, "Member 'FBulletSpeed::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FBulletSpeed, HitAccelarate) == 0x00001C, "Member 'FBulletSpeed::HitAccelarate' has a wrong offset!");

// ScriptStruct GameModule.ScaleImpl
// 0x0014 (0x0014 - 0x0000)
struct FScaleImpl final
{
public:
	float                                         Start;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToEndTime;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpType                                   InterpType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScaleImpl) == 0x000004, "Wrong alignment on FScaleImpl");
static_assert(sizeof(FScaleImpl) == 0x000014, "Wrong size on FScaleImpl");
static_assert(offsetof(FScaleImpl, Start) == 0x000000, "Member 'FScaleImpl::Start' has a wrong offset!");
static_assert(offsetof(FScaleImpl, End) == 0x000004, "Member 'FScaleImpl::End' has a wrong offset!");
static_assert(offsetof(FScaleImpl, ToEndTime) == 0x000008, "Member 'FScaleImpl::ToEndTime' has a wrong offset!");
static_assert(offsetof(FScaleImpl, StartTime) == 0x00000C, "Member 'FScaleImpl::StartTime' has a wrong offset!");
static_assert(offsetof(FScaleImpl, InterpType) == 0x000010, "Member 'FScaleImpl::InterpType' has a wrong offset!");

// ScriptStruct GameModule.Scale
// 0x0078 (0x0078 - 0x0000)
struct FScale final
{
public:
	struct FScaleImpl                             Xyz;                                               // 0x0000(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScaleImpl                             X;                                                 // 0x0014(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScaleImpl                             Y;                                                 // 0x0028(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScaleImpl                             Z;                                                 // 0x003C(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScaleImpl                             XY;                                                // 0x0050(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScaleImpl                             Yz;                                                // 0x0064(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScale) == 0x000004, "Wrong alignment on FScale");
static_assert(sizeof(FScale) == 0x000078, "Wrong size on FScale");
static_assert(offsetof(FScale, Xyz) == 0x000000, "Member 'FScale::Xyz' has a wrong offset!");
static_assert(offsetof(FScale, X) == 0x000014, "Member 'FScale::X' has a wrong offset!");
static_assert(offsetof(FScale, Y) == 0x000028, "Member 'FScale::Y' has a wrong offset!");
static_assert(offsetof(FScale, Z) == 0x00003C, "Member 'FScale::Z' has a wrong offset!");
static_assert(offsetof(FScale, XY) == 0x000050, "Member 'FScale::XY' has a wrong offset!");
static_assert(offsetof(FScale, Yz) == 0x000064, "Member 'FScale::Yz' has a wrong offset!");

// ScriptStruct GameModule.Limit
// 0x0008 (0x0008 - 0x0000)
struct FLimit final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dist;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimit) == 0x000004, "Wrong alignment on FLimit");
static_assert(sizeof(FLimit) == 0x000008, "Wrong size on FLimit");
static_assert(offsetof(FLimit, Time) == 0x000000, "Member 'FLimit::Time' has a wrong offset!");
static_assert(offsetof(FLimit, Dist) == 0x000004, "Member 'FLimit::Dist' has a wrong offset!");

// ScriptStruct GameModule.EventData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FEventData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventData) == 0x000008, "Wrong alignment on FEventData");
static_assert(sizeof(FEventData) == 0x000020, "Wrong size on FEventData");

// ScriptStruct GameModule.AnyData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FAnyData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnyData) == 0x000004, "Wrong alignment on FAnyData");
static_assert(sizeof(FAnyData) == 0x000018, "Wrong size on FAnyData");

// ScriptStruct GameModule.BulletLevelData
// 0x03D0 (0x03D0 - 0x0000)
struct FBulletLevelData final
{
public:
	struct FBlueprintInfo                         BP;                                                // 0x0000(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletSpeed                           SpeedInfo;                                         // 0x0034(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScale                                 ScaleInfo;                                         // 0x0054(0x0078)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScale                                 HitColScaleInfo;                                   // 0x00CC(0x0078)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScale                                 backgroundHitColScaleInfo;                         // 0x0144(0x0078)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0xF0];                                     // 0x01BC(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageAttenuation                     DamageAttenuationInfo;                             // 0x02AC(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLimit                                 Limit;                                             // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x70];                                     // 0x02C0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FEventData>               EventDataTbl;                                      // 0x0330(0x0050)(NativeAccessSpecifierPublic)
	TMap<uint32, struct FAnyData>                 AnyDataMap;                                        // 0x0380(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletLevelData) == 0x000008, "Wrong alignment on FBulletLevelData");
static_assert(sizeof(FBulletLevelData) == 0x0003D0, "Wrong size on FBulletLevelData");
static_assert(offsetof(FBulletLevelData, BP) == 0x000000, "Member 'FBulletLevelData::BP' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, SpeedInfo) == 0x000034, "Member 'FBulletLevelData::SpeedInfo' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, ScaleInfo) == 0x000054, "Member 'FBulletLevelData::ScaleInfo' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, HitColScaleInfo) == 0x0000CC, "Member 'FBulletLevelData::HitColScaleInfo' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, backgroundHitColScaleInfo) == 0x000144, "Member 'FBulletLevelData::backgroundHitColScaleInfo' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, DamageAttenuationInfo) == 0x0002AC, "Member 'FBulletLevelData::DamageAttenuationInfo' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, Limit) == 0x0002B8, "Member 'FBulletLevelData::Limit' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, EventDataTbl) == 0x000330, "Member 'FBulletLevelData::EventDataTbl' has a wrong offset!");
static_assert(offsetof(FBulletLevelData, AnyDataMap) == 0x000380, "Member 'FBulletLevelData::AnyDataMap' has a wrong offset!");

// ScriptStruct GameModule.UniqueNetIdKey
// 0x0008 (0x0008 - 0x0000)
struct FUniqueNetIdKey final
{
public:
	class FName                                   _id;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUniqueNetIdKey) == 0x000004, "Wrong alignment on FUniqueNetIdKey");
static_assert(sizeof(FUniqueNetIdKey) == 0x000008, "Wrong size on FUniqueNetIdKey");
static_assert(offsetof(FUniqueNetIdKey, _id) == 0x000000, "Member 'FUniqueNetIdKey::_id' has a wrong offset!");

// ScriptStruct GameModule.CustomMatchResultPlayerData
// 0x0040 (0x0040 - 0x0000)
struct FCustomMatchResultPlayerData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdKey                        _playerId;                                         // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   _playerName;                                       // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	int32                                         _characterCode;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _characterVariation;                               // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _koCount;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _damage;                                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomMatchResultPlayerData) == 0x000008, "Wrong alignment on FCustomMatchResultPlayerData");
static_assert(sizeof(FCustomMatchResultPlayerData) == 0x000040, "Wrong size on FCustomMatchResultPlayerData");
static_assert(offsetof(FCustomMatchResultPlayerData, _playerId) == 0x000008, "Member 'FCustomMatchResultPlayerData::_playerId' has a wrong offset!");
static_assert(offsetof(FCustomMatchResultPlayerData, _playerName) == 0x000010, "Member 'FCustomMatchResultPlayerData::_playerName' has a wrong offset!");
static_assert(offsetof(FCustomMatchResultPlayerData, _characterCode) == 0x000028, "Member 'FCustomMatchResultPlayerData::_characterCode' has a wrong offset!");
static_assert(offsetof(FCustomMatchResultPlayerData, _characterVariation) == 0x00002C, "Member 'FCustomMatchResultPlayerData::_characterVariation' has a wrong offset!");
static_assert(offsetof(FCustomMatchResultPlayerData, _koCount) == 0x000030, "Member 'FCustomMatchResultPlayerData::_koCount' has a wrong offset!");
static_assert(offsetof(FCustomMatchResultPlayerData, _damage) == 0x000034, "Member 'FCustomMatchResultPlayerData::_damage' has a wrong offset!");

// ScriptStruct GameModule.CustomMatchResultTeamData
// 0x0040 (0x0040 - 0x0000)
struct FCustomMatchResultTeamData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _teamName;                                         // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	int32                                         _ranking;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomMatchResultPlayerData>   _playerList;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomMatchResultTeamData) == 0x000008, "Wrong alignment on FCustomMatchResultTeamData");
static_assert(sizeof(FCustomMatchResultTeamData) == 0x000040, "Wrong size on FCustomMatchResultTeamData");
static_assert(offsetof(FCustomMatchResultTeamData, _teamName) == 0x000008, "Member 'FCustomMatchResultTeamData::_teamName' has a wrong offset!");
static_assert(offsetof(FCustomMatchResultTeamData, _ranking) == 0x000020, "Member 'FCustomMatchResultTeamData::_ranking' has a wrong offset!");
static_assert(offsetof(FCustomMatchResultTeamData, _playerList) == 0x000028, "Member 'FCustomMatchResultTeamData::_playerList' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataPhaseTopData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerDataPhaseTopData final
{
public:
	uint8                                         _playerIdx;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _value;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataPhaseTopData) == 0x000004, "Wrong alignment on FPlayerDataPhaseTopData");
static_assert(sizeof(FPlayerDataPhaseTopData) == 0x000008, "Wrong size on FPlayerDataPhaseTopData");
static_assert(offsetof(FPlayerDataPhaseTopData, _playerIdx) == 0x000000, "Member 'FPlayerDataPhaseTopData::_playerIdx' has a wrong offset!");
static_assert(offsetof(FPlayerDataPhaseTopData, _value) == 0x000004, "Member 'FPlayerDataPhaseTopData::_value' has a wrong offset!");

// ScriptStruct GameModule.TrainingCharacterData
// 0x0018 (0x0018 - 0x0000)
struct FTrainingCharacterData
{
public:
	ECharacterId                                  _characterId;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _aiActionIndex;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _technique1Level;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _technique2Level;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _technique3Level;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _skillVariationCode;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainingCharacterData) == 0x000004, "Wrong alignment on FTrainingCharacterData");
static_assert(sizeof(FTrainingCharacterData) == 0x000018, "Wrong size on FTrainingCharacterData");
static_assert(offsetof(FTrainingCharacterData, _characterId) == 0x000000, "Member 'FTrainingCharacterData::_characterId' has a wrong offset!");
static_assert(offsetof(FTrainingCharacterData, _aiActionIndex) == 0x000004, "Member 'FTrainingCharacterData::_aiActionIndex' has a wrong offset!");
static_assert(offsetof(FTrainingCharacterData, _technique1Level) == 0x000008, "Member 'FTrainingCharacterData::_technique1Level' has a wrong offset!");
static_assert(offsetof(FTrainingCharacterData, _technique2Level) == 0x00000C, "Member 'FTrainingCharacterData::_technique2Level' has a wrong offset!");
static_assert(offsetof(FTrainingCharacterData, _technique3Level) == 0x000010, "Member 'FTrainingCharacterData::_technique3Level' has a wrong offset!");
static_assert(offsetof(FTrainingCharacterData, _skillVariationCode) == 0x000014, "Member 'FTrainingCharacterData::_skillVariationCode' has a wrong offset!");

// ScriptStruct GameModule.ContactInvitedData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FContactInvitedData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContactInvitedData) == 0x000008, "Wrong alignment on FContactInvitedData");
static_assert(sizeof(FContactInvitedData) == 0x000050, "Wrong size on FContactInvitedData");

// ScriptStruct GameModule.AvatarCreateSliderData
// 0x0010 (0x0010 - 0x0000)
struct FAvatarCreateSliderData final
{
public:
	float                                         _value;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _min;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _max;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _stepSize;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvatarCreateSliderData) == 0x000004, "Wrong alignment on FAvatarCreateSliderData");
static_assert(sizeof(FAvatarCreateSliderData) == 0x000010, "Wrong size on FAvatarCreateSliderData");
static_assert(offsetof(FAvatarCreateSliderData, _value) == 0x000000, "Member 'FAvatarCreateSliderData::_value' has a wrong offset!");
static_assert(offsetof(FAvatarCreateSliderData, _min) == 0x000004, "Member 'FAvatarCreateSliderData::_min' has a wrong offset!");
static_assert(offsetof(FAvatarCreateSliderData, _max) == 0x000008, "Member 'FAvatarCreateSliderData::_max' has a wrong offset!");
static_assert(offsetof(FAvatarCreateSliderData, _stepSize) == 0x00000C, "Member 'FAvatarCreateSliderData::_stepSize' has a wrong offset!");

// ScriptStruct GameModule.GeneralDataRep
// 0x0020 (0x0020 - 0x0000)
struct FGeneralDataRep final
{
public:
	class AActor*                                 TargetCharacter;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        GenID;                                             // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Type;                                              // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipOwner;                                         // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Bytes;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralDataRep) == 0x000008, "Wrong alignment on FGeneralDataRep");
static_assert(sizeof(FGeneralDataRep) == 0x000020, "Wrong size on FGeneralDataRep");
static_assert(offsetof(FGeneralDataRep, TargetCharacter) == 0x000000, "Member 'FGeneralDataRep::TargetCharacter' has a wrong offset!");
static_assert(offsetof(FGeneralDataRep, GenID) == 0x000008, "Member 'FGeneralDataRep::GenID' has a wrong offset!");
static_assert(offsetof(FGeneralDataRep, Type) == 0x00000A, "Member 'FGeneralDataRep::Type' has a wrong offset!");
static_assert(offsetof(FGeneralDataRep, SkipOwner) == 0x00000B, "Member 'FGeneralDataRep::SkipOwner' has a wrong offset!");
static_assert(offsetof(FGeneralDataRep, Bytes) == 0x000010, "Member 'FGeneralDataRep::Bytes' has a wrong offset!");

// ScriptStruct GameModule.MuteButtonParam
// 0x04C8 (0x04C8 - 0x0000)
struct FMuteButtonParam final
{
public:
	class UCanvasPanel*                           Panel;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlatformWidgetButton*                  Button;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDbSquadMemberParam                    PlayerParam;                                       // 0x0010(0x0498)(NativeAccessSpecifierPublic)
	class FString                                 PlayerId;                                          // 0x04A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAdjustTextWidget*                      Text;                                              // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChatMuteIcon*                          Icon;                                              // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMuteButtonParam) == 0x000008, "Wrong alignment on FMuteButtonParam");
static_assert(sizeof(FMuteButtonParam) == 0x0004C8, "Wrong size on FMuteButtonParam");
static_assert(offsetof(FMuteButtonParam, Panel) == 0x000000, "Member 'FMuteButtonParam::Panel' has a wrong offset!");
static_assert(offsetof(FMuteButtonParam, Button) == 0x000008, "Member 'FMuteButtonParam::Button' has a wrong offset!");
static_assert(offsetof(FMuteButtonParam, PlayerParam) == 0x000010, "Member 'FMuteButtonParam::PlayerParam' has a wrong offset!");
static_assert(offsetof(FMuteButtonParam, PlayerId) == 0x0004A8, "Member 'FMuteButtonParam::PlayerId' has a wrong offset!");
static_assert(offsetof(FMuteButtonParam, Text) == 0x0004B8, "Member 'FMuteButtonParam::Text' has a wrong offset!");
static_assert(offsetof(FMuteButtonParam, Icon) == 0x0004C0, "Member 'FMuteButtonParam::Icon' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataActivityStatus
// 0x0020 (0x0020 - 0x0000)
struct FPlayerDataActivityStatus final
{
public:
	int32                                         _damage;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _lifeTime;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _levelUpCount;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _getItemCount;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _itemSupportCount;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _citizenSupportCount;                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _rescuePlayerCount;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _plusUltraCount;                                   // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataActivityStatus) == 0x000004, "Wrong alignment on FPlayerDataActivityStatus");
static_assert(sizeof(FPlayerDataActivityStatus) == 0x000020, "Wrong size on FPlayerDataActivityStatus");
static_assert(offsetof(FPlayerDataActivityStatus, _damage) == 0x000000, "Member 'FPlayerDataActivityStatus::_damage' has a wrong offset!");
static_assert(offsetof(FPlayerDataActivityStatus, _lifeTime) == 0x000004, "Member 'FPlayerDataActivityStatus::_lifeTime' has a wrong offset!");
static_assert(offsetof(FPlayerDataActivityStatus, _levelUpCount) == 0x000008, "Member 'FPlayerDataActivityStatus::_levelUpCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataActivityStatus, _getItemCount) == 0x00000C, "Member 'FPlayerDataActivityStatus::_getItemCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataActivityStatus, _itemSupportCount) == 0x000010, "Member 'FPlayerDataActivityStatus::_itemSupportCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataActivityStatus, _citizenSupportCount) == 0x000014, "Member 'FPlayerDataActivityStatus::_citizenSupportCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataActivityStatus, _rescuePlayerCount) == 0x000018, "Member 'FPlayerDataActivityStatus::_rescuePlayerCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataActivityStatus, _plusUltraCount) == 0x00001C, "Member 'FPlayerDataActivityStatus::_plusUltraCount' has a wrong offset!");

// ScriptStruct GameModule.CustomMatchResultData
// 0x0018 (0x0018 - 0x0000)
struct FCustomMatchResultData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomMatchResultTeamData>     _teamList;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomMatchResultData) == 0x000008, "Wrong alignment on FCustomMatchResultData");
static_assert(sizeof(FCustomMatchResultData) == 0x000018, "Wrong size on FCustomMatchResultData");
static_assert(offsetof(FCustomMatchResultData, _teamList) == 0x000008, "Member 'FCustomMatchResultData::_teamList' has a wrong offset!");

// ScriptStruct GameModule.BulletSE
// 0x0020 (0x0020 - 0x0000)
struct FBulletSE final
{
public:
	class FString                                 SoundAtomCueName;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletSE) == 0x000008, "Wrong alignment on FBulletSE");
static_assert(sizeof(FBulletSE) == 0x000020, "Wrong size on FBulletSE");
static_assert(offsetof(FBulletSE, SoundAtomCueName) == 0x000000, "Member 'FBulletSE::SoundAtomCueName' has a wrong offset!");
static_assert(offsetof(FBulletSE, VolumeMultiplier) == 0x000010, "Member 'FBulletSE::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(FBulletSE, PitchMultiplier) == 0x000014, "Member 'FBulletSE::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(FBulletSE, Attached) == 0x000018, "Member 'FBulletSE::Attached' has a wrong offset!");

// ScriptStruct GameModule.AvatarCharaCustomParam
// 0x0020 (0x0020 - 0x0000)
struct FAvatarCharaCustomParam final
{
public:
	float                                         _bodyScale;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _bodyPhysique;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _mouthType;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _faceContourType;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _assignType;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _battleStyleCode;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bMaleFlag;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bChangedEyesColorFlag;                            // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _voiceCode;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvatarCharaCustomParam) == 0x000004, "Wrong alignment on FAvatarCharaCustomParam");
static_assert(sizeof(FAvatarCharaCustomParam) == 0x000020, "Wrong size on FAvatarCharaCustomParam");
static_assert(offsetof(FAvatarCharaCustomParam, _bodyScale) == 0x000000, "Member 'FAvatarCharaCustomParam::_bodyScale' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _bodyPhysique) == 0x000004, "Member 'FAvatarCharaCustomParam::_bodyPhysique' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _mouthType) == 0x000008, "Member 'FAvatarCharaCustomParam::_mouthType' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _faceContourType) == 0x00000C, "Member 'FAvatarCharaCustomParam::_faceContourType' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _assignType) == 0x000010, "Member 'FAvatarCharaCustomParam::_assignType' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _battleStyleCode) == 0x000014, "Member 'FAvatarCharaCustomParam::_battleStyleCode' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _bMaleFlag) == 0x000018, "Member 'FAvatarCharaCustomParam::_bMaleFlag' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _bChangedEyesColorFlag) == 0x000019, "Member 'FAvatarCharaCustomParam::_bChangedEyesColorFlag' has a wrong offset!");
static_assert(offsetof(FAvatarCharaCustomParam, _voiceCode) == 0x00001C, "Member 'FAvatarCharaCustomParam::_voiceCode' has a wrong offset!");

// ScriptStruct GameModule.DropItemParamInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDropItemParamInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _category;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _code;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _num;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _dropType;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropItemParamInfo) == 0x000008, "Wrong alignment on FDropItemParamInfo");
static_assert(sizeof(FDropItemParamInfo) == 0x000018, "Wrong size on FDropItemParamInfo");
static_assert(offsetof(FDropItemParamInfo, _category) == 0x000008, "Member 'FDropItemParamInfo::_category' has a wrong offset!");
static_assert(offsetof(FDropItemParamInfo, _code) == 0x00000C, "Member 'FDropItemParamInfo::_code' has a wrong offset!");
static_assert(offsetof(FDropItemParamInfo, _num) == 0x000010, "Member 'FDropItemParamInfo::_num' has a wrong offset!");
static_assert(offsetof(FDropItemParamInfo, _dropType) == 0x000014, "Member 'FDropItemParamInfo::_dropType' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataPhaseData
// 0x0020 (0x0020 - 0x0000)
struct FPlayerDataPhaseData final
{
public:
	struct FPlayerDataPhaseTopData                _topDamage;                                        // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerDataPhaseTopData                _topKO;                                            // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerDataPhaseTopData                _topCitizenAction;                                 // 0x0010(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerDataPhaseTopData                _topSupplySupport;                                 // 0x0018(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataPhaseData) == 0x000004, "Wrong alignment on FPlayerDataPhaseData");
static_assert(sizeof(FPlayerDataPhaseData) == 0x000020, "Wrong size on FPlayerDataPhaseData");
static_assert(offsetof(FPlayerDataPhaseData, _topDamage) == 0x000000, "Member 'FPlayerDataPhaseData::_topDamage' has a wrong offset!");
static_assert(offsetof(FPlayerDataPhaseData, _topKO) == 0x000008, "Member 'FPlayerDataPhaseData::_topKO' has a wrong offset!");
static_assert(offsetof(FPlayerDataPhaseData, _topCitizenAction) == 0x000010, "Member 'FPlayerDataPhaseData::_topCitizenAction' has a wrong offset!");
static_assert(offsetof(FPlayerDataPhaseData, _topSupplySupport) == 0x000018, "Member 'FPlayerDataPhaseData::_topSupplySupport' has a wrong offset!");

// ScriptStruct GameModule.ContactDetailData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FContactDetailData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContactDetailData) == 0x000008, "Wrong alignment on FContactDetailData");
static_assert(sizeof(FContactDetailData) == 0x000050, "Wrong size on FContactDetailData");

// ScriptStruct GameModule.PlayerDataCostumeParam
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FPlayerDataCostumeParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _costumeCode;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _auraLevel;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _auraDisplayTarget;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _auraDisplayArea;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataCostumeParam) == 0x000008, "Wrong alignment on FPlayerDataCostumeParam");
static_assert(sizeof(FPlayerDataCostumeParam) == 0x000028, "Wrong size on FPlayerDataCostumeParam");
static_assert(offsetof(FPlayerDataCostumeParam, _costumeCode) == 0x000008, "Member 'FPlayerDataCostumeParam::_costumeCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataCostumeParam, _auraLevel) == 0x00000C, "Member 'FPlayerDataCostumeParam::_auraLevel' has a wrong offset!");
static_assert(offsetof(FPlayerDataCostumeParam, _auraDisplayTarget) == 0x000010, "Member 'FPlayerDataCostumeParam::_auraDisplayTarget' has a wrong offset!");
static_assert(offsetof(FPlayerDataCostumeParam, _auraDisplayArea) == 0x000014, "Member 'FPlayerDataCostumeParam::_auraDisplayArea' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataTeamRankingData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerDataTeamRankingData final
{
public:
	uint8                                         _ranking;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 _teamList;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataTeamRankingData) == 0x000008, "Wrong alignment on FPlayerDataTeamRankingData");
static_assert(sizeof(FPlayerDataTeamRankingData) == 0x000018, "Wrong size on FPlayerDataTeamRankingData");
static_assert(offsetof(FPlayerDataTeamRankingData, _ranking) == 0x000000, "Member 'FPlayerDataTeamRankingData::_ranking' has a wrong offset!");
static_assert(offsetof(FPlayerDataTeamRankingData, _teamList) == 0x000008, "Member 'FPlayerDataTeamRankingData::_teamList' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataPhaseScoreData
// 0x000C (0x000C - 0x0000)
struct FPlayerDataPhaseScoreData final
{
public:
	int32                                         _scoreCode;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _score;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _phase;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataPhaseScoreData) == 0x000004, "Wrong alignment on FPlayerDataPhaseScoreData");
static_assert(sizeof(FPlayerDataPhaseScoreData) == 0x00000C, "Wrong size on FPlayerDataPhaseScoreData");
static_assert(offsetof(FPlayerDataPhaseScoreData, _scoreCode) == 0x000000, "Member 'FPlayerDataPhaseScoreData::_scoreCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataPhaseScoreData, _score) == 0x000004, "Member 'FPlayerDataPhaseScoreData::_score' has a wrong offset!");
static_assert(offsetof(FPlayerDataPhaseScoreData, _phase) == 0x000008, "Member 'FPlayerDataPhaseScoreData::_phase' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataScoreData
// 0x000C (0x000C - 0x0000)
struct FPlayerDataScoreData final
{
public:
	int32                                         _scoreCode;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _calcValue;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _score;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataScoreData) == 0x000004, "Wrong alignment on FPlayerDataScoreData");
static_assert(sizeof(FPlayerDataScoreData) == 0x00000C, "Wrong size on FPlayerDataScoreData");
static_assert(offsetof(FPlayerDataScoreData, _scoreCode) == 0x000000, "Member 'FPlayerDataScoreData::_scoreCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreData, _calcValue) == 0x000004, "Member 'FPlayerDataScoreData::_calcValue' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreData, _score) == 0x000008, "Member 'FPlayerDataScoreData::_score' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataPlayerScoreData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerDataPlayerScoreData final
{
public:
	int32                                         _scoreCode;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerIdx;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _calcValue;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _score;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataPlayerScoreData) == 0x000004, "Wrong alignment on FPlayerDataPlayerScoreData");
static_assert(sizeof(FPlayerDataPlayerScoreData) == 0x000010, "Wrong size on FPlayerDataPlayerScoreData");
static_assert(offsetof(FPlayerDataPlayerScoreData, _scoreCode) == 0x000000, "Member 'FPlayerDataPlayerScoreData::_scoreCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerScoreData, _playerIdx) == 0x000004, "Member 'FPlayerDataPlayerScoreData::_playerIdx' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerScoreData, _calcValue) == 0x000008, "Member 'FPlayerDataPlayerScoreData::_calcValue' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerScoreData, _score) == 0x00000C, "Member 'FPlayerDataPlayerScoreData::_score' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataSupportCountData
// 0x000C (0x000C - 0x0000)
struct FPlayerDataSupportCountData final
{
public:
	int32                                         _scoreCode;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _count;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _rate;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataSupportCountData) == 0x000004, "Wrong alignment on FPlayerDataSupportCountData");
static_assert(sizeof(FPlayerDataSupportCountData) == 0x00000C, "Wrong size on FPlayerDataSupportCountData");
static_assert(offsetof(FPlayerDataSupportCountData, _scoreCode) == 0x000000, "Member 'FPlayerDataSupportCountData::_scoreCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataSupportCountData, _count) == 0x000004, "Member 'FPlayerDataSupportCountData::_count' has a wrong offset!");
static_assert(offsetof(FPlayerDataSupportCountData, _rate) == 0x000008, "Member 'FPlayerDataSupportCountData::_rate' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataSupportScoreData
// 0x0020 (0x0020 - 0x0000)
struct FPlayerDataSupportScoreData final
{
public:
	uint8                                         _playerIdx;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _baseScore;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _score;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerDataSupportCountData>    _supportCountData;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataSupportScoreData) == 0x000008, "Wrong alignment on FPlayerDataSupportScoreData");
static_assert(sizeof(FPlayerDataSupportScoreData) == 0x000020, "Wrong size on FPlayerDataSupportScoreData");
static_assert(offsetof(FPlayerDataSupportScoreData, _playerIdx) == 0x000000, "Member 'FPlayerDataSupportScoreData::_playerIdx' has a wrong offset!");
static_assert(offsetof(FPlayerDataSupportScoreData, _baseScore) == 0x000004, "Member 'FPlayerDataSupportScoreData::_baseScore' has a wrong offset!");
static_assert(offsetof(FPlayerDataSupportScoreData, _score) == 0x000008, "Member 'FPlayerDataSupportScoreData::_score' has a wrong offset!");
static_assert(offsetof(FPlayerDataSupportScoreData, _supportCountData) == 0x000010, "Member 'FPlayerDataSupportScoreData::_supportCountData' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataScoreParam
// 0x0798 (0x0798 - 0x0000)
struct FPlayerDataScoreParam final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bExitPlayer;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _playModeCode;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _gameId;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataPhaseData>           _phaseData;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x618];                                     // 0x0028(0x0618)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         _teamId;                                           // 0x0640(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0xF];                                      // 0x0641(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerDataTeamRankingData>     _teamRanking;                                      // 0x0650(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0x10];                                     // 0x0660(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerDataPlayerRPData>        _rpList;                                           // 0x0670(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         _rank;                                             // 0x0680(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _totalRp;                                          // 0x0684(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataBonusData>           _playerExpBonusList;                               // 0x0688(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataBonusData>           _seasonPassExpBonusList;                           // 0x0698(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataBonusData>           _guildPointBonusList;                              // 0x06A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataBonusData>           _goldBonusList;                                    // 0x06B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniqueNetIdKey>                _playerIdList;                                     // 0x06C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataScoreData>           _scoreData;                                        // 0x06D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataPlayerScoreData>     _playerScoreData;                                  // 0x06E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataPhaseScoreData>      _phaseScoreData;                                   // 0x06F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerDataSupportScoreData>    _supportScoreData;                                 // 0x0708(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_718[0x80];                                     // 0x0718(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataScoreParam) == 0x000008, "Wrong alignment on FPlayerDataScoreParam");
static_assert(sizeof(FPlayerDataScoreParam) == 0x000798, "Wrong size on FPlayerDataScoreParam");
static_assert(offsetof(FPlayerDataScoreParam, _bExitPlayer) == 0x000001, "Member 'FPlayerDataScoreParam::_bExitPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _playModeCode) == 0x000004, "Member 'FPlayerDataScoreParam::_playModeCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _gameId) == 0x000008, "Member 'FPlayerDataScoreParam::_gameId' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _phaseData) == 0x000018, "Member 'FPlayerDataScoreParam::_phaseData' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _teamId) == 0x000640, "Member 'FPlayerDataScoreParam::_teamId' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _teamRanking) == 0x000650, "Member 'FPlayerDataScoreParam::_teamRanking' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _rpList) == 0x000670, "Member 'FPlayerDataScoreParam::_rpList' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _rank) == 0x000680, "Member 'FPlayerDataScoreParam::_rank' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _totalRp) == 0x000684, "Member 'FPlayerDataScoreParam::_totalRp' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _playerExpBonusList) == 0x000688, "Member 'FPlayerDataScoreParam::_playerExpBonusList' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _seasonPassExpBonusList) == 0x000698, "Member 'FPlayerDataScoreParam::_seasonPassExpBonusList' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _guildPointBonusList) == 0x0006A8, "Member 'FPlayerDataScoreParam::_guildPointBonusList' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _goldBonusList) == 0x0006B8, "Member 'FPlayerDataScoreParam::_goldBonusList' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _playerIdList) == 0x0006C8, "Member 'FPlayerDataScoreParam::_playerIdList' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _scoreData) == 0x0006D8, "Member 'FPlayerDataScoreParam::_scoreData' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _playerScoreData) == 0x0006E8, "Member 'FPlayerDataScoreParam::_playerScoreData' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _phaseScoreData) == 0x0006F8, "Member 'FPlayerDataScoreParam::_phaseScoreData' has a wrong offset!");
static_assert(offsetof(FPlayerDataScoreParam, _supportScoreData) == 0x000708, "Member 'FPlayerDataScoreParam::_supportScoreData' has a wrong offset!");

// ScriptStruct GameModule.BattleResultData
// 0x07F8 (0x07F8 - 0x0000)
struct FBattleResultData final
{
public:
	struct FUniqueNetIdKey                        _cosmosUserId;                                     // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _playerName;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _characterCode;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerDataCostumeParam                _costumeParam;                                     // 0x0020(0x0028)(NativeAccessSpecifierPublic)
	uint32                                        _hairId;                                           // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _accessoryIds;                                     // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPlayerDataScoreParam                  _scoreParam;                                       // 0x0060(0x0798)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleResultData) == 0x000008, "Wrong alignment on FBattleResultData");
static_assert(sizeof(FBattleResultData) == 0x0007F8, "Wrong size on FBattleResultData");
static_assert(offsetof(FBattleResultData, _cosmosUserId) == 0x000000, "Member 'FBattleResultData::_cosmosUserId' has a wrong offset!");
static_assert(offsetof(FBattleResultData, _playerName) == 0x000008, "Member 'FBattleResultData::_playerName' has a wrong offset!");
static_assert(offsetof(FBattleResultData, _characterCode) == 0x000018, "Member 'FBattleResultData::_characterCode' has a wrong offset!");
static_assert(offsetof(FBattleResultData, _costumeParam) == 0x000020, "Member 'FBattleResultData::_costumeParam' has a wrong offset!");
static_assert(offsetof(FBattleResultData, _hairId) == 0x000048, "Member 'FBattleResultData::_hairId' has a wrong offset!");
static_assert(offsetof(FBattleResultData, _accessoryIds) == 0x000050, "Member 'FBattleResultData::_accessoryIds' has a wrong offset!");
static_assert(offsetof(FBattleResultData, _scoreParam) == 0x000060, "Member 'FBattleResultData::_scoreParam' has a wrong offset!");

// ScriptStruct GameModule.BriefingCollisionInfo
// 0x0018 (0x0018 - 0x0000)
struct FBriefingCollisionInfo final
{
public:
	class FString                                 _path;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              _size;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBriefingCollisionInfo) == 0x000008, "Wrong alignment on FBriefingCollisionInfo");
static_assert(sizeof(FBriefingCollisionInfo) == 0x000018, "Wrong size on FBriefingCollisionInfo");
static_assert(offsetof(FBriefingCollisionInfo, _path) == 0x000000, "Member 'FBriefingCollisionInfo::_path' has a wrong offset!");
static_assert(offsetof(FBriefingCollisionInfo, _size) == 0x000010, "Member 'FBriefingCollisionInfo::_size' has a wrong offset!");

// ScriptStruct GameModule.BattleRecordData
// 0x0048 (0x0048 - 0x0000)
struct FBattleRecordData final
{
public:
	class FString                                 _name;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _total;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _season;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _unitname;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleRecordSize                             _size;                                             // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleRecordType                             _type;                                             // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleRecordUnitType                         _unittype;                                         // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _truncatePoint;                                    // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleRecordData) == 0x000008, "Wrong alignment on FBattleRecordData");
static_assert(sizeof(FBattleRecordData) == 0x000048, "Wrong size on FBattleRecordData");
static_assert(offsetof(FBattleRecordData, _name) == 0x000000, "Member 'FBattleRecordData::_name' has a wrong offset!");
static_assert(offsetof(FBattleRecordData, _total) == 0x000010, "Member 'FBattleRecordData::_total' has a wrong offset!");
static_assert(offsetof(FBattleRecordData, _season) == 0x000020, "Member 'FBattleRecordData::_season' has a wrong offset!");
static_assert(offsetof(FBattleRecordData, _unitname) == 0x000030, "Member 'FBattleRecordData::_unitname' has a wrong offset!");
static_assert(offsetof(FBattleRecordData, _size) == 0x000040, "Member 'FBattleRecordData::_size' has a wrong offset!");
static_assert(offsetof(FBattleRecordData, _type) == 0x000041, "Member 'FBattleRecordData::_type' has a wrong offset!");
static_assert(offsetof(FBattleRecordData, _unittype) == 0x000042, "Member 'FBattleRecordData::_unittype' has a wrong offset!");
static_assert(offsetof(FBattleRecordData, _truncatePoint) == 0x000043, "Member 'FBattleRecordData::_truncatePoint' has a wrong offset!");

// ScriptStruct GameModule.AvatarCreateMenuData
// 0x00E8 (0x00E8 - 0x0000)
struct FAvatarCreateMenuData final
{
public:
	struct FAvatarCreateSlotTextData              _category;                                         // 0x0000(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAvatarCreateSlotTextData              _selectedItem;                                     // 0x0070(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSoundDiplay;                                      // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvatarCreateMenuData) == 0x000008, "Wrong alignment on FAvatarCreateMenuData");
static_assert(sizeof(FAvatarCreateMenuData) == 0x0000E8, "Wrong size on FAvatarCreateMenuData");
static_assert(offsetof(FAvatarCreateMenuData, _category) == 0x000000, "Member 'FAvatarCreateMenuData::_category' has a wrong offset!");
static_assert(offsetof(FAvatarCreateMenuData, _selectedItem) == 0x000070, "Member 'FAvatarCreateMenuData::_selectedItem' has a wrong offset!");
static_assert(offsetof(FAvatarCreateMenuData, bSoundDiplay) == 0x0000E0, "Member 'FAvatarCreateMenuData::bSoundDiplay' has a wrong offset!");

// ScriptStruct GameModule.ContactListParameters
// 0x00C0 (0x00C0 - 0x0000)
struct FContactListParameters final
{
public:
	class FString                                 _noticeId;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x28];                                      // 0x0010(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _index;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContactListEntryType                         _entryType;                                        // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bRead;                                            // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bPresent;                                         // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _dateForDelivery;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _titleString;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECosmosInviteTarget                           _invitationType;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _userId;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _targetId;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _inviteId;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _squadId;                                          // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContactListParameters) == 0x000008, "Wrong alignment on FContactListParameters");
static_assert(sizeof(FContactListParameters) == 0x0000C0, "Wrong size on FContactListParameters");
static_assert(offsetof(FContactListParameters, _noticeId) == 0x000000, "Member 'FContactListParameters::_noticeId' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _index) == 0x000038, "Member 'FContactListParameters::_index' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _entryType) == 0x00003C, "Member 'FContactListParameters::_entryType' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _bRead) == 0x00003D, "Member 'FContactListParameters::_bRead' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _bPresent) == 0x00003E, "Member 'FContactListParameters::_bPresent' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _dateForDelivery) == 0x000040, "Member 'FContactListParameters::_dateForDelivery' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _titleString) == 0x000048, "Member 'FContactListParameters::_titleString' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _invitationType) == 0x000058, "Member 'FContactListParameters::_invitationType' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _userId) == 0x000060, "Member 'FContactListParameters::_userId' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _targetId) == 0x000070, "Member 'FContactListParameters::_targetId' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _inviteId) == 0x000080, "Member 'FContactListParameters::_inviteId' has a wrong offset!");
static_assert(offsetof(FContactListParameters, _squadId) == 0x000090, "Member 'FContactListParameters::_squadId' has a wrong offset!");

// ScriptStruct GameModule.AbilityArtColorInfo
// 0x0140 (0x0140 - 0x0000)
struct FAbilityArtColorInfo final
{
public:
	struct FSlateColor                            _abilityTypeUIColor;                               // 0x0000(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _uniqueInfoTriangleDarker;                         // 0x0028(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _uniqueInfoBase;                                   // 0x0050(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _cardColorLeftBG;                                  // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _cardColorRightBG;                                 // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            _cardColorDots;                                    // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           _meshColor1;                                       // 0x00F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _meshColor2;                                       // 0x0100(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _meshColor3;                                       // 0x0110(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _particleBaseColor;                                // 0x0120(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _particleLightColor;                               // 0x0130(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityArtColorInfo) == 0x000008, "Wrong alignment on FAbilityArtColorInfo");
static_assert(sizeof(FAbilityArtColorInfo) == 0x000140, "Wrong size on FAbilityArtColorInfo");
static_assert(offsetof(FAbilityArtColorInfo, _abilityTypeUIColor) == 0x000000, "Member 'FAbilityArtColorInfo::_abilityTypeUIColor' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _uniqueInfoTriangleDarker) == 0x000028, "Member 'FAbilityArtColorInfo::_uniqueInfoTriangleDarker' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _uniqueInfoBase) == 0x000050, "Member 'FAbilityArtColorInfo::_uniqueInfoBase' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _cardColorLeftBG) == 0x000078, "Member 'FAbilityArtColorInfo::_cardColorLeftBG' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _cardColorRightBG) == 0x0000A0, "Member 'FAbilityArtColorInfo::_cardColorRightBG' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _cardColorDots) == 0x0000C8, "Member 'FAbilityArtColorInfo::_cardColorDots' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _meshColor1) == 0x0000F0, "Member 'FAbilityArtColorInfo::_meshColor1' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _meshColor2) == 0x000100, "Member 'FAbilityArtColorInfo::_meshColor2' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _meshColor3) == 0x000110, "Member 'FAbilityArtColorInfo::_meshColor3' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _particleBaseColor) == 0x000120, "Member 'FAbilityArtColorInfo::_particleBaseColor' has a wrong offset!");
static_assert(offsetof(FAbilityArtColorInfo, _particleLightColor) == 0x000130, "Member 'FAbilityArtColorInfo::_particleLightColor' has a wrong offset!");

// ScriptStruct GameModule.EffLocateOnlyParticleInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FEffLocateOnlyParticleInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomParticleSystemComponent*         PSC;                                               // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotOffset;                                         // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocateOffset;                                      // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         Mesh;                                              // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EffectRootTransformRot;                            // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EffectRootTransformLocate;                         // 0x0070(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffLocateOnlyParticleInfo) == 0x000010, "Wrong alignment on FEffLocateOnlyParticleInfo");
static_assert(sizeof(FEffLocateOnlyParticleInfo) == 0x0000A0, "Wrong size on FEffLocateOnlyParticleInfo");
static_assert(offsetof(FEffLocateOnlyParticleInfo, Actor) == 0x000000, "Member 'FEffLocateOnlyParticleInfo::Actor' has a wrong offset!");
static_assert(offsetof(FEffLocateOnlyParticleInfo, PSC) == 0x000008, "Member 'FEffLocateOnlyParticleInfo::PSC' has a wrong offset!");
static_assert(offsetof(FEffLocateOnlyParticleInfo, RotOffset) == 0x000010, "Member 'FEffLocateOnlyParticleInfo::RotOffset' has a wrong offset!");
static_assert(offsetof(FEffLocateOnlyParticleInfo, LocateOffset) == 0x00001C, "Member 'FEffLocateOnlyParticleInfo::LocateOffset' has a wrong offset!");
static_assert(offsetof(FEffLocateOnlyParticleInfo, SocketName) == 0x000028, "Member 'FEffLocateOnlyParticleInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FEffLocateOnlyParticleInfo, Mesh) == 0x000030, "Member 'FEffLocateOnlyParticleInfo::Mesh' has a wrong offset!");
static_assert(offsetof(FEffLocateOnlyParticleInfo, EffectRootTransformRot) == 0x000040, "Member 'FEffLocateOnlyParticleInfo::EffectRootTransformRot' has a wrong offset!");
static_assert(offsetof(FEffLocateOnlyParticleInfo, EffectRootTransformLocate) == 0x000070, "Member 'FEffLocateOnlyParticleInfo::EffectRootTransformLocate' has a wrong offset!");

// ScriptStruct GameModule.SelectedCoinData
// 0x0048 (0x0048 - 0x0000)
struct FSelectedCoinData final
{
public:
	ECurrencyType                                 _type;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _needNum;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   _cmdMessage;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            _numColor;                                         // 0x0020(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectedCoinData) == 0x000008, "Wrong alignment on FSelectedCoinData");
static_assert(sizeof(FSelectedCoinData) == 0x000048, "Wrong size on FSelectedCoinData");
static_assert(offsetof(FSelectedCoinData, _type) == 0x000000, "Member 'FSelectedCoinData::_type' has a wrong offset!");
static_assert(offsetof(FSelectedCoinData, _needNum) == 0x000004, "Member 'FSelectedCoinData::_needNum' has a wrong offset!");
static_assert(offsetof(FSelectedCoinData, _cmdMessage) == 0x000008, "Member 'FSelectedCoinData::_cmdMessage' has a wrong offset!");
static_assert(offsetof(FSelectedCoinData, _numColor) == 0x000020, "Member 'FSelectedCoinData::_numColor' has a wrong offset!");

// ScriptStruct GameModule.AvatarCreateCarouselData
// 0x0040 (0x0040 - 0x0000)
struct FAvatarCreateCarouselData final
{
public:
	int32                                         _index;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           _textList;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAnchorData                            _itemAnchor;                                       // 0x0018(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvatarCreateCarouselData) == 0x000008, "Wrong alignment on FAvatarCreateCarouselData");
static_assert(sizeof(FAvatarCreateCarouselData) == 0x000040, "Wrong size on FAvatarCreateCarouselData");
static_assert(offsetof(FAvatarCreateCarouselData, _index) == 0x000000, "Member 'FAvatarCreateCarouselData::_index' has a wrong offset!");
static_assert(offsetof(FAvatarCreateCarouselData, _textList) == 0x000008, "Member 'FAvatarCreateCarouselData::_textList' has a wrong offset!");
static_assert(offsetof(FAvatarCreateCarouselData, _itemAnchor) == 0x000018, "Member 'FAvatarCreateCarouselData::_itemAnchor' has a wrong offset!");

// ScriptStruct GameModule.CharacterAbilityInfo
// 0x0008 (0x0008 - 0x0000)
struct FCharacterAbilityInfo final
{
public:
	ECharacterId                                  _characterId;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterVariation;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAbilityInfo) == 0x000004, "Wrong alignment on FCharacterAbilityInfo");
static_assert(sizeof(FCharacterAbilityInfo) == 0x000008, "Wrong size on FCharacterAbilityInfo");
static_assert(offsetof(FCharacterAbilityInfo, _characterId) == 0x000000, "Member 'FCharacterAbilityInfo::_characterId' has a wrong offset!");
static_assert(offsetof(FCharacterAbilityInfo, _characterVariation) == 0x000004, "Member 'FCharacterAbilityInfo::_characterVariation' has a wrong offset!");

// ScriptStruct GameModule.CharacterSelectData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterSelectData final
{
public:
	TArray<ECharacterId>                          _characterIds;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSelectData) == 0x000008, "Wrong alignment on FCharacterSelectData");
static_assert(sizeof(FCharacterSelectData) == 0x000010, "Wrong size on FCharacterSelectData");
static_assert(offsetof(FCharacterSelectData, _characterIds) == 0x000000, "Member 'FCharacterSelectData::_characterIds' has a wrong offset!");

// ScriptStruct GameModule.PlayerDisplayData
// 0x00C8 (0x00C8 - 0x0000)
struct FPlayerDisplayData final
{
public:
	bool                                          bDisplayOnlineId;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _onlineId;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _name;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHideBattleRecord;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _introduction;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHideIntroduction;                                // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _rank;                                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMasterDataRankExp                     _rankMd;                                           // 0x0048(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         _rankPoint;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _rankProgress;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bMaxRank;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDisplayOnlyRank;                                 // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _level;                                            // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _levelPoint;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMasterDataPlayerExp                   _levelMd;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         _levelProgress;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bMaxLevel;                                        // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDisplayOnlyLevel;                                // 0x00AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterId                                  _characterId;                                      // 0x00AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF[0x1];                                       // 0x00AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _costumeCode;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _auraLevel;                                        // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlreadyFriends;                                   // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _rankNumber;                                       // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _billboardSeasonPoint;                             // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _billboardDailyPoint;                              // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDisplayData) == 0x000008, "Wrong alignment on FPlayerDisplayData");
static_assert(sizeof(FPlayerDisplayData) == 0x0000C8, "Wrong size on FPlayerDisplayData");
static_assert(offsetof(FPlayerDisplayData, bDisplayOnlineId) == 0x000000, "Member 'FPlayerDisplayData::bDisplayOnlineId' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _onlineId) == 0x000008, "Member 'FPlayerDisplayData::_onlineId' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _name) == 0x000018, "Member 'FPlayerDisplayData::_name' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _bHideBattleRecord) == 0x000028, "Member 'FPlayerDisplayData::_bHideBattleRecord' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _introduction) == 0x000030, "Member 'FPlayerDisplayData::_introduction' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _bHideIntroduction) == 0x000040, "Member 'FPlayerDisplayData::_bHideIntroduction' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _rank) == 0x000044, "Member 'FPlayerDisplayData::_rank' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _rankMd) == 0x000048, "Member 'FPlayerDisplayData::_rankMd' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _rankPoint) == 0x000080, "Member 'FPlayerDisplayData::_rankPoint' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _rankProgress) == 0x000084, "Member 'FPlayerDisplayData::_rankProgress' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _bMaxRank) == 0x000088, "Member 'FPlayerDisplayData::_bMaxRank' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _bDisplayOnlyRank) == 0x000089, "Member 'FPlayerDisplayData::_bDisplayOnlyRank' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _level) == 0x00008C, "Member 'FPlayerDisplayData::_level' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _levelPoint) == 0x000090, "Member 'FPlayerDisplayData::_levelPoint' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _levelMd) == 0x000098, "Member 'FPlayerDisplayData::_levelMd' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _levelProgress) == 0x0000A8, "Member 'FPlayerDisplayData::_levelProgress' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _bMaxLevel) == 0x0000AC, "Member 'FPlayerDisplayData::_bMaxLevel' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _bDisplayOnlyLevel) == 0x0000AD, "Member 'FPlayerDisplayData::_bDisplayOnlyLevel' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _characterId) == 0x0000AE, "Member 'FPlayerDisplayData::_characterId' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _costumeCode) == 0x0000B0, "Member 'FPlayerDisplayData::_costumeCode' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _auraLevel) == 0x0000B4, "Member 'FPlayerDisplayData::_auraLevel' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, bAlreadyFriends) == 0x0000B8, "Member 'FPlayerDisplayData::bAlreadyFriends' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _rankNumber) == 0x0000BC, "Member 'FPlayerDisplayData::_rankNumber' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _billboardSeasonPoint) == 0x0000C0, "Member 'FPlayerDisplayData::_billboardSeasonPoint' has a wrong offset!");
static_assert(offsetof(FPlayerDisplayData, _billboardDailyPoint) == 0x0000C4, "Member 'FPlayerDisplayData::_billboardDailyPoint' has a wrong offset!");

// ScriptStruct GameModule.AvatarCreateVoiceData
// 0x0008 (0x0008 - 0x0000)
struct FAvatarCreateVoiceData final
{
public:
	ECharacterAssign                              _assign;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bMale;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _voiceCode;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvatarCreateVoiceData) == 0x000004, "Wrong alignment on FAvatarCreateVoiceData");
static_assert(sizeof(FAvatarCreateVoiceData) == 0x000008, "Wrong size on FAvatarCreateVoiceData");
static_assert(offsetof(FAvatarCreateVoiceData, _assign) == 0x000000, "Member 'FAvatarCreateVoiceData::_assign' has a wrong offset!");
static_assert(offsetof(FAvatarCreateVoiceData, _bMale) == 0x000001, "Member 'FAvatarCreateVoiceData::_bMale' has a wrong offset!");
static_assert(offsetof(FAvatarCreateVoiceData, _voiceCode) == 0x000004, "Member 'FAvatarCreateVoiceData::_voiceCode' has a wrong offset!");

// ScriptStruct GameModule.AvatarColorPaletteData
// 0x002C (0x002C - 0x0000)
struct FAvatarColorPaletteData final
{
public:
	EAvatarDetailedAppearanceColorSettingItem     _type;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnchorData                            _itemAnchor;                                       // 0x0004(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvatarColorPaletteData) == 0x000004, "Wrong alignment on FAvatarColorPaletteData");
static_assert(sizeof(FAvatarColorPaletteData) == 0x00002C, "Wrong size on FAvatarColorPaletteData");
static_assert(offsetof(FAvatarColorPaletteData, _type) == 0x000000, "Member 'FAvatarColorPaletteData::_type' has a wrong offset!");
static_assert(offsetof(FAvatarColorPaletteData, _itemAnchor) == 0x000004, "Member 'FAvatarColorPaletteData::_itemAnchor' has a wrong offset!");

// ScriptStruct GameModule.AbilityDataTable
// 0x0010 (0x0018 - 0x0008)
struct FAbilityDataTable final : public FTableRowBase
{
public:
	EMdAbilityType                                _type;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 _color;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _time;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityDataTable) == 0x000008, "Wrong alignment on FAbilityDataTable");
static_assert(sizeof(FAbilityDataTable) == 0x000018, "Wrong size on FAbilityDataTable");
static_assert(offsetof(FAbilityDataTable, _type) == 0x000008, "Member 'FAbilityDataTable::_type' has a wrong offset!");
static_assert(offsetof(FAbilityDataTable, _color) == 0x00000C, "Member 'FAbilityDataTable::_color' has a wrong offset!");
static_assert(offsetof(FAbilityDataTable, _time) == 0x000010, "Member 'FAbilityDataTable::_time' has a wrong offset!");

// ScriptStruct GameModule.VariationAnimTable
// 0x0010 (0x0010 - 0x0000)
struct FVariationAnimTable final
{
public:
	TArray<class UDataTable*>                     _variationAnimTables;                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVariationAnimTable) == 0x000008, "Wrong alignment on FVariationAnimTable");
static_assert(sizeof(FVariationAnimTable) == 0x000010, "Wrong size on FVariationAnimTable");
static_assert(offsetof(FVariationAnimTable, _variationAnimTables) == 0x000000, "Member 'FVariationAnimTable::_variationAnimTables' has a wrong offset!");

// ScriptStruct GameModule.PossessedCoinData
// 0x0008 (0x0008 - 0x0000)
struct FPossessedCoinData final
{
public:
	int32                                         _type;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _num;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPossessedCoinData) == 0x000004, "Wrong alignment on FPossessedCoinData");
static_assert(sizeof(FPossessedCoinData) == 0x000008, "Wrong size on FPossessedCoinData");
static_assert(offsetof(FPossessedCoinData, _type) == 0x000000, "Member 'FPossessedCoinData::_type' has a wrong offset!");
static_assert(offsetof(FPossessedCoinData, _num) == 0x000004, "Member 'FPossessedCoinData::_num' has a wrong offset!");

// ScriptStruct GameModule.ContactNoticeDisplayParameters
// 0x0048 (0x0048 - 0x0000)
struct FContactNoticeDisplayParameters final
{
public:
	int32                                         _pageCount;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _totalPageCount;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FContactListParameters>         _invitationListParams;                             // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FContactInvitedData>            _contactInvitedData;                               // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FContactDetailData>             _ontactDetailData;                                 // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FContactDetailData>             _contactAllGetData;                                // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContactNoticeDisplayParameters) == 0x000008, "Wrong alignment on FContactNoticeDisplayParameters");
static_assert(sizeof(FContactNoticeDisplayParameters) == 0x000048, "Wrong size on FContactNoticeDisplayParameters");
static_assert(offsetof(FContactNoticeDisplayParameters, _pageCount) == 0x000000, "Member 'FContactNoticeDisplayParameters::_pageCount' has a wrong offset!");
static_assert(offsetof(FContactNoticeDisplayParameters, _totalPageCount) == 0x000004, "Member 'FContactNoticeDisplayParameters::_totalPageCount' has a wrong offset!");
static_assert(offsetof(FContactNoticeDisplayParameters, _invitationListParams) == 0x000008, "Member 'FContactNoticeDisplayParameters::_invitationListParams' has a wrong offset!");
static_assert(offsetof(FContactNoticeDisplayParameters, _contactInvitedData) == 0x000018, "Member 'FContactNoticeDisplayParameters::_contactInvitedData' has a wrong offset!");
static_assert(offsetof(FContactNoticeDisplayParameters, _ontactDetailData) == 0x000028, "Member 'FContactNoticeDisplayParameters::_ontactDetailData' has a wrong offset!");
static_assert(offsetof(FContactNoticeDisplayParameters, _contactAllGetData) == 0x000038, "Member 'FContactNoticeDisplayParameters::_contactAllGetData' has a wrong offset!");

// ScriptStruct GameModule.TrainingBattleCharacterData
// 0x0028 (0x0040 - 0x0018)
struct FTrainingBattleCharacterData final : public FTrainingCharacterData
{
public:
	int32                                         _costumeCode;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _costumeAuraType;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 _emoteCodes;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 _voiceCodes;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainingBattleCharacterData) == 0x000008, "Wrong alignment on FTrainingBattleCharacterData");
static_assert(sizeof(FTrainingBattleCharacterData) == 0x000040, "Wrong size on FTrainingBattleCharacterData");
static_assert(offsetof(FTrainingBattleCharacterData, _costumeCode) == 0x000018, "Member 'FTrainingBattleCharacterData::_costumeCode' has a wrong offset!");
static_assert(offsetof(FTrainingBattleCharacterData, _costumeAuraType) == 0x00001C, "Member 'FTrainingBattleCharacterData::_costumeAuraType' has a wrong offset!");
static_assert(offsetof(FTrainingBattleCharacterData, _emoteCodes) == 0x000020, "Member 'FTrainingBattleCharacterData::_emoteCodes' has a wrong offset!");
static_assert(offsetof(FTrainingBattleCharacterData, _voiceCodes) == 0x000030, "Member 'FTrainingBattleCharacterData::_voiceCodes' has a wrong offset!");

// ScriptStruct GameModule.ItemGetListItemParam
// 0x0014 (0x0014 - 0x0000)
struct FItemGetListItemParam final
{
public:
	int32                                         _itemCode;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _itemCategory;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 _itemCategoryEnum;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _itemCount;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _bgType;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemGetListItemParam) == 0x000004, "Wrong alignment on FItemGetListItemParam");
static_assert(sizeof(FItemGetListItemParam) == 0x000014, "Wrong size on FItemGetListItemParam");
static_assert(offsetof(FItemGetListItemParam, _itemCode) == 0x000000, "Member 'FItemGetListItemParam::_itemCode' has a wrong offset!");
static_assert(offsetof(FItemGetListItemParam, _itemCategory) == 0x000004, "Member 'FItemGetListItemParam::_itemCategory' has a wrong offset!");
static_assert(offsetof(FItemGetListItemParam, _itemCategoryEnum) == 0x000008, "Member 'FItemGetListItemParam::_itemCategoryEnum' has a wrong offset!");
static_assert(offsetof(FItemGetListItemParam, _itemCount) == 0x00000C, "Member 'FItemGetListItemParam::_itemCount' has a wrong offset!");
static_assert(offsetof(FItemGetListItemParam, _bgType) == 0x000010, "Member 'FItemGetListItemParam::_bgType' has a wrong offset!");

// ScriptStruct GameModule.ItemGetListParam
// 0x0030 (0x0030 - 0x0000)
struct FItemGetListParam final
{
public:
	class FText                                   _name;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FItemGetListItemParam>          _list;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         _bgNo;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemGetListParam) == 0x000008, "Wrong alignment on FItemGetListParam");
static_assert(sizeof(FItemGetListParam) == 0x000030, "Wrong size on FItemGetListParam");
static_assert(offsetof(FItemGetListParam, _name) == 0x000000, "Member 'FItemGetListParam::_name' has a wrong offset!");
static_assert(offsetof(FItemGetListParam, _list) == 0x000018, "Member 'FItemGetListParam::_list' has a wrong offset!");
static_assert(offsetof(FItemGetListParam, _bgNo) == 0x000028, "Member 'FItemGetListParam::_bgNo' has a wrong offset!");

// ScriptStruct GameModule.DebugGameRuleListParams
// 0x0010 (0x0010 - 0x0000)
struct FDebugGameRuleListParams final
{
public:
	int32                                         _index;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _numberOfPeople;                                   // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayModeModeCategory                         _category;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMdGameMode                                   _gameModeTypes;                                    // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _stageIndex;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugGameRuleListParams) == 0x000004, "Wrong alignment on FDebugGameRuleListParams");
static_assert(sizeof(FDebugGameRuleListParams) == 0x000010, "Wrong size on FDebugGameRuleListParams");
static_assert(offsetof(FDebugGameRuleListParams, _index) == 0x000000, "Member 'FDebugGameRuleListParams::_index' has a wrong offset!");
static_assert(offsetof(FDebugGameRuleListParams, _numberOfPeople) == 0x000004, "Member 'FDebugGameRuleListParams::_numberOfPeople' has a wrong offset!");
static_assert(offsetof(FDebugGameRuleListParams, _category) == 0x000008, "Member 'FDebugGameRuleListParams::_category' has a wrong offset!");
static_assert(offsetof(FDebugGameRuleListParams, _gameModeTypes) == 0x000009, "Member 'FDebugGameRuleListParams::_gameModeTypes' has a wrong offset!");
static_assert(offsetof(FDebugGameRuleListParams, _stageIndex) == 0x00000C, "Member 'FDebugGameRuleListParams::_stageIndex' has a wrong offset!");

// ScriptStruct GameModule.CustomizeFetchParam
// 0x0004 (0x0004 - 0x0000)
struct FCustomizeFetchParam final
{
public:
	bool                                          _bCostume;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bVoice;                                           // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEmote;                                           // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEmblem;                                          // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizeFetchParam) == 0x000001, "Wrong alignment on FCustomizeFetchParam");
static_assert(sizeof(FCustomizeFetchParam) == 0x000004, "Wrong size on FCustomizeFetchParam");
static_assert(offsetof(FCustomizeFetchParam, _bCostume) == 0x000000, "Member 'FCustomizeFetchParam::_bCostume' has a wrong offset!");
static_assert(offsetof(FCustomizeFetchParam, _bVoice) == 0x000001, "Member 'FCustomizeFetchParam::_bVoice' has a wrong offset!");
static_assert(offsetof(FCustomizeFetchParam, _bEmote) == 0x000002, "Member 'FCustomizeFetchParam::_bEmote' has a wrong offset!");
static_assert(offsetof(FCustomizeFetchParam, _bEmblem) == 0x000003, "Member 'FCustomizeFetchParam::_bEmblem' has a wrong offset!");

// ScriptStruct GameModule.GashaPickupData
// 0x0010 (0x0010 - 0x0000)
struct FGashaPickupData final
{
public:
	ECharacterId                                  _characterId;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _itemCode;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 _itemCategory;                                     // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _exChangePoint;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGashaPickupData) == 0x000004, "Wrong alignment on FGashaPickupData");
static_assert(sizeof(FGashaPickupData) == 0x000010, "Wrong size on FGashaPickupData");
static_assert(offsetof(FGashaPickupData, _characterId) == 0x000000, "Member 'FGashaPickupData::_characterId' has a wrong offset!");
static_assert(offsetof(FGashaPickupData, _itemCode) == 0x000004, "Member 'FGashaPickupData::_itemCode' has a wrong offset!");
static_assert(offsetof(FGashaPickupData, _itemCategory) == 0x000008, "Member 'FGashaPickupData::_itemCategory' has a wrong offset!");
static_assert(offsetof(FGashaPickupData, _exChangePoint) == 0x00000C, "Member 'FGashaPickupData::_exChangePoint' has a wrong offset!");

// ScriptStruct GameModule.GashaPushData
// 0x0038 (0x0038 - 0x0000)
struct FGashaPushData final
{
public:
	class FString                                 _paymentId;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bIsPush;                                          // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _itemCode;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 _itemCategory;                                     // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _price;                                            // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _itemNum;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _currentMileage;                                   // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _mileage;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bSingle;                                          // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _paymentIndex;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGashaPushData) == 0x000008, "Wrong alignment on FGashaPushData");
static_assert(sizeof(FGashaPushData) == 0x000038, "Wrong size on FGashaPushData");
static_assert(offsetof(FGashaPushData, _paymentId) == 0x000000, "Member 'FGashaPushData::_paymentId' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _bIsPush) == 0x000010, "Member 'FGashaPushData::_bIsPush' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _itemCode) == 0x000014, "Member 'FGashaPushData::_itemCode' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _itemCategory) == 0x000018, "Member 'FGashaPushData::_itemCategory' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _price) == 0x00001C, "Member 'FGashaPushData::_price' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _itemNum) == 0x000020, "Member 'FGashaPushData::_itemNum' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _currentMileage) == 0x000024, "Member 'FGashaPushData::_currentMileage' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _mileage) == 0x000028, "Member 'FGashaPushData::_mileage' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _bSingle) == 0x00002C, "Member 'FGashaPushData::_bSingle' has a wrong offset!");
static_assert(offsetof(FGashaPushData, _paymentIndex) == 0x000030, "Member 'FGashaPushData::_paymentIndex' has a wrong offset!");

// ScriptStruct GameModule.GashaInfoData
// 0x00C8 (0x00C8 - 0x0000)
struct FGashaInfoData final
{
public:
	class FText                                   _gashaName;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         _gashaCode;                                        // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELotteryLotteryType                           _gashaType;                                        // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGashaPushData>                 _paymentInfos;                                     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGashaPickupData>               _pickupCharas;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGashaPickupData>               _otherPickups;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 _assetName;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _bannerAssetName;                                  // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _currentMileage;                                   // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxStep;                                          // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            _mileageCodeList;                                  // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGashaInfoData) == 0x000008, "Wrong alignment on FGashaInfoData");
static_assert(sizeof(FGashaInfoData) == 0x0000C8, "Wrong size on FGashaInfoData");
static_assert(offsetof(FGashaInfoData, _gashaName) == 0x000000, "Member 'FGashaInfoData::_gashaName' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _gashaCode) == 0x000018, "Member 'FGashaInfoData::_gashaCode' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _gashaType) == 0x00001C, "Member 'FGashaInfoData::_gashaType' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _paymentInfos) == 0x000020, "Member 'FGashaInfoData::_paymentInfos' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _pickupCharas) == 0x000030, "Member 'FGashaInfoData::_pickupCharas' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _otherPickups) == 0x000040, "Member 'FGashaInfoData::_otherPickups' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _assetName) == 0x000050, "Member 'FGashaInfoData::_assetName' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _bannerAssetName) == 0x000060, "Member 'FGashaInfoData::_bannerAssetName' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _currentMileage) == 0x000070, "Member 'FGashaInfoData::_currentMileage' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _maxStep) == 0x000074, "Member 'FGashaInfoData::_maxStep' has a wrong offset!");
static_assert(offsetof(FGashaInfoData, _mileageCodeList) == 0x000078, "Member 'FGashaInfoData::_mileageCodeList' has a wrong offset!");

// ScriptStruct GameModule.DelaySpawnReplicateTestRep
// 0x0001 (0x0001 - 0x0000)
struct FDelaySpawnReplicateTestRep final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelaySpawnReplicateTestRep) == 0x000001, "Wrong alignment on FDelaySpawnReplicateTestRep");
static_assert(sizeof(FDelaySpawnReplicateTestRep) == 0x000001, "Wrong size on FDelaySpawnReplicateTestRep");

// ScriptStruct GameModule.RestorationGeneratorDataImpl
// 0x0034 (0x0034 - 0x0000)
struct FRestorationGeneratorDataImpl final
{
public:
	struct FVector                                _locate;                                           // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _scale;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _rotate;                                           // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _DBHash;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _state;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        _genID;                                            // 0x002C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        _charaId;                                          // 0x002E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _level;                                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _playerId;                                         // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRestorationGeneratorDataImpl) == 0x000004, "Wrong alignment on FRestorationGeneratorDataImpl");
static_assert(sizeof(FRestorationGeneratorDataImpl) == 0x000034, "Wrong size on FRestorationGeneratorDataImpl");
static_assert(offsetof(FRestorationGeneratorDataImpl, _locate) == 0x000000, "Member 'FRestorationGeneratorDataImpl::_locate' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _scale) == 0x00000C, "Member 'FRestorationGeneratorDataImpl::_scale' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _rotate) == 0x000018, "Member 'FRestorationGeneratorDataImpl::_rotate' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _DBHash) == 0x000024, "Member 'FRestorationGeneratorDataImpl::_DBHash' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _state) == 0x000028, "Member 'FRestorationGeneratorDataImpl::_state' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _genID) == 0x00002C, "Member 'FRestorationGeneratorDataImpl::_genID' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _charaId) == 0x00002E, "Member 'FRestorationGeneratorDataImpl::_charaId' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _level) == 0x000030, "Member 'FRestorationGeneratorDataImpl::_level' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorDataImpl, _playerId) == 0x000031, "Member 'FRestorationGeneratorDataImpl::_playerId' has a wrong offset!");

// ScriptStruct GameModule.RestorationGeneratorRep
// 0x0D04 (0x0D04 - 0x0000)
struct FRestorationGeneratorRep final
{
public:
	struct FRestorationGeneratorDataImpl          Data[0x40];                                        // 0x0000(0x0034)(NoDestructor, NativeAccessSpecifierPublic)
	uint32                                        Size;                                              // 0x0D00(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRestorationGeneratorRep) == 0x000004, "Wrong alignment on FRestorationGeneratorRep");
static_assert(sizeof(FRestorationGeneratorRep) == 0x000D04, "Wrong size on FRestorationGeneratorRep");
static_assert(offsetof(FRestorationGeneratorRep, Data) == 0x000000, "Member 'FRestorationGeneratorRep::Data' has a wrong offset!");
static_assert(offsetof(FRestorationGeneratorRep, Size) == 0x000D00, "Member 'FRestorationGeneratorRep::Size' has a wrong offset!");

// ScriptStruct GameModule.StateRep
// 0x000C (0x000C - 0x0000)
struct FStateRep final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SerialID;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GenID;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateRep) == 0x000004, "Wrong alignment on FStateRep");
static_assert(sizeof(FStateRep) == 0x00000C, "Wrong size on FStateRep");
static_assert(offsetof(FStateRep, State) == 0x000000, "Member 'FStateRep::State' has a wrong offset!");
static_assert(offsetof(FStateRep, SerialID) == 0x000004, "Member 'FStateRep::SerialID' has a wrong offset!");
static_assert(offsetof(FStateRep, GenID) == 0x000008, "Member 'FStateRep::GenID' has a wrong offset!");

// ScriptStruct GameModule.DestroyGeneratorRep
// 0x0008 (0x0008 - 0x0000)
struct FDestroyGeneratorRep final
{
public:
	uint8                                         SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GenID;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestroyGeneratorRep) == 0x000004, "Wrong alignment on FDestroyGeneratorRep");
static_assert(sizeof(FDestroyGeneratorRep) == 0x000008, "Wrong size on FDestroyGeneratorRep");
static_assert(offsetof(FDestroyGeneratorRep, SerialID) == 0x000000, "Member 'FDestroyGeneratorRep::SerialID' has a wrong offset!");
static_assert(offsetof(FDestroyGeneratorRep, GenID) == 0x000004, "Member 'FDestroyGeneratorRep::GenID' has a wrong offset!");

// ScriptStruct GameModule.DestroyBulletRepImpl
// 0x0020 (0x0020 - 0x0000)
struct FDestroyBulletRepImpl final
{
public:
	uint8                                         SerialID;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetCharacter;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenID;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        bulletIdx;                                         // 0x0014(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletDestroyType                            DestroyType;                                       // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Timestamp;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestroyBulletRepImpl) == 0x000008, "Wrong alignment on FDestroyBulletRepImpl");
static_assert(sizeof(FDestroyBulletRepImpl) == 0x000020, "Wrong size on FDestroyBulletRepImpl");
static_assert(offsetof(FDestroyBulletRepImpl, SerialID) == 0x000000, "Member 'FDestroyBulletRepImpl::SerialID' has a wrong offset!");
static_assert(offsetof(FDestroyBulletRepImpl, TargetCharacter) == 0x000008, "Member 'FDestroyBulletRepImpl::TargetCharacter' has a wrong offset!");
static_assert(offsetof(FDestroyBulletRepImpl, GenID) == 0x000010, "Member 'FDestroyBulletRepImpl::GenID' has a wrong offset!");
static_assert(offsetof(FDestroyBulletRepImpl, bulletIdx) == 0x000014, "Member 'FDestroyBulletRepImpl::bulletIdx' has a wrong offset!");
static_assert(offsetof(FDestroyBulletRepImpl, DestroyType) == 0x000016, "Member 'FDestroyBulletRepImpl::DestroyType' has a wrong offset!");
static_assert(offsetof(FDestroyBulletRepImpl, Timestamp) == 0x000018, "Member 'FDestroyBulletRepImpl::Timestamp' has a wrong offset!");

// ScriptStruct GameModule.DestroyBulletRep
// 0x0068 (0x0068 - 0x0000)
struct FDestroyBulletRep final
{
public:
	struct FDestroyBulletRepImpl                  Data[0x3];                                         // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	int8                                          SerialID;                                          // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestroyBulletRep) == 0x000008, "Wrong alignment on FDestroyBulletRep");
static_assert(sizeof(FDestroyBulletRep) == 0x000068, "Wrong size on FDestroyBulletRep");
static_assert(offsetof(FDestroyBulletRep, Data) == 0x000000, "Member 'FDestroyBulletRep::Data' has a wrong offset!");
static_assert(offsetof(FDestroyBulletRep, SerialID) == 0x000060, "Member 'FDestroyBulletRep::SerialID' has a wrong offset!");

// ScriptStruct GameModule.ProjectileGenerateRep
// 0x0070 (0x0070 - 0x0000)
struct FProjectileGenerateRep final
{
public:
	class AActor*                                 Parent;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        SerialID;                                          // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        GeneratorDataID;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        GeneratorDataIndexID;                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CharaID;                                           // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 TargetLocate;                                      // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 InitLocate;                                        // 0x0024(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  InitQuat;                                          // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 InitScale;                                         // 0x0040(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachTime;                                        // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SocketIdx;                                         // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttachType;                                        // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationNo;                                       // 0x0056(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CommandID;                                         // 0x0057(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttackId;                                          // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionID;                                       // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        GenID;                                             // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttackSerial;                                      // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          OverrideJsonIDX;                                   // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0xE];                                       // 0x0062(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileGenerateRep) == 0x000010, "Wrong alignment on FProjectileGenerateRep");
static_assert(sizeof(FProjectileGenerateRep) == 0x000070, "Wrong size on FProjectileGenerateRep");
static_assert(offsetof(FProjectileGenerateRep, Parent) == 0x000000, "Member 'FProjectileGenerateRep::Parent' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, SerialID) == 0x000008, "Member 'FProjectileGenerateRep::SerialID' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, GeneratorDataID) == 0x00000C, "Member 'FProjectileGenerateRep::GeneratorDataID' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, GeneratorDataIndexID) == 0x000010, "Member 'FProjectileGenerateRep::GeneratorDataIndexID' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, CharaID) == 0x000014, "Member 'FProjectileGenerateRep::CharaID' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, TargetLocate) == 0x000018, "Member 'FProjectileGenerateRep::TargetLocate' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, InitLocate) == 0x000024, "Member 'FProjectileGenerateRep::InitLocate' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, InitQuat) == 0x000030, "Member 'FProjectileGenerateRep::InitQuat' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, InitScale) == 0x000040, "Member 'FProjectileGenerateRep::InitScale' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, AttachTime) == 0x00004C, "Member 'FProjectileGenerateRep::AttachTime' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, SocketIdx) == 0x000050, "Member 'FProjectileGenerateRep::SocketIdx' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, AttachType) == 0x000054, "Member 'FProjectileGenerateRep::AttachType' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, Level) == 0x000055, "Member 'FProjectileGenerateRep::Level' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, VariationNo) == 0x000056, "Member 'FProjectileGenerateRep::VariationNo' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, CommandID) == 0x000057, "Member 'FProjectileGenerateRep::CommandID' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, AttackId) == 0x000058, "Member 'FProjectileGenerateRep::AttackId' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, ConditionID) == 0x000059, "Member 'FProjectileGenerateRep::ConditionID' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, GenID) == 0x00005C, "Member 'FProjectileGenerateRep::GenID' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, AttackSerial) == 0x000060, "Member 'FProjectileGenerateRep::AttackSerial' has a wrong offset!");
static_assert(offsetof(FProjectileGenerateRep, OverrideJsonIDX) == 0x000061, "Member 'FProjectileGenerateRep::OverrideJsonIDX' has a wrong offset!");

// ScriptStruct GameModule.OverrideRVTParameter
// 0x0020 (0x0020 - 0x0000)
struct FOverrideRVTParameter final
{
public:
	EPlatform                                     Platform;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TileCount;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileSize;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileBorderSize;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERuntimeVirtualTextureMaterialType            MaterialType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompressTextures;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearTextures;                                    // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSinglePhysicalSpace;                              // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrivateSpace;                                     // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdaptive;                                         // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuousUpdate;                                 // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RemoveLowMips;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureGroup                                 LODGroup;                                          // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverrideRVTParameter) == 0x000004, "Wrong alignment on FOverrideRVTParameter");
static_assert(sizeof(FOverrideRVTParameter) == 0x000020, "Wrong size on FOverrideRVTParameter");
static_assert(offsetof(FOverrideRVTParameter, Platform) == 0x000000, "Member 'FOverrideRVTParameter::Platform' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, TileCount) == 0x000004, "Member 'FOverrideRVTParameter::TileCount' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, TileSize) == 0x000008, "Member 'FOverrideRVTParameter::TileSize' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, TileBorderSize) == 0x00000C, "Member 'FOverrideRVTParameter::TileBorderSize' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, MaterialType) == 0x000010, "Member 'FOverrideRVTParameter::MaterialType' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, bCompressTextures) == 0x000011, "Member 'FOverrideRVTParameter::bCompressTextures' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, bClearTextures) == 0x000012, "Member 'FOverrideRVTParameter::bClearTextures' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, bSinglePhysicalSpace) == 0x000013, "Member 'FOverrideRVTParameter::bSinglePhysicalSpace' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, bPrivateSpace) == 0x000014, "Member 'FOverrideRVTParameter::bPrivateSpace' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, bAdaptive) == 0x000015, "Member 'FOverrideRVTParameter::bAdaptive' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, bContinuousUpdate) == 0x000016, "Member 'FOverrideRVTParameter::bContinuousUpdate' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, RemoveLowMips) == 0x000018, "Member 'FOverrideRVTParameter::RemoveLowMips' has a wrong offset!");
static_assert(offsetof(FOverrideRVTParameter, LODGroup) == 0x00001C, "Member 'FOverrideRVTParameter::LODGroup' has a wrong offset!");

// ScriptStruct GameModule.BattlePlayerInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FBattlePlayerInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattlePlayerInfo) == 0x000004, "Wrong alignment on FBattlePlayerInfo");
static_assert(sizeof(FBattlePlayerInfo) == 0x000014, "Wrong size on FBattlePlayerInfo");

// ScriptStruct GameModule.HudCharacterInfo
// 0x0050 (0x0050 - 0x0000)
struct FHudCharacterInfo final
{
public:
	TSoftObjectPtr<class UPaperSprite>            _characterFaceTexture;                             // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            _specialSupplyImages;                              // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHudCharacterInfo) == 0x000008, "Wrong alignment on FHudCharacterInfo");
static_assert(sizeof(FHudCharacterInfo) == 0x000050, "Wrong size on FHudCharacterInfo");
static_assert(offsetof(FHudCharacterInfo, _characterFaceTexture) == 0x000000, "Member 'FHudCharacterInfo::_characterFaceTexture' has a wrong offset!");
static_assert(offsetof(FHudCharacterInfo, _specialSupplyImages) == 0x000028, "Member 'FHudCharacterInfo::_specialSupplyImages' has a wrong offset!");

// ScriptStruct GameModule.InputDataForCharacter
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FInputDataForCharacter final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputDataForCharacter) == 0x000008, "Wrong alignment on FInputDataForCharacter");
static_assert(sizeof(FInputDataForCharacter) == 0x000060, "Wrong size on FInputDataForCharacter");

// ScriptStruct GameModule.FieldItemColorTableRow
// 0x0048 (0x0050 - 0x0008)
struct FFieldItemColorTableRow final : public FTableRowBase
{
public:
	struct FLinearColor                           _particleBaseColor;                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _particleLightColor;                               // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bUseMeshColor;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _meshOneColor;                                     // 0x002C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _meshTwoColor;                                     // 0x003C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFieldItemColorTableRow) == 0x000008, "Wrong alignment on FFieldItemColorTableRow");
static_assert(sizeof(FFieldItemColorTableRow) == 0x000050, "Wrong size on FFieldItemColorTableRow");
static_assert(offsetof(FFieldItemColorTableRow, _particleBaseColor) == 0x000008, "Member 'FFieldItemColorTableRow::_particleBaseColor' has a wrong offset!");
static_assert(offsetof(FFieldItemColorTableRow, _particleLightColor) == 0x000018, "Member 'FFieldItemColorTableRow::_particleLightColor' has a wrong offset!");
static_assert(offsetof(FFieldItemColorTableRow, _bUseMeshColor) == 0x000028, "Member 'FFieldItemColorTableRow::_bUseMeshColor' has a wrong offset!");
static_assert(offsetof(FFieldItemColorTableRow, _meshOneColor) == 0x00002C, "Member 'FFieldItemColorTableRow::_meshOneColor' has a wrong offset!");
static_assert(offsetof(FFieldItemColorTableRow, _meshTwoColor) == 0x00003C, "Member 'FFieldItemColorTableRow::_meshTwoColor' has a wrong offset!");

// ScriptStruct GameModule.LeaderboardDisplayData
// 0x0038 (0x0038 - 0x0000)
struct FLeaderboardDisplayData final
{
public:
	struct FUniqueNetIdKey                        _playerId;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _name;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _point;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _likeCount;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bSameTeam;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaderboardDisplayData) == 0x000008, "Wrong alignment on FLeaderboardDisplayData");
static_assert(sizeof(FLeaderboardDisplayData) == 0x000038, "Wrong size on FLeaderboardDisplayData");
static_assert(offsetof(FLeaderboardDisplayData, _playerId) == 0x000000, "Member 'FLeaderboardDisplayData::_playerId' has a wrong offset!");
static_assert(offsetof(FLeaderboardDisplayData, _name) == 0x000008, "Member 'FLeaderboardDisplayData::_name' has a wrong offset!");
static_assert(offsetof(FLeaderboardDisplayData, _point) == 0x000028, "Member 'FLeaderboardDisplayData::_point' has a wrong offset!");
static_assert(offsetof(FLeaderboardDisplayData, _likeCount) == 0x00002C, "Member 'FLeaderboardDisplayData::_likeCount' has a wrong offset!");
static_assert(offsetof(FLeaderboardDisplayData, _bSameTeam) == 0x000030, "Member 'FLeaderboardDisplayData::_bSameTeam' has a wrong offset!");

// ScriptStruct GameModule.LeaderboardPhaseData
// 0x00F0 (0x00F0 - 0x0000)
struct FLeaderboardPhaseData final
{
public:
	struct FLeaderboardDisplayData                _topDamage;                                        // 0x0000(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLeaderboardDisplayData                _topKill;                                          // 0x0038(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLeaderboardDisplayData                _topRescueAssault;                                 // 0x0070(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLeaderboardDisplayData                _topItemSupport;                                   // 0x00A8(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaderboardPhaseData) == 0x000008, "Wrong alignment on FLeaderboardPhaseData");
static_assert(sizeof(FLeaderboardPhaseData) == 0x0000F0, "Wrong size on FLeaderboardPhaseData");
static_assert(offsetof(FLeaderboardPhaseData, _topDamage) == 0x000000, "Member 'FLeaderboardPhaseData::_topDamage' has a wrong offset!");
static_assert(offsetof(FLeaderboardPhaseData, _topKill) == 0x000038, "Member 'FLeaderboardPhaseData::_topKill' has a wrong offset!");
static_assert(offsetof(FLeaderboardPhaseData, _topRescueAssault) == 0x000070, "Member 'FLeaderboardPhaseData::_topRescueAssault' has a wrong offset!");
static_assert(offsetof(FLeaderboardPhaseData, _topItemSupport) == 0x0000A8, "Member 'FLeaderboardPhaseData::_topItemSupport' has a wrong offset!");

// ScriptStruct GameModule.LeaderboardData
// 0x0050 (0x0050 - 0x0000)
struct FLeaderboardData final
{
public:
	TMap<int32, struct FLeaderboardPhaseData>     _data;                                             // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardData) == 0x000008, "Wrong alignment on FLeaderboardData");
static_assert(sizeof(FLeaderboardData) == 0x000050, "Wrong size on FLeaderboardData");
static_assert(offsetof(FLeaderboardData, _data) == 0x000000, "Member 'FLeaderboardData::_data' has a wrong offset!");

// ScriptStruct GameModule.TransitionMaterialVectorParamArgment
// 0x0038 (0x0038 - 0x0000)
struct FTransitionMaterialVectorParamArgment final
{
public:
	class FName                                   _parameterName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _cacheName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _time;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _startValue;                                       // 0x0014(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _endValue;                                         // 0x0024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _easingType;                                       // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialGroupFlag                            _group;                                            // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransitionMaterialVectorParamArgment) == 0x000004, "Wrong alignment on FTransitionMaterialVectorParamArgment");
static_assert(sizeof(FTransitionMaterialVectorParamArgment) == 0x000038, "Wrong size on FTransitionMaterialVectorParamArgment");
static_assert(offsetof(FTransitionMaterialVectorParamArgment, _parameterName) == 0x000000, "Member 'FTransitionMaterialVectorParamArgment::_parameterName' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialVectorParamArgment, _cacheName) == 0x000008, "Member 'FTransitionMaterialVectorParamArgment::_cacheName' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialVectorParamArgment, _time) == 0x000010, "Member 'FTransitionMaterialVectorParamArgment::_time' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialVectorParamArgment, _startValue) == 0x000014, "Member 'FTransitionMaterialVectorParamArgment::_startValue' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialVectorParamArgment, _endValue) == 0x000024, "Member 'FTransitionMaterialVectorParamArgment::_endValue' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialVectorParamArgment, _easingType) == 0x000034, "Member 'FTransitionMaterialVectorParamArgment::_easingType' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialVectorParamArgment, _group) == 0x000035, "Member 'FTransitionMaterialVectorParamArgment::_group' has a wrong offset!");

// ScriptStruct GameModule.SoundParamBase
// 0x0068 (0x0068 - 0x0000)
struct FSoundParamBase
{
public:
	struct FAtomComponentParams                   _atomComponentParams;                              // 0x0000(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          _bAutoDestroy;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundParamBase) == 0x000008, "Wrong alignment on FSoundParamBase");
static_assert(sizeof(FSoundParamBase) == 0x000068, "Wrong size on FSoundParamBase");
static_assert(offsetof(FSoundParamBase, _atomComponentParams) == 0x000000, "Member 'FSoundParamBase::_atomComponentParams' has a wrong offset!");
static_assert(offsetof(FSoundParamBase, _bAutoDestroy) == 0x000060, "Member 'FSoundParamBase::_bAutoDestroy' has a wrong offset!");

// ScriptStruct GameModule.SoundParamAtLocation
// 0x0010 (0x0078 - 0x0068)
struct FSoundParamAtLocation final : public FSoundParamBase
{
public:
	struct FVector                                _location;                                         // 0x0068(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundParamAtLocation) == 0x000008, "Wrong alignment on FSoundParamAtLocation");
static_assert(sizeof(FSoundParamAtLocation) == 0x000078, "Wrong size on FSoundParamAtLocation");
static_assert(offsetof(FSoundParamAtLocation, _location) == 0x000068, "Member 'FSoundParamAtLocation::_location' has a wrong offset!");

// ScriptStruct GameModule.TransitionMaterialScalarParamArgment
// 0x0020 (0x0020 - 0x0000)
struct FTransitionMaterialScalarParamArgment final
{
public:
	class FName                                   _parameterName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _cacheName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _time;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _startValue;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _endValue;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _easingType;                                       // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialGroupFlag                            _group;                                            // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialOverWriteType                        _overWriteType;                                    // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransitionMaterialScalarParamArgment) == 0x000004, "Wrong alignment on FTransitionMaterialScalarParamArgment");
static_assert(sizeof(FTransitionMaterialScalarParamArgment) == 0x000020, "Wrong size on FTransitionMaterialScalarParamArgment");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _parameterName) == 0x000000, "Member 'FTransitionMaterialScalarParamArgment::_parameterName' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _cacheName) == 0x000008, "Member 'FTransitionMaterialScalarParamArgment::_cacheName' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _time) == 0x000010, "Member 'FTransitionMaterialScalarParamArgment::_time' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _startValue) == 0x000014, "Member 'FTransitionMaterialScalarParamArgment::_startValue' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _endValue) == 0x000018, "Member 'FTransitionMaterialScalarParamArgment::_endValue' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _easingType) == 0x00001C, "Member 'FTransitionMaterialScalarParamArgment::_easingType' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _group) == 0x00001D, "Member 'FTransitionMaterialScalarParamArgment::_group' has a wrong offset!");
static_assert(offsetof(FTransitionMaterialScalarParamArgment, _overWriteType) == 0x00001E, "Member 'FTransitionMaterialScalarParamArgment::_overWriteType' has a wrong offset!");

// ScriptStruct GameModule.MaterialCacheInfo
// 0x0018 (0x0018 - 0x0000)
struct FMaterialCacheInfo final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterialInstance;                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicOutlineMaterialInstance;                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialCacheInfo) == 0x000008, "Wrong alignment on FMaterialCacheInfo");
static_assert(sizeof(FMaterialCacheInfo) == 0x000018, "Wrong size on FMaterialCacheInfo");
static_assert(offsetof(FMaterialCacheInfo, DynamicMaterialInstance) == 0x000000, "Member 'FMaterialCacheInfo::DynamicMaterialInstance' has a wrong offset!");
static_assert(offsetof(FMaterialCacheInfo, DynamicOutlineMaterialInstance) == 0x000008, "Member 'FMaterialCacheInfo::DynamicOutlineMaterialInstance' has a wrong offset!");

// ScriptStruct GameModule.GuildDisplayData
// 0x0048 (0x0048 - 0x0000)
struct FGuildDisplayData final
{
public:
	class FString                                 _searchId;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _id;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _name;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _introduction;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _emblemId;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlreadyJoin;                                      // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHiddenDisplay;                                   // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuildDisplayData) == 0x000008, "Wrong alignment on FGuildDisplayData");
static_assert(sizeof(FGuildDisplayData) == 0x000048, "Wrong size on FGuildDisplayData");
static_assert(offsetof(FGuildDisplayData, _searchId) == 0x000000, "Member 'FGuildDisplayData::_searchId' has a wrong offset!");
static_assert(offsetof(FGuildDisplayData, _id) == 0x000010, "Member 'FGuildDisplayData::_id' has a wrong offset!");
static_assert(offsetof(FGuildDisplayData, _name) == 0x000020, "Member 'FGuildDisplayData::_name' has a wrong offset!");
static_assert(offsetof(FGuildDisplayData, _introduction) == 0x000030, "Member 'FGuildDisplayData::_introduction' has a wrong offset!");
static_assert(offsetof(FGuildDisplayData, _emblemId) == 0x000040, "Member 'FGuildDisplayData::_emblemId' has a wrong offset!");
static_assert(offsetof(FGuildDisplayData, bAlreadyJoin) == 0x000044, "Member 'FGuildDisplayData::bAlreadyJoin' has a wrong offset!");
static_assert(offsetof(FGuildDisplayData, _bHiddenDisplay) == 0x000045, "Member 'FGuildDisplayData::_bHiddenDisplay' has a wrong offset!");

// ScriptStruct GameModule.MpActionParam
// 0x0158 (0x0158 - 0x0000)
struct FMpActionParam final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunInitialSpeed;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunLastSpeed;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunAccelSpan;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunInitialTurnSpan;                                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunTurnRate;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunEndBrakeSpan;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashBeginBrakeSpan;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashInitialSpeed;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashLastSpeed;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashAccelSpan;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashInitialTurnSpan;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashTurnRate;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashEndBrakeSpan;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDashInitialSpeed;                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDashLastSpeed;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDashAccelSpan;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDashInitialTurnSpan;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDashTurnRate;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDashLimitTime;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoveringTimeRate;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpBeginBrakeSpan;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForwardInitialTurnSpan;                        // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpVerticalSpan;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpVerticalHeight;                                // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForwardSpan;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForwardHeight;                                 // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForwardInitialSpeedH;                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForwardLastSpeedH;                             // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForwardAccelSpanH;                             // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirJumpMaxCount;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirJumpVerticalSpan;                               // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirJumpVerticalHeight;                             // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirJumpForwardSpan;                                // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirJumpForwardHeight;                              // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirJumpForwardInitialSpeedH;                       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirJumpForwardLastSpeedH;                          // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirJumpForwardAccelSpanH;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallJumpSpan;                                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallJumpHeight;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WallJumpInitialSpeed;                              // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallJumpLastSpeed;                                 // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallJumpAccelSpan;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandPenaltyStartTime;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandPenaltyMaxTime;                                // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandPenaltyStartHeight;                            // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LandPenaltyMaxHeight;                              // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCrawlInitialSpeed;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCrawlLastSpeed;                                // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCrawlAccelSpan;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCrawlInitialTurnSpan;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCrawlTurnRate;                                 // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeInitialSpeed;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeLastSpeed;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeInvincibleSpan;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingMoveRate;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssistableDistance;                                // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchMoveRate;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParkourableMaxHeight;                              // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreHeightInParkourCheck;                        // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallAttachingDistance;                             // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallAttachedMargin;                                // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinisherCompleteSeconds;                           // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantScale;                                        // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantMoveRate;                                     // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantAnimBaseRate;                                 // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantAnimAttackRate;                               // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantRunInitialSpeed;                              // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantRunLastSpeed;                                 // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantRunAccelSpan;                                 // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantRunInitialTurnSpan;                           // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantRunTurnRate;                                  // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantRunEndBrakeSpan;                              // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpBeginBrakeSpan;                           // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpForwardInitialTurnSpan;                   // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpVerticalSpan;                             // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpVerticalHeight;                           // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpForwardSpan;                              // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpForwardHeight;                            // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpForwardInitialSpeedH;                     // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpForwardLastSpeedH;                        // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantJumpForwardAccelSpanH;                        // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMpActionParam) == 0x000008, "Wrong alignment on FMpActionParam");
static_assert(sizeof(FMpActionParam) == 0x000158, "Wrong size on FMpActionParam");
static_assert(offsetof(FMpActionParam, CharacterId) == 0x000000, "Member 'FMpActionParam::CharacterId' has a wrong offset!");
static_assert(offsetof(FMpActionParam, RunInitialSpeed) == 0x000010, "Member 'FMpActionParam::RunInitialSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, RunLastSpeed) == 0x000014, "Member 'FMpActionParam::RunLastSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, RunAccelSpan) == 0x000018, "Member 'FMpActionParam::RunAccelSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, RunInitialTurnSpan) == 0x00001C, "Member 'FMpActionParam::RunInitialTurnSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, RunTurnRate) == 0x000020, "Member 'FMpActionParam::RunTurnRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, RunEndBrakeSpan) == 0x000024, "Member 'FMpActionParam::RunEndBrakeSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DashBeginBrakeSpan) == 0x000028, "Member 'FMpActionParam::DashBeginBrakeSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DashInitialSpeed) == 0x00002C, "Member 'FMpActionParam::DashInitialSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DashLastSpeed) == 0x000030, "Member 'FMpActionParam::DashLastSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DashAccelSpan) == 0x000034, "Member 'FMpActionParam::DashAccelSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DashInitialTurnSpan) == 0x000038, "Member 'FMpActionParam::DashInitialTurnSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DashTurnRate) == 0x00003C, "Member 'FMpActionParam::DashTurnRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DashEndBrakeSpan) == 0x000040, "Member 'FMpActionParam::DashEndBrakeSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirDashInitialSpeed) == 0x000044, "Member 'FMpActionParam::AirDashInitialSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirDashLastSpeed) == 0x000048, "Member 'FMpActionParam::AirDashLastSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirDashAccelSpan) == 0x00004C, "Member 'FMpActionParam::AirDashAccelSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirDashInitialTurnSpan) == 0x000050, "Member 'FMpActionParam::AirDashInitialTurnSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirDashTurnRate) == 0x000054, "Member 'FMpActionParam::AirDashTurnRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirDashLimitTime) == 0x000058, "Member 'FMpActionParam::AirDashLimitTime' has a wrong offset!");
static_assert(offsetof(FMpActionParam, HoveringTimeRate) == 0x00005C, "Member 'FMpActionParam::HoveringTimeRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpBeginBrakeSpan) == 0x000060, "Member 'FMpActionParam::JumpBeginBrakeSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpForwardInitialTurnSpan) == 0x000064, "Member 'FMpActionParam::JumpForwardInitialTurnSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpVerticalSpan) == 0x000068, "Member 'FMpActionParam::JumpVerticalSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpVerticalHeight) == 0x00006C, "Member 'FMpActionParam::JumpVerticalHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpForwardSpan) == 0x000070, "Member 'FMpActionParam::JumpForwardSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpForwardHeight) == 0x000074, "Member 'FMpActionParam::JumpForwardHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpForwardInitialSpeedH) == 0x000078, "Member 'FMpActionParam::JumpForwardInitialSpeedH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpForwardLastSpeedH) == 0x00007C, "Member 'FMpActionParam::JumpForwardLastSpeedH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, JumpForwardAccelSpanH) == 0x000080, "Member 'FMpActionParam::JumpForwardAccelSpanH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpMaxCount) == 0x000084, "Member 'FMpActionParam::AirJumpMaxCount' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpVerticalSpan) == 0x000088, "Member 'FMpActionParam::AirJumpVerticalSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpVerticalHeight) == 0x00008C, "Member 'FMpActionParam::AirJumpVerticalHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpForwardSpan) == 0x000090, "Member 'FMpActionParam::AirJumpForwardSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpForwardHeight) == 0x000094, "Member 'FMpActionParam::AirJumpForwardHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpForwardInitialSpeedH) == 0x000098, "Member 'FMpActionParam::AirJumpForwardInitialSpeedH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpForwardLastSpeedH) == 0x00009C, "Member 'FMpActionParam::AirJumpForwardLastSpeedH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AirJumpForwardAccelSpanH) == 0x0000A0, "Member 'FMpActionParam::AirJumpForwardAccelSpanH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallJumpSpan) == 0x0000A4, "Member 'FMpActionParam::WallJumpSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallJumpHeight) == 0x0000A8, "Member 'FMpActionParam::WallJumpHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallJumpInitialSpeed) == 0x0000AC, "Member 'FMpActionParam::WallJumpInitialSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallJumpLastSpeed) == 0x0000B0, "Member 'FMpActionParam::WallJumpLastSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallJumpAccelSpan) == 0x0000B4, "Member 'FMpActionParam::WallJumpAccelSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, LandPenaltyStartTime) == 0x0000B8, "Member 'FMpActionParam::LandPenaltyStartTime' has a wrong offset!");
static_assert(offsetof(FMpActionParam, LandPenaltyMaxTime) == 0x0000BC, "Member 'FMpActionParam::LandPenaltyMaxTime' has a wrong offset!");
static_assert(offsetof(FMpActionParam, LandPenaltyStartHeight) == 0x0000C0, "Member 'FMpActionParam::LandPenaltyStartHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, LandPenaltyMaxHeight) == 0x0000C4, "Member 'FMpActionParam::LandPenaltyMaxHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallCrawlInitialSpeed) == 0x0000C8, "Member 'FMpActionParam::WallCrawlInitialSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallCrawlLastSpeed) == 0x0000CC, "Member 'FMpActionParam::WallCrawlLastSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallCrawlAccelSpan) == 0x0000D0, "Member 'FMpActionParam::WallCrawlAccelSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallCrawlInitialTurnSpan) == 0x0000D4, "Member 'FMpActionParam::WallCrawlInitialTurnSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallCrawlTurnRate) == 0x0000D8, "Member 'FMpActionParam::WallCrawlTurnRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DodgeInitialSpeed) == 0x0000DC, "Member 'FMpActionParam::DodgeInitialSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DodgeLastSpeed) == 0x0000E0, "Member 'FMpActionParam::DodgeLastSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, DodgeInvincibleSpan) == 0x0000E4, "Member 'FMpActionParam::DodgeInvincibleSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AimingMoveRate) == 0x0000E8, "Member 'FMpActionParam::AimingMoveRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, AssistableDistance) == 0x0000EC, "Member 'FMpActionParam::AssistableDistance' has a wrong offset!");
static_assert(offsetof(FMpActionParam, CrouchMoveRate) == 0x0000F0, "Member 'FMpActionParam::CrouchMoveRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, ParkourableMaxHeight) == 0x0000F4, "Member 'FMpActionParam::ParkourableMaxHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, IgnoreHeightInParkourCheck) == 0x0000F8, "Member 'FMpActionParam::IgnoreHeightInParkourCheck' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallAttachingDistance) == 0x0000FC, "Member 'FMpActionParam::WallAttachingDistance' has a wrong offset!");
static_assert(offsetof(FMpActionParam, WallAttachedMargin) == 0x000100, "Member 'FMpActionParam::WallAttachedMargin' has a wrong offset!");
static_assert(offsetof(FMpActionParam, FinisherCompleteSeconds) == 0x000104, "Member 'FMpActionParam::FinisherCompleteSeconds' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantScale) == 0x000108, "Member 'FMpActionParam::GiantScale' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantMoveRate) == 0x00010C, "Member 'FMpActionParam::GiantMoveRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantAnimBaseRate) == 0x000110, "Member 'FMpActionParam::GiantAnimBaseRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantAnimAttackRate) == 0x000114, "Member 'FMpActionParam::GiantAnimAttackRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantRunInitialSpeed) == 0x000118, "Member 'FMpActionParam::GiantRunInitialSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantRunLastSpeed) == 0x00011C, "Member 'FMpActionParam::GiantRunLastSpeed' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantRunAccelSpan) == 0x000120, "Member 'FMpActionParam::GiantRunAccelSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantRunInitialTurnSpan) == 0x000124, "Member 'FMpActionParam::GiantRunInitialTurnSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantRunTurnRate) == 0x000128, "Member 'FMpActionParam::GiantRunTurnRate' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantRunEndBrakeSpan) == 0x00012C, "Member 'FMpActionParam::GiantRunEndBrakeSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpBeginBrakeSpan) == 0x000130, "Member 'FMpActionParam::GiantJumpBeginBrakeSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpForwardInitialTurnSpan) == 0x000134, "Member 'FMpActionParam::GiantJumpForwardInitialTurnSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpVerticalSpan) == 0x000138, "Member 'FMpActionParam::GiantJumpVerticalSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpVerticalHeight) == 0x00013C, "Member 'FMpActionParam::GiantJumpVerticalHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpForwardSpan) == 0x000140, "Member 'FMpActionParam::GiantJumpForwardSpan' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpForwardHeight) == 0x000144, "Member 'FMpActionParam::GiantJumpForwardHeight' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpForwardInitialSpeedH) == 0x000148, "Member 'FMpActionParam::GiantJumpForwardInitialSpeedH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpForwardLastSpeedH) == 0x00014C, "Member 'FMpActionParam::GiantJumpForwardLastSpeedH' has a wrong offset!");
static_assert(offsetof(FMpActionParam, GiantJumpForwardAccelSpanH) == 0x000150, "Member 'FMpActionParam::GiantJumpForwardAccelSpanH' has a wrong offset!");

// ScriptStruct GameModule.MpAIDifficultyParam
// 0x0028 (0x0028 - 0x0000)
struct FMpAIDifficultyParam final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackFuzzyRate;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackFrequency;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DodgeAccuracy;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DodgeFrequency;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrackingAccuracy;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMpAIDifficultyParam) == 0x000008, "Wrong alignment on FMpAIDifficultyParam");
static_assert(sizeof(FMpAIDifficultyParam) == 0x000028, "Wrong size on FMpAIDifficultyParam");
static_assert(offsetof(FMpAIDifficultyParam, ID) == 0x000000, "Member 'FMpAIDifficultyParam::ID' has a wrong offset!");
static_assert(offsetof(FMpAIDifficultyParam, AttackFuzzyRate) == 0x000010, "Member 'FMpAIDifficultyParam::AttackFuzzyRate' has a wrong offset!");
static_assert(offsetof(FMpAIDifficultyParam, AttackFrequency) == 0x000014, "Member 'FMpAIDifficultyParam::AttackFrequency' has a wrong offset!");
static_assert(offsetof(FMpAIDifficultyParam, DodgeAccuracy) == 0x000018, "Member 'FMpAIDifficultyParam::DodgeAccuracy' has a wrong offset!");
static_assert(offsetof(FMpAIDifficultyParam, DodgeFrequency) == 0x00001C, "Member 'FMpAIDifficultyParam::DodgeFrequency' has a wrong offset!");
static_assert(offsetof(FMpAIDifficultyParam, TrackingAccuracy) == 0x000020, "Member 'FMpAIDifficultyParam::TrackingAccuracy' has a wrong offset!");

// ScriptStruct GameModule.MpAIParam
// 0x0078 (0x0078 - 0x0000)
struct FMpAIParam final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillMeleeGroup;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillUnique1Group;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillUnique2Group;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillUnique3Group;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RangeType;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x47];                                      // 0x0031(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMpAIParam) == 0x000008, "Wrong alignment on FMpAIParam");
static_assert(sizeof(FMpAIParam) == 0x000078, "Wrong size on FMpAIParam");
static_assert(offsetof(FMpAIParam, CharacterId) == 0x000000, "Member 'FMpAIParam::CharacterId' has a wrong offset!");
static_assert(offsetof(FMpAIParam, SkillMeleeGroup) == 0x000010, "Member 'FMpAIParam::SkillMeleeGroup' has a wrong offset!");
static_assert(offsetof(FMpAIParam, SkillUnique1Group) == 0x000018, "Member 'FMpAIParam::SkillUnique1Group' has a wrong offset!");
static_assert(offsetof(FMpAIParam, SkillUnique2Group) == 0x000020, "Member 'FMpAIParam::SkillUnique2Group' has a wrong offset!");
static_assert(offsetof(FMpAIParam, SkillUnique3Group) == 0x000028, "Member 'FMpAIParam::SkillUnique3Group' has a wrong offset!");
static_assert(offsetof(FMpAIParam, RangeType) == 0x000030, "Member 'FMpAIParam::RangeType' has a wrong offset!");

// ScriptStruct GameModule.MpAISkill
// 0x0058 (0x0058 - 0x0000)
struct FMpAISkill final
{
public:
	class FName                                   GroupCode;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Step;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepSet;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WholeAttack;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stance;                                            // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Command;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Instant;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FuzzyAngle;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcceptAngle;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcceptLengthMin;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcceptLengthMax;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcceptHeightMin;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcceptHeightMax;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalMin;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalMax;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMpAISkill) == 0x000008, "Wrong alignment on FMpAISkill");
static_assert(sizeof(FMpAISkill) == 0x000058, "Wrong size on FMpAISkill");
static_assert(offsetof(FMpAISkill, GroupCode) == 0x000000, "Member 'FMpAISkill::GroupCode' has a wrong offset!");
static_assert(offsetof(FMpAISkill, Weight) == 0x000008, "Member 'FMpAISkill::Weight' has a wrong offset!");
static_assert(offsetof(FMpAISkill, Ratio) == 0x00000C, "Member 'FMpAISkill::Ratio' has a wrong offset!");
static_assert(offsetof(FMpAISkill, Step) == 0x000010, "Member 'FMpAISkill::Step' has a wrong offset!");
static_assert(offsetof(FMpAISkill, StepSet) == 0x000014, "Member 'FMpAISkill::StepSet' has a wrong offset!");
static_assert(offsetof(FMpAISkill, WholeAttack) == 0x000018, "Member 'FMpAISkill::WholeAttack' has a wrong offset!");
static_assert(offsetof(FMpAISkill, Stance) == 0x000019, "Member 'FMpAISkill::Stance' has a wrong offset!");
static_assert(offsetof(FMpAISkill, Command) == 0x000020, "Member 'FMpAISkill::Command' has a wrong offset!");
static_assert(offsetof(FMpAISkill, Instant) == 0x000030, "Member 'FMpAISkill::Instant' has a wrong offset!");
static_assert(offsetof(FMpAISkill, Duration) == 0x000034, "Member 'FMpAISkill::Duration' has a wrong offset!");
static_assert(offsetof(FMpAISkill, FuzzyAngle) == 0x000038, "Member 'FMpAISkill::FuzzyAngle' has a wrong offset!");
static_assert(offsetof(FMpAISkill, AcceptAngle) == 0x00003C, "Member 'FMpAISkill::AcceptAngle' has a wrong offset!");
static_assert(offsetof(FMpAISkill, AcceptLengthMin) == 0x000040, "Member 'FMpAISkill::AcceptLengthMin' has a wrong offset!");
static_assert(offsetof(FMpAISkill, AcceptLengthMax) == 0x000044, "Member 'FMpAISkill::AcceptLengthMax' has a wrong offset!");
static_assert(offsetof(FMpAISkill, AcceptHeightMin) == 0x000048, "Member 'FMpAISkill::AcceptHeightMin' has a wrong offset!");
static_assert(offsetof(FMpAISkill, AcceptHeightMax) == 0x00004C, "Member 'FMpAISkill::AcceptHeightMax' has a wrong offset!");
static_assert(offsetof(FMpAISkill, IntervalMin) == 0x000050, "Member 'FMpAISkill::IntervalMin' has a wrong offset!");
static_assert(offsetof(FMpAISkill, IntervalMax) == 0x000054, "Member 'FMpAISkill::IntervalMax' has a wrong offset!");

// ScriptStruct GameModule.MpCharacterCameraParam
// 0x0064 (0x0064 - 0x0000)
struct FMpCharacterCameraParam final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalPan;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalPan;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotSpeed;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistRate;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarAimAssistRate;                                  // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearAimAssistRate;                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarAimAssistIgnoreSpan;                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearAimAssistIgnoreSpan;                           // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarAimAssistMaxArea;                               // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearAimAssistMaxArea;                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalOffsetOnGiant;                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalHorizontalPanOnGiant;                    // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalVerticalPanOnGiant;                      // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SkirtOffset;                                       // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SkirtOffsetOnGiant;                                // 0x0054(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkirtCameraPitchThreshold;                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMpCharacterCameraParam) == 0x000004, "Wrong alignment on FMpCharacterCameraParam");
static_assert(sizeof(FMpCharacterCameraParam) == 0x000064, "Wrong size on FMpCharacterCameraParam");
static_assert(offsetof(FMpCharacterCameraParam, ID) == 0x000000, "Member 'FMpCharacterCameraParam::ID' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, Offset) == 0x000008, "Member 'FMpCharacterCameraParam::Offset' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, HorizontalPan) == 0x00000C, "Member 'FMpCharacterCameraParam::HorizontalPan' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, VerticalPan) == 0x000010, "Member 'FMpCharacterCameraParam::VerticalPan' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, FOV) == 0x000014, "Member 'FMpCharacterCameraParam::FOV' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, RotSpeed) == 0x000018, "Member 'FMpCharacterCameraParam::RotSpeed' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, InterpTime) == 0x00001C, "Member 'FMpCharacterCameraParam::InterpTime' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, AimAssistRate) == 0x000020, "Member 'FMpCharacterCameraParam::AimAssistRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, FarAimAssistRate) == 0x000024, "Member 'FMpCharacterCameraParam::FarAimAssistRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, NearAimAssistRate) == 0x000028, "Member 'FMpCharacterCameraParam::NearAimAssistRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, FarAimAssistIgnoreSpan) == 0x00002C, "Member 'FMpCharacterCameraParam::FarAimAssistIgnoreSpan' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, NearAimAssistIgnoreSpan) == 0x000030, "Member 'FMpCharacterCameraParam::NearAimAssistIgnoreSpan' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, FarAimAssistMaxArea) == 0x000034, "Member 'FMpCharacterCameraParam::FarAimAssistMaxArea' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, NearAimAssistMaxArea) == 0x000038, "Member 'FMpCharacterCameraParam::NearAimAssistMaxArea' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, AdditionalOffsetOnGiant) == 0x00003C, "Member 'FMpCharacterCameraParam::AdditionalOffsetOnGiant' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, AdditionalHorizontalPanOnGiant) == 0x000040, "Member 'FMpCharacterCameraParam::AdditionalHorizontalPanOnGiant' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, AdditionalVerticalPanOnGiant) == 0x000044, "Member 'FMpCharacterCameraParam::AdditionalVerticalPanOnGiant' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, SkirtOffset) == 0x000048, "Member 'FMpCharacterCameraParam::SkirtOffset' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, SkirtOffsetOnGiant) == 0x000054, "Member 'FMpCharacterCameraParam::SkirtOffsetOnGiant' has a wrong offset!");
static_assert(offsetof(FMpCharacterCameraParam, SkirtCameraPitchThreshold) == 0x000060, "Member 'FMpCharacterCameraParam::SkirtCameraPitchThreshold' has a wrong offset!");

// ScriptStruct GameModule.MpCharacterParam
// 0x0048 (0x0048 - 0x0000)
struct FMpCharacterParam final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMainHealth;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGuardPoint;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxArmor;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBreakDown;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFreeze;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShock;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardBreakRate;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TakeDamageRate;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TakeDamageRateSpecial;                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantArmorResistanceRate;                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantBreakDownResistanceRate;                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiantNagativeConditionResistanceRate;              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterGender                              Gender;                                            // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterAssign                              Assign;                                            // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterBodySize                            BodySize;                                          // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMpCharacterParam) == 0x000008, "Wrong alignment on FMpCharacterParam");
static_assert(sizeof(FMpCharacterParam) == 0x000048, "Wrong size on FMpCharacterParam");
static_assert(offsetof(FMpCharacterParam, CharacterId) == 0x000000, "Member 'FMpCharacterParam::CharacterId' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, MaxMainHealth) == 0x000010, "Member 'FMpCharacterParam::MaxMainHealth' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, MaxGuardPoint) == 0x000014, "Member 'FMpCharacterParam::MaxGuardPoint' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, MaxArmor) == 0x000018, "Member 'FMpCharacterParam::MaxArmor' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, MaxBreakDown) == 0x00001C, "Member 'FMpCharacterParam::MaxBreakDown' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, MaxFreeze) == 0x000020, "Member 'FMpCharacterParam::MaxFreeze' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, MaxShock) == 0x000024, "Member 'FMpCharacterParam::MaxShock' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, GuardBreakRate) == 0x000028, "Member 'FMpCharacterParam::GuardBreakRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, TakeDamageRate) == 0x00002C, "Member 'FMpCharacterParam::TakeDamageRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, TakeDamageRateSpecial) == 0x000030, "Member 'FMpCharacterParam::TakeDamageRateSpecial' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, GiantArmorResistanceRate) == 0x000034, "Member 'FMpCharacterParam::GiantArmorResistanceRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, GiantBreakDownResistanceRate) == 0x000038, "Member 'FMpCharacterParam::GiantBreakDownResistanceRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, GiantNagativeConditionResistanceRate) == 0x00003C, "Member 'FMpCharacterParam::GiantNagativeConditionResistanceRate' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, Gender) == 0x000040, "Member 'FMpCharacterParam::Gender' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, Assign) == 0x000041, "Member 'FMpCharacterParam::Assign' has a wrong offset!");
static_assert(offsetof(FMpCharacterParam, BodySize) == 0x000042, "Member 'FMpCharacterParam::BodySize' has a wrong offset!");

// ScriptStruct GameModule.MpDamageLevelData
// 0x0020 (0x0020 - 0x0000)
struct FMpDamageLevelData final
{
public:
	class FName                                   TableName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupCode;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         DamageNameList;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMpDamageLevelData) == 0x000008, "Wrong alignment on FMpDamageLevelData");
static_assert(sizeof(FMpDamageLevelData) == 0x000020, "Wrong size on FMpDamageLevelData");
static_assert(offsetof(FMpDamageLevelData, TableName) == 0x000000, "Member 'FMpDamageLevelData::TableName' has a wrong offset!");
static_assert(offsetof(FMpDamageLevelData, GroupCode) == 0x000008, "Member 'FMpDamageLevelData::GroupCode' has a wrong offset!");
static_assert(offsetof(FMpDamageLevelData, DamageNameList) == 0x000010, "Member 'FMpDamageLevelData::DamageNameList' has a wrong offset!");

// ScriptStruct GameModule.MpDamageList
// 0x0040 (0x0040 - 0x0000)
struct FMpDamageList final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageParamGroupCode;                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageLevelDataGroupCode;                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x20];                                      // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMpDamageList) == 0x000008, "Wrong alignment on FMpDamageList");
static_assert(sizeof(FMpDamageList) == 0x000040, "Wrong size on FMpDamageList");
static_assert(offsetof(FMpDamageList, CharacterId) == 0x000000, "Member 'FMpDamageList::CharacterId' has a wrong offset!");
static_assert(offsetof(FMpDamageList, DamageParamGroupCode) == 0x000010, "Member 'FMpDamageList::DamageParamGroupCode' has a wrong offset!");
static_assert(offsetof(FMpDamageList, DamageLevelDataGroupCode) == 0x000018, "Member 'FMpDamageList::DamageLevelDataGroupCode' has a wrong offset!");

// ScriptStruct GameModule.SceneCaptureSpawnCharacterInfo
// 0x0010 (0x0010 - 0x0000)
struct FSceneCaptureSpawnCharacterInfo final
{
public:
	ECharacterId                                  _characterId;                                      // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _costumeCode;                                      // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _auraLevel;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bMySelf;                                          // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneCaptureSpawnCharacterInfo) == 0x000004, "Wrong alignment on FSceneCaptureSpawnCharacterInfo");
static_assert(sizeof(FSceneCaptureSpawnCharacterInfo) == 0x000010, "Wrong size on FSceneCaptureSpawnCharacterInfo");
static_assert(offsetof(FSceneCaptureSpawnCharacterInfo, _characterId) == 0x000000, "Member 'FSceneCaptureSpawnCharacterInfo::_characterId' has a wrong offset!");
static_assert(offsetof(FSceneCaptureSpawnCharacterInfo, _costumeCode) == 0x000004, "Member 'FSceneCaptureSpawnCharacterInfo::_costumeCode' has a wrong offset!");
static_assert(offsetof(FSceneCaptureSpawnCharacterInfo, _auraLevel) == 0x000008, "Member 'FSceneCaptureSpawnCharacterInfo::_auraLevel' has a wrong offset!");
static_assert(offsetof(FSceneCaptureSpawnCharacterInfo, _bMySelf) == 0x00000C, "Member 'FSceneCaptureSpawnCharacterInfo::_bMySelf' has a wrong offset!");

// ScriptStruct GameModule.MpDamageParam
// 0x00B0 (0x00B0 - 0x0000)
struct FMpDamageParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupCode;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageValue;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardBreakValue;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgDamageRate;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DamageType;                                        // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GuardType;                                         // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitPower;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorBreakPower;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComboPower;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownPower;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreezePower;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShockPower;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditinalSeconds;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableRecoverSpan;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityRate;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCount;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSpan;                                           // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DamageKind;                                        // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitMarkType;                                       // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BGHitMarkType;                                     // 0x004E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RestraintType;                                     // 0x004F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayHitSound;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinHitMarkAmplitude;                               // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxHitMarkAmplitude;                               // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitMarkOffset;                                     // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitMarkScale;                                      // 0x006D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DamageAttribute;                                   // 0x006E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraShakeAttack;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeDamage;                                 // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionID;                                       // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionSpan;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConditionValue;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConditionInterval;                                 // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSlowAttack;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSlowDamage;                                     // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardSlowAttack;                                   // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardSlowDamage;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DirectionType;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnorePitch;                                       // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustPitch;                                       // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustYaw;                                         // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unkillable;                                        // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PenetrateSuperArmor;                               // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NearDeathKiller;                                   // 0x00A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GrantSuperArmor;                                   // 0x00A7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DirectKill;                                        // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreDyingDead;                                   // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForcedKnockDownKill;                               // 0x00AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DispLocationOnHit;                                 // 0x00AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitNotification;                                   // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitTargetType;                                     // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SystemKill;                                        // 0x00AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF[0x1];                                       // 0x00AF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMpDamageParam) == 0x000004, "Wrong alignment on FMpDamageParam");
static_assert(sizeof(FMpDamageParam) == 0x0000B0, "Wrong size on FMpDamageParam");
static_assert(offsetof(FMpDamageParam, Name) == 0x000000, "Member 'FMpDamageParam::Name' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, GroupCode) == 0x000008, "Member 'FMpDamageParam::GroupCode' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DamageValue) == 0x000010, "Member 'FMpDamageParam::DamageValue' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, GuardBreakValue) == 0x000014, "Member 'FMpDamageParam::GuardBreakValue' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, BgDamageRate) == 0x000018, "Member 'FMpDamageParam::BgDamageRate' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DamageType) == 0x00001C, "Member 'FMpDamageParam::DamageType' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, GuardType) == 0x00001D, "Member 'FMpDamageParam::GuardType' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitPower) == 0x000020, "Member 'FMpDamageParam::HitPower' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ArmorBreakPower) == 0x000024, "Member 'FMpDamageParam::ArmorBreakPower' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ComboPower) == 0x000028, "Member 'FMpDamageParam::ComboPower' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DownPower) == 0x00002C, "Member 'FMpDamageParam::DownPower' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, FreezePower) == 0x000030, "Member 'FMpDamageParam::FreezePower' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ShockPower) == 0x000034, "Member 'FMpDamageParam::ShockPower' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, AdditinalSeconds) == 0x000038, "Member 'FMpDamageParam::AdditinalSeconds' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, EnableRecoverSpan) == 0x00003C, "Member 'FMpDamageParam::EnableRecoverSpan' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, GravityRate) == 0x000040, "Member 'FMpDamageParam::GravityRate' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitCount) == 0x000044, "Member 'FMpDamageParam::HitCount' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitSpan) == 0x000048, "Member 'FMpDamageParam::HitSpan' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DamageKind) == 0x00004C, "Member 'FMpDamageParam::DamageKind' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitMarkType) == 0x00004D, "Member 'FMpDamageParam::HitMarkType' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, BGHitMarkType) == 0x00004E, "Member 'FMpDamageParam::BGHitMarkType' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, RestraintType) == 0x00004F, "Member 'FMpDamageParam::RestraintType' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, PlayHitSound) == 0x000050, "Member 'FMpDamageParam::PlayHitSound' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, MinHitMarkAmplitude) == 0x000054, "Member 'FMpDamageParam::MinHitMarkAmplitude' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, MaxHitMarkAmplitude) == 0x000060, "Member 'FMpDamageParam::MaxHitMarkAmplitude' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitMarkOffset) == 0x00006C, "Member 'FMpDamageParam::HitMarkOffset' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitMarkScale) == 0x00006D, "Member 'FMpDamageParam::HitMarkScale' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DamageAttribute) == 0x00006E, "Member 'FMpDamageParam::DamageAttribute' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, CameraShakeAttack) == 0x000070, "Member 'FMpDamageParam::CameraShakeAttack' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, CameraShakeDamage) == 0x000074, "Member 'FMpDamageParam::CameraShakeDamage' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ConditionID) == 0x000078, "Member 'FMpDamageParam::ConditionID' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ConditionSpan) == 0x00007C, "Member 'FMpDamageParam::ConditionSpan' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ConditionValue) == 0x000080, "Member 'FMpDamageParam::ConditionValue' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ConditionInterval) == 0x000084, "Member 'FMpDamageParam::ConditionInterval' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitSlowAttack) == 0x000088, "Member 'FMpDamageParam::HitSlowAttack' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitSlowDamage) == 0x00008C, "Member 'FMpDamageParam::HitSlowDamage' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, GuardSlowAttack) == 0x000090, "Member 'FMpDamageParam::GuardSlowAttack' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, GuardSlowDamage) == 0x000094, "Member 'FMpDamageParam::GuardSlowDamage' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DirectionType) == 0x000098, "Member 'FMpDamageParam::DirectionType' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, IgnorePitch) == 0x000099, "Member 'FMpDamageParam::IgnorePitch' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, AdjustPitch) == 0x00009C, "Member 'FMpDamageParam::AdjustPitch' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, AdjustYaw) == 0x0000A0, "Member 'FMpDamageParam::AdjustYaw' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, Unkillable) == 0x0000A4, "Member 'FMpDamageParam::Unkillable' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, PenetrateSuperArmor) == 0x0000A5, "Member 'FMpDamageParam::PenetrateSuperArmor' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, NearDeathKiller) == 0x0000A6, "Member 'FMpDamageParam::NearDeathKiller' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, GrantSuperArmor) == 0x0000A7, "Member 'FMpDamageParam::GrantSuperArmor' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DirectKill) == 0x0000A8, "Member 'FMpDamageParam::DirectKill' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, IgnoreDyingDead) == 0x0000A9, "Member 'FMpDamageParam::IgnoreDyingDead' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, ForcedKnockDownKill) == 0x0000AA, "Member 'FMpDamageParam::ForcedKnockDownKill' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, DispLocationOnHit) == 0x0000AB, "Member 'FMpDamageParam::DispLocationOnHit' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitNotification) == 0x0000AC, "Member 'FMpDamageParam::HitNotification' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, HitTargetType) == 0x0000AD, "Member 'FMpDamageParam::HitTargetType' has a wrong offset!");
static_assert(offsetof(FMpDamageParam, SystemKill) == 0x0000AE, "Member 'FMpDamageParam::SystemKill' has a wrong offset!");

// ScriptStruct GameModule.MpMagazineParam
// 0x0040 (0x0040 - 0x0000)
struct FMpMagazineParam final
{
public:
	class FString                                 Code;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ammo;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadTime;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadStartSpan;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenaltyReloadTime;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenaltySpan;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplenishmentAmmo;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseType;                                           // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseAmmo;                                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopAttack;                                        // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopDamage;                                        // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopDying;                                         // 0x0036(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EmptyStart;                                        // 0x0037(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsableinMaxAmmo;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReloadStartGroundState;                          // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMpMagazineParam) == 0x000008, "Wrong alignment on FMpMagazineParam");
static_assert(sizeof(FMpMagazineParam) == 0x000040, "Wrong size on FMpMagazineParam");
static_assert(offsetof(FMpMagazineParam, Code) == 0x000000, "Member 'FMpMagazineParam::Code' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, Level) == 0x000010, "Member 'FMpMagazineParam::Level' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, Ammo) == 0x000014, "Member 'FMpMagazineParam::Ammo' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, ReloadTime) == 0x000018, "Member 'FMpMagazineParam::ReloadTime' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, ReloadStartSpan) == 0x00001C, "Member 'FMpMagazineParam::ReloadStartSpan' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, PenaltyReloadTime) == 0x000020, "Member 'FMpMagazineParam::PenaltyReloadTime' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, PenaltySpan) == 0x000024, "Member 'FMpMagazineParam::PenaltySpan' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, ReplenishmentAmmo) == 0x000028, "Member 'FMpMagazineParam::ReplenishmentAmmo' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, UseType) == 0x00002C, "Member 'FMpMagazineParam::UseType' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, UseAmmo) == 0x000030, "Member 'FMpMagazineParam::UseAmmo' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, StopAttack) == 0x000034, "Member 'FMpMagazineParam::StopAttack' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, StopDamage) == 0x000035, "Member 'FMpMagazineParam::StopDamage' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, StopDying) == 0x000036, "Member 'FMpMagazineParam::StopDying' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, EmptyStart) == 0x000037, "Member 'FMpMagazineParam::EmptyStart' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, IsUsableinMaxAmmo) == 0x000038, "Member 'FMpMagazineParam::IsUsableinMaxAmmo' has a wrong offset!");
static_assert(offsetof(FMpMagazineParam, IsReloadStartGroundState) == 0x000039, "Member 'FMpMagazineParam::IsReloadStartGroundState' has a wrong offset!");

// ScriptStruct GameModule.MpStaffRoll
// 0x0068 (0x0068 - 0x0000)
struct FMpStaffRoll final
{
public:
	int32                                         StaffRollIndex;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TextSlot1;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextSlot2;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextSlot3;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextSlot4;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextType;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextColor;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMpStaffRoll) == 0x000008, "Wrong alignment on FMpStaffRoll");
static_assert(sizeof(FMpStaffRoll) == 0x000068, "Wrong size on FMpStaffRoll");
static_assert(offsetof(FMpStaffRoll, StaffRollIndex) == 0x000000, "Member 'FMpStaffRoll::StaffRollIndex' has a wrong offset!");
static_assert(offsetof(FMpStaffRoll, TextSlot1) == 0x000008, "Member 'FMpStaffRoll::TextSlot1' has a wrong offset!");
static_assert(offsetof(FMpStaffRoll, TextSlot2) == 0x000018, "Member 'FMpStaffRoll::TextSlot2' has a wrong offset!");
static_assert(offsetof(FMpStaffRoll, TextSlot3) == 0x000028, "Member 'FMpStaffRoll::TextSlot3' has a wrong offset!");
static_assert(offsetof(FMpStaffRoll, TextSlot4) == 0x000038, "Member 'FMpStaffRoll::TextSlot4' has a wrong offset!");
static_assert(offsetof(FMpStaffRoll, TextType) == 0x000048, "Member 'FMpStaffRoll::TextType' has a wrong offset!");
static_assert(offsetof(FMpStaffRoll, TextColor) == 0x000058, "Member 'FMpStaffRoll::TextColor' has a wrong offset!");

// ScriptStruct GameModule.NetworkError
// 0x0038 (0x0040 - 0x0008)
struct FNetworkError final : public FTableRowBase
{
public:
	int32                                         ResponseCode;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkErrorType                             ErrorType;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisplayCode;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayMessage;                                    // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkError) == 0x000008, "Wrong alignment on FNetworkError");
static_assert(sizeof(FNetworkError) == 0x000040, "Wrong size on FNetworkError");
static_assert(offsetof(FNetworkError, ResponseCode) == 0x000008, "Member 'FNetworkError::ResponseCode' has a wrong offset!");
static_assert(offsetof(FNetworkError, Message) == 0x000010, "Member 'FNetworkError::Message' has a wrong offset!");
static_assert(offsetof(FNetworkError, ErrorType) == 0x000020, "Member 'FNetworkError::ErrorType' has a wrong offset!");
static_assert(offsetof(FNetworkError, DisplayCode) == 0x000024, "Member 'FNetworkError::DisplayCode' has a wrong offset!");
static_assert(offsetof(FNetworkError, DisplayMessage) == 0x000028, "Member 'FNetworkError::DisplayMessage' has a wrong offset!");

// ScriptStruct GameModule.NetworkWorkSquadMemberData
// 0x0020 (0x0020 - 0x0000)
struct FNetworkWorkSquadMemberData final
{
public:
	class FString                                 CosmosUserId;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkWorkSquadMemberData) == 0x000008, "Wrong alignment on FNetworkWorkSquadMemberData");
static_assert(sizeof(FNetworkWorkSquadMemberData) == 0x000020, "Wrong size on FNetworkWorkSquadMemberData");
static_assert(offsetof(FNetworkWorkSquadMemberData, CosmosUserId) == 0x000000, "Member 'FNetworkWorkSquadMemberData::CosmosUserId' has a wrong offset!");
static_assert(offsetof(FNetworkWorkSquadMemberData, DisplayName) == 0x000010, "Member 'FNetworkWorkSquadMemberData::DisplayName' has a wrong offset!");

// ScriptStruct GameModule.NotificationMasterInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FNotificationMasterInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotificationMasterInfo) == 0x000008, "Wrong alignment on FNotificationMasterInfo");
static_assert(sizeof(FNotificationMasterInfo) == 0x000020, "Wrong size on FNotificationMasterInfo");

// ScriptStruct GameModule.ItemParamInfo
// 0x0020 (0x0020 - 0x0000)
struct FItemParamInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _category;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _code;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _num;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              _limitDateTime;                                    // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemParamInfo) == 0x000008, "Wrong alignment on FItemParamInfo");
static_assert(sizeof(FItemParamInfo) == 0x000020, "Wrong size on FItemParamInfo");
static_assert(offsetof(FItemParamInfo, _category) == 0x000008, "Member 'FItemParamInfo::_category' has a wrong offset!");
static_assert(offsetof(FItemParamInfo, _code) == 0x00000C, "Member 'FItemParamInfo::_code' has a wrong offset!");
static_assert(offsetof(FItemParamInfo, _num) == 0x000010, "Member 'FItemParamInfo::_num' has a wrong offset!");
static_assert(offsetof(FItemParamInfo, _limitDateTime) == 0x000018, "Member 'FItemParamInfo::_limitDateTime' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataItemParam
// 0x0028 (0x0028 - 0x0000)
struct FPlayerDataItemParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemParamInfo>                 _itemsTicket;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataItemParam) == 0x000008, "Wrong alignment on FPlayerDataItemParam");
static_assert(sizeof(FPlayerDataItemParam) == 0x000028, "Wrong size on FPlayerDataItemParam");
static_assert(offsetof(FPlayerDataItemParam, _itemsTicket) == 0x000008, "Member 'FPlayerDataItemParam::_itemsTicket' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataFriendParam
// 0x0028 (0x0028 - 0x0000)
struct FPlayerDataFriendParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _count;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxCount;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxPage;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFriendInfo>                    _friends;                                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataFriendParam) == 0x000008, "Wrong alignment on FPlayerDataFriendParam");
static_assert(sizeof(FPlayerDataFriendParam) == 0x000028, "Wrong size on FPlayerDataFriendParam");
static_assert(offsetof(FPlayerDataFriendParam, _count) == 0x000008, "Member 'FPlayerDataFriendParam::_count' has a wrong offset!");
static_assert(offsetof(FPlayerDataFriendParam, _maxCount) == 0x00000C, "Member 'FPlayerDataFriendParam::_maxCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataFriendParam, _maxPage) == 0x000010, "Member 'FPlayerDataFriendParam::_maxPage' has a wrong offset!");
static_assert(offsetof(FPlayerDataFriendParam, _friends) == 0x000018, "Member 'FPlayerDataFriendParam::_friends' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataVoiceParam
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPlayerDataVoiceParam final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataVoiceParam) == 0x000008, "Wrong alignment on FPlayerDataVoiceParam");
static_assert(sizeof(FPlayerDataVoiceParam) == 0x000020, "Wrong size on FPlayerDataVoiceParam");

// ScriptStruct GameModule.PlayerDataEmoteParam
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPlayerDataEmoteParam final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataEmoteParam) == 0x000008, "Wrong alignment on FPlayerDataEmoteParam");
static_assert(sizeof(FPlayerDataEmoteParam) == 0x000020, "Wrong size on FPlayerDataEmoteParam");

// ScriptStruct GameModule.PlayerDataCharacterParam
// 0x00F0 (0x00F0 - 0x0000)
struct FPlayerDataCharacterParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _characterCode;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _variationNo;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _hairId;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _accessoryIds;                                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPlayerDataCostumeParam                _currentCostume;                                   // 0x0028(0x0028)(NativeAccessSpecifierPublic)
	struct FPlayerDataVoiceParam                  _currentVoice;                                     // 0x0050(0x0020)(NativeAccessSpecifierPublic)
	struct FPlayerDataEmoteParam                  _currentEmote;                                     // 0x0070(0x0020)(NativeAccessSpecifierPublic)
	struct FPlayerDataEmblemParam                 _currentEmblem;                                    // 0x0090(0x0020)(NativeAccessSpecifierPublic)
	TArray<int32>                                 _hasCostumeIds;                                    // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 _hasEmoteIds;                                      // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 _hasVoiceIds;                                      // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 _hasEmblemIds;                                     // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataCharacterParam) == 0x000008, "Wrong alignment on FPlayerDataCharacterParam");
static_assert(sizeof(FPlayerDataCharacterParam) == 0x0000F0, "Wrong size on FPlayerDataCharacterParam");
static_assert(offsetof(FPlayerDataCharacterParam, _characterCode) == 0x000008, "Member 'FPlayerDataCharacterParam::_characterCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _variationNo) == 0x00000C, "Member 'FPlayerDataCharacterParam::_variationNo' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _hairId) == 0x000010, "Member 'FPlayerDataCharacterParam::_hairId' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _accessoryIds) == 0x000018, "Member 'FPlayerDataCharacterParam::_accessoryIds' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _currentCostume) == 0x000028, "Member 'FPlayerDataCharacterParam::_currentCostume' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _currentVoice) == 0x000050, "Member 'FPlayerDataCharacterParam::_currentVoice' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _currentEmote) == 0x000070, "Member 'FPlayerDataCharacterParam::_currentEmote' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _currentEmblem) == 0x000090, "Member 'FPlayerDataCharacterParam::_currentEmblem' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _hasCostumeIds) == 0x0000B0, "Member 'FPlayerDataCharacterParam::_hasCostumeIds' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _hasEmoteIds) == 0x0000C0, "Member 'FPlayerDataCharacterParam::_hasEmoteIds' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _hasVoiceIds) == 0x0000D0, "Member 'FPlayerDataCharacterParam::_hasVoiceIds' has a wrong offset!");
static_assert(offsetof(FPlayerDataCharacterParam, _hasEmblemIds) == 0x0000E0, "Member 'FPlayerDataCharacterParam::_hasEmblemIds' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataAvatarParam
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FPlayerDataAvatarParam final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataAvatarParam) == 0x000008, "Wrong alignment on FPlayerDataAvatarParam");
static_assert(sizeof(FPlayerDataAvatarParam) == 0x000038, "Wrong size on FPlayerDataAvatarParam");

// ScriptStruct GameModule.PlayerDataBillboardParam
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FPlayerDataBillboardParam final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataBillboardParam) == 0x000008, "Wrong alignment on FPlayerDataBillboardParam");
static_assert(sizeof(FPlayerDataBillboardParam) == 0x000028, "Wrong size on FPlayerDataBillboardParam");

// ScriptStruct GameModule.PlayerDataPlayerParam
// 0x0B88 (0x0B88 - 0x0000)
struct FPlayerDataPlayerParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdKey                        _cosmosUserId;                                     // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       _unrealUserId;                                     // 0x0010(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _selectCharacterCode;                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerDataCharacterParam>      _characterParams;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPlayerDataAvatarParam                 _avatarParam;                                      // 0x0050(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 _playerName;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bHideBattleRecord;                                // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _introduction;                                     // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _onlineId;                                         // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 _emblemIds;                                        // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        _friendshipStatus;                                 // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerDataBillboardParam              _bilboardParams;                                   // 0x00D8(0x0028)(NativeAccessSpecifierPublic)
	uint32                                        _sendLikeCount;                                    // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xB4];                                     // 0x0104(0x00B4)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerDataScoreParam                  _scoreParam;                                       // 0x01B8(0x0798)(NativeAccessSpecifierPublic)
	struct FPlayerDataFriendParam                 _playerFriendParam;                                // 0x0950(0x0028)(NativeAccessSpecifierPublic)
	struct FPlayerDataItemParam                   _playerItemParam;                                  // 0x0978(0x0028)(NativeAccessSpecifierPublic)
	TArray<struct FDropItemParamInfo>             _dropItemParam;                                    // 0x09A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B0[0x1D8];                                    // 0x09B0(0x01D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataPlayerParam) == 0x000008, "Wrong alignment on FPlayerDataPlayerParam");
static_assert(sizeof(FPlayerDataPlayerParam) == 0x000B88, "Wrong size on FPlayerDataPlayerParam");
static_assert(offsetof(FPlayerDataPlayerParam, _cosmosUserId) == 0x000008, "Member 'FPlayerDataPlayerParam::_cosmosUserId' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _unrealUserId) == 0x000010, "Member 'FPlayerDataPlayerParam::_unrealUserId' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _selectCharacterCode) == 0x000038, "Member 'FPlayerDataPlayerParam::_selectCharacterCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _characterParams) == 0x000040, "Member 'FPlayerDataPlayerParam::_characterParams' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _avatarParam) == 0x000050, "Member 'FPlayerDataPlayerParam::_avatarParam' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _playerName) == 0x000088, "Member 'FPlayerDataPlayerParam::_playerName' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _bHideBattleRecord) == 0x000098, "Member 'FPlayerDataPlayerParam::_bHideBattleRecord' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _introduction) == 0x0000A0, "Member 'FPlayerDataPlayerParam::_introduction' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _onlineId) == 0x0000B0, "Member 'FPlayerDataPlayerParam::_onlineId' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _emblemIds) == 0x0000C0, "Member 'FPlayerDataPlayerParam::_emblemIds' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _friendshipStatus) == 0x0000D0, "Member 'FPlayerDataPlayerParam::_friendshipStatus' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _bilboardParams) == 0x0000D8, "Member 'FPlayerDataPlayerParam::_bilboardParams' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _sendLikeCount) == 0x000100, "Member 'FPlayerDataPlayerParam::_sendLikeCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _scoreParam) == 0x0001B8, "Member 'FPlayerDataPlayerParam::_scoreParam' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _playerFriendParam) == 0x000950, "Member 'FPlayerDataPlayerParam::_playerFriendParam' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _playerItemParam) == 0x000978, "Member 'FPlayerDataPlayerParam::_playerItemParam' has a wrong offset!");
static_assert(offsetof(FPlayerDataPlayerParam, _dropItemParam) == 0x0009A0, "Member 'FPlayerDataPlayerParam::_dropItemParam' has a wrong offset!");

// ScriptStruct GameModule.SupplyParticleColorInfo
// 0x0020 (0x0020 - 0x0000)
struct FSupplyParticleColorInfo final
{
public:
	struct FLinearColor                           _particleBaseColor;                                // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _particleLightColor;                               // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupplyParticleColorInfo) == 0x000004, "Wrong alignment on FSupplyParticleColorInfo");
static_assert(sizeof(FSupplyParticleColorInfo) == 0x000020, "Wrong size on FSupplyParticleColorInfo");
static_assert(offsetof(FSupplyParticleColorInfo, _particleBaseColor) == 0x000000, "Member 'FSupplyParticleColorInfo::_particleBaseColor' has a wrong offset!");
static_assert(offsetof(FSupplyParticleColorInfo, _particleLightColor) == 0x000010, "Member 'FSupplyParticleColorInfo::_particleLightColor' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataKPIParam
// 0x01D8 (0x01D8 - 0x0000)
struct alignas(0x08) FPlayerDataKPIParam final
{
public:
	uint8                                         Pad_0[0x1D8];                                      // 0x0000(0x01D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataKPIParam) == 0x000008, "Wrong alignment on FPlayerDataKPIParam");
static_assert(sizeof(FPlayerDataKPIParam) == 0x0001D8, "Wrong size on FPlayerDataKPIParam");

// ScriptStruct GameModule.PlayerDataKilledParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FPlayerDataKilledParam final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataKilledParam) == 0x000004, "Wrong alignment on FPlayerDataKilledParam");
static_assert(sizeof(FPlayerDataKilledParam) == 0x000018, "Wrong size on FPlayerDataKilledParam");

// ScriptStruct GameModule.PlayerDataAtkUserCountParam
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FPlayerDataAtkUserCountParam final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataAtkUserCountParam) == 0x000004, "Wrong alignment on FPlayerDataAtkUserCountParam");
static_assert(sizeof(FPlayerDataAtkUserCountParam) == 0x00000C, "Wrong size on FPlayerDataAtkUserCountParam");

// ScriptStruct GameModule.PlayerDataKOData
// 0x001C (0x001C - 0x0000)
struct FPlayerDataKOData final
{
public:
	class FName                                   _playerName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         _playerId;                                         // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _teamId;                                           // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _squadId;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _characterCode;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _koCount;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bBot;                                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataKOData) == 0x000004, "Wrong alignment on FPlayerDataKOData");
static_assert(sizeof(FPlayerDataKOData) == 0x00001C, "Wrong size on FPlayerDataKOData");
static_assert(offsetof(FPlayerDataKOData, _playerName) == 0x000000, "Member 'FPlayerDataKOData::_playerName' has a wrong offset!");
static_assert(offsetof(FPlayerDataKOData, _playerId) == 0x000008, "Member 'FPlayerDataKOData::_playerId' has a wrong offset!");
static_assert(offsetof(FPlayerDataKOData, _teamId) == 0x00000A, "Member 'FPlayerDataKOData::_teamId' has a wrong offset!");
static_assert(offsetof(FPlayerDataKOData, _squadId) == 0x00000C, "Member 'FPlayerDataKOData::_squadId' has a wrong offset!");
static_assert(offsetof(FPlayerDataKOData, _characterCode) == 0x000010, "Member 'FPlayerDataKOData::_characterCode' has a wrong offset!");
static_assert(offsetof(FPlayerDataKOData, _koCount) == 0x000014, "Member 'FPlayerDataKOData::_koCount' has a wrong offset!");
static_assert(offsetof(FPlayerDataKOData, _bBot) == 0x000018, "Member 'FPlayerDataKOData::_bBot' has a wrong offset!");

// ScriptStruct GameModule.PlayerDataBattleRecordParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FPlayerDataBattleRecordParam final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataBattleRecordParam) == 0x000008, "Wrong alignment on FPlayerDataBattleRecordParam");
static_assert(sizeof(FPlayerDataBattleRecordParam) == 0x000018, "Wrong size on FPlayerDataBattleRecordParam");

// ScriptStruct GameModule.PlayerDataBattleRecordDetailParam
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPlayerDataBattleRecordDetailParam final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataBattleRecordDetailParam) == 0x000008, "Wrong alignment on FPlayerDataBattleRecordDetailParam");
static_assert(sizeof(FPlayerDataBattleRecordDetailParam) == 0x000020, "Wrong size on FPlayerDataBattleRecordDetailParam");

// ScriptStruct GameModule.PlayerDataBillboardVoterParam
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FPlayerDataBillboardVoterParam final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataBillboardVoterParam) == 0x000008, "Wrong alignment on FPlayerDataBillboardVoterParam");
static_assert(sizeof(FPlayerDataBillboardVoterParam) == 0x000048, "Wrong size on FPlayerDataBillboardVoterParam");

// ScriptStruct GameModule.PlayerDataOutGameParam
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPlayerDataOutGameParam final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataOutGameParam) == 0x000008, "Wrong alignment on FPlayerDataOutGameParam");
static_assert(sizeof(FPlayerDataOutGameParam) == 0x000010, "Wrong size on FPlayerDataOutGameParam");

// ScriptStruct GameModule.PlayerDataMyAdvertiseParam
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FPlayerDataMyAdvertiseParam final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataMyAdvertiseParam) == 0x000008, "Wrong alignment on FPlayerDataMyAdvertiseParam");
static_assert(sizeof(FPlayerDataMyAdvertiseParam) == 0x000068, "Wrong size on FPlayerDataMyAdvertiseParam");

// ScriptStruct GameModule.PlaySoundNotifyBaseInfo
// 0x000C (0x000C - 0x0000)
struct FPlaySoundNotifyBaseInfo
{
public:
	class FName                                   _socketName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bCheckFloor;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaySoundNotifyBaseInfo) == 0x000004, "Wrong alignment on FPlaySoundNotifyBaseInfo");
static_assert(sizeof(FPlaySoundNotifyBaseInfo) == 0x00000C, "Wrong size on FPlaySoundNotifyBaseInfo");
static_assert(offsetof(FPlaySoundNotifyBaseInfo, _socketName) == 0x000000, "Member 'FPlaySoundNotifyBaseInfo::_socketName' has a wrong offset!");
static_assert(offsetof(FPlaySoundNotifyBaseInfo, _bCheckFloor) == 0x000008, "Member 'FPlaySoundNotifyBaseInfo::_bCheckFloor' has a wrong offset!");

// ScriptStruct GameModule.BriefingSelectableAreaInfo
// 0x0014 (0x0014 - 0x0000)
struct FBriefingSelectableAreaInfo final
{
public:
	int32                                         _idx;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _areaSize;                                         // 0x0004(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _areaPosition;                                     // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBriefingSelectableAreaInfo) == 0x000004, "Wrong alignment on FBriefingSelectableAreaInfo");
static_assert(sizeof(FBriefingSelectableAreaInfo) == 0x000014, "Wrong size on FBriefingSelectableAreaInfo");
static_assert(offsetof(FBriefingSelectableAreaInfo, _idx) == 0x000000, "Member 'FBriefingSelectableAreaInfo::_idx' has a wrong offset!");
static_assert(offsetof(FBriefingSelectableAreaInfo, _areaSize) == 0x000004, "Member 'FBriefingSelectableAreaInfo::_areaSize' has a wrong offset!");
static_assert(offsetof(FBriefingSelectableAreaInfo, _areaPosition) == 0x00000C, "Member 'FBriefingSelectableAreaInfo::_areaPosition' has a wrong offset!");

// ScriptStruct GameModule.BriefingStageInfo
// 0x0098 (0x0098 - 0x0000)
struct FBriefingStageInfo final
{
public:
	TSoftClassPtr<class UClass>                   _stageWidget;                                      // 0x0000(0x0028)(Edit, DisableEditOnInstance, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                _mapTexture;                                       // 0x0028(0x0028)(Edit, DisableEditOnInstance, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBriefingSelectableAreaInfo            _squad;                                            // 0x0050(0x0014)(Edit, DisableEditOnInstance, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FBriefingSelectableAreaInfo            _teamA;                                            // 0x0064(0x0014)(Edit, DisableEditOnInstance, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FBriefingSelectableAreaInfo            _teamB;                                            // 0x0078(0x0014)(Edit, DisableEditOnInstance, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              _briefingSize;                                     // 0x008C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBriefingStageInfo) == 0x000008, "Wrong alignment on FBriefingStageInfo");
static_assert(sizeof(FBriefingStageInfo) == 0x000098, "Wrong size on FBriefingStageInfo");
static_assert(offsetof(FBriefingStageInfo, _stageWidget) == 0x000000, "Member 'FBriefingStageInfo::_stageWidget' has a wrong offset!");
static_assert(offsetof(FBriefingStageInfo, _mapTexture) == 0x000028, "Member 'FBriefingStageInfo::_mapTexture' has a wrong offset!");
static_assert(offsetof(FBriefingStageInfo, _squad) == 0x000050, "Member 'FBriefingStageInfo::_squad' has a wrong offset!");
static_assert(offsetof(FBriefingStageInfo, _teamA) == 0x000064, "Member 'FBriefingStageInfo::_teamA' has a wrong offset!");
static_assert(offsetof(FBriefingStageInfo, _teamB) == 0x000078, "Member 'FBriefingStageInfo::_teamB' has a wrong offset!");
static_assert(offsetof(FBriefingStageInfo, _briefingSize) == 0x00008C, "Member 'FBriefingStageInfo::_briefingSize' has a wrong offset!");

// ScriptStruct GameModule.PMActionAttackAssetData
// 0x0078 (0x0078 - 0x0000)
struct FPMActionAttackAssetData final
{
public:
	TSoftClassPtr<class UClass>                   _skillAlpha;                                       // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   _skillBeta;                                        // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   _skillGamma;                                       // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPMActionAttackAssetData) == 0x000008, "Wrong alignment on FPMActionAttackAssetData");
static_assert(sizeof(FPMActionAttackAssetData) == 0x000078, "Wrong size on FPMActionAttackAssetData");
static_assert(offsetof(FPMActionAttackAssetData, _skillAlpha) == 0x000000, "Member 'FPMActionAttackAssetData::_skillAlpha' has a wrong offset!");
static_assert(offsetof(FPMActionAttackAssetData, _skillBeta) == 0x000028, "Member 'FPMActionAttackAssetData::_skillBeta' has a wrong offset!");
static_assert(offsetof(FPMActionAttackAssetData, _skillGamma) == 0x000050, "Member 'FPMActionAttackAssetData::_skillGamma' has a wrong offset!");

// ScriptStruct GameModule.PrimaryCharacterAssets
// 0x0088 (0x0088 - 0x0000)
struct FPrimaryCharacterAssets final
{
public:
	TSoftClassPtr<class UClass>                   _aiControllerBlueprint;                            // 0x0000(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStringTable>            _stringTableWords;                                 // 0x0028(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              _animTableDefault;                                 // 0x0050(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      _animTableVariation;                               // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimaryCharacterAssets) == 0x000008, "Wrong alignment on FPrimaryCharacterAssets");
static_assert(sizeof(FPrimaryCharacterAssets) == 0x000088, "Wrong size on FPrimaryCharacterAssets");
static_assert(offsetof(FPrimaryCharacterAssets, _aiControllerBlueprint) == 0x000000, "Member 'FPrimaryCharacterAssets::_aiControllerBlueprint' has a wrong offset!");
static_assert(offsetof(FPrimaryCharacterAssets, _stringTableWords) == 0x000028, "Member 'FPrimaryCharacterAssets::_stringTableWords' has a wrong offset!");
static_assert(offsetof(FPrimaryCharacterAssets, _animTableDefault) == 0x000050, "Member 'FPrimaryCharacterAssets::_animTableDefault' has a wrong offset!");
static_assert(offsetof(FPrimaryCharacterAssets, _animTableVariation) == 0x000078, "Member 'FPrimaryCharacterAssets::_animTableVariation' has a wrong offset!");

// ScriptStruct GameModule.EmblemDisplayData
// 0x000C (0x000C - 0x0000)
struct FEmblemDisplayData final
{
public:
	int32                                         _leftId;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _middleId;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _rightId;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmblemDisplayData) == 0x000004, "Wrong alignment on FEmblemDisplayData");
static_assert(sizeof(FEmblemDisplayData) == 0x00000C, "Wrong size on FEmblemDisplayData");
static_assert(offsetof(FEmblemDisplayData, _leftId) == 0x000000, "Member 'FEmblemDisplayData::_leftId' has a wrong offset!");
static_assert(offsetof(FEmblemDisplayData, _middleId) == 0x000004, "Member 'FEmblemDisplayData::_middleId' has a wrong offset!");
static_assert(offsetof(FEmblemDisplayData, _rightId) == 0x000008, "Member 'FEmblemDisplayData::_rightId' has a wrong offset!");

// ScriptStruct GameModule.GeneratorIndexLevelData
// 0x00A8 (0x00A8 - 0x0000)
struct FGeneratorIndexLevelData final
{
public:
	struct FBlueprintInfo                         GeneratorBP;                                       // 0x0000(0x0030)(NativeAccessSpecifierPublic)
	TArray<class UBulletData*>                    BulletData;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MomentHit;                                         // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttackPriorityReplicate;                           // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bulletAutoGen;                                     // 0x004E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShareGroupHit;                                     // 0x004F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestroyReplicated;                                 // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClippingActive;                                    // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReplicateType                                ReplicateType;                                     // 0x0052(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirType                                      SpawnForwardType;                                  // 0x0053(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FAnyData>                 AnyDataMap;                                        // 0x0058(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneratorIndexLevelData) == 0x000008, "Wrong alignment on FGeneratorIndexLevelData");
static_assert(sizeof(FGeneratorIndexLevelData) == 0x0000A8, "Wrong size on FGeneratorIndexLevelData");
static_assert(offsetof(FGeneratorIndexLevelData, GeneratorBP) == 0x000000, "Member 'FGeneratorIndexLevelData::GeneratorBP' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, BulletData) == 0x000030, "Member 'FGeneratorIndexLevelData::BulletData' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, Speed) == 0x000040, "Member 'FGeneratorIndexLevelData::Speed' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, Count) == 0x000044, "Member 'FGeneratorIndexLevelData::Count' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, Interval) == 0x000048, "Member 'FGeneratorIndexLevelData::Interval' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, MomentHit) == 0x00004C, "Member 'FGeneratorIndexLevelData::MomentHit' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, AttackPriorityReplicate) == 0x00004D, "Member 'FGeneratorIndexLevelData::AttackPriorityReplicate' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, bulletAutoGen) == 0x00004E, "Member 'FGeneratorIndexLevelData::bulletAutoGen' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, ShareGroupHit) == 0x00004F, "Member 'FGeneratorIndexLevelData::ShareGroupHit' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, DestroyReplicated) == 0x000050, "Member 'FGeneratorIndexLevelData::DestroyReplicated' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, ClippingActive) == 0x000051, "Member 'FGeneratorIndexLevelData::ClippingActive' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, ReplicateType) == 0x000052, "Member 'FGeneratorIndexLevelData::ReplicateType' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, SpawnForwardType) == 0x000053, "Member 'FGeneratorIndexLevelData::SpawnForwardType' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexLevelData, AnyDataMap) == 0x000058, "Member 'FGeneratorIndexLevelData::AnyDataMap' has a wrong offset!");

// ScriptStruct GameModule.GeneratorIndexData
// 0x00D0 (0x00D0 - 0x0000)
struct FGeneratorIndexData final
{
public:
	struct FGeneratorIndexLevelData               baseLevel;                                         // 0x0000(0x00A8)(NativeAccessSpecifierPublic)
	TArray<struct FGeneratorIndexLevelData>       Levels;                                            // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratorIndexData) == 0x000008, "Wrong alignment on FGeneratorIndexData");
static_assert(sizeof(FGeneratorIndexData) == 0x0000D0, "Wrong size on FGeneratorIndexData");
static_assert(offsetof(FGeneratorIndexData, baseLevel) == 0x000000, "Member 'FGeneratorIndexData::baseLevel' has a wrong offset!");
static_assert(offsetof(FGeneratorIndexData, Levels) == 0x0000A8, "Member 'FGeneratorIndexData::Levels' has a wrong offset!");

// ScriptStruct GameModule.ConstraintInfo
// 0x000C (0x000C - 0x0000)
struct FConstraintInfo final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConstraintInfo) == 0x000004, "Wrong alignment on FConstraintInfo");
static_assert(sizeof(FConstraintInfo) == 0x00000C, "Wrong size on FConstraintInfo");
static_assert(offsetof(FConstraintInfo, SocketName) == 0x000000, "Member 'FConstraintInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FConstraintInfo, Time) == 0x000008, "Member 'FConstraintInfo::Time' has a wrong offset!");

// ScriptStruct GameModule.GlobalSetting
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FGlobalSetting final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalSetting) == 0x000008, "Wrong alignment on FGlobalSetting");
static_assert(sizeof(FGlobalSetting) == 0x000030, "Wrong size on FGlobalSetting");

// ScriptStruct GameModule.GeneratorGameRep
// 0x0050 (0x0050 - 0x0000)
struct FGeneratorGameRep final
{
public:
	class UProjectileReplicateGameComponent*      _replicator;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _GeneratorDBID;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        _GeneratorDBIndexID;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _charaId;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 _initDirection;                                    // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 _initTarget;                                       // 0x0020(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _parent;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _level;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _socketIdx;                                        // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _attachTime;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _attachType;                                       // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x1];                                       // 0x0045(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        _genID;                                            // 0x0046(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _commandID;                                        // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _attackID;                                         // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _conditionID;                                      // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _variationNo;                                      // 0x004B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _attackSerial;                                     // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _overwriteBulletCount;                             // 0x004D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratorGameRep) == 0x000008, "Wrong alignment on FGeneratorGameRep");
static_assert(sizeof(FGeneratorGameRep) == 0x000050, "Wrong size on FGeneratorGameRep");
static_assert(offsetof(FGeneratorGameRep, _replicator) == 0x000000, "Member 'FGeneratorGameRep::_replicator' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _GeneratorDBID) == 0x000008, "Member 'FGeneratorGameRep::_GeneratorDBID' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _GeneratorDBIndexID) == 0x00000C, "Member 'FGeneratorGameRep::_GeneratorDBIndexID' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _charaId) == 0x000010, "Member 'FGeneratorGameRep::_charaId' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _initDirection) == 0x000014, "Member 'FGeneratorGameRep::_initDirection' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _initTarget) == 0x000020, "Member 'FGeneratorGameRep::_initTarget' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _parent) == 0x000030, "Member 'FGeneratorGameRep::_parent' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _level) == 0x000038, "Member 'FGeneratorGameRep::_level' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _socketIdx) == 0x00003C, "Member 'FGeneratorGameRep::_socketIdx' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _attachTime) == 0x000040, "Member 'FGeneratorGameRep::_attachTime' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _attachType) == 0x000044, "Member 'FGeneratorGameRep::_attachType' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _genID) == 0x000046, "Member 'FGeneratorGameRep::_genID' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _commandID) == 0x000048, "Member 'FGeneratorGameRep::_commandID' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _attackID) == 0x000049, "Member 'FGeneratorGameRep::_attackID' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _conditionID) == 0x00004A, "Member 'FGeneratorGameRep::_conditionID' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _variationNo) == 0x00004B, "Member 'FGeneratorGameRep::_variationNo' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _attackSerial) == 0x00004C, "Member 'FGeneratorGameRep::_attackSerial' has a wrong offset!");
static_assert(offsetof(FGeneratorGameRep, _overwriteBulletCount) == 0x00004D, "Member 'FGeneratorGameRep::_overwriteBulletCount' has a wrong offset!");

// ScriptStruct GameModule.GeneratorSpawnInit
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FGeneratorSpawnInit final
{
public:
	class UProjectileReplicateGameComponent*      Replicator;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x78];                                       // 0x0008(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratorSpawnInit) == 0x000010, "Wrong alignment on FGeneratorSpawnInit");
static_assert(sizeof(FGeneratorSpawnInit) == 0x000080, "Wrong size on FGeneratorSpawnInit");
static_assert(offsetof(FGeneratorSpawnInit, Replicator) == 0x000000, "Member 'FGeneratorSpawnInit::Replicator' has a wrong offset!");

// ScriptStruct GameModule.SoundParamAttachToComponent
// 0x0010 (0x0078 - 0x0068)
struct FSoundParamAttachToComponent final : public FSoundParamBase
{
public:
	class USceneComponent*                        _componentToAttach;                                // 0x0068(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _attachPointName;                                  // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundParamAttachToComponent) == 0x000008, "Wrong alignment on FSoundParamAttachToComponent");
static_assert(sizeof(FSoundParamAttachToComponent) == 0x000078, "Wrong size on FSoundParamAttachToComponent");
static_assert(offsetof(FSoundParamAttachToComponent, _componentToAttach) == 0x000068, "Member 'FSoundParamAttachToComponent::_componentToAttach' has a wrong offset!");
static_assert(offsetof(FSoundParamAttachToComponent, _attachPointName) == 0x000070, "Member 'FSoundParamAttachToComponent::_attachPointName' has a wrong offset!");

// ScriptStruct GameModule.AtomCueSheetTableRow
// 0x0008 (0x0010 - 0x0008)
struct FAtomCueSheetTableRow final : public FTableRowBase
{
public:
	class USoundAtomCueSheet*                     _soundAtomCueSheet;                                // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomCueSheetTableRow) == 0x000008, "Wrong alignment on FAtomCueSheetTableRow");
static_assert(sizeof(FAtomCueSheetTableRow) == 0x000010, "Wrong size on FAtomCueSheetTableRow");
static_assert(offsetof(FAtomCueSheetTableRow, _soundAtomCueSheet) == 0x000008, "Member 'FAtomCueSheetTableRow::_soundAtomCueSheet' has a wrong offset!");

// ScriptStruct GameModule.SpawnRateCtrl
// 0x0010 (0x0018 - 0x0008)
struct FSpawnRateCtrl final : public FTableRowBase
{
public:
	float                                         StartFPS;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFPS;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEndSpawnRate;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinEndSpawnRate;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnRateCtrl) == 0x000008, "Wrong alignment on FSpawnRateCtrl");
static_assert(sizeof(FSpawnRateCtrl) == 0x000018, "Wrong size on FSpawnRateCtrl");
static_assert(offsetof(FSpawnRateCtrl, StartFPS) == 0x000008, "Member 'FSpawnRateCtrl::StartFPS' has a wrong offset!");
static_assert(offsetof(FSpawnRateCtrl, EndFPS) == 0x00000C, "Member 'FSpawnRateCtrl::EndFPS' has a wrong offset!");
static_assert(offsetof(FSpawnRateCtrl, MaxEndSpawnRate) == 0x000010, "Member 'FSpawnRateCtrl::MaxEndSpawnRate' has a wrong offset!");
static_assert(offsetof(FSpawnRateCtrl, MinEndSpawnRate) == 0x000014, "Member 'FSpawnRateCtrl::MinEndSpawnRate' has a wrong offset!");

// ScriptStruct GameModule.BasicSupplyTableRow
// 0x0028 (0x0030 - 0x0008)
struct FBasicSupplyTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USupplyBaseDataAsset>    _supplyDataAsset;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasicSupplyTableRow) == 0x000008, "Wrong alignment on FBasicSupplyTableRow");
static_assert(sizeof(FBasicSupplyTableRow) == 0x000030, "Wrong size on FBasicSupplyTableRow");
static_assert(offsetof(FBasicSupplyTableRow, _supplyDataAsset) == 0x000008, "Member 'FBasicSupplyTableRow::_supplyDataAsset' has a wrong offset!");

// ScriptStruct GameModule.LeadersTeamColorInfo
// 0x0050 (0x0050 - 0x0000)
struct FLeadersTeamColorInfo final
{
public:
	struct FLinearColor                           _borderColor;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _rankWidgetNameColor;                              // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _rankWidgetBgColor;                                // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _rankWidgetBigBgColor;                             // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _rankWidgetOtherTeamColor;                         // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeadersTeamColorInfo) == 0x000004, "Wrong alignment on FLeadersTeamColorInfo");
static_assert(sizeof(FLeadersTeamColorInfo) == 0x000050, "Wrong size on FLeadersTeamColorInfo");
static_assert(offsetof(FLeadersTeamColorInfo, _borderColor) == 0x000000, "Member 'FLeadersTeamColorInfo::_borderColor' has a wrong offset!");
static_assert(offsetof(FLeadersTeamColorInfo, _rankWidgetNameColor) == 0x000010, "Member 'FLeadersTeamColorInfo::_rankWidgetNameColor' has a wrong offset!");
static_assert(offsetof(FLeadersTeamColorInfo, _rankWidgetBgColor) == 0x000020, "Member 'FLeadersTeamColorInfo::_rankWidgetBgColor' has a wrong offset!");
static_assert(offsetof(FLeadersTeamColorInfo, _rankWidgetBigBgColor) == 0x000030, "Member 'FLeadersTeamColorInfo::_rankWidgetBigBgColor' has a wrong offset!");
static_assert(offsetof(FLeadersTeamColorInfo, _rankWidgetOtherTeamColor) == 0x000040, "Member 'FLeadersTeamColorInfo::_rankWidgetOtherTeamColor' has a wrong offset!");

// ScriptStruct GameModule.WheelItemIconData
// 0x0110 (0x0110 - 0x0000)
struct FWheelItemIconData final
{
public:
	struct FSlateBrush                            _brush;                                            // 0x0000(0x00D0)(Edit, NativeAccessSpecifierPublic)
	class FText                                   _text;                                             // 0x00D0(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          _bAvailable;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EWheelItemType                                _iconType;                                         // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _additionalIconOffset;                             // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              _additionalTextOffset;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _iconScale;                                        // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xC];                                      // 0x0104(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWheelItemIconData) == 0x000010, "Wrong alignment on FWheelItemIconData");
static_assert(sizeof(FWheelItemIconData) == 0x000110, "Wrong size on FWheelItemIconData");
static_assert(offsetof(FWheelItemIconData, _brush) == 0x000000, "Member 'FWheelItemIconData::_brush' has a wrong offset!");
static_assert(offsetof(FWheelItemIconData, _text) == 0x0000D0, "Member 'FWheelItemIconData::_text' has a wrong offset!");
static_assert(offsetof(FWheelItemIconData, _bAvailable) == 0x0000E8, "Member 'FWheelItemIconData::_bAvailable' has a wrong offset!");
static_assert(offsetof(FWheelItemIconData, _iconType) == 0x0000EC, "Member 'FWheelItemIconData::_iconType' has a wrong offset!");
static_assert(offsetof(FWheelItemIconData, _additionalIconOffset) == 0x0000F0, "Member 'FWheelItemIconData::_additionalIconOffset' has a wrong offset!");
static_assert(offsetof(FWheelItemIconData, _additionalTextOffset) == 0x0000F8, "Member 'FWheelItemIconData::_additionalTextOffset' has a wrong offset!");
static_assert(offsetof(FWheelItemIconData, _iconScale) == 0x000100, "Member 'FWheelItemIconData::_iconScale' has a wrong offset!");

// ScriptStruct GameModule.WheelCommandStruct
// 0x0010 (0x0010 - 0x0000)
struct FWheelCommandStruct final
{
public:
	int32                                         _page;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _index;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _commandName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWheelCommandStruct) == 0x000004, "Wrong alignment on FWheelCommandStruct");
static_assert(sizeof(FWheelCommandStruct) == 0x000010, "Wrong size on FWheelCommandStruct");
static_assert(offsetof(FWheelCommandStruct, _page) == 0x000000, "Member 'FWheelCommandStruct::_page' has a wrong offset!");
static_assert(offsetof(FWheelCommandStruct, _index) == 0x000004, "Member 'FWheelCommandStruct::_index' has a wrong offset!");
static_assert(offsetof(FWheelCommandStruct, _commandName) == 0x000008, "Member 'FWheelCommandStruct::_commandName' has a wrong offset!");

}

